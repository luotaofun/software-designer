1
00:00:00,000 --> 00:00:02,940
接下来我们呢，展开看一下呢

2
00:00:02,940 --> 00:00:05,960
对于一些加密技术以及呢

3
00:00:05,960 --> 00:00:07,500
认证技术的应用

4
00:00:07,500 --> 00:00:09,230
首先我们看到的是

5
00:00:09,230 --> 00:00:12,240
数字签名与信息摘要的应用

6
00:00:12,240 --> 00:00:14,630
那什么是签名呢

7
00:00:14,630 --> 00:00:16,030
我们想一想啊

8
00:00:16,030 --> 00:00:17,110
大家在什么的

9
00:00:17,110 --> 00:00:18,880
什么时候签过名啊

10
00:00:18,880 --> 00:00:22,750
签合同的时候还是去银行办业务的时候吧

11
00:00:22,750 --> 00:00:26,120
这种签名是有一定法律意义的

12
00:00:26,120 --> 00:00:29,100
那我们说为什么具有法律意义呢

13
00:00:29,100 --> 00:00:32,409
因为我们会有一些字迹的这种呢，甄别

14
00:00:32,409 --> 00:00:35,230
那我们在网络当中呢

15
00:00:35,230 --> 00:00:36,710
也可以用签名

16
00:00:36,710 --> 00:00:38,250
只是这个用的过程呢

17
00:00:38,250 --> 00:00:40,630
我们叫做数字签名

18
00:00:40,630 --> 00:00:44,130
那关于数字签名与信息摘要

19
00:00:44,130 --> 00:00:47,260
在我们的软件设计师考试当中呢

20
00:00:47,260 --> 00:00:50,680
会涉及到相应算法的考察

21
00:00:50,680 --> 00:00:51,820
以及呢

22
00:00:51,820 --> 00:00:54,160
数字签名与信息摘要

23
00:00:54,160 --> 00:00:56,510
应用的具体过程的考察

24
00:00:56,510 --> 00:01:02,090
还有呢，关于数字签名与信息摘要作用的考察

25
00:01:02,090 --> 00:01:03,580
那这是我们呢

26
00:01:03,580 --> 00:01:07,190
在软件设计师考试当中的具体体现

27
00:01:07,190 --> 00:01:11,050
下面呢，我们来看一下签名的过程

28
00:01:11,290 --> 00:01:15,700
那我们说签名呀，是需要保证哎

29
00:01:15,700 --> 00:01:19,060
我们能够呢体现自己的身份吧

30
00:01:19,060 --> 00:01:21,320
那发送者他有呢

31
00:01:21,320 --> 00:01:22,500
哎，还有接收者

32
00:01:22,500 --> 00:01:24,100
他们传递消息的时候

33
00:01:24,100 --> 00:01:26,830
发送者有自己的公钥和私钥

34
00:01:26,830 --> 00:01:30,090
接收者有自己的公钥和私钥

35
00:01:30,090 --> 00:01:33,670
其中公钥是对外公开的

36
00:01:33,670 --> 00:01:35,260
谁都能拿到

37
00:01:35,260 --> 00:01:38,970
然后呢，唉，我们在传递的过程当

38
00:01:38,970 --> 00:01:41,240
都是呢来传递明文

39
00:01:41,240 --> 00:01:45,850
那到底这个铭文是谁传给接收者的

40
00:01:45,850 --> 00:01:49,390
我们要确保发送者身份吧

41
00:01:49,390 --> 00:01:54,150
那确保发送者身份不可假冒

42
00:02:07,160 --> 00:02:08,840
我们说这种啊

43
00:02:08,840 --> 00:02:12,690
它是保证我们身份的真实性

44
00:02:12,690 --> 00:02:15,600
那谁可以体现

45
00:02:15,600 --> 00:02:15,980
诶

46
00:02:15,980 --> 00:02:20,640
这一定是我发送者自己独有的东西啊

47
00:02:20,640 --> 00:02:23,060
只有我们的私钥吧

48
00:02:23,060 --> 00:02:27,920
所以签名的过程用的是发送者的私钥

49
00:02:27,920 --> 00:02:29,670
来进行签名

50
00:02:29,670 --> 00:02:33,120
那能不能签在我们的，诶

51
00:02:33,120 --> 00:02:35,420
整个文章上面呢

52
00:02:35,420 --> 00:02:37,120
唉，我们会发现

53
00:02:37,120 --> 00:02:39,690
使用私钥进行签名

54
00:02:39,690 --> 00:02:41,170
它的过程啊

55
00:02:41,170 --> 00:02:43,890
实质上还是加密的过程

56
00:02:43,890 --> 00:02:45,510
那我们说加密

57
00:02:45,510 --> 00:02:48,050
在非对称加密过程当中

58
00:02:48,050 --> 00:02:50,370
是不要对明文加密吧

59
00:02:50,370 --> 00:02:52,860
因为效率太低了

60
00:02:52,860 --> 00:02:55,020
那我不对明文加密

61
00:02:55,020 --> 00:02:56,660
我对什么加密呢

62
00:02:56,660 --> 00:02:59,080
唉，我们会对明文

63
00:02:59,080 --> 00:03:03,620
从他的铭文当中抽取一定的数据量

64
00:03:03,620 --> 00:03:06,580
来作为信息摘要

65
00:03:06,610 --> 00:03:09,810
那这个抽取的过程

66
00:03:09,810 --> 00:03:14,430
我们用到的是单向散列值函数，诶

67
00:03:14,430 --> 00:03:16,370
也就是哈希函数

68
00:03:16,370 --> 00:03:19,380
这个生成的过程是单向的

69
00:03:19,380 --> 00:03:20,520
所以不可逆

70
00:03:20,520 --> 00:03:24,410
其他人是没有办法再做这个操作的

71
00:03:24,410 --> 00:03:26,000
其次呢，唉

72
00:03:26,000 --> 00:03:27,800
它是定长的

73
00:03:27,800 --> 00:03:30,910
我们在使用哈希函数的时候呢

74
00:03:30,910 --> 00:03:32,630
生成的铭文啊

75
00:03:32,630 --> 00:03:34,090
生成的消息摘要

76
00:03:34,090 --> 00:03:35,620
它是固定长度

77
00:03:35,620 --> 00:03:38,280
只有呢，诶，几百个比特位

78
00:03:38,280 --> 00:03:40,580
所以量非常小

79
00:03:40,580 --> 00:03:42,680
那量小了之后

80
00:03:42,680 --> 00:03:45,540
我们就可以对这个少量数据进行

81
00:03:45,540 --> 00:03:46,880
非对称加密了

82
00:03:46,880 --> 00:03:48,950
用谁来加密呢

83
00:03:48,950 --> 00:03:53,550
哎，整个签名的过程用的是发送者的私钥

84
00:03:53,550 --> 00:03:55,810
也就是 S

85
00:03:56,020 --> 00:03:59,860
用发送者私钥签名之后啊

86
00:03:59,860 --> 00:04:01,700
把这个，哎，加密

87
00:04:01,700 --> 00:04:03,140
哎，我们说签名之后

88
00:04:03,140 --> 00:04:04,720
这是一个加密的过程

89
00:04:04,720 --> 00:04:06,260
但我们一般说它呢

90
00:04:06,260 --> 00:04:08,140
叫做签名的过程

91
00:04:08,140 --> 00:04:09,990
并不提它的加密了

92
00:04:09,990 --> 00:04:11,170
那为什么呢

93
00:04:11,170 --> 00:04:13,930
因为它没有一个保密作用啊

94
00:04:13,930 --> 00:04:16,430
我们的公钥大家都有

95
00:04:16,430 --> 00:04:18,870
所以你用 SA 加密的话

96
00:04:18,870 --> 00:04:20,220
谁都能够打开

97
00:04:20,220 --> 00:04:22,089
它还具有保密性吗

98
00:04:22,089 --> 00:04:23,730
就没有保密性了

99
00:04:23,730 --> 00:04:26,450
所以我们呢，叫它叫做签名过程

100
00:04:26,450 --> 00:04:28,530
而不是加密过程呢

101
00:04:28,530 --> 00:04:32,160
签名之后呢，得到一个签名的摘要

102
00:04:32,160 --> 00:04:37,750
通过我们的互联网把信息传给接收者

103
00:04:37,750 --> 00:04:41,340
接收者拿到签名摘要之后

104
00:04:41,340 --> 00:04:44,590
用谁来进行解密啊

105
00:04:44,590 --> 00:04:50,310
SA 加密只能用对应的 PA 来解密吧

106
00:04:50,490 --> 00:04:56,450
所以，唉，我们在验证签名是谁的过程当中

107
00:04:56,450 --> 00:05:01,240
会用发送方的公钥来进行验证

108
00:05:01,240 --> 00:05:03,930
那验证它的实质呢

109
00:05:03,930 --> 00:05:05,560
是一个解密过程

110
00:05:05,560 --> 00:05:06,940
但是我们认为呢

111
00:05:06,940 --> 00:05:08,860
诶，因为它不具有保密性呀

112
00:05:08,860 --> 00:05:10,280
所以我们叫做呢

113
00:05:10,280 --> 00:05:12,310
验证签名的过程

114
00:05:12,310 --> 00:05:13,940
得到一个呢，哎

115
00:05:13,940 --> 00:05:16,440
没有签名的消息摘要了

116
00:05:16,440 --> 00:05:20,430
那这个摘要其实在互联网当中

117
00:05:20,430 --> 00:05:22,490
所有人都能获取吧

118
00:05:22,490 --> 00:05:26,220
因为签名摘要在互联网上流通

119
00:05:26,220 --> 00:05:29,200
公钥也是在互联网上流通的

120
00:05:29,200 --> 00:05:30,900
所以这个过程啊

121
00:05:30,900 --> 00:05:33,740
谁都能够拿到这一个摘要

122
00:05:33,740 --> 00:05:37,010
但是拿了有什么用呢

123
00:05:37,010 --> 00:05:42,200
我们在这里主要是了解数字签名的作用

124
00:05:42,200 --> 00:05:44,580
并没有去看它的保密性呢

125
00:05:44,580 --> 00:05:47,940
那我们如何来体现诶

126
00:05:47,940 --> 00:05:50,940
这个消息它的签名作用呢

127
00:05:50,940 --> 00:05:55,790
我们同时啊，在互联网当中会接收到铭文

128
00:05:55,790 --> 00:06:00,570
那我们可以对铭文自己做一次哈希函数

129
00:06:00,570 --> 00:06:03,150
得到一个呢，消息摘要

130
00:06:03,150 --> 00:06:04,550
对比之后

131
00:06:04,550 --> 00:06:07,290
两个消息摘要有没有区别呢

132
00:06:07,290 --> 00:06:09,900
有区别就会有问题

133
00:06:09,900 --> 00:06:13,560
没有区别才是呢，真正的结果吧

134
00:06:13,560 --> 00:06:17,400
那我们的签名可以确保诶

135
00:06:17,400 --> 00:06:19,540
这个消息发送之后呢

136
00:06:19,540 --> 00:06:22,330
是不可假冒身份的

137
00:06:22,330 --> 00:06:24,840
可以保证身份的真实性

138
00:06:24,840 --> 00:06:27,860
保证发送者不可抵赖

139
00:06:27,860 --> 00:06:30,800
哎，发送者身份不可抵赖

140
00:06:41,820 --> 00:06:44,240
那我们在这个过程当中

141
00:06:44,240 --> 00:06:47,700
签名一般会结合消息摘要来用吧

142
00:06:47,700 --> 00:06:49,640
因为铭文太大了

143
00:06:49,640 --> 00:06:51,200
我们的签名对象啊

144
00:06:51,200 --> 00:06:53,450
都是对摘要来签名的

145
00:06:53,450 --> 00:06:56,160
那摘要有什么作用呢

146
00:06:56,160 --> 00:06:59,710
摘要它是单向不可逆的

147
00:06:59,710 --> 00:07:02,630
所以在这个过程当中啊

148
00:07:02,630 --> 00:07:03,810
我们会发现

149
00:07:03,810 --> 00:07:07,650
这个数据是没有办法被别人篡改的

150
00:07:07,650 --> 00:07:09,590
因为一旦篡改了

151
00:07:09,590 --> 00:07:13,030
我们的摘要就会呢发生变化

152
00:07:13,030 --> 00:07:16,280
第消息摘要可以保证呢

153
00:07:16,280 --> 00:07:19,500
哎，信息不被呢篡改

154
00:07:25,960 --> 00:07:30,220
我们把它呢，叫做相应的信息

155
00:07:30,220 --> 00:07:32,200
完整性的保护

156
00:07:34,080 --> 00:07:37,040
那不被篡改以外啊

157
00:07:37,040 --> 00:07:41,310
其实一方面是因为单向散列

158
00:07:41,310 --> 00:07:42,850
确保信息呢

159
00:07:42,850 --> 00:07:46,370
诶，我们不能够反向做可逆操作

160
00:07:46,370 --> 00:07:47,610
其次呢

161
00:07:47,610 --> 00:07:52,550
我们在网上传输的是签名之后的摘要吧

162
00:07:52,550 --> 00:07:56,920
即使你得到了一个新的摘要，诶

163
00:07:56,920 --> 00:07:58,800
一个呢，假冒的摘要

164
00:07:58,800 --> 00:08:00,340
修改之后的摘要

165
00:08:00,340 --> 00:08:02,330
你有没有 S

166
00:08:02,330 --> 00:08:05,830
能够把它作为一个合法的签名

167
00:08:05,830 --> 00:08:06,370
摘要

168
00:08:06,370 --> 00:08:07,730
拿来传递啊

169
00:08:07,730 --> 00:08:10,120
我们是拿不到 SA 的

170
00:08:10,120 --> 00:08:15,010
所以我们的私钥从某一方面来说

171
00:08:15,010 --> 00:08:20,280
签名之后的摘要也可以保证信息不被篡改

172
00:08:20,280 --> 00:08:23,480
因为篡改之后没有新的，唉

173
00:08:23,480 --> 00:08:25,690
我们的 SA 来加密了

174
00:08:25,690 --> 00:08:27,010
所以这个过程啊

175
00:08:27,010 --> 00:08:28,550
也有一定的保证

176
00:08:28,550 --> 00:08:29,950
这里呢，注意一下

177
00:08:29,950 --> 00:08:32,090
它有这样的一个作用

178
00:08:32,260 --> 00:08:35,370
对于单向散列值函数啊

179
00:08:35,370 --> 00:08:38,580
我们说呢，它叫消息摘要或者呢，数字摘要

180
00:08:38,580 --> 00:08:40,059
甚至呢，信息摘要

181
00:08:40,059 --> 00:08:42,570
各种翻译的说法不太一样

182
00:08:42,570 --> 00:08:45,190
那他的得来类似于呢

183
00:08:45,190 --> 00:08:47,110
我们在写论文的时候

184
00:08:47,110 --> 00:08:49,870
一般呢，在文章的前面会用呢

185
00:08:49,870 --> 00:08:52,180
一个摘要来说明全文

186
00:08:52,180 --> 00:08:55,160
这个摘要是非常短的诶

187
00:08:55,160 --> 00:08:56,500
短小精湛

188
00:08:56,500 --> 00:09:00,870
那我们在数字签名当中使用的消息摘要

189
00:09:00,870 --> 00:09:02,850
它是一个单向的

190
00:09:02,850 --> 00:09:05,570
也就是不可逆的过程

191
00:09:07,360 --> 00:09:12,250
然后呢，它生成的是固定长度的散列值

192
00:09:12,250 --> 00:09:15,000
所以大小确定一定呢

193
00:09:15,000 --> 00:09:17,840
是少量的一个信息

194
00:09:17,840 --> 00:09:21,060
那我们将一句话产生摘要之后

195
00:09:21,060 --> 00:09:22,980
它生成的其实是一个呢

196
00:09:22,980 --> 00:09:24,690
不知道是什么的乱码了

197
00:09:24,690 --> 00:09:28,060
那这个过程能不能反向推回原文啊

198
00:09:28,060 --> 00:09:29,620
是推不回来的

199
00:09:29,620 --> 00:09:32,760
所以我们说它单向不可逆

200
00:09:33,010 --> 00:09:35,530
常见的摘要算法

201
00:09:35,530 --> 00:09:36,870
哎，这里也要注意

202
00:09:36,870 --> 00:09:39,580
它的算法分类包含两种

203
00:09:39,580 --> 00:09:41,160
一种呢是 MD 5

204
00:09:41,160 --> 00:09:43,250
一种呢是 SHA 

205
00:09:43,250 --> 00:09:44,900
那我们目前啊

206
00:09:44,900 --> 00:09:47,080
其实市场上广泛应用的

207
00:09:47,080 --> 00:09:49,490
已经有1000多个比特位了

208
00:09:49,490 --> 00:09:51,420
但是我们在考试当中

209
00:09:51,420 --> 00:09:53,500
目前理论上来看的话

210
00:09:53,500 --> 00:09:55,390
我们的 MD 5

211
00:09:55,390 --> 00:10:01,490
它所对应的散列值是128个比特位

212
00:10:01,490 --> 00:10:02,750
s h a 

213
00:10:02,750 --> 00:10:06,070
它生成的消息摘要散列值呢

214
00:10:06,070 --> 00:10:08,980
是160个比特位

215
00:10:08,980 --> 00:10:12,630
所以我们认为后面生成的命要长一些

216
00:10:12,630 --> 00:10:15,080
安全性呢会稍微高一些

217
00:10:15,080 --> 00:10:16,100
这就是呢

218
00:10:16,100 --> 00:10:17,620
摘要算法啊

219
00:10:17,620 --> 00:10:21,540
那它的这种长度在我们考试当中呢

220
00:10:21,540 --> 00:10:23,870
也曾经出现过

221
00:10:23,870 --> 00:10:27,110
关于我们前面讲到的算法

222
00:10:27,110 --> 00:10:31,190
还有呢，在上一个视频当中给大家提到的

223
00:10:31,190 --> 00:10:32,670
对称加密的算法

224
00:10:32,670 --> 00:10:34,400
非对称加密的算法

225
00:10:34,400 --> 00:10:37,670
这里呢，又提到了消息摘要的算法

226
00:10:37,670 --> 00:10:39,010
三类算法

227
00:10:39,010 --> 00:10:40,730
诶，常见的有哪些

228
00:10:40,730 --> 00:10:42,660
注意呢，区分一下

229
00:10:42,660 --> 00:10:46,600
下面呢，我们来看一下数字签名与消息摘要

230
00:10:46,600 --> 00:10:50,760
在我们的软件设计师考试真题当中的体现

231
00:10:50,760 --> 00:10:55,420
首先，下面可用于数字签名的算法是谁

232
00:10:55,420 --> 00:10:57,940
那这是对算法的考察吧

233
00:10:57,940 --> 00:11:00,330
数字签名用谁来签

234
00:11:00,330 --> 00:11:01,830
用私钥来签

235
00:11:01,830 --> 00:11:05,400
这是典型的非对称加密技术的应用

236
00:11:05,400 --> 00:11:10,160
那非对称加密算法典型的就是呢， RSA 

237
00:11:10,160 --> 00:11:16,230
其中 I 、 D 、 EA 以及 RC 杠五、 RC 杠四都是呢

238
00:11:16,230 --> 00:11:17,430
对称加密的

239
00:11:17,430 --> 00:11:21,250
MD 5呢，是典型的摘要算法

240
00:11:21,250 --> 00:11:23,030
那我们还可以拓展一下

241
00:11:23,030 --> 00:11:25,530
它的长度是128位

242
00:11:25,530 --> 00:11:27,660
还有一个呢， SHA 

243
00:11:27,660 --> 00:11:30,600
它的长度呢是160位

244
00:11:30,600 --> 00:11:33,790
那这是呢，相应的算法

245
00:11:33,790 --> 00:11:36,580
那我们的非对称加密算

246
00:11:36,580 --> 00:11:40,480
还有一个呢， ECC 椭圆双曲线算法

247
00:11:40,480 --> 00:11:42,440
对称加密算法

248
00:11:42,440 --> 00:11:46,180
唉，还有 DES 和三重 DES 

249
00:11:46,180 --> 00:11:50,150
这是常见的算法策略的分类

250
00:11:50,150 --> 00:11:54,390
下面呢，考察的是关于摘要算

251
00:11:54,390 --> 00:11:56,480
以及呢它的细节

252
00:11:56,480 --> 00:11:59,250
那 MD 5是什么算法呢

253
00:11:59,250 --> 00:12:01,210
它是典型的哈希

254
00:12:01,210 --> 00:12:04,520
也就是单向散列值函数摘要算法

255
00:12:04,520 --> 00:12:06,590
共享密钥算法

256
00:12:06,590 --> 00:12:07,450
它是呢

257
00:12:07,450 --> 00:12:07,810
唉

258
00:12:07,810 --> 00:12:10,440
我们的对称密钥算法

259
00:12:10,440 --> 00:12:13,530
公开密钥算法是非对称

260
00:12:13,530 --> 00:12:17,150
诶，我们的非对称加密密钥算法

261
00:12:17,150 --> 00:12:18,370
路由选择

262
00:12:18,370 --> 00:12:21,210
它是呢在路由方面的算法策略

263
00:12:21,210 --> 00:12:24,070
跟我们的加密技术无关

264
00:12:24,440 --> 00:12:29,580
那 MD 5对任意长度的输入计算得到的结果

265
00:12:29,580 --> 00:12:33,660
长度固定是128位的

266
00:12:33,660 --> 00:12:38,450
其中 SHA 算法生成的长度

267
00:12:38,450 --> 00:12:40,990
固定是160位的

268
00:12:40,990 --> 00:12:44,810
它也是呢典型的摘要算法

269
00:12:45,490 --> 00:12:49,650
接下来看到的是关于签名

270
00:12:49,650 --> 00:12:52,090
它的具体过程的考察

271
00:12:52,090 --> 00:12:56,060
那我们在安全的通信过程当中

272
00:12:56,060 --> 00:13:00,170
S 将所发信息使用什么来签名

273
00:13:00,170 --> 00:13:01,990
T 1接收到之后

274
00:13:01,990 --> 00:13:06,350
利用什么来验证消息的真实性

275
00:13:06,350 --> 00:13:08,860
S 他是发送者

276
00:13:08,860 --> 00:13:13,060
他有自己的公钥以及呢私钥

277
00:13:13,060 --> 00:13:15,580
P 1呢，是接收者

278
00:13:15,580 --> 00:13:19,590
他也有自己的公钥以及呢私钥

279
00:13:19,590 --> 00:13:21,520
那我们要做签名

280
00:13:21,520 --> 00:13:25,140
意味着要证明发送者的身份，诶

281
00:13:25,140 --> 00:13:26,300
独一无二吧

282
00:13:26,300 --> 00:13:30,140
谁是 S 自己独特的一个东西呢

283
00:13:30,140 --> 00:13:32,310
应该是他的私钥

284
00:13:32,310 --> 00:13:36,150
所以我们会用 S 的私钥来签名

285
00:13:36,150 --> 00:13:38,570
与之对应的验证

286
00:13:38,570 --> 00:13:42,190
他的私钥就要用对应的公钥来验证

287
00:13:42,190 --> 00:13:43,790
所以这里呢

288
00:13:43,790 --> 00:13:47,130
进行验证的是 S 的公钥

289
00:13:47,130 --> 00:13:49,390
来验证消息的真实性

290
00:13:49,390 --> 00:13:52,040
其实就是验证他的身份

291
00:13:52,040 --> 00:13:57,190
那我们 S 是没有 T 的私钥的

292
00:13:57,190 --> 00:13:59,930
T 也没有 S 的私钥

293
00:13:59,930 --> 00:14:04,130
这两个呢，是对方相互都拿不到的东西

294
00:14:04,130 --> 00:14:06,740
那其次呢，对于公钥

295
00:14:06,740 --> 00:14:07,840
它的意义呢

296
00:14:07,840 --> 00:14:08,960
全网都有

297
00:14:08,960 --> 00:14:12,080
所以呢，拿过来之后也没办法呢

298
00:14:12,080 --> 00:14:13,700
做签名的作用啊

299
00:14:13,700 --> 00:14:17,300
所以一定是发送者私钥来签名

300
00:14:17,300 --> 00:14:21,790
然后呢，用发送者公钥来验证签名

301
00:14:21,790 --> 00:14:26,930
这是呢，对我们数字签名过程的具体考察

302
00:14:26,930 --> 00:14:31,800
下面呢，再来看一下关于数字签名作用的考察

303
00:14:31,800 --> 00:14:36,020
以下哪一个不是数字签名的作用

304
00:14:36,020 --> 00:14:37,180
两个关键字啊

305
00:14:37,180 --> 00:14:39,540
我们考察的是数字签名的作用

306
00:14:39,540 --> 00:14:43,580
这道题找的是不是数字签名

307
00:14:43,580 --> 00:14:45,120
可以呢，保证

308
00:14:45,120 --> 00:14:48,000
诶，发送者身份的真实性

309
00:14:48,000 --> 00:14:50,880
也就是消息来源的真实性

310
00:14:50,880 --> 00:14:53,210
发送者身份不可抵赖

311
00:14:53,210 --> 00:14:57,020
所以发送者无法否认发送过消息

312
00:14:57,020 --> 00:15:00,570
其次， C 选项和 D 选项当中

313
00:15:00,570 --> 00:15:02,990
接收者能不能验证啊

314
00:15:02,990 --> 00:15:04,950
跟接收者没关系

315
00:15:04,950 --> 00:15:08,830
所有人拿到东西都能够进行验证

316
00:15:08,830 --> 00:15:12,910
那接收者无法伪造或者篡改消息

317
00:15:12,910 --> 00:15:16,330
这里我们在视频当中曾经提到过

318
00:15:16,330 --> 00:15:19,150
如果此时对消息篡改

319
00:15:19,150 --> 00:15:21,510
我们要去推送消息的时候

320
00:15:21,510 --> 00:15:24,670
必须还有一个合法的签名才可以吧

321
00:15:24,670 --> 00:15:26,430
因为拿不到私钥

322
00:15:26,430 --> 00:15:31,030
所以无法对篡改的信息进行签名过程

323
00:15:31,030 --> 00:15:34,370
从而呢唉无法正常的推送

324
00:15:34,370 --> 00:15:36,030
那这个过程呢

325
00:15:36,030 --> 00:15:38,050
接收者没有办法呢

326
00:15:38,050 --> 00:15:41,180
来伪造或者呢篡改我们的消息

327
00:15:41,180 --> 00:15:45,360
我们签名之后的摘要是作为一个整体

328
00:15:45,360 --> 00:15:47,580
没有办法呢去修改了

329
00:15:47,580 --> 00:15:48,770
所以不是

330
00:15:48,770 --> 00:15:50,110
数字签名的作用

331
00:15:50,110 --> 00:15:51,850
应该是 D 选项

332
00:15:51,850 --> 00:15:57,390
数字签名无法验证接收者它的合法性

333
00:15:57,520 --> 00:15:58,860
那这些啊

334
00:15:58,860 --> 00:16:02,900
就是关于数字签名和信息摘要的应用
