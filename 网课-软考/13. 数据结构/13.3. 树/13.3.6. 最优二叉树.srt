1
00:00:00,000 --> 00:00:03,600
接下来我们再来看一种呢，特殊的二叉树

2
00:00:03,600 --> 00:00:05,660
叫做呢，最优二叉树

3
00:00:05,660 --> 00:00:08,620
我们也把它呢，叫做哈夫曼树

4
00:00:08,620 --> 00:00:13,530
在我们的整个软件设计师考试当中啊

5
00:00:13,530 --> 00:00:17,590
这两个名称并没有呢，做特别的区分

6
00:00:17,590 --> 00:00:21,340
最优二叉树呢，可以理解为就是呢，哈夫曼树

7
00:00:21,340 --> 00:00:24,470
那哈夫曼树它的出现主要呢

8
00:00:24,470 --> 00:00:26,120
是为了做哈夫曼编码

9
00:00:26,120 --> 00:00:27,540
最优二叉树呢

10
00:00:27,540 --> 00:00:31,340
它的根本是根据我们的全职来求数的

11
00:00:31,340 --> 00:00:32,750
代价最小

12
00:00:32,750 --> 00:00:34,370
那我们在这里呢

13
00:00:34,370 --> 00:00:36,470
先来了解一些基本的概念

14
00:00:36,470 --> 00:00:38,970
那什么是竖的长度

15
00:00:38,970 --> 00:00:42,240
我们在这里一般考虑路径长度的时候

16
00:00:42,240 --> 00:00:45,520
是叶子节点、离根节点

17
00:00:45,520 --> 00:00:47,870
它的分支长度

18
00:00:47,870 --> 00:00:49,970
那这个分支的长度呢

19
00:00:49,970 --> 00:00:52,410
就是叶子的路径长度

20
00:00:52,410 --> 00:00:56,350
那每一个节点它有相应的数值

21
00:00:56,350 --> 00:00:59,700
这种数值啊，它是有一定含义的

22
00:00:59,700 --> 00:01:05,090
我们把这种数值叫做呢，全职用全平直

23
00:01:05,090 --> 00:01:09,790
哎，这里的路径长度是二乘以它的全职二

24
00:01:09,790 --> 00:01:11,990
就是该叶子节点

25
00:01:11,990 --> 00:01:14,690
它的带权路径长度

26
00:01:14,690 --> 00:01:19,170
所有叶子节点的带权路径长度求和

27
00:01:19,170 --> 00:01:21,360
就是树的代价

28
00:01:21,360 --> 00:01:25,120
也叫做整棵树的带权路径长度

29
00:01:25,120 --> 00:01:28,270
那我们在这里看到左侧这棵树啊

30
00:01:28,270 --> 00:01:30,710
它的代价是2×

31
00:01:30,710 --> 00:01:33,510
加上4×3

32
00:01:34,230 --> 00:01:36,550
加上8×3

33
00:01:36,550 --> 00:01:38,730
加上1×1的

34
00:01:38,730 --> 00:01:43,430
它的结果应该是等于41的

35
00:01:44,410 --> 00:01:47,850
那针对右侧这棵树来看

36
00:01:47,850 --> 00:01:50,990
叶子节点还是1248吧

37
00:01:50,990 --> 00:01:53,170
但是调整了一下顺序

38
00:01:53,170 --> 00:01:56,750
我们会发现这棵树它的代价是多少呢

39
00:01:56,750 --> 00:01:59,920
哎，1×3加上2×3

40
00:01:59,920 --> 00:02:01,750
加上4×2

41
00:02:01,750 --> 00:02:03,780
加上8×1

42
00:02:03,780 --> 00:02:06,860
那这个结果它应该呢

43
00:02:06,860 --> 00:02:10,919
是等于9+16的

44
00:02:11,230 --> 00:02:13,000
等于25

45
00:02:13,000 --> 00:02:16,450
那显然这个代价会更小一些吧

46
00:02:16,450 --> 00:02:18,810
那这种代价更小

47
00:02:18,810 --> 00:02:21,800
就是我们的要求的最优二叉树

48
00:02:21,800 --> 00:02:23,380
最优二叉树

49
00:02:23,380 --> 00:02:26,700
它指的是树的代价最小的形态

50
00:02:26,700 --> 00:02:30,360
那这种形态是可以存在多种的

51
00:02:30,360 --> 00:02:33,370
只要全值是最小就可以了

52
00:02:33,370 --> 00:02:34,940
那他的全职啊

53
00:02:34,940 --> 00:02:37,590
整个数的代价是如何降低的

54
00:02:37,590 --> 00:02:43,370
我们会发现它会将我们全职较大的节点，诶

55
00:02:43,370 --> 00:02:45,600
挪到根节点旁边吧

56
00:02:45,600 --> 00:02:48,670
全值最小的节点放到呢

57
00:02:48,670 --> 00:02:51,290
离根节点最远的位置

58
00:02:51,290 --> 00:02:53,310
从而呢进行构造

59
00:02:53,310 --> 00:02:55,380
那整棵树的构造过程

60
00:02:55,380 --> 00:02:58,630
我们会发现它针对的都是叶子节点吧

61
00:02:58,630 --> 00:03:01,930
我们简单来看一下这里的叶子节点

62
00:03:01,930 --> 00:03:03,090
一、二、四、八

63
00:03:03,090 --> 00:03:06,530
针对这四个节点来构造一棵树

64
00:03:06,530 --> 00:03:07,810
代价最小

65
00:03:07,810 --> 00:03:11,370
我们希望较小全职可以放得远一些吧

66
00:03:11,370 --> 00:03:14,270
那我们从树的迭代过程来看的话

67
00:03:14,270 --> 00:03:14,630
唉

68
00:03:14,630 --> 00:03:18,730
层次数最多的这个叶子节点肯定是

69
00:03:18,730 --> 00:03:20,040
诶，最远的吧

70
00:03:20,040 --> 00:03:24,830
所以我们先选择最小的两个叶子节点

71
00:03:24,830 --> 00:03:26,690
哎，一和二

72
00:03:27,100 --> 00:03:30,180
我们构造出一棵子树

73
00:03:30,180 --> 00:03:34,730
那这棵树它的全值之和是等于三的

74
00:03:34,730 --> 00:03:38,500
此时我们在新的构造过程当中

75
00:03:38,500 --> 00:03:40,440
不再看一和二了

76
00:03:40,440 --> 00:03:44,410
而是呢，看它的全职之和三

77
00:03:44,410 --> 00:03:49,080
所以我们会删掉最小的两个全职节点

78
00:03:49,080 --> 00:03:52,300
引入新的全职之和三

79
00:03:52,300 --> 00:03:57,860
那接下来再来看最小的全职是三和四吧

80
00:03:57,860 --> 00:04:01,070
所以，唉，我们接下来所做的是

81
00:04:01,070 --> 00:04:05,200
将三和四构造成一棵树

82
00:04:05,200 --> 00:04:08,520
那这个三的来源是一和二吧

83
00:04:08,520 --> 00:04:11,410
它们之间构造的子数，诶

84
00:04:11,410 --> 00:04:14,660
它的全值是等于七的

85
00:04:14,660 --> 00:04:18,450
那此时同样把三和四去掉

86
00:04:18,450 --> 00:04:21,290
引入新的全职期

87
00:04:21,290 --> 00:04:25,160
下面我们考虑的就是七和八

88
00:04:25,160 --> 00:04:27,350
构造出一颗子树了吧

89
00:04:27,350 --> 00:04:31,640
这也是呢，我们当前最小的两个节点

90
00:04:31,640 --> 00:04:34,890
那这两个节点放进去之后

91
00:04:34,890 --> 00:04:38,620
整棵树，唉，整个关键字就不存在了吧

92
00:04:38,620 --> 00:04:42,180
我们就已经结束了它的构造过程

93
00:04:42,180 --> 00:04:44,860
将七和八删除之后

94
00:04:44,860 --> 00:04:48,140
没有其他带构造的节点呢

95
00:04:48,140 --> 00:04:51,090
那我们的构造到此结束

96
00:04:51,090 --> 00:04:56,330
我们在这里构造的整个过程而形成的就是呢

97
00:04:56,330 --> 00:04:58,230
最优二叉树

98
00:04:58,230 --> 00:05:04,160
每一步查找最小的两个全职构造子数之后

99
00:05:04,160 --> 00:05:06,200
删除掉这两个全职

100
00:05:06,200 --> 00:05:09,400
并引入它的全职之和

101
00:05:09,400 --> 00:05:11,450
到什么时候结束呢

102
00:05:11,450 --> 00:05:15,430
唉，没有新的带构造节点需要放进去了

103
00:05:15,430 --> 00:05:19,570
我们此时呢，就可以结束它的构造过程

104
00:05:19,570 --> 00:05:23,810
那这个构造呢，就叫做最优二叉树的构造

105
00:05:23,810 --> 00:05:26,290
我们针对下面这个例题呀

106
00:05:26,290 --> 00:05:27,750
大家可以暂停一下

107
00:05:27,750 --> 00:05:29,150
暂停一下视频

108
00:05:29,150 --> 00:05:31,440
自己呢，尝试动手做一做

109
00:05:31,440 --> 00:05:33,600
假设有一组全职啊

110
00:05:33,600 --> 00:05:36,700
五、29、七、八十四、23、31

111
00:05:36,700 --> 00:05:38,500
尝试构造哈夫曼树

112
00:05:38,500 --> 00:05:40,750
也就是呢，最优二叉树

113
00:05:40,750 --> 00:05:42,670
大家可以停下视频啊

114
00:05:42,670 --> 00:05:44,930
自己动手来进行构造

115
00:05:44,930 --> 00:05:48,670
那这样的一个全职序列

116
00:05:48,670 --> 00:05:52,860
我们会发现构造的数其实可以有多种形态

117
00:05:52,860 --> 00:05:56,440
我们首先找到最小全值五和三

118
00:05:56,440 --> 00:05:59,960
那我们把五和三构造成一棵子树

119
00:05:59,960 --> 00:06:02,360
诶，它的结果是等于八的

120
00:06:02,360 --> 00:06:04,940
所以把五和三去掉，诶

121
00:06:04,940 --> 00:06:07,570
放入新的全职之和八

122
00:06:07,570 --> 00:06:10,020
那此时我们会发现啊

123
00:06:10,020 --> 00:06:13,010
接下来的最小全值是七和八吧

124
00:06:13,010 --> 00:06:15,340
这里的八有两个

125
00:06:15,340 --> 00:06:16,680
到底选谁呢

126
00:06:16,680 --> 00:06:18,280
选谁都可以

127
00:06:18,280 --> 00:06:22,120
因为不会影响最终的最小全值

128
00:06:22,120 --> 00:06:24,360
那我们在这里可以呢

129
00:06:24,360 --> 00:06:27,020
直接针对七和八

130
00:06:28,540 --> 00:06:30,780
构造一棵子树，哎

131
00:06:30,780 --> 00:06:32,050
叫做15

132
00:06:32,050 --> 00:06:34,660
删除这两个节点

133
00:06:34,660 --> 00:06:37,090
引入新的节点15

134
00:06:37,090 --> 00:06:41,830
那下面的最小全值应该是八和11

135
00:06:41,830 --> 00:06:43,830
那我们可以选择呢

136
00:06:43,830 --> 00:06:46,090
哎，八和11

137
00:06:47,380 --> 00:06:51,420
让它构造出全值19

138
00:06:54,240 --> 00:06:58,100
那我们接下来把八和11去掉吧

139
00:06:58,100 --> 00:07:00,560
引入新的节点19

140
00:07:00,560 --> 00:07:03,500
下面呢，再来找最小全值

141
00:07:03,500 --> 00:07:06,480
应该是14和15

142
00:07:06,810 --> 00:07:08,430
那我们可以呢

143
00:07:08,430 --> 00:07:10,530
哎，把14放进去

144
00:07:10,530 --> 00:07:12,930
把15放进去

145
00:07:13,970 --> 00:07:17,610
构造出新的子数29

146
00:07:20,600 --> 00:07:22,860
那我们把14去掉

147
00:07:22,860 --> 00:07:23,920
15去掉，唉

148
00:07:23,920 --> 00:07:25,950
放入新的节点29

149
00:07:25,950 --> 00:07:28,140
那接下来构造的时候

150
00:07:28,140 --> 00:07:32,200
我们要找的唉是一个最小全值

151
00:07:32,200 --> 00:07:35,170
应该是19与23吧

152
00:07:35,170 --> 00:07:38,690
那19与23进行构造

153
00:07:39,960 --> 00:07:43,920
它的结果应该是等于42的

154
00:07:43,920 --> 00:07:47,080
那我们去掉19和23

155
00:07:47,080 --> 00:07:48,560
放入新的节点

156
00:07:48,560 --> 00:07:53,750
42下面的最小全值是29和29

157
00:07:53,750 --> 00:07:55,400
那这种情况下

158
00:07:55,400 --> 00:07:58,000
29和29的左右位置，诶

159
00:07:58,000 --> 00:08:00,840
是可以进行交换的

160
00:08:01,150 --> 00:08:05,790
两个位置交换形成的是新的形态

161
00:08:05,790 --> 00:08:08,210
可以呢，有新的这种呢

162
00:08:08,210 --> 00:08:09,900
哈夫曼树的存在啊

163
00:08:09,900 --> 00:08:11,450
那我们在这里呢

164
00:08:11,450 --> 00:08:13,750
可以有两种形态，哎

165
00:08:13,750 --> 00:08:15,170
29放在左侧

166
00:08:15,170 --> 00:08:17,920
或者29放在右侧

167
00:08:17,920 --> 00:08:21,470
那29和29

168
00:08:24,200 --> 00:08:27,840
可以构造出一颗新的子树

169
00:08:27,840 --> 00:08:29,000
58

170
00:08:38,679 --> 00:08:40,419
那我们最后呢

171
00:08:40,419 --> 00:08:42,780
哎，把29、29去掉

172
00:08:42,780 --> 00:08:44,960
引入新的全值58

173
00:08:44,960 --> 00:08:48,030
最后两个全职组合起来

174
00:08:48,030 --> 00:08:50,390
就是最终的这棵树

175
00:08:50,390 --> 00:08:51,750
那它是呢

176
00:08:51,750 --> 00:08:56,970
58与42进行的组合

177
00:08:56,970 --> 00:08:59,950
全值之和是100

178
00:09:00,800 --> 00:09:05,840
58的来源是29与29

179
00:09:06,040 --> 00:09:10,640
29的来源是15与14

180
00:09:10,680 --> 00:09:14,000
15的来源是八和七

181
00:09:14,000 --> 00:09:19,080
那42的来源是23与19

182
00:09:19,270 --> 00:09:22,630
19的来源是11和八

183
00:09:22,630 --> 00:09:24,910
八的来源是五和三

184
00:09:24,910 --> 00:09:26,880
那这棵哈夫曼树呢

185
00:09:26,880 --> 00:09:28,380
哎，就画出来了

186
00:09:28,380 --> 00:09:30,700
我们会发现构造的不同

187
00:09:30,700 --> 00:09:33,480
它这种形态呢，也是正确的吧

188
00:09:33,480 --> 00:09:37,070
那这种形态，它的全职也是呢，一样的

189
00:09:37,070 --> 00:09:39,560
还有呢，另一种形态，哎

190
00:09:39,560 --> 00:09:41,840
29和29的位置交换

191
00:09:41,840 --> 00:09:43,060
它也是呢

192
00:09:43,060 --> 00:09:45,430
合法的一种呢，哈夫曼树

193
00:09:45,430 --> 00:09:47,910
那这里的哈夫曼树啊

194
00:09:47,910 --> 00:09:51,440
它可以有不同的形态的存在

195
00:09:51,440 --> 00:09:54,400
并且，唉，这种形态不同

196
00:09:54,400 --> 00:09:56,640
有什么样的影响呢

197
00:09:56,640 --> 00:09:57,940
我们在这里呀

198
00:09:57,940 --> 00:09:59,520
把第三种形态呢

199
00:09:59,520 --> 00:10:01,640
也给大家画出来

200
00:10:02,260 --> 00:10:04,660
应该说四种形态啊

201
00:10:04,660 --> 00:10:07,380
我们这里的29、29做交换

202
00:10:07,380 --> 00:10:11,300
这里的29、29做交换也是呢，合法的

203
00:10:11,300 --> 00:10:14,420
那这些全值都为最小值的

204
00:10:14,420 --> 00:10:15,780
哎，我们这里就不画了

205
00:10:15,780 --> 00:10:17,900
四种形态我们就不写了啊

206
00:10:17,900 --> 00:10:20,130
那这种 half man 啊

207
00:10:20,130 --> 00:10:21,850
他的这种最优二叉树

208
00:10:21,850 --> 00:10:23,500
全值都是最小的

209
00:10:23,500 --> 00:10:25,260
有什么样的影响呢

210
00:10:25,260 --> 00:10:27,560
我们在哈夫曼的应用当中

211
00:10:27,560 --> 00:10:29,320
经常会说到一种呢

212
00:10:29,320 --> 00:10:31,440
叫做哈夫曼编码

213
00:10:31,440 --> 00:10:33,460
它的编码呀

214
00:10:33,460 --> 00:10:35,240
是一种呢，定长

215
00:10:35,240 --> 00:10:38,260
是一种变长的压缩编码

216
00:10:51,040 --> 00:10:53,860
也有叫做呢霍夫曼编码

217
00:10:53,860 --> 00:10:56,120
它的翻译不一样啊

218
00:10:57,410 --> 00:11:00,690
那这种编码是什么意思呢

219
00:11:00,690 --> 00:11:03,450
我们在日常生活当中的话

220
00:11:03,450 --> 00:11:05,420
如果说碰到一些

221
00:11:05,420 --> 00:11:06,720
比如说英文字

222
00:11:06,720 --> 00:11:09,060
a 、 b 、 c 、 d 、 e 、 f 、 g 

223
00:11:12,200 --> 00:11:16,440
假设这里的全职是各个字符

224
00:11:16,440 --> 00:11:20,090
它所出现的频率或者概率

225
00:11:20,090 --> 00:11:22,410
那有了这些全职之后

226
00:11:22,410 --> 00:11:26,250
唉，我们在这里发现它有几个字符啊

227
00:11:26,250 --> 00:11:28,130
八个字符吧

228
00:11:28,140 --> 00:11:30,020
八个字符

229
00:11:30,020 --> 00:11:32,700
如果用定长编码的话

230
00:11:32,700 --> 00:11:33,840
我们需要呢

231
00:11:33,840 --> 00:11:37,870
哎，二的三次方、三位二进制来表示

232
00:11:37,870 --> 00:11:41,910
分别呢，可以记作000

233
00:11:45,540 --> 00:11:53,340
000001010011100101

234
00:11:57,020 --> 00:11:59,560
110111

235
00:11:59,560 --> 00:12:03,220
这是我们哎，八个字符它的编码过程吧

236
00:12:03,220 --> 00:12:06,700
那这种编码呢，我们叫做定场

237
00:12:07,660 --> 00:12:12,250
定长编码意味着每一个字符都是一样长的

238
00:12:12,250 --> 00:12:15,880
那如果体现在文字或者说一篇文章

239
00:12:15,880 --> 00:12:17,560
它的篇幅上的话

240
00:12:17,560 --> 00:12:19,750
那这是一个固定的长度吧

241
00:12:19,750 --> 00:12:22,070
如果用变长的形式

242
00:12:22,070 --> 00:12:23,570
我们可以怎么考虑啊

243
00:12:23,570 --> 00:12:27,260
用的多的让它呢，编码变短一些

244
00:12:27,260 --> 00:12:30,700
用的少的编码呢，就多一些

245
00:12:30,700 --> 00:12:36,040
那这个编码仍然是用零、一、二进制来进行编码的

246
00:12:36,040 --> 00:12:38,710
那我们在编码的过程当中啊

247
00:12:38,710 --> 00:12:43,520
分支上面可以依次去标注零或一

248
00:12:43,520 --> 00:12:47,850
那我们一般呢，较大边给它呢，标注为一

249
00:12:47,850 --> 00:12:50,320
较小边标注为零

250
00:12:50,320 --> 00:12:53,880
所以我们在画哈夫曼树的时候啊

251
00:12:53,880 --> 00:12:57,970
一定要注意保证某一侧比另一侧呢

252
00:12:57,970 --> 00:13:00,450
相对大小是稳定的

253
00:13:00,450 --> 00:13:02,610
哎，这里呢，左侧比右侧大

254
00:13:02,610 --> 00:13:05,390
下面呢，也是左侧比右侧大

255
00:13:05,390 --> 00:13:07,690
是不是左侧一定要较小呢

256
00:13:07,690 --> 00:13:08,670
这里不一定

257
00:13:08,670 --> 00:13:12,050
只要保证相对位置就可以了

258
00:13:12,050 --> 00:13:16,600
那具体它编码较大位置取的是一还是零

259
00:13:16,600 --> 00:13:19,910
要根据题干来进行判断

260
00:13:19,910 --> 00:13:23,950
题干里面的一些选项是能够呢找到答案的

261
00:13:23,950 --> 00:13:26,160
那如果说这种答案不对

262
00:13:26,160 --> 00:13:28,000
我们可能呢就要换一种编码

263
00:13:28,000 --> 00:13:29,720
或者换一个形态了

264
00:13:29,720 --> 00:13:32,760
必须呢根据选项来确认诶

265
00:13:32,760 --> 00:13:35,960
它真正编码所用到的形态

266
00:13:36,230 --> 00:13:40,090
那我们把所有左侧边标一

267
00:13:40,090 --> 00:13:42,390
右侧边标零

268
00:13:44,040 --> 00:13:48,500
标完之后， A 它的全值是五

269
00:13:48,500 --> 00:13:51,340
它的出现频率是5%

270
00:13:51,340 --> 00:13:56,680
那它的这个编码长度就是一、二、三、四、五、五个一

271
00:13:58,300 --> 00:14:01,140
然后呢，较小值 G 

272
00:14:01,140 --> 00:14:03,480
它的编码长度呢，也是五

273
00:14:03,480 --> 00:14:06,440
它的结果是11110

274
00:14:06,440 --> 00:14:09,550
再来看哎，这是五和三吧

275
00:14:10,100 --> 00:14:11,900
再来看七

276
00:14:11,900 --> 00:14:13,220
它是呢 C 

277
00:14:13,220 --> 00:14:16,740
那它的编码应该是1110

278
00:14:16,740 --> 00:14:17,800
那这是呢

279
00:14:17,800 --> 00:14:18,690
c 

280
00:14:18,690 --> 00:14:21,260
它的长度只有四位

281
00:14:21,260 --> 00:14:22,580
再来看哎

282
00:14:22,580 --> 00:14:27,950
八、八和11对应的是 D 和 H 

283
00:14:27,950 --> 00:14:32,450
那 D 它的编码应该是零、零零

284
00:14:33,980 --> 00:14:37,740
H 的编码应该是011

285
00:14:38,580 --> 00:14:41,480
那我们会发现在这里啊

286
00:14:41,480 --> 00:14:45,590
如果八和八的位置做了交换的话

287
00:14:45,590 --> 00:14:48,210
最终形成的编码是有区别的

288
00:14:48,210 --> 00:14:49,310
这里要注意啊

289
00:14:49,310 --> 00:14:50,350
考试当中

290
00:14:50,350 --> 00:14:55,500
如果你发现 A 它的编码不是1111

291
00:14:55,500 --> 00:14:58,540
而是呢001

292
00:14:58,540 --> 00:15:00,120
那这种情况下

293
00:15:00,120 --> 00:15:03,260
哎，我们就要注意000、001啊

294
00:15:03,260 --> 00:15:04,470
这种情况的话

295
00:15:04,470 --> 00:15:07,580
它的编码形态就是有区别的

296
00:15:07,580 --> 00:15:11,190
所以一定要看清楚选项给出来的位置

297
00:15:11,190 --> 00:15:14,580
那现在的话， D 的编码是000

298
00:15:14,580 --> 00:15:17,140
H 的编码是011

299
00:15:17,140 --> 00:15:20,220
再来看接下来还有哪些字符呢

300
00:15:20,220 --> 00:15:23,320
哎，还有14%的是 E 

301
00:15:23,320 --> 00:15:26,430
29%的是 B 

302
00:15:26,430 --> 00:15:29,330
23%的是 F 

303
00:15:29,330 --> 00:15:33,370
那 B 的字符应该是编码幺零

304
00:15:34,340 --> 00:15:37,380
F 的字符编码零幺

305
00:15:40,220 --> 00:15:43,420
E 的字符编码110

306
00:15:43,420 --> 00:15:47,820
那这种情况，哎，我们会发现谁用的最频繁啊

307
00:15:47,820 --> 00:15:52,620
唉，其中频率最高的是 B 以及呢， F 

308
00:15:52,620 --> 00:15:56,990
这两个编码长度都只有两位

309
00:15:56,990 --> 00:16:01,650
所以可以呢，节约很大的篇幅来进行压缩

310
00:16:01,650 --> 00:16:05,360
这就是呢，变长编码它的含义

311
00:16:05,360 --> 00:16:07,540
那我们在考试当中啊

312
00:16:07,540 --> 00:16:11,060
一般考哈夫曼树或者最优二叉树的时候

313
00:16:11,060 --> 00:16:13,550
第一种考察形式呢，比较简单

314
00:16:13,550 --> 00:16:15,610
就是呢，把这棵树画出来

315
00:16:15,610 --> 00:16:19,200
让大家呢判断它的全职或者说数的代价

316
00:16:19,200 --> 00:16:21,210
唉，谁是最优二叉树

317
00:16:21,210 --> 00:16:24,560
那相对来说，第二种考察比较复杂

318
00:16:24,560 --> 00:16:26,940
就是呢，涉及到编码问题

319
00:16:26,940 --> 00:16:29,860
当然也有可能出现对哈夫曼树

320
00:16:29,860 --> 00:16:31,720
它的特性的考察

321
00:16:31,720 --> 00:16:34,290
下面啊，我们来看一下呢

322
00:16:34,290 --> 00:16:37,210
这一部分哈夫曼树或者说最优二叉树

323
00:16:37,210 --> 00:16:39,370
在我们软件设计师考试当

324
00:16:39,370 --> 00:16:40,680
真题的体现

325
00:16:40,680 --> 00:16:42,580
下面这道题，已知呢

326
00:16:42,580 --> 00:16:44,780
某个文档包含五类字符

327
00:16:44,780 --> 00:16:47,920
每个字符出现的频率如下所示

328
00:16:47,920 --> 00:16:50,460
那现在采用霍夫曼编码

329
00:16:50,460 --> 00:16:52,770
对这个文档进行压缩存储

330
00:16:52,770 --> 00:16:55,370
C 、 A 、 D 、 E 的编码是多少呢

331
00:16:55,370 --> 00:16:57,210
它的压缩比是多少呢

332
00:16:57,210 --> 00:17:00,190
其实就是一个构造哈夫曼树的过程吧

333
00:17:00,190 --> 00:17:03,460
最小全值应该是 B 1

334
00:17:03,460 --> 00:17:06,500
那应该是十和14

335
00:17:06,500 --> 00:17:07,800
我们可以把它呢

336
00:17:07,800 --> 00:17:09,930
分别记作 B 和 E 

337
00:17:09,930 --> 00:17:12,030
将较小值放在左侧的话

338
00:17:12,030 --> 00:17:14,290
哎，注意一下它的位置就行了

339
00:17:14,290 --> 00:17:16,910
那十和14合起来

340
00:17:16,910 --> 00:17:19,349
它的子数应该是呢

341
00:17:19,349 --> 00:17:21,940
全值之和24

342
00:17:21,940 --> 00:17:26,849
接下来较小值应该是16和20

343
00:17:26,849 --> 00:17:29,210
哎，接下来16

344
00:17:29,840 --> 00:17:31,300
20

345
00:17:31,300 --> 00:17:35,030
它们的全职之和是36

346
00:17:35,030 --> 00:17:37,730
所以把16、20去掉

347
00:17:37,730 --> 00:17:40,620
唉，接下来新的全职是36

348
00:17:40,620 --> 00:17:45,300
再来看最小值应该是24和36

349
00:17:45,300 --> 00:17:50,620
那它们的全值之和应该呢，是等于60的

350
00:17:50,620 --> 00:17:53,020
那接下来再并入，诶

351
00:17:53,020 --> 00:17:55,420
24和36，去掉

352
00:17:55,420 --> 00:17:56,610
插入60

353
00:17:56,610 --> 00:17:59,580
接下来的最小全值就是呢

354
00:17:59,580 --> 00:18:03,180
A 字符它的40%的频率

355
00:18:03,180 --> 00:18:07,410
那最终形成的这棵树是百分之百的全值吧

356
00:18:07,410 --> 00:18:09,150
没有其他字符了

357
00:18:09,150 --> 00:18:10,430
那我们此时呢

358
00:18:10,430 --> 00:18:12,360
哎，构造完

359
00:18:12,360 --> 00:18:15,140
16%的是 D 和 C 

360
00:18:15,140 --> 00:18:17,820
那这棵树画出来了之后

361
00:18:17,820 --> 00:18:20,480
首先找 C 的编码

362
00:18:20,480 --> 00:18:23,780
C 的编码应该在右侧吧

363
00:18:23,780 --> 00:18:28,160
我们发现它的编码一定是从一开始的

364
00:18:28,160 --> 00:18:30,830
所以右侧编码为一

365
00:18:30,830 --> 00:18:33,530
左侧编码为零

366
00:18:34,150 --> 00:18:38,090
那把编码的零一位置找到之后

367
00:18:38,090 --> 00:18:39,550
那我们在这里

368
00:18:39,550 --> 00:18:42,190
C 显然是111

369
00:18:42,510 --> 00:18:44,870
A 应该是零

370
00:18:45,350 --> 00:18:48,630
D 的话应该是110

371
00:18:49,150 --> 00:18:52,830
E 的话应该是呢？101

372
00:18:53,640 --> 00:18:57,860
那这四个字符找出来之后看一看选项

373
00:18:57,860 --> 00:18:58,300
哎

374
00:18:58,300 --> 00:19:00,080
1110

375
00:19:01,760 --> 00:19:03,100
然后呢

376
00:19:03,100 --> 00:19:04,760
呃110

377
00:19:05,380 --> 00:19:07,360
然后是101

378
00:19:07,360 --> 00:19:10,490
所以第一空选择的是 A 选项

379
00:19:10,490 --> 00:19:12,810
BCD 呢，都不满足要求

380
00:19:12,810 --> 00:19:14,440
这就是我们提到的

381
00:19:14,440 --> 00:19:16,970
如何根据选项来确

382
00:19:16,970 --> 00:19:19,210
它是较大侧设定为一

383
00:19:19,210 --> 00:19:21,880
还是较小侧设定为一的

384
00:19:21,880 --> 00:19:23,830
那再来看第二空

385
00:19:23,830 --> 00:19:25,970
关于文档的压缩比

386
00:19:25,970 --> 00:19:27,460
压缩比的话

387
00:19:27,460 --> 00:19:30,860
首先要知道通用的这个字符的话

388
00:19:30,860 --> 00:19:34,850
哎，如果是定长需要几个二进制位呢

389
00:19:34,850 --> 00:19:37,120
诶，应该需要三个

390
00:19:37,120 --> 00:19:40,790
因为二的二次方只能表示四个字符吧

391
00:19:40,790 --> 00:19:41,410
不够用

392
00:19:41,410 --> 00:19:43,620
所以至少需要三个位置

393
00:19:43,620 --> 00:19:47,160
那三位二进制是定场格的格式

394
00:19:47,160 --> 00:19:50,050
那如果是变长格式呢

395
00:19:50,050 --> 00:19:52,150
诶，变长情况下

396
00:19:52,150 --> 00:19:56,080
它的平均编码长度应该是呢

397
00:19:56,080 --> 00:19:58,470
一乘以40

398
00:19:58,470 --> 00:20:00,850
A 、 B 、 C 、 D 、 E 的长度啊

399
00:20:00,850 --> 00:20:03,270
我们依次呢，给它标一下

400
00:20:04,040 --> 00:20:06,520
A 的长度是一位

401
00:20:06,520 --> 00:20:10,080
B 和 E 的长度是三位

402
00:20:12,780 --> 00:20:17,580
然后呢， C 和 D 的长度也是呢三位

403
00:20:17,810 --> 00:20:20,750
所以这个变长边指当中啊

404
00:20:20,750 --> 00:20:24,250
A 它是呢，40%乘以一

405
00:20:24,650 --> 00:20:26,470
再加上唉

406
00:20:26,470 --> 00:20:31,030
剩下的60%都是呢，定长为三的吧

407
00:20:31,030 --> 00:20:32,530
大家也可以呢

408
00:20:32,530 --> 00:20:36,620
每一个字符单独的来进行求取它的百分率

409
00:20:36,620 --> 00:20:37,980
但是加起来的话

410
00:20:37,980 --> 00:20:39,980
其实刚好是60%

411
00:20:39,980 --> 00:20:41,600
所以综合来看

412
00:20:41,600 --> 00:20:43,900
它是0.4+1.8

413
00:20:43,900 --> 00:20:45,380
结果等于2.2

414
00:20:45,380 --> 00:20:48,530
这是定长和变长的区别吧

415
00:20:48,530 --> 00:20:49,790
定长是三

416
00:20:49,790 --> 00:20:52,490
变长的平均长度只有2.2

417
00:20:52,490 --> 00:20:53,920
压缩了多少呢

418
00:20:53,920 --> 00:20:56,240
3-2.2压缩比

419
00:20:56,240 --> 00:20:57,900
再来除以三

420
00:20:57,900 --> 00:21:00,780
哎，0.8÷3

421
00:21:01,820 --> 00:21:07,140
它的结果应该是约等于27%的

422
00:21:07,140 --> 00:21:09,720
这就是呢，关于压缩比

423
00:21:09,720 --> 00:21:11,280
它的求

424
00:21:11,280 --> 00:21:14,120
定长长度减去边长长度

425
00:21:14,120 --> 00:21:16,550
再比上我们的定长

426
00:21:16,550 --> 00:21:18,800
这是一个呢，压缩比的求取

427
00:21:18,800 --> 00:21:22,520
这道题是对哈夫曼编码的应用考察

428
00:21:23,590 --> 00:21:28,330
那这是呢，我们比较清晰一些的这个数啊

429
00:21:28,330 --> 00:21:30,280
它的这个哈夫曼树的结构

430
00:21:30,280 --> 00:21:35,600
然后呢，下面是关于定长和变长它的分析过程

431
00:21:35,600 --> 00:21:38,000
接下来再来看下面这道题

432
00:21:38,000 --> 00:21:40,380
以下关于哈夫曼编码的

433
00:21:40,380 --> 00:21:42,080
哈夫曼树的叙述当中

434
00:21:42,080 --> 00:21:43,720
错误的是谁

435
00:21:44,410 --> 00:21:46,260
那首先的话

436
00:21:46,260 --> 00:21:47,690
全值越大

437
00:21:47,690 --> 00:21:50,230
哎，我们会让它离节点越近吧

438
00:21:50,230 --> 00:21:52,910
这样它的树，它的叶子代价会比较小

439
00:21:52,910 --> 00:21:54,940
这个说法呢，是正确的

440
00:21:54,940 --> 00:21:57,390
B 选项，哈夫曼树不存在

441
00:21:57,390 --> 00:21:59,510
只有一个子树的节点

442
00:21:59,510 --> 00:22:00,820
我们会发现啊

443
00:22:00,820 --> 00:22:04,870
哈夫曼树它在求取的时候都是两两合并吧

444
00:22:04,870 --> 00:22:07,370
有没有说单个节点的情况啊

445
00:22:07,370 --> 00:22:09,150
没有单个节点啊

446
00:22:09,150 --> 00:22:11,800
所以它不存在这个，诶

447
00:22:11,800 --> 00:22:13,700
只有一个指数的节点

448
00:22:13,700 --> 00:22:15,810
这种说法是正确的

449
00:22:15,810 --> 00:22:18,420
那没有一个子树的节点的话

450
00:22:18,420 --> 00:22:22,320
我们会发现它的度只有二或者零的情况

451
00:22:22,320 --> 00:22:24,260
没有等于一的情况

452
00:22:24,260 --> 00:22:27,750
那 N 2和 N 0是不是很熟悉啊

453
00:22:27,750 --> 00:22:31,940
它们之间存在一个相差为一的关系

454
00:22:31,940 --> 00:22:33,790
那这种情况下，唉

455
00:22:33,790 --> 00:22:37,490
二者之和其实就是两倍加一

456
00:22:37,490 --> 00:22:40,050
那一个数的两倍一定是偶数

457
00:22:40,050 --> 00:22:41,500
偶数加上一

458
00:22:41,500 --> 00:22:45,470
它的节点总数一定是等于奇数的

459
00:22:45,470 --> 00:22:49,860
它套用了我们二叉树它的一个呢特性

460
00:22:49,860 --> 00:22:52,350
那再来看 D 选项当中

461
00:22:52,350 --> 00:22:54,780
全职相同的节点

462
00:22:54,780 --> 00:22:57,890
到树根的长度一定是相同的

463
00:22:57,890 --> 00:22:59,170
这个不一定吧

464
00:22:59,170 --> 00:23:01,350
我们在构造的过程当

465
00:23:01,350 --> 00:23:03,520
可能会有多种形态

466
00:23:03,520 --> 00:23:05,930
在前面的构造过程当中呢

467
00:23:05,930 --> 00:23:09,350
其实我们已经碰到过不同形态的时候

468
00:23:09,350 --> 00:23:10,560
全职相同

469
00:23:10,560 --> 00:23:12,800
它可能呢是单一的节点

470
00:23:12,800 --> 00:23:16,410
也有可能呢，唉，已经被拿去用了吧

471
00:23:16,410 --> 00:23:18,960
所以这个过程呢，它是不一样的

472
00:23:18,960 --> 00:23:20,880
哎，可以有不同长度

473
00:23:20,880 --> 00:23:22,220
这里呢，注意一下

474
00:23:22,220 --> 00:23:24,800
这个说法呢，是错误的

475
00:23:25,110 --> 00:23:27,130
那关于这道题

476
00:23:27,130 --> 00:23:29,090
它所考察的就是二叉树

477
00:23:29,090 --> 00:23:30,490
它哈夫曼树啊

478
00:23:30,490 --> 00:23:31,620
它的一些特性

479
00:23:31,620 --> 00:23:35,670
那这里关于呢，二叉树特性的相关内容呢

480
00:23:35,670 --> 00:23:38,580
大家可以再去呢，观看前面视

481
00:23:38,580 --> 00:23:41,510
他的一个回放来回顾一下

482
00:23:41,510 --> 00:23:45,680
这是呢，根据数的分支来进行验证的

483
00:23:45,680 --> 00:23:46,670
那这些呢

484
00:23:46,670 --> 00:23:49,950
就是要求大家掌握的关于最优二叉树

485
00:23:49,950 --> 00:23:51,410
或者叫做哈夫曼树

486
00:23:51,410 --> 00:23:53,550
它的一些相关内容
