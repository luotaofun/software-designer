1
00:00:00,000 --> 00:00:03,620
接下来我们简单来看一下图当中

2
00:00:03,620 --> 00:00:07,040
关于最小生成数与最短路径问题

3
00:00:07,040 --> 00:00:10,280
那这一部分在我们软件设计师考试当中

4
00:00:10,280 --> 00:00:12,630
其实涉及到的非常少

5
00:00:12,630 --> 00:00:14,850
这两个问题啊

6
00:00:14,850 --> 00:00:16,010
其实是数学

7
00:00:16,010 --> 00:00:19,110
或者说运筹学当中的两种解决方案

8
00:00:19,110 --> 00:00:20,810
那我们在这里呢

9
00:00:20,810 --> 00:00:23,170
主要需要大家了解到的是

10
00:00:23,170 --> 00:00:27,210
解决这两类问题所使用的算法策略

11
00:00:27,210 --> 00:00:31,180
实实实际上它的具体分析过程啊

12
00:00:31,180 --> 00:00:34,260
对于大家来说呢，是不做要求的

13
00:00:34,260 --> 00:00:38,420
那我们首先看到图它的最小生成树问题

14
00:00:38,420 --> 00:00:40,590
什么是它的最小生成数呢

15
00:00:40,590 --> 00:00:42,610
我们在前面给大家提到了

16
00:00:42,610 --> 00:00:44,130
联通图这样的概念

17
00:00:44,130 --> 00:00:46,100
让所有的节点之间啊

18
00:00:46,100 --> 00:00:48,240
都能够呢，存在一条路径吧

19
00:00:48,240 --> 00:00:50,950
而对于图的最小生成数

20
00:00:50,950 --> 00:00:55,450
它是要求将所有节点都连接起来

21
00:00:55,450 --> 00:00:59,300
并且形成的全值是最小的

22
00:00:59,300 --> 00:01:03,790
所以这里的最小指的是全值最小

23
00:01:04,970 --> 00:01:08,130
因为在形成的过程当中啊

24
00:01:08,130 --> 00:01:10,090
如果形成环路

25
00:01:10,090 --> 00:01:13,090
显然这种全职是有冗余的

26
00:01:13,090 --> 00:01:17,050
所以它是呢形成的是一个无环图

27
00:01:20,630 --> 00:01:23,470
形成的这种无环图的结构

28
00:01:23,470 --> 00:01:26,210
其实就是与树的结构很类似了

29
00:01:26,210 --> 00:01:27,810
我们说图和树啊

30
00:01:27,810 --> 00:01:32,320
是我们数据结构当中两种的逻辑结构数

31
00:01:32,320 --> 00:01:34,660
它有典型的层次关系

32
00:01:34,660 --> 00:01:38,830
图呢，相互之间都可以存在一些逻辑关系吧

33
00:01:38,830 --> 00:01:40,970
那针对这两种形式来看

34
00:01:40,970 --> 00:01:43,970
我们会发现它们有一个特别大的区别

35
00:01:43,970 --> 00:01:46,760
就在于树它是没有环路的

36
00:01:46,760 --> 00:01:49,730
所以这里生成的无环图呢

37
00:01:49,730 --> 00:01:52,230
我们也把它叫做呢树的结构

38
00:01:52,230 --> 00:01:54,620
或者说叫做生成树的结构

39
00:01:54,620 --> 00:01:55,450
啊

40
00:01:55,450 --> 00:01:58,120
那对于图的最小生成数

41
00:01:58,120 --> 00:02:01,260
它所考虑到的是两个维度

42
00:02:01,260 --> 00:02:04,650
一个是所有顶点都要接入

43
00:02:04,650 --> 00:02:05,970
第二个维度呢

44
00:02:05,970 --> 00:02:09,030
就是所有边上面的全值之

45
00:02:09,030 --> 00:02:10,930
一定是最小的

46
00:02:10,930 --> 00:02:13,630
那我们在解决这一类问题的时候

47
00:02:13,630 --> 00:02:15,900
可以有两类解决方案

48
00:02:15,900 --> 00:02:18,020
一个叫做克鲁斯卡尔算法

49
00:02:18,020 --> 00:02:19,910
一个叫做普里姆算法

50
00:02:19,910 --> 00:02:25,510
这两种算法使用的都是贪心的算法策略

51
00:02:25,510 --> 00:02:28,310
具体贪心的算法策略啊

52
00:02:28,310 --> 00:02:31,310
它的特点，我们在算法的章节当中

53
00:02:31,310 --> 00:02:34,090
还会呢，来给大家进行介绍

54
00:02:34,090 --> 00:02:38,720
那在这里简单了解贪心的思想呢

55
00:02:38,720 --> 00:02:41,640
就是在当前维度下

56
00:02:41,640 --> 00:02:45,140
来判断当前的最优 A 步

57
00:02:45,140 --> 00:02:47,340
往下去进行推进

58
00:02:47,340 --> 00:02:52,090
那我们现在知道目标是连接所有顶点

59
00:02:52,090 --> 00:02:54,630
并且这些顶点之间

60
00:02:54,630 --> 00:02:59,330
边上的全原值之和是最小的

61
00:03:02,440 --> 00:03:05,080
那我们在考虑问题的时候

62
00:03:05,080 --> 00:03:09,570
可以图从图当中两个维度去出发

63
00:03:09,570 --> 00:03:12,590
我们说图当中有两个重要的元素吧

64
00:03:12,590 --> 00:03:13,730
一个是节点

65
00:03:13,730 --> 00:03:15,120
一个呢是边

66
00:03:15,120 --> 00:03:17,510
那现在克鲁斯卡尔算法呢

67
00:03:17,510 --> 00:03:19,960
他就是从边去进行考虑的

68
00:03:19,960 --> 00:03:21,370
他考虑什么呢

69
00:03:21,370 --> 00:03:25,120
唉，既然要求所有的边全值最小

70
00:03:25,120 --> 00:03:29,420
那我一步一步地用最小值去求取累加

71
00:03:29,420 --> 00:03:32,190
结果就会呢，是最小值了

72
00:03:32,190 --> 00:03:34,440
所以我们从一个呢

73
00:03:34,440 --> 00:03:36,500
诶，画生成树的过程

74
00:03:36,500 --> 00:03:39,760
变成了一个寻找最小边的过程

75
00:03:39,760 --> 00:03:41,890
嗯，那比如说呢，唉

76
00:03:41,890 --> 00:03:44,270
我们以左侧这个图示为例

77
00:03:44,270 --> 00:03:46,360
上面有很多边吧

78
00:03:46,360 --> 00:03:48,140
边上面的全

79
00:03:48,140 --> 00:03:51,880
包括100、200、200、五、300、400等等

80
00:03:51,880 --> 00:03:54,920
那针对这些全值谁最小啊

81
00:03:54,920 --> 00:03:58,840
首先对比一下，最小值是100

82
00:03:59,400 --> 00:04:03,400
所以我们将 ab 这条边

83
00:04:03,400 --> 00:04:06,660
作为结果集合当中的第一条边

84
00:04:06,660 --> 00:04:09,250
那第一条边找到之后

85
00:04:09,250 --> 00:04:11,270
接下来的最小值是谁呢

86
00:04:11,270 --> 00:04:14,100
哎，显然应该是200吧

87
00:04:14,100 --> 00:04:16,510
那我们将 A 1这条边

88
00:04:16,510 --> 00:04:19,370
也放到了结果集合当中

89
00:04:19,370 --> 00:04:21,180
接下来的最小边呢

90
00:04:21,180 --> 00:04:22,680
应该是200

91
00:04:22,680 --> 00:04:26,700
那这里有两条全值为200的编码

92
00:04:26,700 --> 00:04:30,760
都需要放到结果集合当中来

93
00:04:31,840 --> 00:04:33,360
放入之后

94
00:04:33,360 --> 00:04:35,660
接下来的最小全值是谁呢

95
00:04:35,660 --> 00:04:38,960
唉，最短边应该是250

96
00:04:38,960 --> 00:04:43,900
所以将 AF 放到我们的结果集合当中

97
00:04:43,900 --> 00:04:47,430
下面的最小值应该是300了吧

98
00:04:47,430 --> 00:04:51,260
那这里同样有两条300的边

99
00:04:51,260 --> 00:04:55,990
是不是都要接入我们的最终生成数当中呢

100
00:04:55,990 --> 00:04:57,280
我们会发现

101
00:04:57,280 --> 00:05:01,920
BF 这条边如果连接起来的话

102
00:05:01,920 --> 00:05:04,450
它会形成一个环路

103
00:05:04,450 --> 00:05:07,010
那我们对于最小生成树

104
00:05:07,010 --> 00:05:09,500
它是只需要连通即可

105
00:05:09,500 --> 00:05:15,630
所以 baa f 原本是将 B 和 F 的路径打通了

106
00:05:15,630 --> 00:05:19,890
那这里环路解决的是 B 和 F 的连通问题

107
00:05:19,890 --> 00:05:22,520
在这里完全没有必要

108
00:05:22,520 --> 00:05:26,440
所以它是一条冗余的边环路

109
00:05:26,440 --> 00:05:29,260
不计入我们的结果

110
00:05:29,580 --> 00:05:32,620
那另外一条300的边呢

111
00:05:32,620 --> 00:05:35,870
哎，就会接入结果集合当中去了

112
00:05:35,870 --> 00:05:39,750
那接入之后到什么样的情况下结束呢

113
00:05:39,750 --> 00:05:42,810
所有节点都联系起来

114
00:05:42,810 --> 00:05:45,880
形成的就是最小生成数

115
00:05:45,880 --> 00:05:49,020
那这些红色的边的结果就是呢

116
00:05:49,020 --> 00:05:53,500
唉， A 、 B 、 A 1、 A 、 F 、 F 、 D 以及 DC 

117
00:05:53,500 --> 00:05:57,760
那这就是呢，最小生成树的结果

118
00:05:58,110 --> 00:06:01,670
第二种算法呢，叫做普利姆算法

119
00:06:01,670 --> 00:06:03,870
普利姆算法同样呢

120
00:06:03,870 --> 00:06:06,310
用到了贪心的算法策略

121
00:06:06,310 --> 00:06:08,360
它不是从边考虑

122
00:06:08,360 --> 00:06:12,710
而是呢，从我们的邻接顶点来考虑

123
00:06:12,710 --> 00:06:17,210
那我们的目标是需要将所有的顶点接入

124
00:06:17,210 --> 00:06:18,520
最小生成树吧

125
00:06:18,520 --> 00:06:23,410
所以我们可以选择任意一个顶点开始思考

126
00:06:23,410 --> 00:06:25,380
那我们选择谁呢

127
00:06:25,380 --> 00:06:27,120
唉，我们可以选择

128
00:06:27,120 --> 00:06:29,120
比如说 F 这个零点

129
00:06:29,120 --> 00:06:33,140
接下来我们需要将所有的顶点与 F 呢

130
00:06:33,140 --> 00:06:34,490
做连通图

131
00:06:34,490 --> 00:06:37,190
那在做这个连通图的过程当中

132
00:06:37,190 --> 00:06:39,750
我们希望全值之和最小吧

133
00:06:39,750 --> 00:06:42,150
所以我们在这里找的是

134
00:06:42,150 --> 00:06:46,150
离当前结果及最近的顶点

135
00:06:46,150 --> 00:06:51,140
那离 F 相关的顶点有400、200、五

136
00:06:51,140 --> 00:06:53,220
300、400和200

137
00:06:53,220 --> 00:06:54,860
谁离他最近啊

138
00:06:54,860 --> 00:06:58,080
应该是 D 顶点离他最近

139
00:06:58,080 --> 00:07:02,080
所以把 D 呢，放入结果集合当中去

140
00:07:02,080 --> 00:07:04,480
那 D 已经接入之后

141
00:07:04,480 --> 00:07:08,400
接下来在 D 和 F 集合基础上

142
00:07:08,400 --> 00:07:11,520
注意现在不是从 F 出发了

143
00:07:11,520 --> 00:07:14,970
而是从 D 和 F 两个顶点出发

144
00:07:14,970 --> 00:07:18,600
那他们能够找到的连接顶点

145
00:07:18,600 --> 00:07:20,380
还多了一个 C 吧

146
00:07:20,380 --> 00:07:22,820
那谁离他们最近呢

147
00:07:22,820 --> 00:07:25,180
哎，应该是250

148
00:07:25,180 --> 00:07:26,810
离他们最近

149
00:07:26,810 --> 00:07:31,880
所以接下来把顶点 A 接入到了结果集合

150
00:07:31,880 --> 00:07:34,700
那我们下一步在考虑的时候

151
00:07:34,700 --> 00:07:36,740
当前情况下

152
00:07:36,740 --> 00:07:39,370
DF 已经连通

153
00:07:39,370 --> 00:07:42,590
剩下的就是从 DF 出发

154
00:07:42,590 --> 00:07:45,190
找离他们最近的顶点了

155
00:07:45,190 --> 00:07:47,220
那接下来谁最近啊

156
00:07:47,220 --> 00:07:48,840
应该是100

157
00:07:48,840 --> 00:07:51,000
也就是 B 最近

158
00:07:51,000 --> 00:07:54,010
那 A 、 B 、 D 、 F 接入之后

159
00:07:54,010 --> 00:07:55,790
离他们最近的是谁呢

160
00:07:55,790 --> 00:07:58,830
哎，应该是 E 这个节点

161
00:07:58,830 --> 00:08:02,460
它所需要的临界边是200

162
00:08:02,460 --> 00:08:04,160
那最后，哎

163
00:08:04,160 --> 00:08:07,530
在 A 、 BDEEF 的基础上

164
00:08:07,530 --> 00:08:10,090
离他们最近的只有顶点 C 

165
00:08:10,090 --> 00:08:13,420
而 C 的话它有多条边接入

166
00:08:13,420 --> 00:08:18,560
最近的这条边应该是与 D 节点进行连接

167
00:08:18,560 --> 00:08:21,900
那这种情况下得到的也是呢

168
00:08:21,900 --> 00:08:24,390
这棵最小生成树

169
00:08:24,390 --> 00:08:25,380
注意啊

170
00:08:25,380 --> 00:08:28,600
最小生成树可以有多种形态

171
00:08:28,600 --> 00:08:31,850
与我们的最优二叉树有一些相似

172
00:08:31,850 --> 00:08:34,440
它只需要全值之和最小

173
00:08:34,440 --> 00:08:36,460
如果有其他形

174
00:08:36,460 --> 00:08:38,760
全值之和跟它相等的话

175
00:08:38,760 --> 00:08:42,419
也是合法的最小生成数

176
00:08:42,659 --> 00:08:46,220
那对于最小生成树的问题啊

177
00:08:46,220 --> 00:08:50,280
它的具体分析过程大家听一听就可以了

178
00:08:50,280 --> 00:08:52,280
我们需要大家了解到的是

179
00:08:52,280 --> 00:08:57,450
这两种算法都用到了贪心的算法策略

180
00:08:57,450 --> 00:09:02,690
从当前条件下来考虑当前的最优

181
00:09:02,690 --> 00:09:06,820
这就是呢，贪心他的一个呢，基本思想

182
00:09:06,890 --> 00:09:10,390
它一般用来解决什么样的问题呢

183
00:09:10,390 --> 00:09:13,150
哎，比如说我们现在有一个小区

184
00:09:13,150 --> 00:09:14,730
它有六栋楼

185
00:09:14,730 --> 00:09:18,850
我们要在六栋楼之间来建立燃气管道

186
00:09:18,850 --> 00:09:23,650
那什么样的方式才能让燃气管道距离最短

187
00:09:23,650 --> 00:09:25,690
这样成本就会降低吧

188
00:09:25,690 --> 00:09:27,490
那这个过程当中

189
00:09:27,490 --> 00:09:31,570
就只需要让大家相互之间形成通路

190
00:09:31,570 --> 00:09:34,560
就能够推动燃气的流动了吧

191
00:09:34,560 --> 00:09:37,420
有没有必要在中间增加环路呢

192
00:09:37,420 --> 00:09:38,260
唉，没有

193
00:09:38,260 --> 00:09:40,020
这是额外的成本

194
00:09:40,020 --> 00:09:42,030
开销是不需要的

195
00:09:42,030 --> 00:09:42,970
是浪费的

196
00:09:42,970 --> 00:09:44,510
所以这种情况下呢

197
00:09:44,510 --> 00:09:48,400
就会用最小生成数来解决问题

198
00:09:48,400 --> 00:09:50,290
我们再来看一下呢

199
00:09:50,290 --> 00:09:51,990
最短路径的问题

200
00:09:51,990 --> 00:09:56,780
最短路径呢，它一般是给大家一个起点和终点

201
00:09:56,780 --> 00:10:01,500
让大家分析从起点到终点哪一条路径

202
00:10:01,500 --> 00:10:03,750
它的成本是最低的

203
00:10:03,750 --> 00:10:05,620
那这个过程当中啊

204
00:10:05,620 --> 00:10:10,070
我们用到的是狄杰斯迪杰斯特拉算法

205
00:10:10,070 --> 00:10:11,550
针对这个算法

206
00:10:11,550 --> 00:10:15,480
它用到的仍然是贪心的算法策略

207
00:10:15,480 --> 00:10:16,950
我们首先啊

208
00:10:16,950 --> 00:10:20,110
对于最短路径与我们的项目工期呢

209
00:10:20,110 --> 00:10:21,750
要注意区分

210
00:10:22,840 --> 00:10:25,700
项目工期的分析当中

211
00:10:25,700 --> 00:10:28,470
我们的从起点到终点

212
00:10:28,470 --> 00:10:29,890
它不是呢目的地

213
00:10:29,890 --> 00:10:32,490
而是呢所有的活动

214
00:10:32,490 --> 00:10:35,770
所以只有全部节点都经过完成

215
00:10:35,770 --> 00:10:37,840
才能够完成最终任务吧

216
00:10:37,840 --> 00:10:39,640
才能够去交付项目

217
00:10:39,640 --> 00:10:42,020
而最短路径它是呢

218
00:10:42,020 --> 00:10:43,880
可以通过起点到终点

219
00:10:43,880 --> 00:10:46,660
比如说从北京到我们的上海

220
00:10:46,660 --> 00:10:48,380
可以呢飞机直达

221
00:10:48,380 --> 00:10:49,500
可以坐高铁

222
00:10:49,500 --> 00:10:50,780
还可以去换乘

223
00:10:50,780 --> 00:10:53,100
你甚至可以绕国家一周

224
00:10:53,100 --> 00:10:54,720
绕地球一周再回来吧

225
00:10:54,720 --> 00:10:58,360
那这种过程当中有不同的路径可选

226
00:10:58,360 --> 00:11:01,960
是不是它所标注的所有节点都要达到呢

227
00:11:01,960 --> 00:11:05,860
不需要，只需要考虑某一条通路

228
00:11:05,860 --> 00:11:08,240
它的代价最小就可以了

229
00:11:08,240 --> 00:11:10,990
这就是呢，最短路径的问题

230
00:11:10,990 --> 00:11:14,400
那我们在考虑最短路径的时候啊

231
00:11:14,400 --> 00:11:16,280
对于目的地来说

232
00:11:16,280 --> 00:11:19,110
我们要想到达目的地

233
00:11:19,110 --> 00:11:23,290
它一定会经过其中的这三个顶点吧

234
00:11:23,290 --> 00:11:25,080
那经过这三个顶点

235
00:11:25,080 --> 00:11:29,100
如果我知道这三个顶点到达的时候

236
00:11:29,100 --> 00:11:31,030
所花费的最小成本

237
00:11:31,030 --> 00:11:35,380
那我是不是通过这三个点顶点依次去分析，诶

238
00:11:35,380 --> 00:11:38,340
它到达目的地的最终成本就可以啦

239
00:11:38,340 --> 00:11:40,250
所以这种情况下

240
00:11:40,250 --> 00:11:44,030
我们从求 S 到 T 的最终成本，哎

241
00:11:44,030 --> 00:11:45,990
最小成本变成了求

242
00:11:45,990 --> 00:11:50,330
从 S 到569的最小成本

243
00:11:50,330 --> 00:11:52,100
或者叫呢，最短路径

244
00:11:52,100 --> 00:11:54,630
那同样569的最短路

245
00:11:54,630 --> 00:11:55,990
我们可以通过诶

246
00:11:55,990 --> 00:11:58,830
三四、七、八来进行分析吧

247
00:11:59,070 --> 00:12:01,230
所以我们啊

248
00:12:01,230 --> 00:12:02,800
反向来推的话

249
00:12:02,800 --> 00:12:05,700
到达目的地的最小成本

250
00:12:05,700 --> 00:12:10,060
最短路径由前面节点的最短路径来决定

251
00:12:10,060 --> 00:12:13,030
那同样我们正向来分析的话

252
00:12:13,030 --> 00:12:17,250
只要将每一个节点的最短路径求出来

253
00:12:17,250 --> 00:12:21,400
我们就可以通过某一个节点去推算

254
00:12:21,400 --> 00:12:24,080
后面节点的最短路径吧

255
00:12:24,080 --> 00:12:27,030
从而解决最终的问题

256
00:12:27,030 --> 00:12:30,150
所以我们由整体求解

257
00:12:30,150 --> 00:12:30,950
把它呢

258
00:12:30,950 --> 00:12:36,830
诶，考虑到的问题就只考虑当前最短就足够了

259
00:12:36,830 --> 00:12:39,020
那这种当前条件下

260
00:12:39,020 --> 00:12:42,350
用到的就是贪心的算法策略了

261
00:12:42,350 --> 00:12:44,100
那我们首先看到呢

262
00:12:44,100 --> 00:12:47,340
从 S 出发到节点一

263
00:12:47,340 --> 00:12:49,530
我们可以直达25

264
00:12:49,530 --> 00:12:52,920
可以呢，绕个圈从二到达46吧

265
00:12:52,920 --> 00:12:57,640
甚至你可以通过二、四、六、五、七、八再回到一

266
00:12:57,640 --> 00:12:59,330
有没有必要验证呢

267
00:12:59,330 --> 00:13:00,540
没有必要了

268
00:13:00,540 --> 00:13:04,900
它的最短路径一定呢，是25

269
00:13:04,990 --> 00:13:09,440
一般正向分析就足够了

270
00:13:09,440 --> 00:13:13,660
那2号节点同样的可以如此去分析

271
00:13:13,660 --> 00:13:15,930
离它最短的路径是谁啊

272
00:13:15,930 --> 00:13:17,900
S 直达目的

273
00:13:17,900 --> 00:13:20,980
它的长度呢是21

274
00:13:20,980 --> 00:13:24,760
那我们接下来分析3号节点

275
00:13:24,760 --> 00:13:28,090
它可以通过2号节点直达吧

276
00:13:28,090 --> 00:13:30,390
甚至可以通过一号节点

277
00:13:30,390 --> 00:13:33,220
然后依次到达3号节点

278
00:13:33,220 --> 00:13:36,210
那显然2号节点直达

279
00:13:36,210 --> 00:13:39,020
它的这个长度是最短的

280
00:13:39,020 --> 00:13:42,850
这里的结果应该是41

281
00:13:42,960 --> 00:13:48,020
也就是说从 S 出发到达节点三

282
00:13:48,020 --> 00:13:50,740
它的最短路径是41

283
00:13:50,740 --> 00:13:52,580
从哪里到达的

284
00:13:52,580 --> 00:13:56,100
哎，通过二、 S 2、三到达的

285
00:13:56,100 --> 00:13:59,840
那这就是呢，最短路径的分析过程

286
00:14:00,090 --> 00:14:03,830
我们将所有节点依次去分析啊

287
00:14:03,830 --> 00:14:07,550
就能找到目的地 T 它的最短路径了

288
00:14:07,550 --> 00:14:11,310
那我们说4号节点可以通过3号节点

289
00:14:11,310 --> 00:14:14,000
也可以通过2号节点到达坝

290
00:14:14,000 --> 00:14:15,840
通过3号节点

291
00:14:15,840 --> 00:14:17,500
结果是53

292
00:14:17,500 --> 00:14:20,550
2号节点呢，结果是46

293
00:14:20,550 --> 00:14:24,350
显然下面这条路更近一些

294
00:14:25,080 --> 00:14:27,480
5号节点可以呢

295
00:14:27,480 --> 00:14:30,160
通过七八节点绕过来

296
00:14:30,160 --> 00:14:33,500
也可以直接通过3号节点到达坝

297
00:14:33,500 --> 00:14:38,600
那我们绕过来的这条路径至少包含70，唉

298
00:14:38,600 --> 00:14:40,820
至少包含我们的这个

299
00:14:40,820 --> 00:14:43,160
25+6加35吧

300
00:14:43,160 --> 00:14:45,410
相对来说是比较大的一个数值

301
00:14:45,410 --> 00:14:48,140
而直接通过三到达的话

302
00:14:48,140 --> 00:14:51,250
只需要61就足够了

303
00:14:51,250 --> 00:14:54,180
那我们再来看对6号节点

304
00:14:54,180 --> 00:14:56,100
可以通过4号节

305
00:14:56,100 --> 00:14:58,280
经过45的代价过来

306
00:14:58,280 --> 00:15:00,640
也可以通过5号节点

307
00:15:00,640 --> 00:15:03,070
通过八个代价就到达了

308
00:15:03,070 --> 00:15:04,920
所以谁更划算

309
00:15:04,920 --> 00:15:06,580
上面更划算

310
00:15:06,580 --> 00:15:09,440
最小代价或者说最短路径呢

311
00:15:09,440 --> 00:15:11,600
应该是68

312
00:15:11,600 --> 00:15:15,740
那7号节点可以通过5号节点过来

313
00:15:15,740 --> 00:15:18,770
也可以直接通过一号节点过来吧

314
00:15:18,770 --> 00:15:22,550
那此时通过一号节点肯定比较近

315
00:15:22,550 --> 00:15:24,760
代价是36

316
00:15:24,760 --> 00:15:26,580
我们也可以注意一下

317
00:15:26,580 --> 00:15:31,470
36、七到5号节点至少是需要70的

318
00:15:31,470 --> 00:15:34,370
也就是说没有低于61

319
00:15:34,370 --> 00:15:36,600
这是呢，不需要调整的

320
00:15:36,600 --> 00:15:39,940
那这种交错的位置容易呢，出错

321
00:15:39,940 --> 00:15:43,380
要留意前面的分析有没有问题

322
00:15:43,380 --> 00:15:47,150
那8号节点从一号节点直接过来

323
00:15:47,150 --> 00:15:48,470
只需要31

324
00:15:48,470 --> 00:15:52,150
从7号节点过来需要61

325
00:15:52,150 --> 00:15:55,960
显然上面这条路径更划算

326
00:15:55,960 --> 00:15:56,850
好

327
00:15:56,850 --> 00:15:59,270
再来看9号节点

328
00:15:59,270 --> 00:16:01,650
可以通过7号节点到达

329
00:16:01,650 --> 00:16:04,340
也可以通过8号节点到达吧

330
00:16:04,340 --> 00:16:06,390
8号节点更划算

331
00:16:06,390 --> 00:16:09,130
最小代价是64

332
00:16:09,130 --> 00:16:11,140
那这样分析之后

333
00:16:11,140 --> 00:16:14,500
到达目的地 T 之前的三个节点

334
00:16:14,500 --> 00:16:17,900
最短路径我们都分析完成了

335
00:16:17,900 --> 00:16:22,880
9号节点到目的地 T 需要82的代价

336
00:16:22,880 --> 00:16:27,200
5号节点到 T 需要呢，82的代价

337
00:16:27,200 --> 00:16:30,950
而6号节点到 T 应该呢

338
00:16:30,950 --> 00:16:32,390
需要80的代价

339
00:16:32,390 --> 00:16:34,030
这里有一些问题啊

340
00:16:34,030 --> 00:16:36,850
61+8这里应该是69

341
00:16:36,850 --> 00:16:38,430
不是呢，68

342
00:16:38,430 --> 00:16:42,800
那最终到 T 的代价应该是69+12

343
00:16:42,800 --> 00:16:43,770
81

344
00:16:43,770 --> 00:16:46,050
所以这个代价应该是81

345
00:16:46,050 --> 00:16:47,050
不是80啊

346
00:16:47,050 --> 00:16:48,960
前面有一个步骤算错了

347
00:16:48,960 --> 00:16:51,940
那我们在这里三条路径对比一下

348
00:16:51,940 --> 00:16:52,900
谁划算啊

349
00:16:52,900 --> 00:16:55,650
显然下面这条路径更划算吧

350
00:16:55,650 --> 00:17:00,020
他需要的花费至少是81万元

351
00:17:00,020 --> 00:17:04,440
那他所选择的路径是通过 S 出发

352
00:17:04,440 --> 00:17:07,050
也经过了哪些节点呢

353
00:17:07,050 --> 00:17:07,390
哎

354
00:17:07,390 --> 00:17:09,849
经过了2号节点

355
00:17:11,010 --> 00:17:17,839
3号节点、5号节点、6号节点到达的 T 节点

356
00:17:17,839 --> 00:17:19,359
所以这是它的呢

357
00:17:19,359 --> 00:17:22,050
最短路径分析的过程

358
00:17:22,050 --> 00:17:23,960
那这个具体的分析过程

359
00:17:23,960 --> 00:17:26,250
相对来说还是比较复杂的

360
00:17:26,250 --> 00:17:27,980
那我们在这里呀

361
00:17:27,980 --> 00:17:30,240
主要呢，是了解贪

362
00:17:30,240 --> 00:17:32,990
他的这个策略就可以了

363
00:17:32,990 --> 00:17:35,270
目前在软件设计师考试啊

364
00:17:35,270 --> 00:17:37,720
并没有涉及具体的分析过程

365
00:17:37,720 --> 00:17:40,520
只考到了这三种算法

366
00:17:40,520 --> 00:17:44,470
诶，它所使用的算法策略是哪一种

367
00:17:44,470 --> 00:17:47,140
这就是呢，给大家介绍到的

368
00:17:47,140 --> 00:17:50,170
最小生成树和最短路径问题

369
00:17:50,170 --> 00:17:53,110
目前呢，只是要求了解算

370
00:17:53,110 --> 00:17:54,910
它的具体分析过程

371
00:17:54,910 --> 00:17:55,770
不做要求
