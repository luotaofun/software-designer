1
00:00:00,000 --> 00:00:03,280
下面我们来看一下关于图的操作

2
00:00:03,280 --> 00:00:05,340
也就是它的便利过程

3
00:00:05,340 --> 00:00:07,320
对于图的便利啊

4
00:00:07,320 --> 00:00:10,440
它是呢，从某一个顶点出发之后

5
00:00:10,440 --> 00:00:12,440
对所有顶点呢

6
00:00:12,440 --> 00:00:14,630
按照我们的搜索路径

7
00:00:14,630 --> 00:00:16,260
然后呢，探索一遍

8
00:00:16,260 --> 00:00:18,260
并且每一个顶点访问

9
00:00:18,260 --> 00:00:20,770
且只访问一次的过程啊

10
00:00:20,770 --> 00:00:22,290
它与数的便利呢

11
00:00:22,290 --> 00:00:23,790
有一定的相似性

12
00:00:23,790 --> 00:00:24,720
这个操作

13
00:00:24,720 --> 00:00:27,910
那我们看到呢，对于树的遍历

14
00:00:27,910 --> 00:00:30,640
它其实有先序、中序、后序吧

15
00:00:30,640 --> 00:00:32,530
而我们对于图来说

16
00:00:32,530 --> 00:00:35,620
它其实是没有明确的层次结构的

17
00:00:35,620 --> 00:00:38,300
这个图是看起来有层次结构吧

18
00:00:38,300 --> 00:00:40,560
但是转一转还是一个图

19
00:00:40,560 --> 00:00:42,890
但它呢，可能就没有层次了

20
00:00:42,890 --> 00:00:45,800
所以图啊，我们说便利，不说层次

21
00:00:45,800 --> 00:00:47,840
也不说先序、中序、后序

22
00:00:47,840 --> 00:00:49,630
它的便利方法呢

23
00:00:49,630 --> 00:00:53,890
是按深度优先和广度优先来划分的

24
00:00:53,890 --> 00:00:56,940
那我们整个便利的过程

25
00:00:56,940 --> 00:01:00,440
它也可以呢，用递归来进行实现啊

26
00:01:00,440 --> 00:01:03,090
那我们首先看深度，遍历

27
00:01:03,090 --> 00:01:04,349
深度便利啊

28
00:01:04,349 --> 00:01:07,930
我们首先呢，会访问某一个出发顶点

29
00:01:07,930 --> 00:01:10,060
唉，到底要不要是 V 1呢

30
00:01:10,060 --> 00:01:14,180
不一定，我们可以任意去选择某一个顶点啊

31
00:01:14,180 --> 00:01:19,050
但是如果我们是对某一个数据结构的图

32
00:01:19,050 --> 00:01:20,130
来访问的话

33
00:01:20,130 --> 00:01:24,470
比如说如果给大家一个二维矩阵

34
00:01:24,470 --> 00:01:26,150
A 连接矩阵存储

35
00:01:26,150 --> 00:01:29,170
12345678

36
00:01:29,170 --> 00:01:32,700
12345678

37
00:01:32,700 --> 00:01:34,990
这是它的二维矩阵吧

38
00:01:34,990 --> 00:01:36,990
那我们在便利的时候

39
00:01:36,990 --> 00:01:42,120
一般呢会从第一个非零元素开始找起

40
00:01:42,120 --> 00:01:46,670
然后从这个12 A 这个顶点出发

41
00:01:46,670 --> 00:01:48,420
然后呢，去访问

42
00:01:48,420 --> 00:01:51,050
从一号顶点开始进行便利

43
00:01:51,050 --> 00:01:55,250
然后呢，通过它的边找到2号连接顶点

44
00:01:55,250 --> 00:01:56,210
这就是呢

45
00:01:56,210 --> 00:01:58,970
通过邻接矩阵来便利的过程

46
00:01:58,970 --> 00:02:01,600
邻接表呢，同样也可以

47
00:02:01,600 --> 00:02:03,500
那谁是起点啊

48
00:02:03,500 --> 00:02:06,400
根据我们的存储结构来看

49
00:02:06,400 --> 00:02:07,690
谁是起点

50
00:02:07,690 --> 00:02:09,840
没有存储结构的情况下

51
00:02:09,840 --> 00:02:13,560
根据图示是可以选择任意一个顶点出发

52
00:02:13,560 --> 00:02:16,160
作为呢，起始顶点的

53
00:02:16,160 --> 00:02:20,740
那我们出发之后搜索它的连接顶点

54
00:02:20,740 --> 00:02:24,140
也就是存在非零元素或者表结构，呃

55
00:02:24,140 --> 00:02:26,060
表节点的这样的位置

56
00:02:26,060 --> 00:02:28,810
那我们从 V 1出发的话

57
00:02:28,810 --> 00:02:31,750
可以找到 V 2以及 V 3

58
00:02:31,750 --> 00:02:34,120
都是它的临界0.8

59
00:02:34,120 --> 00:02:36,960
如果是深度优先啊

60
00:02:36,960 --> 00:02:41,090
它会呢，找到一个临界顶点之后

61
00:02:41,090 --> 00:02:46,030
接下来找邻接顶点的下一个连接顶点

62
00:02:46,030 --> 00:02:49,550
直到不再呢深入为止

63
00:02:49,550 --> 00:02:51,480
所以我们会发现呢

64
00:02:51,480 --> 00:02:53,120
对 V 1出发

65
00:02:53,120 --> 00:02:55,200
如果是深度遍历

66
00:02:55,200 --> 00:02:59,220
我们可以找 V 2、 V 4、 V 8、 V 5

67
00:02:59,630 --> 00:03:02,950
那 V 5有没有连接顶点呢

68
00:03:02,950 --> 00:03:04,670
有在 V 2

69
00:03:04,670 --> 00:03:07,820
但是 VR 已经访问过了

70
00:03:07,820 --> 00:03:09,520
所以我们在涉及啊

71
00:03:09,520 --> 00:03:11,820
对图的便利写算法的时候

72
00:03:11,820 --> 00:03:15,310
其实一般会给每一个节点加一个标记符

73
00:03:15,310 --> 00:03:17,420
表示呢有没有访问过

74
00:03:17,420 --> 00:03:18,960
那已经访问过了

75
00:03:18,960 --> 00:03:20,780
肯定不能再来便利了吧

76
00:03:20,780 --> 00:03:24,180
所以我们可以返回上一层节点

77
00:03:24,180 --> 00:03:27,360
如果 V 8有其他未被访问的

78
00:03:27,360 --> 00:03:29,060
我们可以呢接着访问

79
00:03:29,060 --> 00:03:30,560
但是没有吧

80
00:03:30,560 --> 00:03:33,690
所以接着返回，返回

81
00:03:33,690 --> 00:03:36,300
直到返回 V 1之后

82
00:03:36,300 --> 00:03:40,560
才有新的未被访问的连接顶点

83
00:03:40,560 --> 00:03:42,440
唉，谁 V 3

84
00:03:42,440 --> 00:03:46,610
那我们接下来从 V 3找连接顶点，诶

85
00:03:46,610 --> 00:03:50,290
V 6、 V 7，将所有顶点访问一遍

86
00:03:50,290 --> 00:03:54,280
这就是它的深度优先的便利过程

87
00:03:54,280 --> 00:03:57,170
那我如果从 V 1出发

88
00:03:57,170 --> 00:04:00,940
先访问 V 3、 V 6、 V 7

89
00:04:00,940 --> 00:04:05,340
再返回从 V 2进行深度便利，哎

90
00:04:05,340 --> 00:04:08,830
找 V 4、 V 8、 V 5可不可以呢

91
00:04:08,830 --> 00:04:09,980
也可以

92
00:04:09,980 --> 00:04:14,690
这也是一个合法的深度便利的序列

93
00:04:14,690 --> 00:04:17,170
所以我们在涉及考试当中啊

94
00:04:17,170 --> 00:04:19,800
考察大家便利序列的时候

95
00:04:19,800 --> 00:04:22,310
更多的是找非法的序列

96
00:04:22,310 --> 00:04:24,510
更好呢，去查看一些啊

97
00:04:24,510 --> 00:04:27,730
合法的序列其实会非常多

98
00:04:27,730 --> 00:04:30,440
那这是深度遍历的过程

99
00:04:30,440 --> 00:04:31,340
注意呢

100
00:04:31,340 --> 00:04:35,860
我们的起点可以根据临接表或者临接矩阵

101
00:04:35,860 --> 00:04:36,980
来确定

102
00:04:36,980 --> 00:04:39,700
在便利的过程当中

103
00:04:39,700 --> 00:04:42,610
如果没有可访问的临界

104
00:04:42,610 --> 00:04:45,230
顶点是返回上一层

105
00:04:45,230 --> 00:04:49,480
并不会一下子就返回到初始的顶点啊

106
00:04:49,480 --> 00:04:51,260
只会返回一层

107
00:04:51,260 --> 00:04:53,540
这个地方呢，注意一下

108
00:04:59,760 --> 00:05:01,400
那我们，哎

109
00:05:01,400 --> 00:05:04,080
对于广度优先什么意思呢

110
00:05:04,080 --> 00:05:08,560
广度优先其实很类似我们的层次变异

111
00:05:08,560 --> 00:05:11,670
他选择某一个临界顶点之后

112
00:05:11,670 --> 00:05:15,630
接下来会把它所有相关的临界顶点呢

113
00:05:15,630 --> 00:05:16,600
访问一次

114
00:05:16,600 --> 00:05:18,600
如果从 V 1出发

115
00:05:18,600 --> 00:05:21,950
它会直接访问相邻的二和三

116
00:05:21,950 --> 00:05:24,800
那二和三访问之后

117
00:05:24,800 --> 00:05:27,940
我们接下来的层次是从 V 2开始

118
00:05:27,940 --> 00:05:29,810
还是 V 3开始

119
00:05:29,810 --> 00:05:33,370
如果使用相应的数据结构

120
00:05:33,370 --> 00:05:35,430
存这个节点的时候

121
00:05:35,430 --> 00:05:36,750
数据结构不一样

122
00:05:36,750 --> 00:05:38,240
区别不一样

123
00:05:38,240 --> 00:05:40,850
如果用队列来存的话

124
00:05:40,850 --> 00:05:43,630
我们一般用队列比较多

125
00:05:43,630 --> 00:05:46,140
那我们队列会先进

126
00:05:46,140 --> 00:05:47,960
V 2是连接顶点吧

127
00:05:47,960 --> 00:05:51,000
然后呢，让 V 3进入队列

128
00:05:51,000 --> 00:05:53,290
那我们在出对的时候

129
00:05:53,290 --> 00:05:55,950
接下来会把呢， V 2出对

130
00:05:55,950 --> 00:05:58,490
找 V 2的邻接顶点

131
00:05:58,490 --> 00:06:02,150
那 V 2的连接顶点有 V 4和 V 58

132
00:06:02,150 --> 00:06:06,880
然后呢，再来访问 AV 3的连接顶

133
00:06:06,880 --> 00:06:08,650
V 6和 V 7

134
00:06:08,650 --> 00:06:11,280
那我们在访问临界顶点的时候

135
00:06:11,280 --> 00:06:16,180
又会把那 V 4、 V 5、 V 6、 V 

136
00:06:16,180 --> 00:06:18,440
按我们访问的顺序啊

137
00:06:18,440 --> 00:06:21,440
把这个节点呢存到队列当中去

138
00:06:21,440 --> 00:06:23,950
接下来让 V 4出对

139
00:06:23,950 --> 00:06:27,470
我们对 V 4呢，找它的连接顶点

140
00:06:27,470 --> 00:06:28,660
也就是 V 8

141
00:06:28,660 --> 00:06:31,940
从而将所有的序列访问一次

142
00:06:31,940 --> 00:06:35,110
就可以能达到便秘的效果了

143
00:06:35,110 --> 00:06:36,790
所以广度便利啊

144
00:06:36,790 --> 00:06:38,770
是找一个连接顶点之后

145
00:06:38,770 --> 00:06:41,320
找它相关的连接顶点

146
00:06:41,320 --> 00:06:44,880
然后选择其中一个再访问它

147
00:06:44,880 --> 00:06:47,880
所有的临界顶点都要访问一

148
00:06:47,880 --> 00:06:50,140
才会呢，返回上一层

149
00:06:50,140 --> 00:06:51,820
所以它也是啊

150
00:06:51,820 --> 00:06:55,900
访问完之后要返回上一层的过程

151
00:06:55,900 --> 00:06:56,940
那这是呢

152
00:06:56,940 --> 00:06:58,250
广度优先

153
00:06:58,250 --> 00:06:59,520
深度优先啊

154
00:06:59,520 --> 00:07:02,840
就是不断往下去探索的过程

155
00:07:02,840 --> 00:07:05,820
广度优先是从一个顶点出发

156
00:07:05,820 --> 00:07:07,760
扫描相关节点

157
00:07:07,760 --> 00:07:10,760
然后呢，选择其中一个顶点

158
00:07:10,760 --> 00:07:12,480
扫描相关顶点

159
00:07:12,480 --> 00:07:15,430
一层一层的去进行处理

160
00:07:15,430 --> 00:07:16,710
那这是我们呢

161
00:07:16,710 --> 00:07:21,300
涉及到的深度优先和广度优先的过程

162
00:07:21,300 --> 00:07:23,210
那我们会发现啊

163
00:07:23,210 --> 00:07:25,230
他看的整个便利呢

164
00:07:25,230 --> 00:07:28,610
其实是通过顶点把所有顶点都找一遍吧

165
00:07:28,610 --> 00:07:30,750
那它搜索的过程当中

166
00:07:30,750 --> 00:07:33,250
是通过边来进行搜索的

167
00:07:33,250 --> 00:07:37,420
所以它最终啊，其实是会扫描边的过程的

168
00:07:37,420 --> 00:07:42,000
那如果我们用邻接矩阵来存的话

169
00:07:42,000 --> 00:07:43,540
我们会发现

170
00:07:43,540 --> 00:07:46,560
要想确定是否有其他边

171
00:07:46,560 --> 00:07:49,910
或者其他的顶点未被扫描到

172
00:07:49,910 --> 00:07:53,350
我们一般呢，要对整个二维矩

173
00:07:53,350 --> 00:07:56,270
做一个全部的便利吧

174
00:07:56,270 --> 00:07:58,290
所以它是一个呢，诶

175
00:07:58,290 --> 00:08:03,420
二维矩阵的双层嵌套循环来进行扫描的

176
00:08:03,420 --> 00:08:08,070
那如果是用邻接表的形式来存储的话

177
00:08:08,070 --> 00:08:11,630
它需要呢，通过连接顶点，诶

178
00:08:11,630 --> 00:08:13,070
通过节点

179
00:08:13,070 --> 00:08:17,640
然后呢，去访问他的这个各个表节点吧

180
00:08:17,640 --> 00:08:21,460
那表检点的个数是与一相关的

181
00:08:21,460 --> 00:08:23,020
所以我们会发现呢

182
00:08:23,020 --> 00:08:25,500
便利它的时间复杂度啊

183
00:08:25,500 --> 00:08:28,710
与存储结构是有相关性的

184
00:08:28,710 --> 00:08:31,200
与我们选择的算法无关啊

185
00:08:31,200 --> 00:08:34,190
只与呢，我们的存储结构相关

186
00:08:34,190 --> 00:08:35,220
那这是呢

187
00:08:35,220 --> 00:08:38,020
关于图便利的时间复杂度

188
00:08:38,020 --> 00:08:40,620
需要大家呢了解一下

189
00:08:40,740 --> 00:08:45,330
如何确定这一个图已经被编辑完了呢

190
00:08:45,330 --> 00:08:48,700
我们可以用一个数值来进行记录啊

191
00:08:48,700 --> 00:08:50,420
比如说用 count 来记录

192
00:08:50,420 --> 00:08:53,710
我们便利一个节点就 count 加加

193
00:08:53,710 --> 00:08:56,100
直到 count 的数值等于 N 

194
00:08:56,100 --> 00:08:59,240
是不是就表示所有节点都访问了一次

195
00:08:59,240 --> 00:09:02,520
所以可以用计数值来表示便利

196
00:09:02,520 --> 00:09:05,230
它的技术过程是否结束

197
00:09:05,230 --> 00:09:08,180
我们下面呢，再来看一个连接

198
00:09:08,180 --> 00:09:10,690
来表示便利的过程

199
00:09:10,690 --> 00:09:13,490
那这个邻接表有七个节点

200
00:09:13,490 --> 00:09:16,110
所以表节点，哎，应该有八个啊

201
00:09:16,110 --> 00:09:18,310
0~78个节点

202
00:09:18,310 --> 00:09:20,350
那八个节点之间呢

203
00:09:20,350 --> 00:09:23,690
零相关的有，哎，431

204
00:09:23,690 --> 00:09:26,460
一相关的有二和四

205
00:09:26,460 --> 00:09:28,590
然后呢，唉，还有零

206
00:09:28,590 --> 00:09:31,060
注意这是一个无向图啊

207
00:09:31,060 --> 00:09:34,990
所以呢，它的这个邻接表的临接表当中啊

208
00:09:34,990 --> 00:09:37,900
表节点的个数其实是比较多的

209
00:09:37,900 --> 00:09:39,140
那我们呢

210
00:09:39,140 --> 00:09:42,080
通过连接表可以呢找到图

211
00:09:42,080 --> 00:09:45,900
通过图可以找到连接表或者临接矩阵啊

212
00:09:45,900 --> 00:09:48,610
那根据这个图来看的话

213
00:09:48,610 --> 00:09:52,810
我们如果要做一个深度便利的话

214
00:09:53,520 --> 00:09:57,360
首先我们会找到第一个表头

215
00:09:57,360 --> 00:09:59,310
也就是 V 0出发

216
00:09:59,310 --> 00:10:04,950
那 V 0它能够访问的第一个邻接顶点是谁呢

217
00:10:04,950 --> 00:10:06,160
是 V 4

218
00:10:06,160 --> 00:10:08,460
那我们接下来要找的

219
00:10:08,460 --> 00:10:11,020
其实是 V 4的邻接顶点

220
00:10:11,020 --> 00:10:13,600
来做深度遍历吧

221
00:10:14,090 --> 00:10:16,790
所以找到 V 4之后

222
00:10:16,790 --> 00:10:20,930
V 4的第一个连接顶点是 V 6

223
00:10:21,380 --> 00:10:23,660
那找到 V 6之后

224
00:10:23,660 --> 00:10:28,020
下一步应该是从 V 6出发找连接顶点吧

225
00:10:28,020 --> 00:10:30,350
第一个是 V 7

226
00:10:30,350 --> 00:10:32,540
那 V 7找到之后

227
00:10:32,540 --> 00:10:33,740
通过 V 

228
00:10:33,740 --> 00:10:36,240
下一个连接顶点是 V 6吧

229
00:10:36,240 --> 00:10:38,620
但是 V 6已访问

230
00:10:38,620 --> 00:10:42,040
所以唉，我们不能通过 V 7来找

231
00:10:42,040 --> 00:10:45,070
所以返回上一层

232
00:10:45,070 --> 00:10:50,180
返回上一层应该是返回了 V 6吧

233
00:10:50,180 --> 00:10:52,740
返回 V 6之后

234
00:10:52,740 --> 00:10:57,930
V 6的连接顶点还有一个没有被访问到

235
00:10:57,930 --> 00:10:58,820
是谁呢

236
00:10:58,820 --> 00:11:01,940
唉，下一个临界顶点四已访问呢

237
00:11:01,940 --> 00:11:03,980
应该呢找到三

238
00:11:03,980 --> 00:11:07,950
所以 V 7返回会找到 V 3

239
00:11:08,710 --> 00:11:12,850
通过 V 3再来找邻接顶点

240
00:11:12,850 --> 00:11:15,310
哎，六和二都有了

241
00:11:15,310 --> 00:11:16,950
所以呢，不可用吧

242
00:11:16,950 --> 00:11:18,030
不可用

243
00:11:18,030 --> 00:11:20,230
返回上一层诶

244
00:11:20,230 --> 00:11:22,440
通过 V 3返回了

245
00:11:22,440 --> 00:11:25,260
返回之后，哎， V 3没有了

246
00:11:25,260 --> 00:11:27,000
V 3的上一层是谁啊

247
00:11:27,000 --> 00:11:28,090
是 V 6吧

248
00:11:28,090 --> 00:11:30,820
哎，我们发现 V 6也没有了呀

249
00:11:30,820 --> 00:11:32,880
那我们只能接着返

250
00:11:32,880 --> 00:11:34,840
找到 V 4

251
00:11:35,670 --> 00:11:39,030
通过 V 3不停的返回

252
00:11:39,030 --> 00:11:41,230
返回之后只有 V 4

253
00:11:41,230 --> 00:11:44,950
有未被访问的连接零点 V 1

254
00:11:45,510 --> 00:11:49,110
通过 V 1搜索连接零点

255
00:11:49,110 --> 00:11:52,230
V 4不可用访问 V 2

256
00:11:52,770 --> 00:11:56,450
通过 V 2找到连接顶点

257
00:11:56,450 --> 00:12:00,580
V 51层一层地进行深入

258
00:12:00,580 --> 00:12:04,060
这就是呢，深度便利它的过程

259
00:12:04,060 --> 00:12:06,280
通过图示来看的话

260
00:12:06,280 --> 00:12:12,500
从 V 0、 V 4、 V 6、 V 7返回之后

261
00:12:12,500 --> 00:12:15,130
通过 V 6找到 V 3

262
00:12:15,130 --> 00:12:18,620
然后呢，哎， V 3没有连接顶点了

263
00:12:18,620 --> 00:12:19,660
返回 V 6

264
00:12:19,660 --> 00:12:21,460
通过 V 6，哎，找 V 

265
00:12:21,460 --> 00:12:23,910
返回上层 V 4、 V 4

266
00:12:23,910 --> 00:12:26,670
它的下一个临界顶点是 V 1

267
00:12:26,670 --> 00:12:29,470
与之相关的深度便利

268
00:12:29,470 --> 00:12:32,000
直到呢，查找完成

269
00:12:32,000 --> 00:12:32,920
所以说啊

270
00:12:32,920 --> 00:12:34,980
它的这个数据结构呢

271
00:12:34,980 --> 00:12:37,600
如果确定我们查找的这个过程呢

272
00:12:37,600 --> 00:12:40,240
其实也差不多可以确定了

273
00:12:40,240 --> 00:12:43,710
那深度遍历其实看起来很麻烦吧

274
00:12:43,710 --> 00:12:48,030
广度遍历呢，相对来说就比较简单了

275
00:12:48,460 --> 00:12:50,980
同样， V 0出发

276
00:12:52,660 --> 00:12:55,700
我们写在下面啊

277
00:12:55,700 --> 00:12:57,780
从 V 0出发

278
00:12:57,780 --> 00:12:59,900
找所有的连

279
00:12:59,900 --> 00:13:03,380
零点、 V 4、 V 3、 V 1

280
00:13:03,890 --> 00:13:06,470
返然后返回诶

281
00:13:06,470 --> 00:13:09,500
我们从第一个元素一

282
00:13:09,500 --> 00:13:11,130
一般而言啊

283
00:13:11,130 --> 00:13:14,110
广度遍历会与队列结合来使用

284
00:13:14,110 --> 00:13:15,790
先进先出 V 4

285
00:13:15,790 --> 00:13:17,600
先进让 V 4先出

286
00:13:17,600 --> 00:13:19,870
找 V 4的连接顶点

287
00:13:19,870 --> 00:13:23,270
V 6、 V 1和 V 0已经有了

288
00:13:23,270 --> 00:13:26,230
再找 V 3的连接顶点

289
00:13:27,200 --> 00:13:29,560
V 6、 V 0已经有了

290
00:13:29,560 --> 00:13:31,920
再找 V 1的连接顶点

291
00:13:31,920 --> 00:13:34,140
还 V 4 V 0已经有了

292
00:13:34,140 --> 00:13:35,800
还有呢， V 

293
00:13:36,150 --> 00:13:39,750
那三个连接顶点都找完了吧

294
00:13:39,750 --> 00:13:41,690
再来找下一

295
00:13:41,690 --> 00:13:44,790
V 6的邻接顶点 V 7

296
00:13:44,790 --> 00:13:46,280
那我们在这里

297
00:13:46,280 --> 00:13:49,490
零、一、二、三四、 av 7找到了之后

298
00:13:49,490 --> 00:13:52,570
V 6相关的临界顶点只有一个

299
00:13:52,570 --> 00:13:53,950
V 7未被访问

300
00:13:53,950 --> 00:13:56,130
V 3已经访问过了

301
00:13:56,130 --> 00:13:58,490
那 V 6处理完

302
00:13:58,490 --> 00:14:00,470
下一个 V 2的连接顶点

303
00:14:00,470 --> 00:14:03,210
剩下的还有 V 5未被访问

304
00:14:03,210 --> 00:14:06,340
从而呢，找到广度遍地的结果

305
00:14:06,340 --> 00:14:08,340
那我们同样可以呢

306
00:14:08,340 --> 00:14:09,850
结合图示来看

307
00:14:09,850 --> 00:14:12,090
首先从 V 0出发

308
00:14:12,090 --> 00:14:16,050
将所有的连接顶点 A 431

309
00:14:16,050 --> 00:14:17,910
全部呢访问一遍

310
00:14:17,910 --> 00:14:20,680
然后呢，第一个访问的是 V 4吧

311
00:14:20,680 --> 00:14:23,520
所以访问 V 4的连接顶点

312
00:14:23,520 --> 00:14:25,960
哎，应该是 V 6

313
00:14:27,030 --> 00:14:28,370
有没有了

314
00:14:28,370 --> 00:14:29,030
没有了

315
00:14:29,030 --> 00:14:29,990
那接下来

316
00:14:29,990 --> 00:14:32,200
V 3的连接顶点没

317
00:14:32,200 --> 00:14:34,270
V 1的连接顶点 V 2

318
00:14:34,270 --> 00:14:35,550
这是访问的，诶

319
00:14:35,550 --> 00:14:36,830
第二个层次

320
00:14:36,830 --> 00:14:38,140
接着往下，唉

321
00:14:38,140 --> 00:14:41,860
V 6刚访问的我们针对 V 6处理连接顶点

322
00:14:41,860 --> 00:14:43,670
V 7结束之后

323
00:14:43,670 --> 00:14:45,710
V 2的连接零点 V 5

324
00:14:45,710 --> 00:14:48,940
从而呢，形成广度便利的结

325
00:14:48,940 --> 00:14:52,300
与层次结构呢，有一些相似性

326
00:14:52,300 --> 00:14:54,890
那这是呢，根据一个连接表

327
00:14:54,890 --> 00:14:58,530
大家呢，看一看它的这个查找的过程

328
00:14:58,530 --> 00:15:01,870
在我们的软件设计师考试当中啊

329
00:15:01,870 --> 00:15:04,300
考察较多的还是给图示

330
00:15:04,300 --> 00:15:08,930
让大家呢来判断便利的序列是否合法

331
00:15:08,930 --> 00:15:11,630
这种考察类型呢，会多一些

332
00:15:11,630 --> 00:15:14,760
下面我们来看一下关于图的便利

333
00:15:14,760 --> 00:15:17,690
在软件设计师考试当中的体现

334
00:15:17,690 --> 00:15:20,700
首先呢，以下关于图的便利啊

335
00:15:20,700 --> 00:15:23,900
它的叙述当中呢，正确的是谁

336
00:15:23,900 --> 00:15:26,420
那找正确的说法

337
00:15:26,420 --> 00:15:27,850
那我们看一看呢

338
00:15:27,850 --> 00:15:31,220
A 选项图的便利是从给定的原点出发

339
00:15:31,220 --> 00:15:32,950
对每一个顶点

340
00:15:32,950 --> 00:15:35,090
即因访问一次的过程

341
00:15:35,090 --> 00:15:39,370
这个选项很多同学都是呢，认为是正确的

342
00:15:39,370 --> 00:15:40,900
当我们在这里啊

343
00:15:40,900 --> 00:15:44,880
其实图的便利是可以从任意的顶点来出发

344
00:15:44,880 --> 00:15:47,940
并没有给定原点的说法

345
00:15:48,460 --> 00:15:54,080
B 选项，图的深度优先遍历不适用于那无向图

346
00:15:54,080 --> 00:15:57,130
那我们在这里所有的便利啊

347
00:15:57,130 --> 00:16:00,070
它并没有针对有向图还是无向图

348
00:16:00,070 --> 00:16:04,100
大家都可以做深度遍历和广度遍历

349
00:16:04,100 --> 00:16:05,250
C 选项呢

350
00:16:05,250 --> 00:16:09,440
我们使用队列对图进行广度优先的便利

351
00:16:09,440 --> 00:16:12,890
我们在前面提到过广度优先啊

352
00:16:12,890 --> 00:16:13,960
它一般呢

353
00:16:13,960 --> 00:16:16,500
涉及到有一个层次当中

354
00:16:16,500 --> 00:16:19,410
所有的节点进行了记录

355
00:16:19,410 --> 00:16:23,540
那我们下一个级别从哪一个节点出发

356
00:16:23,540 --> 00:16:26,720
一般呢，会用队列来进行放置

357
00:16:26,720 --> 00:16:27,940
先进先出

358
00:16:27,940 --> 00:16:30,850
谁先做的层次遍历出现

359
00:16:30,850 --> 00:16:35,040
我们就先对呢，这个节点做下一轮的层次遍历

360
00:16:35,040 --> 00:16:37,740
所以这个说法呢，是正确的

361
00:16:37,740 --> 00:16:42,350
D 选项，图中有回路的时候无法进行便利

362
00:16:42,350 --> 00:16:45,870
那我们前面的图示当中其实有回路吧

363
00:16:45,870 --> 00:16:48,730
仍然是可以进行便利的啊

364
00:16:48,730 --> 00:16:53,130
是否有回路不影响图的便利过程

365
00:16:53,130 --> 00:16:55,700
那就是对图啊，它的便利

366
00:16:55,700 --> 00:16:58,580
它的便利的一些定义的考察

367
00:16:58,580 --> 00:17:00,650
再来看下面这道题

368
00:17:00,650 --> 00:17:03,040
某个有向图如下所示

369
00:17:03,040 --> 00:17:05,420
那从 V 1顶点出发

370
00:17:05,420 --> 00:17:08,260
对它进行深度优先的便利

371
00:17:08,260 --> 00:17:10,960
可能得到的便利序列是谁

372
00:17:10,960 --> 00:17:13,760
从 V 1出发，进行广度优

373
00:17:13,760 --> 00:17:15,750
遍历可能的序列是谁

374
00:17:15,750 --> 00:17:19,680
所以只是让大家判断这些便利啊

375
00:17:19,680 --> 00:17:21,640
到底是属于谁的

376
00:17:21,640 --> 00:17:24,619
第一个选项，从 V 1出发

377
00:17:24,619 --> 00:17:28,170
接下来访问的 V 2以及呢？ V 3

378
00:17:28,170 --> 00:17:30,610
那这显然不会是深度吧

379
00:17:30,610 --> 00:17:32,950
肯定的是广度便利

380
00:17:32,950 --> 00:17:35,730
那第二个选项当中

381
00:17:35,730 --> 00:17:39,150
从 V 1出发访问 V 3、 V 4 A 

382
00:17:39,150 --> 00:17:40,530
还有一个连接顶点

383
00:17:40,530 --> 00:17:41,530
没有看到吧

384
00:17:41,530 --> 00:17:44,050
所以它肯定是深度便利

385
00:17:44,050 --> 00:17:46,430
而不是广度遍历

386
00:17:46,430 --> 00:17:49,030
第三个选项

387
00:17:50,180 --> 00:17:52,660
通过 V 1出发

388
00:17:52,660 --> 00:17:56,220
然后呢，可以从 V 3访问 V 2

389
00:17:56,220 --> 00:17:59,080
然后访问 V 4和 V 5

390
00:17:59,080 --> 00:17:59,480
唉

391
00:17:59,480 --> 00:18:00,520
我们会发

392
00:18:00,520 --> 00:18:06,070
V 1访问 V 2、 V 3、 V 2好像满足广度便利

393
00:18:06,070 --> 00:18:08,500
然而我们又发现了

394
00:18:08,500 --> 00:18:09,860
通过 V 1

395
00:18:09,860 --> 00:18:15,090
它 V 3到 V 2也是可以满足深度便利的

396
00:18:15,090 --> 00:18:18,150
所以选项三它很特殊

397
00:18:18,150 --> 00:18:20,350
既满足广度便利

398
00:18:20,350 --> 00:18:23,640
也满足深度便利的过程

399
00:18:23,640 --> 00:18:25,460
第四个选项

400
00:18:25,460 --> 00:18:29,220
V 1到 V 2到 V 4到 V 5

401
00:18:29,220 --> 00:18:32,720
显然没有满足广度优先

402
00:18:32,720 --> 00:18:35,510
只满足深度优先

403
00:18:35,510 --> 00:18:37,720
所以综合来看

404
00:18:37,720 --> 00:18:41,880
第一空选择深度优先的有哪些

405
00:18:41,880 --> 00:18:45,270
二、三、四都是满足要求的

406
00:18:45,270 --> 00:18:48,940
第二空进行广度优先，便利

407
00:18:48,940 --> 00:18:52,680
有第一个选项和第三个选项

408
00:18:52,680 --> 00:18:53,990
所以这道题啊

409
00:18:53,990 --> 00:18:58,000
是对便利具体的合法序列的考察

410
00:18:58,000 --> 00:18:58,950
这些呢

411
00:18:58,950 --> 00:19:02,890
就是要求大家掌握关于图的便利的过程
