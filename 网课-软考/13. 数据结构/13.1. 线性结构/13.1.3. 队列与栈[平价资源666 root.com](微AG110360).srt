1
00:00:00,000 --> 00:00:01,940
接下来我们来看一下呢

2
00:00:01,940 --> 00:00:03,360
线性结构当中啊

3
00:00:03,360 --> 00:00:06,540
线性表的它的它的两种特殊的应用

4
00:00:06,540 --> 00:00:07,870
队列与栈

5
00:00:07,870 --> 00:00:09,010
队列与栈啊

6
00:00:09,010 --> 00:00:11,790
它们最终呢形成的数据结构

7
00:00:11,790 --> 00:00:14,210
还是呢，线性表这种形式的

8
00:00:14,210 --> 00:00:16,440
但是他们有各自的一些特点

9
00:00:16,440 --> 00:00:18,580
在我们软件设计师考试当中啊

10
00:00:18,580 --> 00:00:21,240
经常会涉及到对队列与栈

11
00:00:21,240 --> 00:00:23,630
它的一些操作特点的考察

12
00:00:23,630 --> 00:00:27,320
以及呢，对它们相关的序列考察啊

13
00:00:27,320 --> 00:00:30,350
那针对队列与栈来看的话

14
00:00:30,350 --> 00:00:31,770
队列它有一种呢

15
00:00:31,770 --> 00:00:33,490
典型的特点叫做呢

16
00:00:33,490 --> 00:00:35,070
先进先出

17
00:00:35,070 --> 00:00:36,710
它类似于什么呢

18
00:00:36,710 --> 00:00:39,520
我们在食堂打打饭、排队，呃

19
00:00:39,520 --> 00:00:40,780
包括呢在很多地方

20
00:00:40,780 --> 00:00:42,700
比如说出去买票的时候排队

21
00:00:42,700 --> 00:00:46,750
那我们这里是排队的窗口

22
00:00:46,750 --> 00:00:51,280
那我们排队的时候都是走到队尾来

23
00:00:51,280 --> 00:00:52,660
一个排一个吧

24
00:00:52,660 --> 00:00:56,430
所以他在入队操作的时候

25
00:00:57,780 --> 00:01:01,040
是从哪队尾去入队的

26
00:01:01,040 --> 00:01:04,000
那什么时候离开队伍啊

27
00:01:04,000 --> 00:01:05,580
完成购票了

28
00:01:05,580 --> 00:01:07,460
我们会离开队伍法

29
00:01:07,460 --> 00:01:10,730
那离开的时候我们叫做出对

30
00:01:10,730 --> 00:01:12,290
出对的方向呢

31
00:01:12,290 --> 00:01:13,870
是从对头

32
00:01:13,870 --> 00:01:16,870
那这是呢队列它的特点

33
00:01:16,870 --> 00:01:19,230
那针对队列来看的话

34
00:01:19,230 --> 00:01:23,380
我们啊一般会用呢循环单链表来表示

35
00:01:23,380 --> 00:01:25,960
那我们以为指针哎

36
00:01:25,960 --> 00:01:28,720
我们用了循环单链表的形式

37
00:01:28,720 --> 00:01:30,100
呃，以

38
00:01:32,680 --> 00:01:38,740
然后让尾指针指向了他的第一个节点吧

39
00:01:38,740 --> 00:01:41,000
然后还有一个呢，头指针

40
00:01:41,130 --> 00:01:45,930
那有了这种循循环单链表之后啊

41
00:01:48,660 --> 00:01:51,540
对于这种循环单链表

42
00:01:51,540 --> 00:01:54,650
我们如如果要出对的话

43
00:01:54,650 --> 00:01:57,070
会从对头头部出堆

44
00:01:57,070 --> 00:02:00,470
那我们呢，用头指针删除下一个节点

45
00:02:00,470 --> 00:02:03,320
那如果是入队的话

46
00:02:03,320 --> 00:02:05,800
我们会在队尾指针插入

47
00:02:05,800 --> 00:02:09,389
那插入的时候修改一下它的下一个指针指向

48
00:02:09,389 --> 00:02:10,270
诶，对尾

49
00:02:10,270 --> 00:02:12,690
新的队尾指向头部就行了吧

50
00:02:12,690 --> 00:02:13,920
那这种情况下

51
00:02:13,920 --> 00:02:17,520
我们需不需要用 next 来便利我们的队列啊

52
00:02:17,520 --> 00:02:18,360
不需要

53
00:02:18,360 --> 00:02:25,030
所以队列它经常与循环单链表来结合使用

54
00:02:28,040 --> 00:02:33,040
使用的过程当中是不需要便利的

55
00:02:36,520 --> 00:02:40,900
这是呢唉关于队列它的特点

56
00:02:40,900 --> 00:02:44,230
那队列它有一定的序列存在

57
00:02:44,230 --> 00:02:46,010
我们在入队的时候

58
00:02:46,010 --> 00:02:48,110
比如说 A 先进， B 先进

59
00:02:48,110 --> 00:02:50,900
C 先接着是 B ，然后是 C 

60
00:02:50,900 --> 00:02:53,570
那谁先进谁就先出

61
00:02:53,570 --> 00:03:00,570
所以入队和出队的序列一定是保持一致的

62
00:03:06,560 --> 00:03:11,740
这是呢，关于我们队列它的一些特点

63
00:03:11,740 --> 00:03:13,540
那我们队列的操作啊

64
00:03:13,540 --> 00:03:15,720
只考虑入队和出队

65
00:03:15,720 --> 00:03:18,640
其实就是插入和删除的操作

66
00:03:18,640 --> 00:03:21,770
那还有一种特殊的结构呢

67
00:03:21,770 --> 00:03:23,890
唉，叫做站

68
00:03:28,700 --> 00:03:30,980
对于站来说的话

69
00:03:30,980 --> 00:03:32,750
它类似于什么呢

70
00:03:32,750 --> 00:03:33,690
大家想一想

71
00:03:33,690 --> 00:03:36,090
平时的时候如果吃过薯片

72
00:03:36,090 --> 00:03:38,260
桶装薯片大家都有印象吧

73
00:03:38,260 --> 00:03:40,430
那桶装薯片

74
00:03:40,430 --> 00:03:44,300
我们每一次取薯片的时候从哪里取啊

75
00:03:44,300 --> 00:03:46,040
头部取出来吧

76
00:03:46,040 --> 00:03:48,540
那如果哎我们取了没有吃

77
00:03:48,540 --> 00:03:50,040
放回去会放在哪

78
00:03:50,040 --> 00:03:51,710
还是放在头部吧

79
00:03:51,710 --> 00:03:53,640
所以啊，对于站来说

80
00:03:53,640 --> 00:03:57,620
它的占比是封起来不无法操作的

81
00:03:57,620 --> 00:04:00,810
而栈顶是我们呢操作的对象

82
00:04:00,810 --> 00:04:03,470
那我们对于站来说

83
00:04:03,470 --> 00:04:07,630
入站和出站都是从栈顶

84
00:04:09,480 --> 00:04:13,120
那大家都是从栈顶来进行操作的

85
00:04:13,120 --> 00:04:17,180
那它是否需要用循环链表来使用呢

86
00:04:17,180 --> 00:04:19,500
哎，不需要结合循环链表了

87
00:04:19,500 --> 00:04:23,890
我们直接呢，用单链表就足以呢解决问题了

88
00:04:23,890 --> 00:04:28,330
我们用单链表在插入和删除的时候

89
00:04:28,330 --> 00:04:30,770
都是呢，从站顶

90
00:04:30,770 --> 00:04:33,990
也就是对头来进行操作的

91
00:04:33,990 --> 00:04:36,400
那操操作的过程当中

92
00:04:36,400 --> 00:04:38,120
只要呢，有头节点

93
00:04:38,120 --> 00:04:42,110
这些操作呢，同样是不需要便利的

94
00:04:42,110 --> 00:04:44,780
那就是呢，占它的特点

95
00:04:44,780 --> 00:04:47,600
那对于占序列来说

96
00:04:47,600 --> 00:04:49,730
唉，它就非常灵活了

97
00:04:49,730 --> 00:04:54,120
我们在考试当中经常考到占它的序列问题

98
00:04:54,120 --> 00:04:56,730
那为什么说它非常灵活呢

99
00:04:56,730 --> 00:05:01,420
如果要求 ABC 的顺序入站的话

100
00:05:01,420 --> 00:05:02,880
我们可以

101
00:05:02,880 --> 00:05:06,440
唉，进站之后 I 表示，呃，进站

102
00:05:06,440 --> 00:05:07,660
O 表示出站

103
00:05:07,660 --> 00:05:13,630
那进站、出站、进站、出站、进站、出站、出站序列是什么

104
00:05:13,630 --> 00:05:16,400
A 、 B 、 C 还是 A 、 B 、 C 

105
00:05:16,400 --> 00:05:20,860
那如果说我们三个元素全部入站之后

106
00:05:20,860 --> 00:05:21,820
再出站的话

107
00:05:21,820 --> 00:05:25,510
那它出站的序列就是呢， C 、 B 、 A 

108
00:05:25,510 --> 00:05:29,550
所以正序倒序其实我们都能实现

109
00:05:29,550 --> 00:05:31,800
包括，诶，进去两个再出站

110
00:05:31,800 --> 00:05:33,720
进去三个再出站等等

111
00:05:33,720 --> 00:05:37,780
所以我们说站的序列它是呢，非常灵活的

112
00:05:37,780 --> 00:05:39,980
而队列它的序列呢

113
00:05:39,980 --> 00:05:40,960
相对来说

114
00:05:40,960 --> 00:05:43,780
出队和入队的序列是一致的

115
00:05:43,780 --> 00:05:45,870
我们在考试当中啊

116
00:05:45,870 --> 00:05:48,800
对于队列它的序列相关问题

117
00:05:48,800 --> 00:05:51,580
一般呢，会给一些特殊的序列

118
00:05:51,580 --> 00:05:54,250
或者结合站综合来考察

119
00:05:54,250 --> 00:05:55,760
那我们来看一下

120
00:05:55,760 --> 00:05:59,700
占序列体现在灵活体现在哪里呢

121
00:05:59,890 --> 00:06:02,190
假设我们说元素啊

122
00:06:02,190 --> 00:06:04,930
按照 A 、 B 、 C 的次序可以入站

123
00:06:04,930 --> 00:06:08,750
尝试写出所有可能的出战序列

124
00:06:08,750 --> 00:06:10,740
结合这里来看的话

125
00:06:10,740 --> 00:06:15,330
我们先想一想 ABC 有哪些排列组合

126
00:06:15,330 --> 00:06:18,730
那如果说先 A 、 B 、 C ，哎

127
00:06:18,730 --> 00:06:20,670
这是呢原有的顺序吧

128
00:06:20,670 --> 00:06:22,630
然后呢， A 、 C 、 B 、 E ，哎

129
00:06:22,630 --> 00:06:24,000
这是一种序列吧

130
00:06:24,000 --> 00:06:26,180
然后能不能 B 先出

131
00:06:26,180 --> 00:06:30,830
然后 B 、 A 、 C 、 B 、 C 、 A 或者 C 先出

132
00:06:30,830 --> 00:06:33,060
那 C 、 A 、 B 、 C 、 B 、 A 

133
00:06:33,060 --> 00:06:37,010
这是它所有可能的排列组合

134
00:06:37,010 --> 00:06:41,770
我们已经验证了 ABC 和 CBA 吧

135
00:06:41,770 --> 00:06:44,830
那这两个肯定是能够实现的

136
00:06:44,830 --> 00:06:47,810
其他序列能不能实现呢

137
00:06:47,810 --> 00:06:49,350
唉，我们考虑一下

138
00:06:49,350 --> 00:06:52,760
A 进来立即就出站

139
00:06:52,760 --> 00:06:56,000
A 出站，入站就是出站序列 A 

140
00:06:56,000 --> 00:06:59,900
然后接下来入站之后是 B 吧

141
00:06:59,900 --> 00:07:01,440
没有立即出战

142
00:07:01,440 --> 00:07:03,170
让 C 先入站

143
00:07:03,170 --> 00:07:04,950
那我们出站的时候

144
00:07:04,950 --> 00:07:08,030
唉，这里出站站顶元素是 C 

145
00:07:08,030 --> 00:07:11,220
所以出战序列是 A ， CB 

146
00:07:11,220 --> 00:07:14,000
同样呢是可以实现的

147
00:07:14,000 --> 00:07:16,640
那 BAC 的序列来看一看

148
00:07:16,640 --> 00:07:18,740
唉，让 A 进去了

149
00:07:18,740 --> 00:07:19,780
B 进去了

150
00:07:19,780 --> 00:07:21,940
接下来 B 出来， A 出来

151
00:07:21,940 --> 00:07:23,840
C 进去， C 出来

152
00:07:23,840 --> 00:07:26,460
所以 B 、 A 、 C 可以实现

153
00:07:26,460 --> 00:07:29,320
那 B 、 C 、 A 能不能实现呢

154
00:07:29,320 --> 00:07:31,460
唉，先让 B 进去

155
00:07:31,460 --> 00:07:33,260
是先让 A 进去

156
00:07:33,260 --> 00:07:34,820
再让 B 进去

157
00:07:34,820 --> 00:07:36,910
接下来 B 出站

158
00:07:36,910 --> 00:07:38,980
C 进去， C 出站

159
00:07:38,980 --> 00:07:41,320
然后让 A 出站

160
00:07:41,320 --> 00:07:45,400
那此时 A 、 B 、 C 、 A 同样可以实现

161
00:07:45,400 --> 00:07:48,430
那我们这里以 B 开头的都可以

162
00:07:48,430 --> 00:07:51,550
还剩下最后一个 C 、 A 、 B 

163
00:07:51,550 --> 00:07:55,830
那考虑一下要让 C 先入站的话

164
00:07:55,830 --> 00:07:58,440
我们有哪些序列已经进去了

165
00:07:58,440 --> 00:08:00,860
A 、 B 、 C 都进去了吧

166
00:08:00,860 --> 00:08:05,310
那都进去之后开始出站的是 C 

167
00:08:05,310 --> 00:08:07,980
能不能接着让 B 出来呀

168
00:08:07,980 --> 00:08:08,900
不行

169
00:08:08,900 --> 00:08:13,290
因为我们现在 ABCC 出站之后

170
00:08:13,290 --> 00:08:17,650
站顶是 B 越过 B 是拿不到 A 的

171
00:08:17,650 --> 00:08:21,490
所以唉，我们发现六种 ABC 的排列组合

172
00:08:21,490 --> 00:08:24,600
只有其中一种是无法识别的

173
00:08:24,600 --> 00:08:28,230
其他都是呢合法的出站序列

174
00:08:28,230 --> 00:08:31,270
那这是呢？占它的序列比较呢

175
00:08:31,270 --> 00:08:32,429
灵活

176
00:08:33,030 --> 00:08:37,020
那我们在考虑这种灵活序列的时候啊

177
00:08:37,020 --> 00:08:41,440
比如说我们要达到 CBA 的出站序列

178
00:08:41,440 --> 00:08:43,659
至少要让 C 入站马

179
00:08:43,659 --> 00:08:49,460
所以，唉，我们有三个占容量才能达成 ABC 入站

180
00:08:49,460 --> 00:08:54,020
那如果要求 BAC 或者 BCA 的话

181
00:08:54,020 --> 00:08:56,380
我们只需要让 A 进去

182
00:08:56,380 --> 00:08:57,160
B 进去

183
00:08:57,160 --> 00:08:58,040
B 出来

184
00:08:58,040 --> 00:08:59,040
A 出来

185
00:08:59,040 --> 00:09:00,890
塞进去、塞出来

186
00:09:00,890 --> 00:09:02,210
那这种情况

187
00:09:02,210 --> 00:09:06,160
占容量只需要放两个元素就够了

188
00:09:06,160 --> 00:09:09,520
所以我们这里出站入站的序列啊

189
00:09:09,520 --> 00:09:11,750
在形成的过程当中

190
00:09:11,750 --> 00:09:15,390
与占的容量呢，也有一定的关联性

191
00:09:15,390 --> 00:09:18,700
曾经呢，在早年真题当中考察过啊

192
00:09:18,700 --> 00:09:21,190
我们近几次的考试来看的话

193
00:09:21,190 --> 00:09:24,090
考察较多的还是呢，队列与栈

194
00:09:24,090 --> 00:09:25,050
它的一些特点

195
00:09:25,050 --> 00:09:27,320
然后它的序列问题

196
00:09:27,320 --> 00:09:30,300
那这是常规的队列与站

197
00:09:30,300 --> 00:09:32,300
还有特殊的队列

198
00:09:32,300 --> 00:09:34,520
叫做呢，循环队列

199
00:09:34,520 --> 00:09:36,750
循环队列当中啊

200
00:09:36,750 --> 00:09:39,490
它的对头与队尾呢

201
00:09:39,490 --> 00:09:43,590
诶，形成的指针可以形成一个环路

202
00:09:43,590 --> 00:09:48,860
那这种循环队列在考试当中考察较少了

203
00:09:48,860 --> 00:09:54,000
我们目前要求大家掌握的是它的三个条件

204
00:09:54,000 --> 00:09:58,140
首先的话，我们有头指针和尾指针

205
00:09:58,140 --> 00:10:02,180
它应该是指向队列的头部和尾部

206
00:10:02,180 --> 00:10:05,250
那判断对空的条件是

207
00:10:05,250 --> 00:10:08,650
头和尾指针指向同一个节点

208
00:10:08,650 --> 00:10:12,710
但其实所有元素都是满的时候

209
00:10:12,710 --> 00:10:15,270
它也能够达到这个条件吧

210
00:10:15,270 --> 00:10:17,310
但是我们限定了这种

211
00:10:17,310 --> 00:10:19,670
只表示对空对满

212
00:10:19,670 --> 00:10:22,170
我们用新的条件来表示

213
00:10:22,170 --> 00:10:25,170
那这里为了区分这种情况的话

214
00:10:25,170 --> 00:10:29,990
我们是让 tr 指向

215
00:10:30,720 --> 00:10:34,600
最后一个元素的后一个位置

216
00:10:42,500 --> 00:10:45,990
所以它其实是空余了一个位置吧

217
00:10:45,990 --> 00:10:48,470
只要这一个位置到达对头

218
00:10:48,470 --> 00:10:50,250
我们就说它堆满了

219
00:10:50,250 --> 00:10:53,830
它会有呢， tr 加 E 来进行处理

220
00:10:53,830 --> 00:10:57,080
那我们在这里还可能存在

221
00:10:57,080 --> 00:11:00,550
头部和尾部交错的这种情况

222
00:11:00,550 --> 00:11:03,770
原本应该是头在前、尾在后吧

223
00:11:03,770 --> 00:11:05,840
那也有可能在插

224
00:11:05,840 --> 00:11:08,760
或者呢，诶，出队和入队的过程当中

225
00:11:08,760 --> 00:11:11,180
形成了头在尾后面

226
00:11:11,180 --> 00:11:14,150
那这种情况我们还需要呢

227
00:11:14,150 --> 00:11:18,110
唉，与 size 取来进行验证

228
00:11:18,110 --> 00:11:21,250
那这个取余的过程当中呢

229
00:11:21,250 --> 00:11:26,130
size 是它总的队列的这个容量数

230
00:11:26,130 --> 00:11:31,190
那队列它的 ABC 这样的一个长度怎么来求呢

231
00:11:31,190 --> 00:11:34,610
它需要用头、用尾减去头部吧

232
00:11:34,610 --> 00:11:36,550
那我们说有错位怎么办

233
00:11:36,550 --> 00:11:39,520
加上总容量来进行修正

234
00:11:39,520 --> 00:11:42,870
然后呢，对容量来进行取余

235
00:11:42,870 --> 00:11:44,880
从而求出的是长度

236
00:11:44,880 --> 00:11:46,700
在这里大家需要呢

237
00:11:46,700 --> 00:11:49,480
注意要通过取鱼啊

238
00:11:49,480 --> 00:11:52,460
通过整数取余的运算来进行验证

239
00:11:52,460 --> 00:11:56,820
中间的长度还需要加上 size 来进行修正

240
00:11:56,820 --> 00:11:59,750
那 size 这种用法呢，一定要注意

241
00:11:59,750 --> 00:12:02,630
这是循环队列的一个呢特殊点

242
00:12:02,630 --> 00:12:04,290
目前在考试当

243
00:12:04,290 --> 00:12:07,040
这一部分呢已经考察较少了

244
00:12:07,040 --> 00:12:09,180
那我们接下来来看一下

245
00:12:09,180 --> 00:12:11,880
队列与站在我们的软件设计师

246
00:12:11,880 --> 00:12:13,760
近几年的考察真题当

247
00:12:13,760 --> 00:12:15,440
是如何来体现的

248
00:12:15,440 --> 00:12:18,130
首先对于一个长度为 N 

249
00:12:18,130 --> 00:12:20,310
并且呢元素互一的序列

250
00:12:20,310 --> 00:12:25,140
令其呢所有元素依次通过一个初始为空的站

251
00:12:25,140 --> 00:12:25,840
之后啊

252
00:12:25,840 --> 00:12:29,380
再通过一个呢初始为空的队列

253
00:12:29,380 --> 00:12:32,410
所以我们先通过占

254
00:12:34,420 --> 00:12:38,340
然后呢，再进入一个队列

255
00:12:42,620 --> 00:12:46,980
那假设队列和栈的容量都是足够大的

256
00:12:46,980 --> 00:12:51,420
并且呢，哎，栈非空就可以进行出站操作

257
00:12:51,420 --> 00:12:54,720
也就是说我们可以进去一个就出来一个

258
00:12:54,720 --> 00:12:57,360
也可以全部进去立即就出来吧

259
00:12:57,360 --> 00:13:00,400
那只要队列非空就可以进行呢

260
00:13:00,400 --> 00:13:01,380
初对操作

261
00:13:01,380 --> 00:13:05,300
那么以下叙述当中正确的是什么呢

262
00:13:05,300 --> 00:13:09,320
队列无论是进去一个立即出来

263
00:13:09,320 --> 00:13:13,650
还是呢进去两个让它先进先出

264
00:13:13,650 --> 00:13:16,870
这里面所形成的序列啊

265
00:13:16,870 --> 00:13:18,470
都是呢一样的

266
00:13:18,470 --> 00:13:22,840
所以出队与入队的序列一定呢相同

267
00:13:22,840 --> 00:13:24,660
那我们这里呢，哎

268
00:13:24,660 --> 00:13:26,640
出队和入队没有看到

269
00:13:26,640 --> 00:13:29,980
那我们先写一下出对

270
00:13:30,570 --> 00:13:34,050
与入对序列相同

271
00:13:38,560 --> 00:13:42,280
然后现在告诉我们这个出队的序列

272
00:13:42,280 --> 00:13:44,780
哎，这个入队的序列从哪里来啊

273
00:13:44,780 --> 00:13:47,760
入队是由出站才入队吧

274
00:13:47,760 --> 00:13:50,130
所以出站的序列

275
00:13:50,130 --> 00:13:54,170
入队的序列与出站的序列是一样的

276
00:14:03,160 --> 00:14:05,940
前面是通用规则吧

277
00:14:05,940 --> 00:14:10,100
下面呢，是本题当中描述的具体情况呢

278
00:14:10,100 --> 00:14:12,010
那我们会发现，诶

279
00:14:12,010 --> 00:14:15,610
这个出队的序列跟出战的序列

280
00:14:15,610 --> 00:14:17,180
是不是就一样哈

281
00:14:17,180 --> 00:14:22,020
所以出队和出战序列一定是相同的

282
00:14:22,020 --> 00:14:26,840
那由出站序列能不能找到入站序列呢

283
00:14:26,840 --> 00:14:29,220
哎，这里是不确定的吧

284
00:14:29,220 --> 00:14:31,210
我们在这里说，呃

285
00:14:31,210 --> 00:14:34,550
入站和出站，出站它是非常灵活的

286
00:14:34,550 --> 00:14:36,390
所以出站序列知道了

287
00:14:36,390 --> 00:14:39,100
我们是无法找到呢入站的

288
00:14:39,100 --> 00:14:42,080
那我们这里入站的序列

289
00:14:42,080 --> 00:14:44,280
与入队序列一定相同

290
00:14:44,280 --> 00:14:45,320
或者逆序吗

291
00:14:45,320 --> 00:14:47,360
这里是不确定的

292
00:14:47,360 --> 00:14:49,480
那这里的逆序啊

293
00:14:49,480 --> 00:14:52,100
其实都是呢，不确定的啊

294
00:14:52,100 --> 00:14:53,770
我们只有呢

295
00:14:53,770 --> 00:14:57,500
只能看到出队序列与初战序列呢

296
00:14:57,500 --> 00:14:59,760
唉，一定是相同的

297
00:14:59,760 --> 00:15:00,800
为什么相同

298
00:15:00,800 --> 00:15:03,160
因为出站即入队

299
00:15:03,160 --> 00:15:05,760
那出队与入队相

300
00:15:05,760 --> 00:15:08,400
就是与呢，出战序列相同的

301
00:15:08,400 --> 00:15:09,430
这是对啊

302
00:15:09,430 --> 00:15:13,890
站以及呢，队列操作的一个呢，特性的考察

303
00:15:13,890 --> 00:15:15,850
虽然他提到了序列

304
00:15:15,850 --> 00:15:16,990
但没有考细节

305
00:15:16,990 --> 00:15:19,890
只是呢，对它的特点进行了考察

306
00:15:19,890 --> 00:15:22,410
再来看下面这道题

307
00:15:22,410 --> 00:15:25,450
队列的特点呢，是先进先出

308
00:15:25,450 --> 00:15:29,490
如果用循环单链表来表示队列的话

309
00:15:29,490 --> 00:15:30,950
那我们在这里呢

310
00:15:30,950 --> 00:15:34,490
其实在前面的视频当中有讲到啊

311
00:15:34,490 --> 00:15:37,690
如果是循环单链表

312
00:15:37,690 --> 00:15:43,250
那么我们的尾指针会指向同一个元素吧

313
00:15:43,250 --> 00:15:45,750
那会指向头节点这边去

314
00:15:45,750 --> 00:15:49,050
那我们呢，在出队和入队的时候

315
00:15:49,050 --> 00:15:52,160
出队从对头通过呢， head 指针

316
00:15:52,160 --> 00:15:54,730
head 指针、头指针操作就行了

317
00:15:54,730 --> 00:15:58,260
那我们的伪元素呢，通过，诶

318
00:15:58,260 --> 00:16:00,560
入队的时候从队尾插入

319
00:16:00,560 --> 00:16:03,940
通过呢液对尾指针来操作就可以了

320
00:16:03,940 --> 00:16:07,510
所以出队和入队都不需要呢

321
00:16:07,510 --> 00:16:09,600
便利我们的队列

322
00:16:09,600 --> 00:16:10,880
哎，遍历链表

323
00:16:10,880 --> 00:16:14,980
这是我们呢，关于队列它的操作特点的考察

324
00:16:14,980 --> 00:16:17,780
结合了链表它的应用

325
00:16:17,780 --> 00:16:21,520
再来看下面这道题，关于序列问题

326
00:16:21,520 --> 00:16:25,100
那若元素与 A 、 B 、 C 、 D 、 E 的顺

327
00:16:25,100 --> 00:16:26,060
进入一个呢

328
00:16:26,060 --> 00:16:28,290
初始为空的站

329
00:16:28,290 --> 00:16:29,890
那我们现在呢

330
00:16:29,890 --> 00:16:33,030
每个元素进站、出站都只能有一次吧

331
00:16:33,030 --> 00:16:36,610
要求出站的第一个元素为 D 

332
00:16:36,610 --> 00:16:39,650
那原本是一个很复杂的出战序列

333
00:16:39,650 --> 00:16:43,090
现在呢，要求先出 D 的话

334
00:16:43,090 --> 00:16:46,170
那我们显然 D 1定已经入站了

335
00:16:46,170 --> 00:16:48,190
A 、 B 、 C 也入站了吧

336
00:16:48,190 --> 00:16:51,030
那这种情况第一出站呢

337
00:16:51,030 --> 00:16:53,110
还有哪个元素没入站啊

338
00:16:53,110 --> 00:16:55,600
只剩下一个元素了

339
00:16:55,600 --> 00:17:00,690
那 ABC 的相对顺序其实是无法改变的

340
00:17:00,690 --> 00:17:06,260
那我们现在区别的就是 E 是不是立即进入，哎

341
00:17:06,260 --> 00:17:07,480
就出站呢

342
00:17:07,480 --> 00:17:12,280
或者这里应该是 C 、 B 、 A 

343
00:17:13,040 --> 00:17:15,420
出战序列 CBA 

344
00:17:15,420 --> 00:17:18,300
这个相对顺序是不会发生变化的

345
00:17:18,300 --> 00:17:19,560
因为已经进去了

346
00:17:19,560 --> 00:17:20,980
那 E 的话

347
00:17:20,980 --> 00:17:23,520
如果在第一个位置上

348
00:17:23,520 --> 00:17:26,780
那 D 、 E 、 E ，现在 E 立即进去就出战

349
00:17:26,780 --> 00:17:29,780
那 DEECBA 是可以的吧

350
00:17:29,780 --> 00:17:33,880
那我们的 E 可以在 C 出站之后再入站

351
00:17:33,880 --> 00:17:35,100
那就是 D 、 C 

352
00:17:35,100 --> 00:17:37,280
然后呢 E 、 B 、 A 

353
00:17:37,420 --> 00:17:41,120
也可以在 B 后面入站再出站吧

354
00:17:41,120 --> 00:17:42,700
所以可以 D 、 C 、 B 

355
00:17:42,700 --> 00:17:45,540
然后呢， E 、 A 也可以

356
00:17:45,540 --> 00:17:47,620
CBA 都出来了诶

357
00:17:47,620 --> 00:17:51,200
D 、 C 、 B 、 A 让 E 入站再出站

358
00:17:51,200 --> 00:17:55,150
所以一共合法的序列只有四种

359
00:17:55,150 --> 00:18:00,620
其他序列会破坏我们 CBA 的相对顺序

360
00:18:00,620 --> 00:18:01,740
那这是呢

361
00:18:01,740 --> 00:18:05,120
关于占它的序列问题

362
00:18:06,100 --> 00:18:08,630
再来看下面这道题

363
00:18:08,630 --> 00:18:10,320
双端队列呢

364
00:18:10,320 --> 00:18:14,160
是指在我们队列的两个端口都可以呢

365
00:18:14,160 --> 00:18:16,490
插入和删除元素

366
00:18:16,490 --> 00:18:18,090
如下图所示

367
00:18:18,090 --> 00:18:19,990
这是特殊的队列啊

368
00:18:19,990 --> 00:18:23,830
双端队列呢，在我们的考试当中也有出现

369
00:18:23,830 --> 00:18:26,420
只有一端可以既进又出

370
00:18:26,420 --> 00:18:28,800
另一端只能出或者只能入

371
00:18:28,800 --> 00:18:32,680
所以要看清楚题目给出来的是什么样的

372
00:18:32,680 --> 00:18:34,370
特殊双端队列

373
00:18:34,370 --> 00:18:38,010
那现在要求元素

374
00:18:38,010 --> 00:18:39,830
进队列和出队列

375
00:18:39,830 --> 00:18:41,910
必须在同一个端口

376
00:18:41,910 --> 00:18:42,960
也就是说

377
00:18:42,960 --> 00:18:46,460
唉，我们从 A 这个口入队的就要出

378
00:18:46,460 --> 00:18:47,760
从这里出对

379
00:18:47,760 --> 00:18:51,030
B 这个口入对的就要从这里出对

380
00:18:51,030 --> 00:18:53,620
所以这两端的元素啊

381
00:18:53,620 --> 00:18:54,780
从哪里进

382
00:18:54,780 --> 00:18:56,060
从哪里出

383
00:18:56,060 --> 00:19:02,140
那对于四个元素 ABCD 要求前两个元素的 ab 呢

384
00:19:02,140 --> 00:19:04,880
唉，从 A 端依次进入

385
00:19:04,880 --> 00:19:08,430
那已经全部进入队列了啊

386
00:19:08,430 --> 00:19:11,640
后两个元素 C 、 D ，从 B 端呢

387
00:19:11,640 --> 00:19:13,920
哎，全部进入队列了

388
00:19:13,920 --> 00:19:16,290
那都是呢，全部进入

389
00:19:16,290 --> 00:19:19,790
其实这相当于两个站放在一块儿了吧

390
00:19:19,790 --> 00:19:22,540
那不可能得到的序列是什么呢

391
00:19:22,540 --> 00:19:24,800
验证一下 ABCD 就行了

392
00:19:24,800 --> 00:19:30,170
那让我们的队列形成 baa 、 ACD 这种形式

393
00:19:30,170 --> 00:19:32,120
接下来出战的是谁啊

394
00:19:32,120 --> 00:19:34,020
可出对的是谁啊

395
00:19:34,020 --> 00:19:37,280
可以是 B ，也可以是 D 吧

396
00:19:37,280 --> 00:19:39,240
所以 B 先出可以

397
00:19:39,240 --> 00:19:41,160
D 先出也可以

398
00:19:41,160 --> 00:19:44,950
诶，这里第一个元素呢，都是正确的

399
00:19:44,950 --> 00:19:48,050
那我们下一个出对的，唉

400
00:19:48,050 --> 00:19:50,010
可以是 AC 吧

401
00:19:50,010 --> 00:19:51,900
所以我们在这里看的话

402
00:19:51,900 --> 00:19:54,060
如果 D 出来了

403
00:19:54,060 --> 00:19:56,950
下面能不能直接让 A 出来

404
00:19:56,950 --> 00:19:57,950
并不能

405
00:19:57,950 --> 00:20:00,270
因为 B 还没有出

406
00:20:00,270 --> 00:20:03,760
所以我们可以是 DC 或者 BA 

407
00:20:03,760 --> 00:20:05,610
哎，或者 BD 吧

408
00:20:05,610 --> 00:20:09,380
那这里 A 选项是无法得到的

409
00:20:09,380 --> 00:20:11,400
因为 D 出来之后

410
00:20:11,400 --> 00:20:13,760
B 没有处理的情况下

411
00:20:13,760 --> 00:20:15,710
A 无法出对

412
00:20:15,710 --> 00:20:17,690
那这是特殊队

413
00:20:17,690 --> 00:20:19,690
它的这种呢，出对问题

414
00:20:19,690 --> 00:20:21,240
出对的序列问题

415
00:20:21,240 --> 00:20:23,110
那这种情况啊

416
00:20:23,110 --> 00:20:24,650
它在考试当中

417
00:20:24,650 --> 00:20:28,600
一般都是所有元素全全部已经入队了

418
00:20:28,600 --> 00:20:31,830
大家可以把入队的序列划进去

419
00:20:31,830 --> 00:20:35,630
然后呢，再来判断他的出对情况

420
00:20:35,630 --> 00:20:40,540
那这是呢，关于特殊队列的序列问题的考察

421
00:20:40,540 --> 00:20:42,310
那这些是我们呢

422
00:20:42,310 --> 00:20:44,730
关于队列和栈的一些应用
