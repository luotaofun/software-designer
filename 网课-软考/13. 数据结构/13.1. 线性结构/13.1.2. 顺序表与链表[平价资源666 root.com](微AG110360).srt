1
00:00:00,000 --> 00:00:04,059
下面我们来展开看一下线性结构当中啊

2
00:00:04,059 --> 00:00:07,610
线性表与链表这样的一个呢，内容

3
00:00:07,610 --> 00:00:09,060
线性表和链表啊

4
00:00:09,060 --> 00:00:12,930
它是呢，线性表的两种存储形式

5
00:00:12,930 --> 00:00:15,240
我们说呢，在数据结构当中

6
00:00:15,240 --> 00:00:18,180
它包含逻辑结构和物理结构

7
00:00:18,180 --> 00:00:21,450
线性结构它其实是一种逻辑结构

8
00:00:21,450 --> 00:00:25,540
那它只有呢，唯一的前驱和唯一的后继

9
00:00:25,540 --> 00:00:27,980
那我们以表的形式来存储

10
00:00:27,980 --> 00:00:29,260
就是呢，线性表

11
00:00:29,260 --> 00:00:31,820
那这种线性表它顺序存

12
00:00:31,820 --> 00:00:34,270
顺序存储的时候叫做顺序表

13
00:00:34,270 --> 00:00:36,560
以链式的方式来存储

14
00:00:36,560 --> 00:00:38,360
就叫做呢链表

15
00:00:38,360 --> 00:00:41,850
针对线性表当中，顺序表与链表

16
00:00:41,850 --> 00:00:45,260
我们需要呢，掌握这两种表的特点

17
00:00:45,260 --> 00:00:48,380
以及呢，它的一些操作上的对比

18
00:00:48,380 --> 00:00:50,360
那我们可以看到呢

19
00:00:50,360 --> 00:00:52,570
首先看到的是顺序表

20
00:00:52,570 --> 00:00:55,450
顺序表与我们数据结构当中啊

21
00:00:55,450 --> 00:00:56,880
呃，常用的一种呢

22
00:00:56,880 --> 00:00:59,620
数组结构基本上呢，是一致的

23
00:00:59,620 --> 00:01:02,870
我们可以把它看作呢，一个数组 A 

24
00:01:02,870 --> 00:01:05,420
那这个数组 A 当中呢

25
00:01:05,420 --> 00:01:09,390
它的下标有零、一、二、三、四、五、六、七

26
00:01:09,390 --> 00:01:10,710
那这是呢

27
00:01:10,710 --> 00:01:12,150
哎，一个顺序表

28
00:01:12,150 --> 00:01:14,910
那顺序表我们在创建的时候

29
00:01:14,910 --> 00:01:18,160
比如说数组我们必须要声明它的长度

30
00:01:18,160 --> 00:01:22,140
因为在一个大的存储区域当中

31
00:01:22,140 --> 00:01:25,690
我们创建一个顺序存储结构之前

32
00:01:25,690 --> 00:01:30,890
需要呢，先把它的这种结构所需的存储空间

33
00:01:30,890 --> 00:01:32,440
给它呢留出来

34
00:01:32,440 --> 00:01:37,370
所以我们会开辟一个长度为八的存储空间

35
00:01:37,370 --> 00:01:39,070
分配给顺序表

36
00:01:39,070 --> 00:01:41,750
那这种必须呢，在诶

37
00:01:41,750 --> 00:01:44,910
声明之后就立即使用之前啊

38
00:01:44,910 --> 00:01:47,340
就需要呢把空间留好

39
00:01:47,340 --> 00:01:50,770
那我们针对这种顺序表而言的话

40
00:01:50,770 --> 00:01:53,270
它的读操作

41
00:01:53,470 --> 00:01:56,630
比如说呢，读 A 5、 A 4

42
00:01:56,630 --> 00:02:00,290
那我们直接呢，返回一个数值就可以了吧

43
00:02:00,290 --> 00:02:02,970
那这种返回是非常快速的

44
00:02:02,970 --> 00:02:04,530
实践性能很高

45
00:02:04,530 --> 00:02:06,520
它的时间复杂度

46
00:02:06,520 --> 00:02:10,220
我们呢，唉，可以把它记作大 O 级的一

47
00:02:10,220 --> 00:02:12,970
关于具体的时间复杂度，诶

48
00:02:12,970 --> 00:02:14,090
他的一个求取啊

49
00:02:14,090 --> 00:02:14,850
或者分析

50
00:02:14,850 --> 00:02:17,820
我们在后面的算法部分会给大家讲到

51
00:02:17,820 --> 00:02:20,410
这里呢，我们在数据结构当中

52
00:02:20,410 --> 00:02:25,400
主要的是了解一些特殊的时间复杂度的对比

53
00:02:25,400 --> 00:02:28,730
那读操作它是常量级诶

54
00:02:28,730 --> 00:02:29,550
也就是呢

55
00:02:29,550 --> 00:02:31,190
顺序的返回就可以了

56
00:02:31,190 --> 00:02:32,570
只有呢，几个步骤

57
00:02:32,570 --> 00:02:35,700
时间复杂度呢，是大 O 级的一

58
00:02:35,700 --> 00:02:37,550
查询操作呢

59
00:02:37,550 --> 00:02:40,890
它一般指的是查询某个数值

60
00:02:40,890 --> 00:02:42,900
返回其位置

61
00:02:42,900 --> 00:02:47,770
那我们在查询元素值等于五的具体位置

62
00:02:47,770 --> 00:02:49,090
进行返回的时候

63
00:02:49,090 --> 00:02:50,140
怎么查呢

64
00:02:50,140 --> 00:02:54,210
我们必须从第一个元素位置开始

65
00:02:54,210 --> 00:02:56,720
依次去进行比较

66
00:02:56,720 --> 00:02:58,830
直到呢，查找成功

67
00:02:58,830 --> 00:03:03,150
返回查找失败也可以返回一

68
00:03:03,150 --> 00:03:06,770
那这个查找的过程当中啊

69
00:03:06,770 --> 00:03:11,110
我们的比较次数最快的是比较一次吧

70
00:03:11,110 --> 00:03:14,200
唉，如果是找第二个元素

71
00:03:14,200 --> 00:03:16,450
它可能呢，就比较两次，呃

72
00:03:16,450 --> 00:03:18,430
第三个元素比较三次

73
00:03:18,430 --> 00:03:22,190
也有可能比较最后一个元素八次吧

74
00:03:22,190 --> 00:03:25,380
假设，唉，我们要查的元素是

75
00:03:25,380 --> 00:03:29,720
其中每一个元素的概率都是呢，一样的

76
00:03:29,720 --> 00:03:32,290
那我们最终呢，还可以除以八

77
00:03:32,290 --> 00:03:35,460
这就是它的平均比较次数

78
00:03:35,460 --> 00:03:38,510
那它的平均比较次数啊

79
00:03:38,510 --> 00:03:42,240
如果扩展到通用变量 N 来看的话

80
00:03:42,240 --> 00:03:46,350
就是呢，1+2加三加到 N 

81
00:03:46,350 --> 00:03:48,900
那这是一个等差数列

82
00:03:48,900 --> 00:03:50,900
求和可以呢

83
00:03:50,900 --> 00:03:55,350
唉，上底加下底乘以高除以二

84
00:03:55,350 --> 00:03:56,650
再除以呢

85
00:03:56,650 --> 00:03:58,410
唉，它的个数 N 

86
00:03:58,410 --> 00:04:03,060
最终呢，平均比较次数是二分之 N 加一

87
00:04:03,060 --> 00:04:05,360
这是他的查询过程

88
00:04:05,360 --> 00:04:07,840
哎，最方便的是查一次

89
00:04:07,840 --> 00:04:10,910
平均呢是查二分之 N 加一

90
00:04:10,910 --> 00:04:14,310
查的最多的是需要查询 N 次

91
00:04:14,310 --> 00:04:17,339
这是呢，查找或者叫做查询操作

92
00:04:17,339 --> 00:04:20,839
如果是插入某一个元素的话

93
00:04:20,839 --> 00:04:23,060
它的插入操作啊

94
00:04:23,060 --> 00:04:26,100
我们要插到某一个位置上

95
00:04:26,100 --> 00:04:27,920
插入比较特殊

96
00:04:27,920 --> 00:04:29,710
在顺序表当中

97
00:04:29,710 --> 00:04:32,930
如果要插入某一个元素

98
00:04:32,930 --> 00:04:37,580
那后面所有的元素都需要后移

99
00:04:37,580 --> 00:04:40,010
那我们在插入的时候

100
00:04:40,010 --> 00:04:42,170
如果插入尾部，诶

101
00:04:42,170 --> 00:04:43,800
就不需要移动吧

102
00:04:43,800 --> 00:04:48,710
插入诶，前面一个元素位置就需要呢移动一个

103
00:04:48,710 --> 00:04:49,030
诶

104
00:04:49,030 --> 00:04:50,630
有可能移动两个

105
00:04:50,630 --> 00:04:53,700
或者呢，直到所有元素，唉

106
00:04:53,700 --> 00:04:56,200
我们插入在起始位置

107
00:04:56,200 --> 00:04:59,350
移动后面的八个元素

108
00:04:59,350 --> 00:05:02,140
所以我们在这里会发现

109
00:05:02,140 --> 00:05:03,870
差插入过程当中

110
00:05:03,870 --> 00:05:07,210
元素的移动也是不一样的吧

111
00:05:07,210 --> 00:05:11,440
那我们同样呢，可以去求平均值

112
00:05:11,440 --> 00:05:14,690
然后呢，唉，去进行计算

113
00:05:14,690 --> 00:05:18,100
那这个插入的过程当中，诶

114
00:05:18,100 --> 00:05:20,920
它的平均次数仍然呢

115
00:05:20,920 --> 00:05:23,660
也是需要0+1加

116
00:05:23,660 --> 00:05:27,400
加到 N 除以 N 

117
00:05:27,400 --> 00:05:30,900
那上面也是一个等差数列，哎

118
00:05:30,900 --> 00:05:35,490
上底加下底乘以高除以二

119
00:05:35,490 --> 00:05:37,730
然后再除以 N 

120
00:05:37,730 --> 00:05:41,390
这里所涉及到的平均移动次数

121
00:05:41,390 --> 00:05:44,060
还是二分之 N 加一

122
00:05:44,060 --> 00:05:46,470
它有可能不移动

123
00:05:46,470 --> 00:05:49,490
有可能移动二分之 N 加一

124
00:05:49,490 --> 00:05:52,220
也有可能呢，唉，移动 N 次

125
00:05:52,220 --> 00:05:55,430
那这是我们呢涉及到的插入操作

126
00:05:55,430 --> 00:05:59,170
它的移动删除操作呢

127
00:05:59,170 --> 00:06:00,960
它也比较特殊

128
00:06:00,960 --> 00:06:04,270
我们要知道在删除的过程当中

129
00:06:04,270 --> 00:06:05,370
顺序存储

130
00:06:05,370 --> 00:06:07,990
它的存储空间一定是连续的

131
00:06:07,990 --> 00:06:09,570
有这样的一个特点啊

132
00:06:09,570 --> 00:06:11,380
那我们要插入

133
00:06:11,380 --> 00:06:14,090
我们要删除某一个数值的时候

134
00:06:14,090 --> 00:06:16,480
空余了一个空间怎么办呢

135
00:06:16,480 --> 00:06:20,040
把后续的所有元素前移

136
00:06:20,040 --> 00:06:22,970
所以它也有移动的过程

137
00:06:22,970 --> 00:06:25,930
那我们删除最后一个元素的话

138
00:06:25,930 --> 00:06:27,470
不需要移动吧

139
00:06:27,470 --> 00:06:29,680
删除前面的元素，诶

140
00:06:29,680 --> 00:06:30,920
一次、两次

141
00:06:30,920 --> 00:06:32,220
直到多少次呢

142
00:06:32,220 --> 00:06:37,050
删除第一个元素需要移动 N 减一次

143
00:06:37,050 --> 00:06:38,790
那就是我们呢

144
00:06:38,790 --> 00:06:41,170
在删除元素所做

145
00:06:41,170 --> 00:06:43,010
移动次数的比较

146
00:06:43,010 --> 00:06:46,980
那它的平均次数应该是

147
00:06:46,980 --> 00:06:49,190
加上 N 减一

148
00:06:49,190 --> 00:06:51,420
乘以 N 除以二

149
00:06:51,420 --> 00:06:53,340
然后再除以 N 

150
00:06:53,340 --> 00:06:57,780
那它的移动次数最少可以移动零次

151
00:06:57,780 --> 00:07:01,430
最平均可以移动二分之 N 减一

152
00:07:01,430 --> 00:07:04,610
最多呢，可以移动 N 减一次

153
00:07:04,610 --> 00:07:08,450
这是我们呢涉及到的它的相关的操作

154
00:07:08,450 --> 00:07:12,170
那我们会发现它的读操作很方便吧

155
00:07:12,170 --> 00:07:14,520
其他的操作当中啊

156
00:07:14,520 --> 00:07:18,500
会涉及到对元素它的移动

157
00:07:18,500 --> 00:07:22,580
那尤其是插入操作和删除操作

158
00:07:22,580 --> 00:07:24,560
像插入操作的话

159
00:07:24,560 --> 00:07:27,770
如果空间匹配的是恰好

160
00:07:27,770 --> 00:07:30,490
诶，刚好够用的这个大小的话

161
00:07:30,490 --> 00:07:33,630
我们要在后面插入一个新的元素

162
00:07:33,630 --> 00:07:34,690
可能会失败

163
00:07:34,690 --> 00:07:37,160
因为空间上它可能呢

164
00:07:37,160 --> 00:07:39,300
连续空间已有数值

165
00:07:39,300 --> 00:07:42,050
所以它对于空间性能上

166
00:07:42,050 --> 00:07:45,260
其实并不是呢，特别有优势

167
00:07:45,260 --> 00:07:50,100
主要呢，优势是体现在读操作这个过程的

168
00:07:50,100 --> 00:07:53,920
那这是呢，顺序表它的一些呢操作

169
00:07:54,090 --> 00:07:57,980
下面看到呢，链表顺序存储啊

170
00:07:57,980 --> 00:08:00,140
注意它的内存分配啊

171
00:08:00,140 --> 00:08:01,580
一定是连续分配

172
00:08:01,580 --> 00:08:03,380
并且是静态分配的

173
00:08:03,380 --> 00:08:04,610
使用之前啊

174
00:08:04,610 --> 00:08:07,030
就需要分配给它固定的大小

175
00:08:07,030 --> 00:08:10,150
链式存储的方式是什么呢

176
00:08:10,150 --> 00:08:13,930
链式存储它是呢，空间上不连续

177
00:08:13,930 --> 00:08:18,020
那我如何确保唯一的头或者尾

178
00:08:18,020 --> 00:08:20,860
唯一的前驱和后继能被找到呢

179
00:08:20,860 --> 00:08:26,760
我们通过练这种方式来指向它的逻辑位置

180
00:08:26,760 --> 00:08:31,360
所以一个链式存储的数据来看的话

181
00:08:31,360 --> 00:08:35,080
它的节点啊，除了数据元素以外

182
00:08:35,080 --> 00:08:40,330
还要包含指针指向下一个元素的线索

183
00:08:40,330 --> 00:08:42,760
那他的这种划分呢

184
00:08:42,760 --> 00:08:44,480
内存是不连续的

185
00:08:44,480 --> 00:08:47,000
你需要的时候我给一个新的空间

186
00:08:47,000 --> 00:08:50,160
你把指针呢，指向这个空间就可以了啊

187
00:08:50,160 --> 00:08:52,660
前一个元素存储地址啊

188
00:08:52,660 --> 00:08:56,750
与下一个元素存储地址上可以不连续

189
00:08:56,750 --> 00:08:59,590
它通过链呢，来指向

190
00:08:59,590 --> 00:09:00,830
诶，下一个元素

191
00:09:00,830 --> 00:09:04,890
通过这种链的引用方式将元素串起来

192
00:09:04,890 --> 00:09:05,410
诶

193
00:09:05,410 --> 00:09:07,250
那这是我们呢

194
00:09:07,250 --> 00:09:08,680
关于顺序

195
00:09:08,680 --> 00:09:13,050
它的存储方式和链的存储方式的简单对比

196
00:09:13,050 --> 00:09:14,850
那我们来看一下

197
00:09:14,850 --> 00:09:18,080
对于一个链表而言的话

198
00:09:18,250 --> 00:09:20,550
它的基本结构呢

199
00:09:20,550 --> 00:09:22,170
哎，会有各个节点

200
00:09:22,170 --> 00:09:26,490
包括地址和它的下一个指针指向

201
00:09:26,490 --> 00:09:28,540
在一个链当中啊

202
00:09:28,540 --> 00:09:32,820
一个链表当中它有一些呢特殊的节点

203
00:09:32,820 --> 00:09:35,620
最后一个有效的节点

204
00:09:35,620 --> 00:09:39,180
存数字的我们叫做呢尾节点

205
00:09:39,180 --> 00:09:43,350
第一个存储数据的叫做呢首节点

206
00:09:43,350 --> 00:09:46,000
一般尾节点的指针指

207
00:09:46,000 --> 00:09:47,480
因为没有后继了

208
00:09:47,480 --> 00:09:51,130
所以指针的位置应该呢是空的

209
00:09:51,130 --> 00:09:56,420
那头节点一般指的是第一个有效节点

210
00:09:56,420 --> 00:10:00,040
之前，唉，它可以放一个呢头节点

211
00:10:00,040 --> 00:10:03,240
这个带元素的是首节点

212
00:10:03,240 --> 00:10:06,140
不带元素的是头节点

213
00:10:06,140 --> 00:10:09,480
头节点是可可有可无

214
00:10:09,480 --> 00:10:11,520
自己可以去设置的

215
00:10:13,080 --> 00:10:17,490
那对于头节点它的用法比较特殊

216
00:10:17,490 --> 00:10:21,450
我们可以在头节点里面元素位置

217
00:10:21,450 --> 00:10:24,380
来记录它的表长度

218
00:10:24,380 --> 00:10:26,350
链表长度

219
00:10:28,360 --> 00:10:32,000
那如果有记录链表长度的话

220
00:10:32,000 --> 00:10:34,840
在使用过程当中判断长度

221
00:10:34,840 --> 00:10:36,680
就可以直接返回了吧

222
00:10:36,680 --> 00:10:40,810
那如果说没有头节点的情况下

223
00:10:40,810 --> 00:10:42,910
我们在做一些操作的时候

224
00:10:42,910 --> 00:10:46,080
比如说对于首节点就做一些删除

225
00:10:46,080 --> 00:10:47,780
插入操作的情况下

226
00:10:47,780 --> 00:10:51,040
与后面的操作其实是有区别的

227
00:10:51,040 --> 00:10:53,520
所以对于头节点而言啊

228
00:10:53,520 --> 00:10:59,300
它是呢可以统一各个节点的插入和删除操作

229
00:10:59,300 --> 00:11:01,860
有这样的一个呢特殊的作用

230
00:11:01,860 --> 00:11:04,260
可以记录链表长度，呃

231
00:11:04,260 --> 00:11:06,180
可以统一

232
00:11:07,930 --> 00:11:12,610
对在列表当中的插入和删除操作

233
00:11:18,560 --> 00:11:21,680
如果没有头节点的话

234
00:11:21,680 --> 00:11:25,730
对手节点的操作我们会单独拎出来处理

235
00:11:25,730 --> 00:11:28,230
那我们还有呢，两个特殊的指针

236
00:11:28,230 --> 00:11:29,530
一个叫头指针

237
00:11:29,530 --> 00:11:31,230
一个是尾指针

238
00:11:31,230 --> 00:11:34,620
头指针它就是一个声明的一个指针变量

239
00:11:34,620 --> 00:11:35,880
指向头节点

240
00:11:35,880 --> 00:11:37,190
尾指针呢

241
00:11:37,190 --> 00:11:39,290
就是声明了一个指针变量

242
00:11:39,290 --> 00:11:40,990
指向尾节点

243
00:11:40,990 --> 00:11:43,610
这是一些呢，特殊的概念

244
00:11:43,610 --> 00:11:46,250
那我们对于链表呀

245
00:11:46,250 --> 00:11:48,240
N 个节点它都是呢

246
00:11:48,240 --> 00:11:50,060
可以离散分布的

247
00:11:50,060 --> 00:11:54,180
彼此呢，通过我们的指针链接进行指向

248
00:11:54,180 --> 00:11:58,020
然后呢，除了头节点和尾节点以外

249
00:11:58,020 --> 00:12:01,340
每一个节点都只有唯一的一个前驱

250
00:12:01,340 --> 00:12:03,490
和一个后继头节点

251
00:12:03,490 --> 00:12:05,210
没有前驱尾节点

252
00:12:05,210 --> 00:12:07,620
没有后继头节点呢

253
00:12:07,620 --> 00:12:11,020
它不不需要存放有效的数据

254
00:12:11,020 --> 00:12:14,760
可以呢，只存放链表的诶，首地址

255
00:12:14,760 --> 00:12:17,840
那其节点的数据类型

256
00:12:17,840 --> 00:12:20,670
和我们的首节点都是一样的

257
00:12:20,670 --> 00:12:22,140
在链表当中啊

258
00:12:22,140 --> 00:12:25,640
每一个节点它的格式都是一个呢，数据内

259
00:12:25,640 --> 00:12:27,620
加上一个呢指针

260
00:12:27,620 --> 00:12:30,400
那加头节点的目的呢

261
00:12:30,400 --> 00:12:33,260
就是为了方便对链表的操作

262
00:12:33,260 --> 00:12:34,830
有了这个节点之后

263
00:12:34,830 --> 00:12:37,310
我们对表的头部节点啊

264
00:12:37,310 --> 00:12:40,780
也就是首节点进行删除和插入的时候

265
00:12:40,780 --> 00:12:42,960
可以统一来进行操作

266
00:12:42,960 --> 00:12:46,110
这是链表它的一个呢，基本的结构

267
00:12:46,110 --> 00:12:49,730
有很多同学啊，之前不知道链表到底是什么

268
00:12:49,730 --> 00:12:53,190
那在这里呢，给大家做了一个简单的介绍

269
00:12:53,550 --> 00:12:56,970
我们以 C 语言当中的结构体

270
00:12:56,970 --> 00:12:58,670
简单来展示一下

271
00:12:58,670 --> 00:12:59,770
列表当中啊

272
00:12:59,770 --> 00:13:01,170
它的节点大致呢

273
00:13:01,170 --> 00:13:02,610
有什么样的一些内容

274
00:13:02,610 --> 00:13:04,030
列表当中啊

275
00:13:04,030 --> 00:13:07,510
每一个节点实际上都是一个结构体

276
00:13:07,510 --> 00:13:10,510
它可以包含相关的数据内容

277
00:13:10,510 --> 00:13:12,750
以及呢，唉，一个指针

278
00:13:12,750 --> 00:13:15,490
这个指针我们一般叫做 next 

279
00:13:15,490 --> 00:13:19,650
next 指针呢，它是指向下一个节点的

280
00:13:19,650 --> 00:13:21,490
它的指针类型啊

281
00:13:21,490 --> 00:13:24,630
就是呢，节点它本身的类型

282
00:13:24,630 --> 00:13:28,600
那这里呢，就给出了一些相应的节点

283
00:13:28,600 --> 00:13:31,570
以 list 呢，指向下一个节点

284
00:13:31,570 --> 00:13:34,690
直到呢，把所有的节点串联起来

285
00:13:34,690 --> 00:13:37,120
这就是一个简单的链表

286
00:13:37,120 --> 00:13:38,600
它的一个呢节点

287
00:13:38,600 --> 00:13:40,470
它的数据结构的展示

288
00:13:40,470 --> 00:13:42,940
那我们在链表当中

289
00:13:42,940 --> 00:13:46,320
也可以有一些不同的区分

290
00:13:46,320 --> 00:13:50,940
链表当中如果只有一个节点，唉

291
00:13:50,940 --> 00:13:54,060
只在节点当中只有一个指针域

292
00:13:54,060 --> 00:13:56,090
我们叫做单链表

293
00:13:56,090 --> 00:13:59,010
这个指针域一般叫做 next 

294
00:13:59,010 --> 00:14:01,750
指向下一个数据元素

295
00:14:01,750 --> 00:14:05,060
它也可以由两个指针域

296
00:14:05,060 --> 00:14:08,360
通过单链表我们只能找后继

297
00:14:08,360 --> 00:14:10,400
是无法找前驱的

298
00:14:10,400 --> 00:14:12,130
要想找前驱

299
00:14:12,130 --> 00:14:15,250
我们可以通过双链表来表示

300
00:14:15,250 --> 00:14:18,960
双链表它可以有两个指针域

301
00:14:18,960 --> 00:14:21,360
分别呢，可以记作 a ai

302
00:14:21,360 --> 00:14:23,200
link 表示呢左侧

303
00:14:23,200 --> 00:14:25,450
阿； link 表示呢，右

304
00:14:25,450 --> 00:14:28,000
也可以直接呢记作呃

305
00:14:28,000 --> 00:14:31,840
我们的 right 和 left 来分别表示，呃

306
00:14:31,840 --> 00:14:33,700
我们的右侧及右侧指针

307
00:14:33,700 --> 00:14:35,860
左侧指针这种含义

308
00:14:35,860 --> 00:14:38,940
那还有一种特殊的链表

309
00:14:38,940 --> 00:14:42,680
特殊的链表呢，叫做循环链表

310
00:14:42,680 --> 00:14:46,210
循环链表它会呢，让为指

311
00:14:46,210 --> 00:14:49,220
原本可为空的指针域

312
00:14:49,220 --> 00:14:53,390
唉，原本的为空的指针域来指向头

313
00:14:53,390 --> 00:14:57,040
那指向头部之后形成了一个环路吧

314
00:14:57,040 --> 00:14:58,960
这个过程当中

315
00:14:58,960 --> 00:15:02,570
我们呢，唉，如果要想找某一个节点

316
00:15:02,570 --> 00:15:06,310
可以从任意位置来进行循环便利

317
00:15:06,310 --> 00:15:10,680
那我们一般呢，也会定义一个尾指针

318
00:15:10,680 --> 00:15:13,840
它的 next 是等于头部

319
00:15:13,840 --> 00:15:16,350
从而形成循环

320
00:15:16,350 --> 00:15:19,530
那这是我们呢，涉及到的链表

321
00:15:19,530 --> 00:15:22,420
它的简单的一些呢，分类

322
00:15:22,420 --> 00:15:25,000
那接下来我们再来看一下链表

323
00:15:25,000 --> 00:15:26,960
它的一些呢，基本的操作

324
00:15:26,960 --> 00:15:28,420
包括呢，哎

325
00:15:28,420 --> 00:15:30,080
插入和删除

326
00:15:30,080 --> 00:15:33,190
那其实对于我们的链表

327
00:15:33,190 --> 00:15:36,600
也可以有读和查询的操作

328
00:15:36,600 --> 00:15:39,300
那对于读操作来说

329
00:15:39,300 --> 00:15:43,050
它并不能直接来返回某一个节点

330
00:15:43,050 --> 00:15:44,760
因为对于链表呀

331
00:15:44,760 --> 00:15:46,980
它的结构来看的话

332
00:15:46,980 --> 00:15:50,850
它的唯一有明确指针的是头指针

333
00:15:50,850 --> 00:15:53,760
所以要想读某一个数值

334
00:15:53,760 --> 00:15:55,530
某一个节点的元素值

335
00:15:55,530 --> 00:16:00,680
必须呢，从头指针一直遍历到对应节点为止

336
00:16:00,680 --> 00:16:04,570
所以它可能，诶，直接返回头第一个节点

337
00:16:04,570 --> 00:16:07,660
也有可能便利到最后一个节点

338
00:16:07,660 --> 00:16:12,070
所以它的查找和我们的它的读操作啊

339
00:16:12,070 --> 00:16:14,990
相比于顺序存储来说会麻烦一些

340
00:16:14,990 --> 00:16:17,490
那他的查找操作的话

341
00:16:17,490 --> 00:16:19,790
与顺序存储是一样

342
00:16:19,790 --> 00:16:22,830
需要呢去便利进行查询的

343
00:16:22,830 --> 00:16:27,190
那特殊一些的是它的删除和插入操作

344
00:16:27,190 --> 00:16:30,240
我们通过单链表和双链表

345
00:16:30,240 --> 00:16:34,420
分别来看一下它的删除和插入操作

346
00:16:34,420 --> 00:16:37,490
首先对于一个单链表来看的话

347
00:16:37,490 --> 00:16:40,810
如果要删除某一个节点

348
00:16:40,810 --> 00:16:46,090
我们要做的是将它前园区节点的指针指向

349
00:16:46,090 --> 00:16:48,510
指向呢，它的后继

350
00:16:48,510 --> 00:16:50,970
做这样的一个呢修改

351
00:16:50,970 --> 00:16:53,570
那我们可以看到在这里啊

352
00:16:53,570 --> 00:16:58,190
如果是删除 Q 指针指向的节点

353
00:16:58,190 --> 00:17:02,340
那我们用 P 指向它的前驱节点

354
00:17:02,340 --> 00:17:06,920
那我们在这里只需要修改 P 杠 nest 

355
00:17:07,540 --> 00:17:11,700
等于 Q 到 next 就可以了

356
00:17:11,960 --> 00:17:15,160
但是这里有一个特殊的地方是什么呢

357
00:17:15,160 --> 00:17:19,460
我们一般是只知道要删除哪一个节点吧

358
00:17:19,460 --> 00:17:23,579
那如果我找不到前驱节点的指针怎么办呢

359
00:17:23,579 --> 00:17:28,480
唉，这个前驱有可能需要头指针一直 next 

360
00:17:28,480 --> 00:17:31,530
找到对应位置来进行操作

361
00:17:31,530 --> 00:17:33,750
所以删除操作呀

362
00:17:33,750 --> 00:17:36,850
我们对于它的这种时间复杂度

363
00:17:36,850 --> 00:17:39,350
或者它的具体操作过程来看的话

364
00:17:39,350 --> 00:17:43,080
一般我们是删除某一个节点后面的节点

365
00:17:43,080 --> 00:17:45,450
这种方式会简单一些

366
00:17:45,450 --> 00:17:48,870
那如果是插入某一个节点的话

367
00:17:48,870 --> 00:17:52,950
那插入在 P 1指针指向的节点后面

368
00:17:52,950 --> 00:17:56,900
我们只需要诶修改它的指针指向

369
00:17:56,900 --> 00:17:58,740
但是要注意

370
00:17:58,740 --> 00:18:00,820
我们在修改之

371
00:18:00,820 --> 00:18:03,740
应该是先增加再修改的

372
00:18:03,740 --> 00:18:07,810
我们先需要让 S 杠 next 指针

373
00:18:07,810 --> 00:18:10,350
哎指向 P 杠 next 

374
00:18:10,350 --> 00:18:14,650
然后再修改 P 杠 next 指针

375
00:18:15,830 --> 00:18:17,430
等于 S 

376
00:18:17,430 --> 00:18:18,680
否则的话

377
00:18:18,680 --> 00:18:22,500
如果先对 next 指针进行修改

378
00:18:22,500 --> 00:18:26,160
我们新增的指针指向会发生错误

379
00:18:26,160 --> 00:18:29,860
这是呢，在单列表当中插入和删除

380
00:18:29,860 --> 00:18:32,380
双链表的插入和删除

381
00:18:32,380 --> 00:18:37,210
我们可以看到双面表它的删除和插入，诶

382
00:18:37,210 --> 00:18:41,170
删除过程需要修改两个指针指向

383
00:18:41,170 --> 00:18:42,790
那此时，哎

384
00:18:42,790 --> 00:18:44,550
这是 P 杠

385
00:18:44,550 --> 00:18:46,900
我们写成 L 吧

386
00:18:46,900 --> 00:18:48,380
就不写详细了

387
00:18:48,380 --> 00:18:51,380
这是呢， P 1杠 R 

388
00:18:51,380 --> 00:18:54,370
那我们在进行删除的时候

389
00:18:54,370 --> 00:18:58,510
它是将 P 杠 L 的 list 指针

390
00:18:58,510 --> 00:19:00,930
哎，指向 P 杠二

391
00:19:01,330 --> 00:19:04,290
然后让 P 杠二的，哎

392
00:19:04,290 --> 00:19:06,750
我们的写成不写 left 

393
00:19:06,750 --> 00:19:07,690
写成 R 吧

394
00:19:07,690 --> 00:19:11,210
它的 left 指针呢指向 P 杠 L 

395
00:19:11,430 --> 00:19:15,850
以这种形式来修改它的指针指向

396
00:19:15,850 --> 00:19:19,300
从而呢将中间的节点删除掉

397
00:19:19,300 --> 00:19:21,100
那如果要删

398
00:19:21,100 --> 00:19:23,500
要插入某一个节点的话

399
00:19:23,500 --> 00:19:28,690
同样我们在插入的时候是先新增指针指向

400
00:19:28,690 --> 00:19:31,170
再修改指针指向

401
00:19:31,170 --> 00:19:33,140
那他们的这些操作啊

402
00:19:33,140 --> 00:19:35,700
具体的过程我们来看一下，唉

403
00:19:35,700 --> 00:19:39,410
我们把单链表的表节点结构

404
00:19:39,410 --> 00:19:42,460
定义为数值域和指针域

405
00:19:42,460 --> 00:19:46,010
那用 link 来表示指针不是 last 了

406
00:19:46,010 --> 00:19:50,740
那我们在单链表 P 所指节点后面

407
00:19:50,740 --> 00:19:54,390
插入某一个新元素节点 S 

408
00:19:54,390 --> 00:19:57,030
那我们插入的过程应该是

409
00:19:57,030 --> 00:19:59,810
先对 S 的 link 进行修改

410
00:19:59,810 --> 00:20:02,140
再对 P 的 link 进行修改

411
00:20:02,140 --> 00:20:04,380
先增加再修改

412
00:20:04,380 --> 00:20:06,020
然后再来看

413
00:20:06,020 --> 00:20:12,320
如果是删除 P 节点所指向的后继节点

414
00:20:12,320 --> 00:20:14,140
那这是 P 节点

415
00:20:14,140 --> 00:20:16,100
这是它的后继节点吧

416
00:20:16,100 --> 00:20:19,060
我们用 Q 来表示它的后

417
00:20:19,060 --> 00:20:20,400
待删除的节点

418
00:20:20,400 --> 00:20:26,000
那让 P 杠 link 它的指针指向 Q 杠 link 

419
00:20:26,000 --> 00:20:29,060
那我们在这里的话可以呢

420
00:20:29,060 --> 00:20:31,420
诶，对它来进行修改

421
00:20:31,420 --> 00:20:35,060
首先呢，哎，我们给 Q 进行了赋值

422
00:20:35,060 --> 00:20:37,200
让 Q 等于下一个指针

423
00:20:37,200 --> 00:20:40,460
这个其实就是待删除节点指针

424
00:20:43,080 --> 00:20:45,620
然后，唉，进行修改

425
00:20:45,620 --> 00:20:50,340
让 P 杠 link 指向它的下一个指针位置

426
00:20:50,340 --> 00:20:54,090
其实这里就是 Q 杠 link 吧

427
00:20:54,090 --> 00:20:57,140
这两个是相同含义

428
00:20:57,140 --> 00:20:59,960
那这你做完之后把节点释放

429
00:20:59,960 --> 00:21:02,100
就是删除了节点

430
00:21:02,100 --> 00:21:08,290
那如果我们是直接删除 GP 所指向的节点

431
00:21:08,290 --> 00:21:12,140
那这里的删除并没有用到我们所说的

432
00:21:12,140 --> 00:21:15,320
用 head 指针遍历来指向的过程

433
00:21:15,320 --> 00:21:18,930
它的删除啊，用了一种呢，灵活的方式

434
00:21:18,930 --> 00:21:21,950
它将呢， P 杠 data 唉

435
00:21:21,950 --> 00:21:24,950
定义为下一个节点的 data 

436
00:21:24,950 --> 00:21:28,660
也就是说我将这个数值域呀

437
00:21:28,660 --> 00:21:30,870
给了我们的 A 1

438
00:21:30,870 --> 00:21:34,890
那原本我要删除的应该是 A 1

439
00:21:34,890 --> 00:21:37,680
那我现在 A 1的数值给它呢

440
00:21:37,680 --> 00:21:38,760
哎，取消了

441
00:21:38,760 --> 00:21:41,020
把它呢变成了 A 2

442
00:21:41,020 --> 00:21:43,450
那数值域修改了之后

443
00:21:43,450 --> 00:21:45,330
剩下就是指针域了吧

444
00:21:45,330 --> 00:21:48,330
那这个指针域要不要删除呢

445
00:21:48,330 --> 00:21:51,730
我们把后面的 Q 节点删除了

446
00:21:51,730 --> 00:21:56,470
因为我们原本的目标是删除 A 1这个元素

447
00:21:56,470 --> 00:21:59,980
而现在 A 1已经被 A 2覆盖了

448
00:21:59,980 --> 00:22:02,220
我们只要把 Q 节点删除

449
00:22:02,220 --> 00:22:04,920
其实它的最终实现目标

450
00:22:04,920 --> 00:22:07,500
就是删除了一个 A 1元素吧

451
00:22:07,500 --> 00:22:09,720
A 2元素呢，仍然是保留的

452
00:22:09,720 --> 00:22:12,690
所以它将数值域啊移动了一下

453
00:22:12,690 --> 00:22:15,040
将后面待删除节点

454
00:22:15,040 --> 00:22:20,170
下一个节点的元素给了前面节点的数值域

455
00:22:20,170 --> 00:22:23,180
然后我们后面所做的操作是什么

456
00:22:23,180 --> 00:22:26,660
就是删除后一个节点了

457
00:22:30,460 --> 00:22:33,260
那后继节点怎么删除呢

458
00:22:33,260 --> 00:22:35,490
唉，修改指针域的指向吧

459
00:22:35,490 --> 00:22:38,530
仍然让 Q 呢，指向它的，唉

460
00:22:38,530 --> 00:22:41,530
下一个指针就是我们要删除的下一个节点

461
00:22:41,530 --> 00:22:44,510
然后呢，修改它的指针域

462
00:22:44,510 --> 00:22:47,170
然后释放这个 Q 节点

463
00:22:47,170 --> 00:22:49,410
这也是呢，删除的过程

464
00:22:49,410 --> 00:22:53,690
比我们说的 head 便利的方式要更灵活

465
00:22:53,690 --> 00:22:55,870
实践起来，时间复杂度啊

466
00:22:55,870 --> 00:22:58,150
它的操作效率都会很快吧

467
00:22:58,150 --> 00:23:00,210
所以对于线性表来说

468
00:23:00,210 --> 00:23:02,090
它的删除操作啊

469
00:23:02,090 --> 00:23:05,550
时间复杂度呢，也可以是大 O 级的

470
00:23:05,550 --> 00:23:10,300
一只需要两三个常数级的步骤即可以了

471
00:23:10,300 --> 00:23:12,710
它的插入操作啊

472
00:23:12,710 --> 00:23:15,910
时间复杂度也是呢， DOO 级的一

473
00:23:15,910 --> 00:23:18,700
因为只需要修改指针指向吧

474
00:23:18,700 --> 00:23:21,780
所以这是呢，单链表它的插入和删除

475
00:23:21,780 --> 00:23:25,090
那我们再来看一下双链表它的操作

476
00:23:25,090 --> 00:23:27,290
对于双向链表来看的话

477
00:23:27,290 --> 00:23:29,670
它是有两个指针指向的

478
00:23:29,670 --> 00:23:32,900
现在我们要插入一个新的节点 Q 

479
00:23:32,900 --> 00:23:35,250
那我们首先是先新增吧

480
00:23:35,250 --> 00:23:37,810
可以新增它的诶

481
00:23:37,810 --> 00:23:40,340
左侧和右侧指针指向

482
00:23:40,340 --> 00:23:41,400
那我们说呢

483
00:23:41,400 --> 00:23:43,000
唉， Q 杠 front 

484
00:23:43,000 --> 00:23:46,540
它的前驱指向我们 P 节点

485
00:23:46,540 --> 00:23:49,460
然后呢， Q 杠 nest ，哎

486
00:23:49,460 --> 00:23:53,520
后继应该呢，指向原本 P 节点的后继

487
00:23:53,520 --> 00:23:54,470
那这里呢

488
00:23:54,470 --> 00:23:56,890
唉，就新增了两个指针

489
00:23:56,890 --> 00:23:59,720
接下来就要修改指针了

490
00:23:59,720 --> 00:24:01,720
修改的过程当中

491
00:24:01,720 --> 00:24:03,280
我们可以让呢

492
00:24:03,280 --> 00:24:06,620
哎，后继的前驱指向 Q 

493
00:24:06,620 --> 00:24:10,400
那这是呢， P 1杠 list 

494
00:24:10,590 --> 00:24:12,770
对于这个节点

495
00:24:12,770 --> 00:24:15,170
它的前驱 front 指针呢

496
00:24:15,170 --> 00:24:17,120
指向插入的节点 Q 

497
00:24:17,120 --> 00:24:18,180
再对呢

498
00:24:18,180 --> 00:24:23,060
哎，最后再做呢， P 杠 next 指向 Q 的这个修改

499
00:24:23,060 --> 00:24:25,660
注意这两个顺序是不能交换的

500
00:24:25,660 --> 00:24:27,040
否则的话也会呢

501
00:24:27,040 --> 00:24:29,340
出现数据指向的错误

502
00:24:29,340 --> 00:24:32,020
那这里插入的时间复杂度

503
00:24:32,020 --> 00:24:34,630
同样的大 O 级的一就足够了

504
00:24:34,630 --> 00:24:38,930
那如果是双向链表删除节点 P 

505
00:24:38,930 --> 00:24:41,620
A 指针 P 所指向的节点呢

506
00:24:41,620 --> 00:24:43,830
那我们直接进行修改吧

507
00:24:43,830 --> 00:24:47,350
原本这里是 P 1杠 front 

508
00:24:48,390 --> 00:24:49,710
这是呢

509
00:24:49,710 --> 00:24:52,790
哎 P 1杠 nest 

510
00:24:55,020 --> 00:24:58,500
那我们现在修改的是 P 杠 front 

511
00:24:58,500 --> 00:25:02,630
节点的 next 指针指向了 P 杠 next 吧

512
00:25:02,630 --> 00:25:06,070
然后再修改 P 杠 next 的指针

513
00:25:06,070 --> 00:25:10,030
哎，它的前指针域指向了 P 杠 front 

514
00:25:10,030 --> 00:25:13,180
那此时就删除了节点 P 

515
00:25:13,180 --> 00:25:15,420
再对 P 呢进行释放

516
00:25:15,420 --> 00:25:17,180
这就是呢，双链表

517
00:25:17,180 --> 00:25:19,630
它的插入和删除时间

518
00:25:19,630 --> 00:25:22,300
复杂度都是呢 WOG 的一

519
00:25:22,300 --> 00:25:24,660
我们可以呢，汇总来看一下

520
00:25:24,660 --> 00:25:26,580
对于线性表当中啊

521
00:25:26,580 --> 00:25:28,940
顺序存储和链式存

522
00:25:28,940 --> 00:25:30,720
它们的这个呢对比

523
00:25:30,720 --> 00:25:32,520
那线性表当中呢

524
00:25:32,520 --> 00:25:34,740
顺序存储的方式

525
00:25:34,740 --> 00:25:36,260
它的时间

526
00:25:36,260 --> 00:25:39,600
它的存储从空间性能来看的话

527
00:25:39,600 --> 00:25:41,840
唉，我们用多少给多少

528
00:25:41,840 --> 00:25:44,900
所有的空间都拿来存数据了

529
00:25:44,900 --> 00:25:46,980
所以存储密度等于一

530
00:25:46,980 --> 00:25:48,890
相对来说呢比较好

531
00:25:48,890 --> 00:25:52,300
而链式存储它的一个节点有数据

532
00:25:52,300 --> 00:25:53,640
还有指针吧

533
00:25:53,640 --> 00:25:56,200
所以密度会小于一

534
00:25:56,200 --> 00:25:58,270
从容量分配来看

535
00:25:58,270 --> 00:26:01,030
顺序存储一定是事先确定的

536
00:26:01,030 --> 00:26:05,240
我们对于数组一定要先分配长度才能使用

537
00:26:05,240 --> 00:26:08,540
所以事先确定不好呢，做改变

538
00:26:08,540 --> 00:26:11,410
而链式存储可以动态改变

539
00:26:11,410 --> 00:26:14,990
这种过程来看的话会更优一些

540
00:26:14,990 --> 00:26:17,990
从它们的时间性能来看

541
00:26:17,990 --> 00:26:22,560
顺序存储可以直接返回某一个数据

542
00:26:22,560 --> 00:26:26,680
读操作时间复杂度大 O 及一查找的话

543
00:26:26,680 --> 00:26:29,800
它的平均查找时间

544
00:26:29,800 --> 00:26:30,980
时间复杂度

545
00:26:30,980 --> 00:26:33,780
我们把它呢记作大 O 级的 N 

546
00:26:33,780 --> 00:26:36,030
呃，对于时间复杂度啊

547
00:26:36,030 --> 00:26:37,890
我们的二分之 N 

548
00:26:37,890 --> 00:26:40,500
二分之 N 减一都是呢

549
00:26:40,500 --> 00:26:43,620
哎，把它记作时间量级大 O 几的一的

550
00:26:43,620 --> 00:26:46,430
所以这里呢，直接写的大 O 级的一

551
00:26:46,430 --> 00:26:49,630
查找运算。在链式存储当中啊

552
00:26:49,630 --> 00:26:52,430
也是呢，有这样的时间复杂

553
00:26:52,430 --> 00:26:54,940
独运算的链式方式啊

554
00:26:54,940 --> 00:26:56,700
最好是一

555
00:26:56,700 --> 00:26:58,080
最坏呢是 N 

556
00:26:58,080 --> 00:27:00,860
所以它的时间复杂度也是呢

557
00:27:00,860 --> 00:27:02,840
记作 WOG 的 N 

558
00:27:03,240 --> 00:27:04,700
顺序存储

559
00:27:04,700 --> 00:27:08,940
它的插入和删除需要移动后续的元素

560
00:27:08,940 --> 00:27:12,480
所以时间复杂度是大 O 级的 N 

561
00:27:12,480 --> 00:27:16,600
而链式存储可以直接修改指针指向

562
00:27:16,600 --> 00:27:20,030
时间复杂度只需要大 O 级的一

563
00:27:20,030 --> 00:27:22,750
中间涉及到的数据移动

564
00:27:22,750 --> 00:27:24,280
大家呢要注意

565
00:27:24,280 --> 00:27:25,780
尤其是顺序表啊

566
00:27:25,780 --> 00:27:27,760
移动的元素个数，诶

567
00:27:27,760 --> 00:27:30,160
它最好的情况和平均的情况

568
00:27:30,160 --> 00:27:31,820
大家呢要注意一下

569
00:27:31,820 --> 00:27:33,550
那这是我们说到

570
00:27:33,550 --> 00:27:36,130
顺序存储和链式存储

571
00:27:36,130 --> 00:27:38,240
在线性表当中的对比

572
00:27:38,240 --> 00:27:39,740
那综合来看呢

573
00:27:39,740 --> 00:27:43,000
这就是我们给大家介绍到的第一种线性结构

574
00:27:43,000 --> 00:27:47,210
线性表包括呢，我们的顺序表和链表

575
00:27:47,210 --> 00:27:50,260
它的一些呢，概念和应用的过程

576
00:27:50,260 --> 00:27:52,940
下面呢，我们来看一下这一部分

577
00:27:52,940 --> 00:27:54,960
在软件设计师考试当中

578
00:27:54,960 --> 00:27:57,450
它的真题考察题型

579
00:27:57,450 --> 00:28:02,440
假设呢，有一个包含 N 个元素的有序线性表

580
00:28:02,440 --> 00:28:07,190
等概率情况下删除其中一个元素

581
00:28:07,190 --> 00:28:10,970
那如果采用顺序存储，哎

582
00:28:10,970 --> 00:28:13,310
顺序的情况下是多少啊

583
00:28:13,310 --> 00:28:15,990
我们在这里顺序存储的话

584
00:28:15,990 --> 00:28:18,400
要删除某一个元素

585
00:28:18,400 --> 00:28:21,100
平均需要移动的元素个数

586
00:28:21,100 --> 00:28:22,700
最好情况下不用移

587
00:28:22,700 --> 00:28:25,510
最差情况下移 N 减一次吧

588
00:28:25,510 --> 00:28:29,090
它的平均次数是二分之 N 减一

589
00:28:29,090 --> 00:28:32,050
如果用单链表要不要移动

590
00:28:32,050 --> 00:28:33,360
不需要移

591
00:28:33,360 --> 00:28:34,940
修改指针即可

592
00:28:34,940 --> 00:28:39,000
所以移动的元素个数只需要零个

593
00:28:39,000 --> 00:28:41,900
这就是呢我们给大家介绍到的

594
00:28:41,900 --> 00:28:44,430
关于呢顺序表和链表

595
00:28:44,430 --> 00:28:45,390
它的一些应用

596
00:28:45,390 --> 00:28:46,810
在考察当中呢

597
00:28:46,810 --> 00:28:49,790
主要就涉及到对他们的一些操作的对比
