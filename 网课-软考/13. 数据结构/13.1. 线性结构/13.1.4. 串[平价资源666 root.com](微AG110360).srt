1
00:00:00,000 --> 00:00:03,760
接下来我们来看到一种特殊的线性结构串

2
00:00:03,760 --> 00:00:05,560
我们在讲串的时候啊

3
00:00:05,560 --> 00:00:08,260
通常讲到的都是呢，字符串

4
00:00:08,260 --> 00:00:12,980
它将一串字符放在了一个数据结构当中

5
00:00:12,980 --> 00:00:14,920
可以用数组来存

6
00:00:14,920 --> 00:00:18,660
也可以呢用链的形式来进行存储

7
00:00:18,660 --> 00:00:20,840
也就是说它可以有顺序存储

8
00:00:20,840 --> 00:00:23,410
也可以有链式存储的形式。啊

9
00:00:23,410 --> 00:00:26,860
那对于串，在我们软件设计师考试当中

10
00:00:26,860 --> 00:00:29,280
考察的频率并不高

11
00:00:29,280 --> 00:00:31,400
但是一旦考到的时候呢

12
00:00:31,400 --> 00:00:34,040
出现的问题就会呢，比较多

13
00:00:34,040 --> 00:00:38,060
他平时在出现在考察当中的时候啊

14
00:00:38,060 --> 00:00:41,200
一般涉及到的是串他的一些操作

15
00:00:41,200 --> 00:00:44,110
然后呢，一些特殊的串的定义

16
00:00:44,110 --> 00:00:47,330
包括呢，像串的模式匹配等等

17
00:00:47,330 --> 00:00:49,640
我们在后面呢，展开来看

18
00:00:49,640 --> 00:00:51,060
对于串来讲

19
00:00:51,060 --> 00:00:53,000
首先了解呢，什么是串

20
00:00:53,000 --> 00:00:57,100
那串的话，它是由字符构成的有限序列

21
00:00:57,100 --> 00:00:59,500
它是一种呢，线性的结构

22
00:00:59,500 --> 00:01:03,420
那串它包含一些呢，基本概念

23
00:01:03,420 --> 00:01:05,480
需要大家去进行区分

24
00:01:05,480 --> 00:01:09,690
首先，空串与空格串它是不一样的

25
00:01:09,690 --> 00:01:12,380
我们在界面显示当中啊

26
00:01:12,380 --> 00:01:14,300
能够看到，诶

27
00:01:14,300 --> 00:01:17,340
一系列空白的区域

28
00:01:17,340 --> 00:01:20,390
那这个空白的区域当中啊

29
00:01:20,390 --> 00:01:26,420
如果空串它是没有任何字符长度为零的

30
00:01:26,420 --> 00:01:30,370
而空格串看起来也是空白

31
00:01:30,370 --> 00:01:34,650
但它里面会包含一个或者多个空格

32
00:01:34,650 --> 00:01:38,070
大家知道把空格在敲入之

33
00:01:38,070 --> 00:01:40,570
显示的也是呢，空白区域

34
00:01:40,570 --> 00:01:41,830
但是要知道

35
00:01:41,830 --> 00:01:43,380
对于空格串

36
00:01:43,380 --> 00:01:45,430
在我们阿斯克码当中呢

37
00:01:45,430 --> 00:01:47,210
它其实是有编码的

38
00:01:47,210 --> 00:01:51,300
所以说空格看起来是空白的字符

39
00:01:51,300 --> 00:01:53,080
但它呢，也是

40
00:01:53,080 --> 00:01:55,480
诶，仍然是属于一个字符

41
00:01:55,480 --> 00:01:57,760
有它自己的长长度

42
00:01:57,760 --> 00:01:59,540
所以我们如果说

43
00:01:59,540 --> 00:02:01,160
诶，出现空格串的话

44
00:02:01,160 --> 00:02:03,760
空格串它是有长度的啊

45
00:02:03,760 --> 00:02:07,500
那这是空串和空格串它的区别

46
00:02:07,890 --> 00:02:12,250
第二组概念呢，是子串与子序列

47
00:02:12,250 --> 00:02:14,830
那我们有一个字符串

48
00:02:14,830 --> 00:02:17,290
a , a , b , a ， b , a , b , c 

49
00:02:17,550 --> 00:02:20,890
那对于这个字符串来说

50
00:02:20,890 --> 00:02:25,500
它里面所包含的子串和子序列是什么呢

51
00:02:25,500 --> 00:02:25,890
诶

52
00:02:25,890 --> 00:02:31,690
子串指的是由串当中任意长度的连续字符

53
00:02:31,690 --> 00:02:32,650
构成的序列

54
00:02:32,650 --> 00:02:34,560
称为呢它的子串

55
00:02:34,560 --> 00:02:38,180
也就是说这里 A 、 B 

56
00:02:38,180 --> 00:02:44,740
然后 ABC 这五个字符都是其长度为一的子串

57
00:02:44,740 --> 00:02:46,490
那 A , B ，哎

58
00:02:46,490 --> 00:02:48,550
这是它的一个，呃

59
00:02:48,550 --> 00:02:49,890
这是它的一个呢

60
00:02:49,890 --> 00:02:51,910
子串，长度为二

61
00:02:51,910 --> 00:02:54,390
AABA 是它的一个子串

62
00:02:54,390 --> 00:02:55,710
长度为三

63
00:02:55,710 --> 00:02:58,770
A , B , A , B 也是它的一个子串

64
00:02:58,770 --> 00:03:00,090
长度为四

65
00:03:00,090 --> 00:03:02,250
那这是我们看到的子串

66
00:03:02,250 --> 00:03:04,030
子串当中啊

67
00:03:04,030 --> 00:03:06,630
我们对应的这一个字符串

68
00:03:06,630 --> 00:03:08,930
通常呢叫做主串

69
00:03:08,930 --> 00:03:11,980
子串。在查找的过程当中

70
00:03:11,980 --> 00:03:13,960
通常返回的是

71
00:03:13,960 --> 00:03:17,160
诶，他手四出现的位置

72
00:03:17,160 --> 00:03:21,600
那我们这里呢，第一个字符位置就是呢， A 、 B 

73
00:03:21,600 --> 00:03:24,040
它所出现的子串位置

74
00:03:24,040 --> 00:03:26,820
空串呢，可以是任意的子串

75
00:03:26,820 --> 00:03:29,060
而子序列注意啊

76
00:03:29,060 --> 00:03:31,720
子序列跟子串不一样

77
00:03:31,720 --> 00:03:33,250
子序列啊

78
00:03:33,250 --> 00:03:36,130
它是将一些字符提取出来

79
00:03:36,130 --> 00:03:37,990
形成的一个新串

80
00:03:37,990 --> 00:03:41,660
并且不改变它们的相对位置

81
00:03:41,660 --> 00:03:42,740
那也就是说

82
00:03:42,740 --> 00:03:45,780
其实这些子串都可以作为子序列吧

83
00:03:45,780 --> 00:03:47,060
除此以外

84
00:03:47,060 --> 00:03:48,740
像 AA 

85
00:03:49,490 --> 00:03:52,930
原本在子串去判断的时候

86
00:03:52,930 --> 00:03:55,030
它不符合子串的定义吧

87
00:03:55,030 --> 00:04:01,250
但它是从我们的主串中提取出来的字符

88
00:04:01,250 --> 00:04:03,190
形成的新串

89
00:04:03,190 --> 00:04:06,770
并且没有改变它的相对位置

90
00:04:06,770 --> 00:04:08,350
那这就是呢

91
00:04:08,350 --> 00:04:11,280
唉，它的子序列的含义

92
00:04:11,280 --> 00:04:14,730
对于子序列来说它比较特殊

93
00:04:14,730 --> 00:04:19,070
我们写一个较小的串来找子序列试一试

94
00:04:19,070 --> 00:04:21,730
比如说对于 A 、 B 、 C 

95
00:04:22,460 --> 00:04:26,540
长度为三的一个主串

96
00:04:26,540 --> 00:04:28,820
我们来找它的子序列

97
00:04:28,820 --> 00:04:34,150
首先，唉，长度为一的 A 、 B 、 C 都满足要求吧

98
00:04:34,150 --> 00:04:41,250
长度为二的 A 、 B 、 A 、 C 、 BC 都满足要求吧

99
00:04:41,250 --> 00:04:45,750
长度为三的 ABC 本身满足要求

100
00:04:45,750 --> 00:04:49,310
还有一个空串是不是也满足要求呢

101
00:04:49,310 --> 00:04:54,080
那这就是它所有的满足要求的子序列

102
00:04:54,080 --> 00:04:56,930
这样数起来看起来很麻烦吧

103
00:04:56,930 --> 00:05:00,490
那我们其实把每一个字符

104
00:05:00,490 --> 00:05:03,750
是否出现在子序列位置上

105
00:05:03,750 --> 00:05:07,350
把它呢，分别记作零或一

106
00:05:07,350 --> 00:05:09,930
零表示未出现

107
00:05:09,930 --> 00:05:11,810
一表示出现了

108
00:05:11,810 --> 00:05:14,600
那这个空串就是零零

109
00:05:14,600 --> 00:05:17,580
零表示三个字符没有出现吧

110
00:05:17,580 --> 00:05:20,240
A 表示的是100

111
00:05:20,240 --> 00:05:22,170
B 可以用010

112
00:05:22,170 --> 00:05:24,960
C 用001来表示

113
00:05:24,960 --> 00:05:27,210
A 、 B 可以用110

114
00:05:27,210 --> 00:05:28,970
AC 用101

115
00:05:28,970 --> 00:05:31,130
BC 用011

116
00:05:31,130 --> 00:05:33,800
A 、 B 、 C 用111

117
00:05:33,800 --> 00:05:35,630
那这样来看的话

118
00:05:35,630 --> 00:05:37,310
大家有没有发现呢

119
00:05:37,310 --> 00:05:42,460
这里的三个位置其实刚好对应每个位置

120
00:05:42,460 --> 00:05:46,680
两种可能，总的是八种可能

121
00:05:47,150 --> 00:05:49,450
那它对应的编码

122
00:05:49,450 --> 00:05:55,530
0000010100111

123
00:05:55,530 --> 00:05:59,370
00101110111

124
00:05:59,370 --> 00:06:02,920
是不是刚好三位二进制的编码呀

125
00:06:02,920 --> 00:06:06,110
所以判断子序列个数的时候

126
00:06:06,110 --> 00:06:10,440
我们可以以二进制编码来进行理解

127
00:06:10,440 --> 00:06:12,280
N 位字符串

128
00:06:12,280 --> 00:06:16,630
它的子序列有二的 N 次方个

129
00:06:16,630 --> 00:06:21,340
这是关于呢，子序列它的一种呢用法

130
00:06:21,340 --> 00:06:24,580
那关于子串和子序列

131
00:06:24,580 --> 00:06:26,820
子串要求连续

132
00:06:26,820 --> 00:06:30,120
而子序列不需要连续

133
00:06:30,120 --> 00:06:31,690
下面再来看呢

134
00:06:31,690 --> 00:06:35,970
唉，关于我们的字符串的另一组概念

135
00:06:35,970 --> 00:06:38,490
串比较和串相等

136
00:06:38,490 --> 00:06:41,420
串呢，可以与串来进行比较

137
00:06:41,420 --> 00:06:45,020
比如说 A 、 B 、 C 和 CBA 是可以进行比较的

138
00:06:45,020 --> 00:06:48,230
那两个串比较大小的时候呢

139
00:06:48,230 --> 00:06:51,850
它其实比较的是字符的阿斯克码

140
00:06:51,850 --> 00:06:53,250
实质上呢

141
00:06:53,250 --> 00:06:54,670
比较操作呀

142
00:06:54,670 --> 00:06:58,190
是从两个串它的第一个字符开始的

143
00:06:58,190 --> 00:07:01,220
那阿斯克码较大的这个字符串

144
00:07:01,220 --> 00:07:02,100
所字符啊

145
00:07:02,100 --> 00:07:04,510
所在的串肯定它的值会大一些

146
00:07:04,510 --> 00:07:07,730
如果有一个串先结束的话

147
00:07:07,730 --> 00:07:10,370
串长较大的它会呢大一些

148
00:07:10,370 --> 00:07:12,230
那这是呢，串的比较

149
00:07:12,230 --> 00:07:13,470
串相等

150
00:07:13,470 --> 00:07:15,120
它指的是什么呢

151
00:07:15,120 --> 00:07:20,500
两个串它的长度和对应序号的字符完全相同

152
00:07:20,500 --> 00:07:23,380
它才是呢，相等的字符串

153
00:07:23,380 --> 00:07:24,800
这是串的诶

154
00:07:24,800 --> 00:07:27,160
他的一些呢，基本的概念

155
00:07:27,160 --> 00:07:29,800
那串它有哪些操作呢

156
00:07:29,800 --> 00:07:32,080
串可以进行赋值

157
00:07:32,080 --> 00:07:36,640
将某一个，诶，串 S 赋值给我们的串

158
00:07:36,640 --> 00:07:38,130
T 可以进行赋值

159
00:07:38,130 --> 00:07:41,160
可以呢，诶，进行连接

160
00:07:41,160 --> 00:07:43,970
将 T 呢放到 S 的尾部

161
00:07:43,970 --> 00:07:46,510
我们拼接成一个新的串

162
00:07:46,510 --> 00:07:48,940
还可以呢，求串长

163
00:07:48,940 --> 00:07:50,930
返回它的长

164
00:07:50,930 --> 00:07:52,930
可以呢进行比较

165
00:07:52,930 --> 00:07:56,760
可以有相等、较小、较大这样的一些情况

166
00:07:56,760 --> 00:07:59,690
分别记作一、零和一

167
00:07:59,690 --> 00:08:01,970
那零的时候表示相等

168
00:08:01,970 --> 00:08:04,250
要注意求子串

169
00:08:04,250 --> 00:08:07,870
它可以呢在 S 这个串当中

170
00:08:07,870 --> 00:08:13,370
从 start 位置开始返回长度为 name 的字符序列

171
00:08:13,370 --> 00:08:15,170
就是它的子串

172
00:08:15,170 --> 00:08:17,940
这是串的一些呢基本操作

173
00:08:17,940 --> 00:08:21,330
串可以以顺序的形式存储

174
00:08:21,330 --> 00:08:26,040
那这种所对应的可以用数组唉来进行存储

175
00:08:26,040 --> 00:08:27,700
我们也可以呢

176
00:08:27,700 --> 00:08:29,280
在一些语言当中

177
00:08:29,280 --> 00:08:32,840
可以呢用我们的 string 来表示字符串的序列

178
00:08:32,840 --> 00:08:34,890
然后链式存储

179
00:08:34,890 --> 00:08:38,390
它可以在一个节点当中

180
00:08:38,390 --> 00:08:40,940
存储一个字符串序号

181
00:08:40,940 --> 00:08:43,929
当然，为了节约它的空间

182
00:08:43,929 --> 00:08:46,070
我们也可以在里面呢

183
00:08:46,070 --> 00:08:49,730
哎，把它声明为长度为三

184
00:08:49,730 --> 00:08:51,080
这样的一些呢

185
00:08:51,080 --> 00:08:52,700
字符串的节点

186
00:08:52,700 --> 00:08:55,760
那这是串它的基本概念

187
00:08:55,760 --> 00:08:59,740
接下来呢，我们看到串当中有一种呢

188
00:08:59,740 --> 00:09:01,780
非常特殊的操作

189
00:09:01,780 --> 00:09:04,200
叫做呢模式匹配

190
00:09:04,200 --> 00:09:05,710
模式匹配啊

191
00:09:05,710 --> 00:09:10,820
它其实就是呢，对串当中的子串来进行定义

192
00:09:10,820 --> 00:09:13,970
那我们查找的这个主串啊

193
00:09:13,970 --> 00:09:16,010
查找的这个字符串对象

194
00:09:16,010 --> 00:09:17,890
我们一般呢叫做主串

195
00:09:17,890 --> 00:09:21,520
比如说啊 AB 、 A 、 B 、 ABC 

196
00:09:22,090 --> 00:09:25,930
那我们在这里面查找的过程当中呢

197
00:09:25,930 --> 00:09:27,180
哎，找子串吧

198
00:09:27,180 --> 00:09:28,720
匹配一下 BC 

199
00:09:28,720 --> 00:09:32,250
是不是它的子串就叫做模式匹配

200
00:09:32,250 --> 00:09:36,410
如果找到了就返回它第一次出现的位置

201
00:09:36,410 --> 00:09:40,050
那这种子串它也叫做呢模式串

202
00:09:40,050 --> 00:09:44,450
在做模式匹配的常见有两种算法

203
00:09:44,450 --> 00:09:46,750
第一种呢，是非常暴力的

204
00:09:46,750 --> 00:09:48,560
唉，简单暴力就是呢

205
00:09:48,560 --> 00:09:51,010
模式匹配的朴素算法啊

206
00:09:51,010 --> 00:09:53,100
它的朴素算法呢

207
00:09:53,100 --> 00:09:55,280
我们把这两个串啊

208
00:09:55,280 --> 00:09:57,050
存在一个数组当中

209
00:09:57,050 --> 00:09:59,350
然后呢，用下

210
00:09:59,350 --> 00:10:03,110
分别用 I 、 J 来表示它们的起始位置

211
00:10:03,110 --> 00:10:05,500
那比如说这是 S ，这是 T 

212
00:10:05,500 --> 00:10:11,180
那我们比较一下 SI 和我们的 T 、 J 是否相等

213
00:10:11,180 --> 00:10:13,320
唉，依次去便利

214
00:10:13,320 --> 00:10:16,760
那第一个位置不等，不等的情况下

215
00:10:16,760 --> 00:10:18,420
I 往后移吧

216
00:10:18,420 --> 00:10:19,440
I 加加

217
00:10:19,440 --> 00:10:21,320
那我们就有了，唉

218
00:10:21,320 --> 00:10:25,340
S 1与 B 与 P 0比较吧

219
00:10:25,340 --> 00:10:28,180
那相等的，相等的情况下

220
00:10:28,180 --> 00:10:31,080
I 和 J 同同时后移

221
00:10:31,080 --> 00:10:33,850
那同时后移之后

222
00:10:33,850 --> 00:10:37,960
S 2和我们的 P 一一个是 A 

223
00:10:37,960 --> 00:10:39,620
一个是 C ，相等吗

224
00:10:39,620 --> 00:10:40,720
不相等

225
00:10:40,720 --> 00:10:44,740
那模式匹配在这里就麻烦了

226
00:10:44,740 --> 00:10:48,540
因为匹配到这个位置不相等

227
00:10:48,540 --> 00:10:51,710
那我们所做的操作应该是

228
00:10:51,710 --> 00:10:55,430
前面一轮停下来的位置

229
00:10:55,430 --> 00:10:56,780
I 加加

230
00:10:56,780 --> 00:10:59,220
而 B 的 RT 当中啊

231
00:10:59,220 --> 00:11:00,860
我们的字符串

232
00:11:00,860 --> 00:11:04,980
它的下标会直接回到起始位置

233
00:11:04,980 --> 00:11:08,160
大家呢，重新用 A 比较 B 

234
00:11:08,160 --> 00:11:11,420
然后呢，唉，再用 B 来比较 B 

235
00:11:11,420 --> 00:11:13,560
那这个过程因为啊

236
00:11:13,560 --> 00:11:16,160
如果字符串过长的时候

237
00:11:16,160 --> 00:11:19,490
这种匹配会非常耗费时间

238
00:11:19,490 --> 00:11:24,260
所以后面呢，我们会出现改进的模式匹配算法

239
00:11:24,260 --> 00:11:27,620
也就是非常出名的 k mp 算法

240
00:11:27,940 --> 00:11:29,980
那我们了解到

241
00:11:29,980 --> 00:11:32,000
朴素的模式匹配

242
00:11:32,000 --> 00:11:33,730
如果匹配失败

243
00:11:33,730 --> 00:11:35,850
我们的模式串下标呢

244
00:11:35,850 --> 00:11:38,290
会回到起始位置

245
00:11:38,290 --> 00:11:42,730
主串下标会回到我们当前这一轮

246
00:11:42,730 --> 00:11:45,490
比较位置的下一个位置

247
00:11:45,490 --> 00:11:48,630
那改进的模式匹配算法

248
00:11:48,630 --> 00:11:53,350
在这里其实不要求大家去掌握它的原理

249
00:11:53,350 --> 00:11:57,900
因为 k mp 算法它本身的话是我们的啊

250
00:11:57,900 --> 00:11:59,520
这样的一些人员啊

251
00:11:59,520 --> 00:12:01,720
技术人员去做的一些研究

252
00:12:01,720 --> 00:12:03,520
把它呢找出来一种呢

253
00:12:03,520 --> 00:12:05,100
方便的计算方法

254
00:12:05,100 --> 00:12:09,680
那这种改进之处啊，在于匹配，诶

255
00:12:09,680 --> 00:12:11,390
没有匹配上的时候

256
00:12:11,390 --> 00:12:15,260
不需要呢退回我们的起始位置

257
00:12:15,260 --> 00:12:18,250
而是呢，唉，做部分匹配

258
00:12:18,250 --> 00:12:21,700
那部分匹配到底退回到哪里呢

259
00:12:21,700 --> 00:12:22,980
唉，我们就要呢

260
00:12:22,980 --> 00:12:25,880
将每一轮的返回位

261
00:12:25,880 --> 00:12:28,000
先给它呢计算出来

262
00:12:28,000 --> 00:12:30,870
所以在 k mp 算法当中

263
00:12:30,870 --> 00:12:36,630
它的返回位置会依据模式串的 next 函数值

264
00:12:36,630 --> 00:12:38,380
来进行实现

265
00:12:38,380 --> 00:12:41,050
那我们知道，我们要知道呢

266
00:12:41,050 --> 00:12:43,330
有这样的一个数值

267
00:12:43,330 --> 00:12:44,230
哎，我们用

268
00:12:44,230 --> 00:12:46,300
net 数组来记录

269
00:12:46,300 --> 00:12:50,020
如果模式串长度为二的话

270
00:12:50,020 --> 00:12:51,820
它的这个数组啊

271
00:12:51,820 --> 00:12:54,380
长度也是为二的

272
00:12:54,380 --> 00:12:56,130
长度与

273
00:12:57,920 --> 00:13:00,640
模式串长度一致

274
00:13:04,200 --> 00:13:05,380
也就是说

275
00:13:05,380 --> 00:13:10,730
我们求的是模式串每一个位置的返回值

276
00:13:10,730 --> 00:13:16,410
那它的返回值在求取之后记录到数组当中

277
00:13:16,410 --> 00:13:17,910
什么时候用呢

278
00:13:17,910 --> 00:13:20,360
唉，匹配不完全的时候

279
00:13:20,360 --> 00:13:25,800
当我们的 SI 与 TJ 不相等的情况下

280
00:13:25,800 --> 00:13:29,860
那我们的 J 它会呢返回到 nex

281
00:13:29,860 --> 00:13:34,160
接与我们之前的这种返回不一样

282
00:13:34,160 --> 00:13:36,320
它不会回到起始位置

283
00:13:36,320 --> 00:13:40,340
而是呢，回到数组对应的记录位置上去

284
00:13:40,340 --> 00:13:41,790
那这是我们呢

285
00:13:41,790 --> 00:13:43,550
做模式匹配当中

286
00:13:43,550 --> 00:13:46,530
k mp 算法最核心的一个地方

287
00:13:46,530 --> 00:13:50,860
我们不要求大家掌握所有的理论部分

288
00:13:50,860 --> 00:13:54,010
但是它的这种返回特殊点呢

289
00:13:54,010 --> 00:13:56,460
是需要大家去记住的

290
00:13:56,460 --> 00:14:00,160
那具体内测数组怎么来求呢

291
00:14:00,160 --> 00:14:02,760
其实在不同的，呃

292
00:14:02,760 --> 00:14:06,050
人在不同的出卷老师出题的时候

293
00:14:06,050 --> 00:14:09,250
他给出的表达式可能会有一些区别

294
00:14:09,250 --> 00:14:11,560
那我们在这里主要呢

295
00:14:11,560 --> 00:14:13,300
会带大家看一看

296
00:14:13,300 --> 00:14:16,710
这种表达式是如何来分析的

297
00:14:16,710 --> 00:14:19,780
那这里在我们考试当中啊

298
00:14:19,780 --> 00:14:22,390
模式匹配一旦考到的话

299
00:14:22,390 --> 00:14:23,300
上午

300
00:14:23,300 --> 00:14:27,160
还有呢，我们的算法设计题都有可能出现

301
00:14:27,160 --> 00:14:31,190
但它出现的频次并不是呢特别高

302
00:14:31,190 --> 00:14:35,110
那建议大家呢，还是尽量自己动手算一算

303
00:14:35,110 --> 00:14:37,910
掌握一下他的这种思想

304
00:14:38,440 --> 00:14:42,850
下面我们看到 let 函数它的定义过程

305
00:14:42,850 --> 00:14:46,550
那我们整个求的是一个递归式

306
00:14:46,550 --> 00:14:49,620
这是它的数组定义的部分吧

307
00:14:49,620 --> 00:14:52,910
J 是我们数组的下标变量

308
00:14:52,910 --> 00:14:55,490
那 J 等于一的时候

309
00:14:55,490 --> 00:14:57,450
下标从一开始了

310
00:14:57,450 --> 00:14:59,140
它等于一的时候

311
00:14:59,140 --> 00:15:01,760
取值返回的是零

312
00:15:01,760 --> 00:15:04,710
那它不等于一的情况下

313
00:15:04,710 --> 00:15:06,230
那其他情况的时候

314
00:15:06,230 --> 00:15:07,310
我们要计

315
00:15:07,310 --> 00:15:09,520
计算什么样的数值呢

316
00:15:09,520 --> 00:15:13,380
我们要返回一个 max 最大值

317
00:15:13,380 --> 00:15:15,880
最大的 K 值

318
00:15:15,920 --> 00:15:19,320
所以 K 是我们返回的目标

319
00:15:19,320 --> 00:15:22,500
那这个 K 要满足的条件

320
00:15:22,500 --> 00:15:24,570
如后面所示

321
00:15:24,570 --> 00:15:28,390
K 是需要在一和 J 之间的

322
00:15:28,390 --> 00:15:30,410
那我们刚刚 J 等于一吧

323
00:15:30,410 --> 00:15:33,240
所以我们要依次去分析

324
00:15:33,240 --> 00:15:36,420
J 等于一的时候值等于零

325
00:15:36,420 --> 00:15:38,460
J 等于二的时候

326
00:15:38,460 --> 00:15:42,520
哎， K 应该是等于一到 J 之间

327
00:15:42,520 --> 00:15:44,900
哎，1~2之间有没有数字啊

328
00:15:44,900 --> 00:15:46,040
没有数字

329
00:15:46,040 --> 00:15:47,160
那怎么办

330
00:15:47,160 --> 00:15:48,460
不符合条件

331
00:15:48,460 --> 00:15:51,000
它是属于其他情况

332
00:15:51,000 --> 00:15:53,980
返回值等于一

333
00:15:55,520 --> 00:15:58,800
那 J 等于三的时候

334
00:16:00,040 --> 00:16:04,300
K 可能存在的值在1~3之间吧

335
00:16:04,300 --> 00:16:06,960
那 K 可能取值

336
00:16:08,090 --> 00:16:10,450
是等于二的

337
00:16:11,490 --> 00:16:14,730
那这个二满不满足要求呢

338
00:16:14,730 --> 00:16:16,760
我们需要验证一下

339
00:16:16,760 --> 00:16:21,570
那后面给的是它的前缀和后缀的比较

340
00:16:21,570 --> 00:16:23,960
前缀是从 P 1

341
00:16:23,960 --> 00:16:27,170
也就是第一个字符 A 开始

342
00:16:27,170 --> 00:16:28,990
到哪里结束呢

343
00:16:28,990 --> 00:16:34,140
L 表示的是省略号到 K 减一结束

344
00:16:34,140 --> 00:16:36,180
K 等于二的情况下

345
00:16:36,180 --> 00:16:38,140
也就是到 P 1结束吧

346
00:16:38,140 --> 00:16:41,280
所以左侧只有一个字符

347
00:16:41,280 --> 00:16:48,000
也就是 A 右侧从接减 K 加一开始到哪里结束

348
00:16:48,000 --> 00:16:50,140
到接减一结束

349
00:16:50,140 --> 00:16:53,820
所以它是到呢，也是到我们的，呃

350
00:16:53,820 --> 00:16:55,780
应该是呢2-1结束

351
00:16:55,780 --> 00:16:57,600
也就是到一的位置

352
00:16:57,600 --> 00:17:00,110
那这里也是呢， P 1吧

353
00:17:00,110 --> 00:17:02,290
那我们在这里要注意啊

354
00:17:02,290 --> 00:17:05,980
匹配的时候 L 看作省略号

355
00:17:05,980 --> 00:17:10,859
把相应的前缀和后缀找出来进行比较

356
00:17:10,859 --> 00:17:12,569
如果相等

357
00:17:12,569 --> 00:17:15,290
说明这是符合条件的 K 

358
00:17:15,290 --> 00:17:18,920
但是在接越来越大的情况下

359
00:17:18,920 --> 00:17:21,020
K 的取值可能有多个

360
00:17:21,020 --> 00:17:24,720
那我们将满足条件的 K 找出来

361
00:17:24,720 --> 00:17:29,450
返回其中最大的作为 list 接的取值

362
00:17:29,450 --> 00:17:32,110
如果没有符合条件的 K 

363
00:17:32,110 --> 00:17:35,490
它就是呢其他情况返回一

364
00:17:35,490 --> 00:17:38,480
那这是我们给大家讲到的关于

365
00:17:38,480 --> 00:17:41,700
net 数组这个表达式它的含义

366
00:17:41,700 --> 00:17:44,880
下面呢，我们看一个简单的例子

367
00:17:44,880 --> 00:17:46,880
来看一看这个呢

368
00:17:46,880 --> 00:17:50,560
哎 let 数组它的求取过程

369
00:17:51,360 --> 00:17:54,900
大家可以暂停一下我们的视

370
00:17:54,900 --> 00:17:55,620
自己呢

371
00:17:55,620 --> 00:17:58,080
来验证一下这道题

372
00:17:58,190 --> 00:18:00,010
那我们看到呢

373
00:18:00,010 --> 00:18:03,760
在字符串 KMP 模式匹配算法当中啊

374
00:18:03,760 --> 00:18:06,680
需要先求解 let 函数值

375
00:18:06,680 --> 00:18:08,680
那它的定义如下

376
00:18:08,680 --> 00:18:11,970
皆表示模式串中字符的序号

377
00:18:11,970 --> 00:18:13,150
从一开始

378
00:18:13,150 --> 00:18:16,220
若模式串是 A 、 B 、 A 、 A 、 C 

379
00:18:16,220 --> 00:18:19,360
它的函数值是多少呢

380
00:18:19,360 --> 00:18:22,780
我们可以画出一个数组

381
00:18:22,780 --> 00:18:29,330
那这个数组它的下标分别是一、二、三、四、五

382
00:18:29,330 --> 00:18:33,490
哎，应该是一、二、三、四、五

383
00:18:33,490 --> 00:18:37,640
然后它的取值从一开始

384
00:18:37,640 --> 00:18:41,240
next 数组等于一的情况下

385
00:18:41,240 --> 00:18:43,180
它的取值是多少啊

386
00:18:43,180 --> 00:18:44,420
已经知道了

387
00:18:44,420 --> 00:18:45,530
等于零吧

388
00:18:45,530 --> 00:18:48,490
let 数组皆等于二的时候

389
00:18:48,490 --> 00:18:52,750
诶，1~2之间没有满足要求的 K 存在

390
00:18:52,750 --> 00:18:54,600
属于其他情况

391
00:18:54,600 --> 00:18:57,040
取值是等于一的

392
00:18:57,040 --> 00:18:59,320
那我们重点来看的是

393
00:18:59,320 --> 00:19:01,810
J 等于三的时候

394
00:19:01,810 --> 00:19:08,090
K 在一和三之间满足要求的应该是等于二

395
00:19:08,090 --> 00:19:11,570
那么 P 1 P 2

396
00:19:11,570 --> 00:19:15,660
L 是省略号到 P 的 K 减一

397
00:19:15,660 --> 00:19:18,650
它的值就是 P 1

398
00:19:18,650 --> 00:19:22,500
那 P 1是第一个元素，诶

399
00:19:22,500 --> 00:19:24,620
字符它是等于 A 的

400
00:19:24,620 --> 00:19:29,920
那右侧部分 P 的接减 K 加一

401
00:19:30,020 --> 00:19:34,060
那也就是3-2加一

402
00:19:34,060 --> 00:19:38,330
它应该呢是 P 2开始到哪里结束

403
00:19:38,330 --> 00:19:40,360
到接减一结束

404
00:19:40,360 --> 00:19:42,020
就是等于 P 2吧

405
00:19:42,020 --> 00:19:46,120
那 P 2的位置应该是等于 B 的

406
00:19:46,120 --> 00:19:48,420
A 和 B 是否相等

407
00:19:48,420 --> 00:19:49,700
不相等吧

408
00:19:49,700 --> 00:19:51,320
A 和 B 不等

409
00:19:51,320 --> 00:19:53,540
所以 K 不满足条件

410
00:19:53,540 --> 00:19:56,830
它仍然是属于其他情况

411
00:19:56,830 --> 00:19:59,840
结果应该是等于一的

412
00:19:59,840 --> 00:20:02,610
所以这里啊，应该是011

413
00:20:02,610 --> 00:20:05,440
那我们看到011之后

414
00:20:05,440 --> 00:20:08,340
C 和 A 已经排除掉了

415
00:20:08,340 --> 00:20:11,400
还剩 B 和 D 来验证一下

416
00:20:11,400 --> 00:20:15,010
那我们再来看当阶等于四的时候

417
00:20:15,010 --> 00:20:19,110
满足1~4之间的 K 有几个啊

418
00:20:19,110 --> 00:20:23,490
有两个 K 是可以等于二

419
00:20:23,490 --> 00:20:25,870
也可以等于三的

420
00:20:25,870 --> 00:20:28,630
所以我们接下来可以验证一下

421
00:20:28,630 --> 00:20:32,510
等于二的情况和等于三的情况

422
00:20:32,660 --> 00:20:35,320
K 等于二的情况下

423
00:20:35,320 --> 00:20:38,360
那左侧是到 K 2-1

424
00:20:38,360 --> 00:20:40,310
也就是到 P 1结束吧

425
00:20:40,310 --> 00:20:43,920
它是等于 A 的右侧，哎

426
00:20:43,920 --> 00:20:45,640
到阶减一结束

427
00:20:45,640 --> 00:20:48,780
他应该呢是等于三的

428
00:20:48,860 --> 00:20:50,980
P 3等于 A 

429
00:20:50,980 --> 00:20:54,860
此时 A 和 A 相等满足要求

430
00:20:54,860 --> 00:20:56,100
那这里呢

431
00:20:56,100 --> 00:20:59,040
哎， K 等于二是满足要求的

432
00:20:59,040 --> 00:21:02,130
K 等于三是否满足要求呢

433
00:21:02,130 --> 00:21:04,110
K 等于三的时候

434
00:21:04,110 --> 00:21:06,930
它是 P 1到 P 2结束

435
00:21:06,930 --> 00:21:12,280
等于 ab 右侧是4-3加一

436
00:21:12,280 --> 00:21:15,890
从 P 2开始到 P 3结束

437
00:21:15,890 --> 00:21:20,000
A 23是等于 BA 的不满足要求吧

438
00:21:20,000 --> 00:21:24,210
那此时满足要求的只有一个 K 

439
00:21:24,210 --> 00:21:25,970
那自己就是最大值

440
00:21:25,970 --> 00:21:28,350
所以返回值是二

441
00:21:28,350 --> 00:21:32,660
那此时第四个位置的取值是等于二的

442
00:21:32,660 --> 00:21:36,370
所以这道题啊，选择的是 B 选项

443
00:21:36,370 --> 00:21:41,550
那我们在这里看到比较 A 等于 A 的情况下

444
00:21:41,550 --> 00:21:46,600
唉，我们其实是判断场长度为 K 的时候

445
00:21:46,600 --> 00:21:50,240
它的这种前缀和后缀关系

446
00:21:50,240 --> 00:21:53,990
那我们来看一下前缀和后缀的定义

447
00:21:53,990 --> 00:21:57,950
对于一个字符串 ABA 来看的话

448
00:21:57,950 --> 00:22:00,280
三个长度的字符

449
00:22:00,280 --> 00:22:01,780
它的前缀

450
00:22:01,780 --> 00:22:05,300
哎，可以长度为一的前缀是一

451
00:22:05,300 --> 00:22:07,960
后缀是前缀是 A 

452
00:22:07,960 --> 00:22:09,420
后缀是 A 

453
00:22:09,420 --> 00:22:12,820
那长度为二的前缀呢

454
00:22:12,820 --> 00:22:14,110
唉，有 A ， B 

455
00:22:14,110 --> 00:22:16,300
后缀呢有 BA 

456
00:22:16,300 --> 00:22:21,570
这就是它的前缀和后缀的一个简单的定义

457
00:22:21,570 --> 00:22:25,980
那我们在内测数组当中获取前缀和后缀

458
00:22:25,980 --> 00:22:27,900
有什么样的含义呢

459
00:22:27,900 --> 00:22:31,160
其实就是我们在递归式当中

460
00:22:31,160 --> 00:22:33,240
中间的这一部分

461
00:22:33,240 --> 00:22:38,010
那首先当我们的 J 等于零的时候

462
00:22:38,010 --> 00:22:39,810
唉， J 等于一的时候

463
00:22:39,810 --> 00:22:41,860
这是我们起始位置吧

464
00:22:41,860 --> 00:22:45,530
起始位置它已经告诉我们定义值是零了

465
00:22:45,530 --> 00:22:47,450
J 等于二的时候

466
00:22:47,450 --> 00:22:51,450
唉，我们在这里是没有符合要求的

467
00:22:51,450 --> 00:22:53,630
这种 K 的存在

468
00:22:53,630 --> 00:22:56,430
也就是说呢，属于其他情况

469
00:22:56,430 --> 00:22:58,350
结果是等于一的

470
00:22:58,350 --> 00:23:00,940
那 J 等于三的时候

471
00:23:00,940 --> 00:23:04,160
满足条件的 K 它是等于二的

472
00:23:04,160 --> 00:23:06,390
那此时我们要找

473
00:23:06,390 --> 00:23:09,220
就是找字符串当

474
00:23:09,220 --> 00:23:11,560
长度为二的子串

475
00:23:11,560 --> 00:23:12,700
它的这个呢

476
00:23:12,700 --> 00:23:14,450
前缀和后缀

477
00:23:14,450 --> 00:23:16,880
那它的长度为二

478
00:23:16,880 --> 00:23:19,490
对应的就是我们前面的 ab 

479
00:23:19,490 --> 00:23:21,530
那这个 A 、 B 子串啊

480
00:23:21,530 --> 00:23:22,550
可以找一找

481
00:23:22,550 --> 00:23:24,110
它的前缀是 A 

482
00:23:24,110 --> 00:23:25,530
后缀是 B 吧

483
00:23:25,530 --> 00:23:27,850
有没有其他满足要求的

484
00:23:27,850 --> 00:23:28,800
没有了

485
00:23:28,800 --> 00:23:31,000
那没有其他的前缀和后缀了

486
00:23:31,000 --> 00:23:32,940
那我们的表达式当中，唉

487
00:23:32,940 --> 00:23:35,160
前缀和后缀不相等

488
00:23:35,160 --> 00:23:37,550
说明属于其他情况吧

489
00:23:37,550 --> 00:23:41,380
填写的 net 数组值就是等于一的

490
00:23:41,380 --> 00:23:44,280
那 J 等于四的情况下

491
00:23:44,280 --> 00:23:46,090
K 等于二

492
00:23:46,090 --> 00:23:47,810
那他找的，诶

493
00:23:47,810 --> 00:23:49,390
可以有 K 等于二

494
00:23:49,390 --> 00:23:50,610
K 等于三吧

495
00:23:50,610 --> 00:23:55,560
它所针对的其实是我们的数组当中啊

496
00:23:55,560 --> 00:23:57,470
我们的字符串当

497
00:23:57,470 --> 00:24:00,700
前面的字符前缀 A 、 B 、 A 

498
00:24:00,700 --> 00:24:03,610
那这个前缀 A 、 B 、 A 

499
00:24:03,610 --> 00:24:05,510
它的前缀有哪些呢

500
00:24:05,510 --> 00:24:08,550
长度为一的，哎，它就是 A 

501
00:24:08,550 --> 00:24:11,260
那此时其实就是 K 等于二吧

502
00:24:11,260 --> 00:24:15,740
此时满足长度的只有长度为一

503
00:24:15,740 --> 00:24:21,470
那满足长度为二的是 ab 和 BA 显然不相等

504
00:24:21,470 --> 00:24:24,120
K 等于三的时候是不相等的

505
00:24:24,120 --> 00:24:28,950
所以此时符合要求的 K 值是等于二的

506
00:24:28,950 --> 00:24:30,230
那此时呢

507
00:24:30,230 --> 00:24:33,990
唉，就是我们 next 数组返回的值

508
00:24:33,990 --> 00:24:36,480
那再来看第五个数值

509
00:24:36,480 --> 00:24:39,440
A 的时候它是呢， A 、 B 、 A 、 A 

510
00:24:40,530 --> 00:24:42,730
这个 A 、 B 、 A 、 A 啊

511
00:24:42,730 --> 00:24:46,600
我们可以看到前前缀为一的情况下

512
00:24:46,600 --> 00:24:48,260
哎，它可以得到呢

513
00:24:48,260 --> 00:24:50,880
前缀 A 后缀 A 相等吧

514
00:24:50,880 --> 00:24:53,820
所以 K 等于二满足要求

515
00:24:53,820 --> 00:24:55,440
K 等于三的话

516
00:24:55,440 --> 00:24:58,740
前缀 ab 后缀 AA 不满足

517
00:24:58,740 --> 00:25:00,550
K 等于四的话

518
00:25:00,550 --> 00:25:04,660
前缀 ABA 后缀 BAAA 不满足

519
00:25:04,660 --> 00:25:09,280
所以满足要求的 K 最大值是等于二的

520
00:25:09,280 --> 00:25:13,780
我们在这里看到的 P 12到 K

521
00:25:13,780 --> 00:25:14,580
K 减一

522
00:25:14,580 --> 00:25:19,080
其实就是查找它的前缀和后缀的过程

523
00:25:19,080 --> 00:25:22,950
那关于我们前面分析的 J 的取值

524
00:25:22,950 --> 00:25:24,810
和数组的对应关系

525
00:25:24,810 --> 00:25:27,340
大家也可以自己呢再验证一下

526
00:25:27,340 --> 00:25:29,260
从公式来分析

527
00:25:29,260 --> 00:25:31,460
那假设这是一式

528
00:25:31,460 --> 00:25:32,900
这是二式

529
00:25:32,900 --> 00:25:34,860
这是呢，三式

530
00:25:36,250 --> 00:25:38,670
当 J 等于一的时候

531
00:25:38,670 --> 00:25:40,330
left 1等于零

532
00:25:40,330 --> 00:25:41,900
J 等于二的时候

533
00:25:41,900 --> 00:25:43,300
由第二个表达

534
00:25:43,300 --> 00:25:46,470
我们要查找满足要求的 K 

535
00:25:46,470 --> 00:25:48,400
那此时不存在

536
00:25:48,400 --> 00:25:50,000
所以返回值呢

537
00:25:50,000 --> 00:25:53,520
也是等于其他情况一的

538
00:25:53,520 --> 00:25:56,120
那就根据三来进行返回了

539
00:25:56,120 --> 00:26:00,670
然后呢，再来看相应的这个取值过程

540
00:26:00,670 --> 00:26:02,860
J 等于12345

541
00:26:02,860 --> 00:26:04,480
12345的时候

542
00:26:04,480 --> 00:26:06,670
它的具体分析过程

543
00:26:06,670 --> 00:26:09,680
自己啊，一定要代入验证一下

544
00:26:09,680 --> 00:26:13,530
这是我们说到的 list 数组，它的求取

545
00:26:13,530 --> 00:26:14,070
呃

546
00:26:14,070 --> 00:26:16,730
这里呢，相对来说是字符串当中

547
00:26:16,730 --> 00:26:18,950
最复杂的一个应用呢

548
00:26:18,950 --> 00:26:21,330
那我们下面呢，看到字符串啊

549
00:26:21,330 --> 00:26:24,790
这一部分在我们软件设计师考试真题当中

550
00:26:24,790 --> 00:26:26,930
近十次的考试当中啊

551
00:26:26,930 --> 00:26:28,510
出现的考察题型

552
00:26:28,510 --> 00:26:30,110
那告诉我们呢

553
00:26:30,110 --> 00:26:33,880
假设 S 是一个长度为 N 的非空字符串

554
00:26:33,880 --> 00:26:36,060
其中字符各不相同

555
00:26:36,060 --> 00:26:38,770
互译非平凡子串是什么

556
00:26:38,770 --> 00:26:41,320
那我们现在看到的

557
00:26:41,320 --> 00:26:43,660
其实什么是非平凡子串呢

558
00:26:43,660 --> 00:26:44,700
唉，我们不知道

559
00:26:44,700 --> 00:26:47,240
但是后面解释了一下，非空

560
00:26:47,240 --> 00:26:49,890
并且不同于 S 本身

561
00:26:49,890 --> 00:26:51,830
那这个个数验证啊

562
00:26:51,830 --> 00:26:54,270
有一个非常快捷的方式，诶

563
00:26:54,270 --> 00:26:56,010
代入实例来验证

564
00:26:56,010 --> 00:26:58,820
对于一个字符串 A 来说

565
00:26:58,820 --> 00:27:00,790
它是不是字符串呢

566
00:27:00,790 --> 00:27:02,270
唉，肯定是

567
00:27:02,270 --> 00:27:06,950
那它的非平凡子串首先不能为空吧

568
00:27:06,950 --> 00:27:08,830
然后不能为 A 

569
00:27:08,830 --> 00:27:10,780
还有没有其他情况呢

570
00:27:10,780 --> 00:27:12,620
没有其他情况呢

571
00:27:12,620 --> 00:27:16,850
所以非平凡子串是不存在的

572
00:27:16,850 --> 00:27:20,360
差个数呢，应该是等于零的吧

573
00:27:20,360 --> 00:27:22,560
那我们代入验证一下

574
00:27:22,560 --> 00:27:25,260
长度 N 等于一的时候

575
00:27:25,260 --> 00:27:26,930
个数等于零

576
00:27:26,930 --> 00:27:29,210
满足要求的是谁呀

577
00:27:29,210 --> 00:27:30,510
这里等于一

578
00:27:30,510 --> 00:27:31,850
这里等于一

579
00:27:31,850 --> 00:27:34,370
这里是等于，唉

580
00:27:34,370 --> 00:27:36,030
也是等于一的

581
00:27:36,030 --> 00:27:38,090
那这里代入之后

582
00:27:38,090 --> 00:27:39,700
结果才是零吧

583
00:27:39,700 --> 00:27:43,720
所以满足要求的只有 D 选项

584
00:27:43,720 --> 00:27:45,390
那我们也可以呢

585
00:27:45,390 --> 00:27:49,180
用其他长度代入来进行验证

586
00:27:49,180 --> 00:27:52,130
这一类问题啊，其实从定义去考虑

587
00:27:52,130 --> 00:27:53,760
大家很容易混淆

588
00:27:53,760 --> 00:27:57,180
但是呢，找一个实际存在的字符串

589
00:27:57,180 --> 00:27:59,340
然后去验证一下

590
00:27:59,340 --> 00:28:01,730
还是呢，相对简单一些

591
00:28:01,730 --> 00:28:04,860
那这些呢，就是要求大家掌握到的

592
00:28:04,860 --> 00:28:07,180
关于字符串它的内容
