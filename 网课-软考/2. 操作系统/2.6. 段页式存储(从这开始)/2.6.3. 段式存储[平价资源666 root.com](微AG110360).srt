1
00:00:00,000 --> 00:00:02,240
下面我们展开来看一下

2
00:00:02,240 --> 00:00:04,960
段页式存储当中的段式存储

3
00:00:04,960 --> 00:00:08,370
段式存储呢，在软件设计师考试当中

4
00:00:08,370 --> 00:00:10,440
近几年考的并不多

5
00:00:10,440 --> 00:00:13,450
我们主要呢，了解一下它的形式

6
00:00:13,450 --> 00:00:16,460
以及呢，在断式存储过程当中

7
00:00:16,460 --> 00:00:18,450
涉及到的逻辑地址啊

8
00:00:18,450 --> 00:00:20,590
它的合法段地址的判断

9
00:00:20,590 --> 00:00:23,980
那为什么要有段式存储的方式啊

10
00:00:23,980 --> 00:00:26,190
我们在讲页式存储的时候

11
00:00:26,190 --> 00:00:31,120
它将程序是划分成相同页面的大小

12
00:00:31,120 --> 00:00:33,070
那我们想一想，唉

13
00:00:33,070 --> 00:00:34,810
在这个划分的过程当中

14
00:00:34,810 --> 00:00:36,870
会不会恰好把 for 循环

15
00:00:36,870 --> 00:00:39,440
它的条件放在了上一个页面

16
00:00:39,440 --> 00:00:42,050
循环体放在了下一个页面呢

17
00:00:42,050 --> 00:00:43,790
那这种拆分啊

18
00:00:43,790 --> 00:00:47,840
很有可能会将用户程序的逻辑呢，分开

19
00:00:47,840 --> 00:00:50,480
那这种拆分的过程当中呢

20
00:00:50,480 --> 00:00:53,940
如果我们要调用某一个页面

21
00:00:53,940 --> 00:00:56,360
那也许它的下一个页面，诶

22
00:00:56,360 --> 00:00:57,800
被我们淘汰掉了

23
00:00:57,800 --> 00:00:59,630
这种重复的调用啊

24
00:00:59,630 --> 00:01:01,840
很有可能会碰到

25
00:01:01,840 --> 00:01:04,400
有一些页面的逻辑上是连续

26
00:01:04,400 --> 00:01:07,560
但掉入的过程当中又是分散的

27
00:01:07,560 --> 00:01:11,100
那怎么解决这种逻辑上，哎，连续

28
00:01:11,100 --> 00:01:13,180
然后调用分散的问题呢

29
00:01:13,180 --> 00:01:17,440
那我们按照逻辑完整的顺序来进行调用

30
00:01:17,440 --> 00:01:18,550
就可以了

31
00:01:18,550 --> 00:01:20,940
什么样的逻辑是完整的呢

32
00:01:20,940 --> 00:01:25,120
我们会根据啊，程序本身它的逻辑来划分

33
00:01:25,120 --> 00:01:29,360
那每一个完整的逻辑给它呢，划分成一个段

34
00:01:29,360 --> 00:01:32,020
就形成了段式调用

35
00:01:32,170 --> 00:01:34,690
段式存储的过程当中啊

36
00:01:34,690 --> 00:01:38,980
将用户程序按自然段来进行划分逻辑空间

37
00:01:38,980 --> 00:01:40,710
这个自然段就是呢

38
00:01:40,710 --> 00:01:43,070
逻辑完整的一个部分

39
00:01:43,070 --> 00:01:47,260
那我们呢，按照这种段的形式来调入内存

40
00:01:47,260 --> 00:01:51,330
段的长度是可长可短不一致的

41
00:01:51,330 --> 00:01:53,690
它不需要相同大小了

42
00:01:53,690 --> 00:01:55,480
那在这个过程当中

43
00:01:55,480 --> 00:01:57,980
我们对于一个用户程序的话

44
00:01:57,980 --> 00:01:59,500
我们可以将它呢

45
00:01:59,500 --> 00:02:03,070
哎，比如说主函数划分一个空间变量

46
00:02:03,070 --> 00:02:06,060
划分成一些呢其他的空间

47
00:02:06,060 --> 00:02:08,880
那在划分的过程当中

48
00:02:08,880 --> 00:02:11,760
我们用来区分的不叫页号了

49
00:02:11,760 --> 00:02:13,600
叫做呢段号

50
00:02:13,600 --> 00:02:18,030
那按段调入到内存空间的时候

51
00:02:18,030 --> 00:02:21,530
我们会发现它的大小不一致

52
00:02:21,530 --> 00:02:24,170
起始位置就比较随缘了

53
00:02:24,170 --> 00:02:25,150
怎么办呢

54
00:02:25,150 --> 00:02:28,060
将起始位置记录下来

55
00:02:28,060 --> 00:02:30,750
我们叫做呢段的机制

56
00:02:30,750 --> 00:02:35,170
那依次在记录相应所需的长度

57
00:02:35,170 --> 00:02:36,500
也就是断肠

58
00:02:36,500 --> 00:02:38,860
对于0号段，唉

59
00:02:38,860 --> 00:02:41,980
它的基质是40 K 的位置

60
00:02:41,980 --> 00:02:45,730
再加上段长30 K 的空间

61
00:02:45,730 --> 00:02:49,670
那这一部分呢，都是分给了0号端

62
00:02:49,670 --> 00:02:53,910
同理，一号段从80 K 位置开始

63
00:02:53,910 --> 00:02:59,250
那这里呢，到20 K 的空间都分给一号段了

64
00:02:59,250 --> 00:03:03,190
那这就是呢段式它的一个呢分配过程

65
00:03:03,190 --> 00:03:06,920
这个记录的内容呢，我们叫做断表

66
00:03:06,920 --> 00:03:08,860
对于这一部分啊

67
00:03:08,860 --> 00:03:10,530
我们呢可以

68
00:03:10,530 --> 00:03:14,080
诶，直接标注用户程序

69
00:03:14,080 --> 00:03:17,750
它的段号和段内的偏移量

70
00:03:17,750 --> 00:03:20,970
这种呢，就叫做段的逻辑地址

71
00:03:20,970 --> 00:03:24,110
那段的逻辑地址

72
00:03:27,900 --> 00:03:29,540
我们可以呢

73
00:03:29,540 --> 00:03:31,420
分为段号

74
00:03:32,750 --> 00:03:36,150
以及段内偏移量

75
00:03:42,030 --> 00:03:43,210
比如说呢

76
00:03:43,210 --> 00:03:46,740
大家在小时候是不是上小学经常做啊

77
00:03:46,740 --> 00:03:47,540
阅读理解

78
00:03:47,540 --> 00:03:49,200
语文的阅读理解告诉你

79
00:03:49,200 --> 00:03:52,380
第二自然段第一行是个总体语句

80
00:03:52,380 --> 00:03:56,240
那告诉我们在第二段的位置当中

81
00:03:56,240 --> 00:03:59,740
然后呢，有一个第一行的位置

82
00:03:59,740 --> 00:04:02,800
哎，还有呢，它的结尾是一个呢

83
00:04:02,800 --> 00:04:04,260
唉，总结语句

84
00:04:04,260 --> 00:04:08,080
那我们只需要它在相应段落的位置

85
00:04:08,080 --> 00:04:09,910
就可以找到啊

86
00:04:09,910 --> 00:04:13,730
唉，首先根据它的断表找到呢

87
00:04:13,730 --> 00:04:15,490
对应的第二自然

88
00:04:15,490 --> 00:04:18,180
起始位置在120 K 

89
00:04:18,180 --> 00:04:22,650
偏移量在起始位置还是呢，在结束位置

90
00:04:22,650 --> 00:04:24,990
通过偏移量就可以找到

91
00:04:24,990 --> 00:04:28,070
它在内存当中的真正位置了吧

92
00:04:28,070 --> 00:04:30,770
那对于这种逻辑地址当中啊

93
00:04:30,770 --> 00:04:34,180
我们需要了解合法段地址的判断

94
00:04:34,180 --> 00:04:35,710
如何来判断呢

95
00:04:35,710 --> 00:04:38,490
我们要知道，针对段地址

96
00:04:38,490 --> 00:04:41,140
首先呢，可以找到它的段号

97
00:04:41,140 --> 00:04:43,670
然后呢，再来找偏移量

98
00:04:43,670 --> 00:04:46,350
那偏移量有什么样的限定

99
00:04:46,350 --> 00:04:48,370
段号有什么样的限定呢

100
00:04:48,370 --> 00:04:51,830
首先段号肯定是我们用户程序当中

101
00:04:51,830 --> 00:04:54,080
不会超过最大的段号吧

102
00:04:54,080 --> 00:04:56,280
再来看它的偏移量

103
00:04:56,280 --> 00:05:01,180
应该呢，是不会超过相应段落的段长

104
00:05:01,180 --> 00:05:04,290
比如说这个35 K 的话

105
00:05:04,290 --> 00:05:07,250
从0号 K 、0号位置诶

106
00:05:07,250 --> 00:05:09,110
0号段40 K 位置

107
00:05:09,110 --> 00:05:12,020
如果偏移量35

108
00:05:12,020 --> 00:05:14,680
它会进入这个阴影部分吧

109
00:05:14,680 --> 00:05:18,070
阴影部分是无效的数据空间

110
00:05:18,070 --> 00:05:20,680
并不是段内的合法地址了

111
00:05:20,680 --> 00:05:23,990
所以这种啊就是非法段地址

112
00:05:23,990 --> 00:05:25,670
他的判断依据

113
00:05:25,670 --> 00:05:30,970
一般是段内偏移量不能超过段长

114
00:05:35,300 --> 00:05:38,740
那断肠在哪里啊

115
00:05:38,740 --> 00:05:43,080
断肠在段表当中有记录对应段号

116
00:05:43,080 --> 00:05:45,060
它的断肠限定

117
00:05:45,060 --> 00:05:46,910
那这种方式啊

118
00:05:46,910 --> 00:05:49,430
相对来说有一定的好处

119
00:05:49,430 --> 00:05:51,490
因为呢，我们可以将

120
00:05:51,490 --> 00:05:54,780
比如说将主函数或者排序函

121
00:05:54,780 --> 00:05:55,950
作为一个呢

122
00:05:55,950 --> 00:05:58,760
诶，完整的区域来进行共享

123
00:05:58,760 --> 00:06:00,520
并且修改的时候

124
00:06:00,520 --> 00:06:03,700
是不会影响到其他区域的内容

125
00:06:03,700 --> 00:06:06,150
这是断式存储的优势

126
00:06:06,150 --> 00:06:08,480
那它不好的地方是什么呢

127
00:06:08,480 --> 00:06:11,380
哎，因为我们在这个过程当中啊

128
00:06:11,380 --> 00:06:14,690
他的空余空间是随机的

129
00:06:14,690 --> 00:06:17,450
那很可能我们接下来放的段落

130
00:06:17,450 --> 00:06:19,510
这个空间是用不上的

131
00:06:19,510 --> 00:06:20,370
不够用的

132
00:06:20,370 --> 00:06:22,660
那就形成了新的碎片

133
00:06:22,660 --> 00:06:24,140
这种碎片啊

134
00:06:24,140 --> 00:06:27,080
相对来说浪费就比较大了

135
00:06:27,080 --> 00:06:29,200
唉，整个内存的利用率呢

136
00:06:29,200 --> 00:06:31,220
也就随之降低了

137
00:06:31,220 --> 00:06:34,040
这就是呢，段式存储它的特点

138
00:06:34,040 --> 00:06:38,960
我们主要呢，了解到合法断地址他的判断过程

139
00:06:38,960 --> 00:06:41,130
下面呢，我们来看一下

140
00:06:41,130 --> 00:06:42,690
在早年的时候啊

141
00:06:42,690 --> 00:06:47,150
软件设计师考试对合法段地址的一个呢，考察

142
00:06:48,050 --> 00:06:50,470
首先设进程

143
00:06:50,470 --> 00:06:53,090
它的断表如下图所示

144
00:06:53,090 --> 00:06:58,880
那么逻辑地址 ABCD 4个选项可以转换成唉

145
00:06:58,880 --> 00:07:02,420
可以转换成对应物理地址的是谁呢

146
00:07:02,420 --> 00:07:07,480
首先看到 A 、 B 、 C 、 D 、0号段的选项

147
00:07:08,070 --> 00:07:12,590
0号段，注意看清楚谁是机制

148
00:07:12,590 --> 00:07:14,170
谁是断肠

149
00:07:14,170 --> 00:07:17,910
他的段长是不能超过600的

150
00:07:17,910 --> 00:07:22,920
所有超过600的选项都不符合要求

151
00:07:22,920 --> 00:07:26,010
再来看一号段号

152
00:07:26,130 --> 00:07:28,650
对于一号段来说

153
00:07:28,650 --> 00:07:32,780
那它的断肠是不能超过50的

154
00:07:32,780 --> 00:07:35,900
那30是满足要求的

155
00:07:35,900 --> 00:07:37,880
再来看2号段

156
00:07:37,880 --> 00:07:41,580
他的段长是不能超过100，哎

157
00:07:41,580 --> 00:07:44,140
也是满足要求的

158
00:07:44,140 --> 00:07:46,360
最后3号段

159
00:07:46,700 --> 00:07:49,060
对于3号段来说

160
00:07:49,060 --> 00:07:52,060
它的段长是不能超过呢

161
00:07:52,060 --> 00:07:57,540
段内偏移量不能超过段长2988的

162
00:07:57,540 --> 00:08:02,580
那4号段不能超过它的段长960

163
00:08:02,580 --> 00:08:07,210
所以呢，这里我们排除掉0号段

164
00:08:07,210 --> 00:08:10,090
它的一个超出的选项，诶

165
00:08:10,090 --> 00:08:12,870
有 A 和 C 都是错误选项

166
00:08:12,870 --> 00:08:16,200
然后4号段超过了96

167
00:08:16,200 --> 00:08:17,860
也是呢错误选项

168
00:08:17,860 --> 00:08:22,070
那这道题的合法段地址只有呢， B 选项

169
00:08:22,070 --> 00:08:25,570
其他选项都会造成

170
00:08:26,250 --> 00:08:29,770
逻辑地址转物理地址

171
00:08:30,130 --> 00:08:31,610
异界

172
00:08:37,080 --> 00:08:42,840
这种异界的话，会读取到一些莫名其妙的数值

173
00:08:42,840 --> 00:08:45,770
不能呢作为合法端地址

174
00:08:45,770 --> 00:08:48,850
这些呢，就是关于啊，我们段式存

175
00:08:48,850 --> 00:08:51,010
需要大家呢掌握的内容
