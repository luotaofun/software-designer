1
00:00:00,000 --> 00:00:02,640
下面我们展开来看一下

2
00:00:02,640 --> 00:00:04,200
段页式存储当中

3
00:00:04,200 --> 00:00:07,000
意识存储是什么样的方式

4
00:00:07,000 --> 00:00:08,540
那我们之前啊

5
00:00:08,540 --> 00:00:11,800
在讲 catch 主存之间调用过程的时候

6
00:00:11,800 --> 00:00:15,240
曾经提到储存和 catch 它们之间啊

7
00:00:15,240 --> 00:00:17,670
速度、容量其实也有一定的差距

8
00:00:17,670 --> 00:00:22,460
那我们会将呢， catch 和储存划分成相同大小的液

9
00:00:22,460 --> 00:00:23,540
或者叫做块

10
00:00:23,540 --> 00:00:27,510
由硬件来完成它们之间的地址映射

11
00:00:27,510 --> 00:00:30,940
那在外存与内存当中的时候呢

12
00:00:30,940 --> 00:00:32,860
我们啊也会呢

13
00:00:32,860 --> 00:00:34,900
将程序和储存

14
00:00:34,900 --> 00:00:37,420
划分成相同大小的页面

15
00:00:37,420 --> 00:00:41,390
那这个页面呢，我们一般称之为液或者块

16
00:00:41,390 --> 00:00:42,950
诶，为什么要画页面

17
00:00:42,950 --> 00:00:44,540
之前我们也提到过

18
00:00:44,540 --> 00:00:46,570
因为对于这种啊

19
00:00:46,570 --> 00:00:47,990
较小单位的

20
00:00:47,990 --> 00:00:52,920
比如说比特位、字、节字这种存储单元去查找的话

21
00:00:52,920 --> 00:00:55,830
对于整个系统文件较大的时候

22
00:00:55,830 --> 00:00:57,260
是很大的一个啊

23
00:00:57,260 --> 00:00:58,790
耗费资源的过程

24
00:00:58,790 --> 00:01:01,810
那我们干脆呢，就以一块一块的数据

25
00:01:01,810 --> 00:01:06,510
也就相当于在输这种页面的性质上啊

26
00:01:06,510 --> 00:01:08,270
去进行理解了

27
00:01:08,270 --> 00:01:09,680
那我们每一次呢

28
00:01:09,680 --> 00:01:11,700
查找到在第几个页面

29
00:01:11,700 --> 00:01:15,510
从而呢，再去细究其中的页内地址

30
00:01:15,510 --> 00:01:18,560
那对于页式存储而言呢

31
00:01:18,560 --> 00:01:21,520
它也是将程序和内存划分成

32
00:01:21,520 --> 00:01:23,140
相同大小的液和块

33
00:01:23,140 --> 00:01:26,100
以页为单位来进行调用

34
00:01:26,100 --> 00:01:28,440
这个过程不再是硬件完成

35
00:01:28,440 --> 00:01:30,940
由操作系统来进行处理

36
00:01:30,940 --> 00:01:36,340
首先将用户程序划分成固定大小的页面

37
00:01:36,340 --> 00:01:42,050
然后呢，内存也划分成它们相同大小的页面

38
00:01:42,050 --> 00:01:45,470
那我们的用户程序啊，划分之后

39
00:01:45,470 --> 00:01:48,510
这里呢，哎，我们叫做逻辑页

40
00:01:48,510 --> 00:01:50,970
那这里呢，叫做物理页

41
00:01:50,970 --> 00:01:53,890
对于逻辑页和物理页之间

42
00:01:53,890 --> 00:01:55,830
它的调用过程啊

43
00:01:55,830 --> 00:01:56,690
没有呢

44
00:01:56,690 --> 00:01:59,100
诶，直接印象全相连

45
00:01:59,100 --> 00:02:01,720
印象组相连映象这么麻烦呢

46
00:02:01,720 --> 00:02:04,440
我们是可以任意去调用的

47
00:02:04,440 --> 00:02:07,540
那任意去调用就存在一个问题了

48
00:02:07,540 --> 00:02:11,090
这个调用的规律是没办法计算的

49
00:02:11,090 --> 00:02:12,660
那如何来处理呢

50
00:02:12,660 --> 00:02:15,800
我们用列表来进行记录

51
00:02:16,280 --> 00:02:19,020
在列表当中记录呢

52
00:02:19,020 --> 00:02:21,660
相应的用户程序的页号

53
00:02:21,660 --> 00:02:24,190
并且每一个页面

54
00:02:24,190 --> 00:02:28,070
它具体放到了哪一个内存块当中去

55
00:02:28,070 --> 00:02:30,990
我们呢，就记录在列表当中

56
00:02:30,990 --> 00:02:33,400
在这个记录的过程当中啊

57
00:02:33,400 --> 00:02:35,020
物理块号我们呢

58
00:02:35,020 --> 00:02:37,530
也可以叫做液征号

59
00:02:37,530 --> 00:02:40,080
那这是关于呢，页式存储

60
00:02:40,080 --> 00:02:41,750
它的调用过程

61
00:02:41,750 --> 00:02:43,870
我们重点需要了解

62
00:02:43,870 --> 00:02:48,630
对于啊，我们一个程序某一个位置

63
00:02:48,900 --> 00:02:52,120
它掉入到内存之后

64
00:02:52,120 --> 00:02:54,020
所对应的，诶

65
00:02:54,020 --> 00:02:57,740
内存位置如何来进行表示

66
00:02:57,740 --> 00:02:59,610
那在这个过程当中

67
00:02:59,610 --> 00:03:04,110
首先这个地址应该在用户程序当中

68
00:03:04,110 --> 00:03:06,560
取到某一个页面

69
00:03:06,560 --> 00:03:09,530
在页面当中的某一个位置吧

70
00:03:09,530 --> 00:03:11,610
那我们之前也有提到呢

71
00:03:11,610 --> 00:03:14,190
业内地址这样的一个概念

72
00:03:14,210 --> 00:03:16,070
首先知道呢

73
00:03:16,070 --> 00:03:17,990
在用户程序当中

74
00:03:17,990 --> 00:03:20,420
我们说的是逻辑地址

75
00:03:20,420 --> 00:03:23,910
逻辑地址它包含相应的页号

76
00:03:23,910 --> 00:03:25,500
比如说一号页

77
00:03:25,500 --> 00:03:28,510
然后呢，有相应的业内地址

78
00:03:28,510 --> 00:03:31,050
比如说一号页的起始位置

79
00:03:31,050 --> 00:03:33,410
诶，0000的位置里

80
00:03:33,410 --> 00:03:34,920
那现在的话

81
00:03:34,920 --> 00:03:37,660
将它呢转换到内存当中

82
00:03:37,660 --> 00:03:40,050
有一个相应的物理地址

83
00:03:40,050 --> 00:03:42,400
在转换过程当中

84
00:03:42,400 --> 00:03:47,500
那这个业内地址是不会发生变化的

85
00:03:47,850 --> 00:03:53,270
为什么我们在前面讲 catch 和储存调用的时候

86
00:03:53,270 --> 00:03:55,990
其实也提到过这样一个概念

87
00:03:55,990 --> 00:03:58,410
如果说告诉大

88
00:03:58,410 --> 00:04:02,310
在讲义上有一个第十页，诶

89
00:04:02,310 --> 00:04:04,450
有一个第十行的内容

90
00:04:04,450 --> 00:04:08,950
那这个第十行其实是在第十页页内的

91
00:04:08,950 --> 00:04:10,420
某一个相对位置吧

92
00:04:10,420 --> 00:04:12,790
那现在对于讲义

93
00:04:12,790 --> 00:04:16,070
我们从家里拿到了，诶

94
00:04:16,070 --> 00:04:17,829
我们的公司当中

95
00:04:17,829 --> 00:04:19,750
在这个拿的过程当中

96
00:04:19,750 --> 00:04:23,470
这个第十行的相对位置会不会发生变化

97
00:04:23,470 --> 00:04:25,980
是不会发生变化的

98
00:04:25,980 --> 00:04:28,980
所以呀，按页来调用的时候

99
00:04:28,980 --> 00:04:31,960
业内地址是固定不变的

100
00:04:31,960 --> 00:04:33,700
它变化的是什么呢

101
00:04:33,700 --> 00:04:37,050
是页号和页征号

102
00:04:37,050 --> 00:04:42,050
那这个页号和页真号有怎样的对应关系呢

103
00:04:42,050 --> 00:04:46,960
唉，其实我们已经把它记录在列表当中呢

104
00:04:46,960 --> 00:04:49,480
所以所谓的对应关系

105
00:04:49,480 --> 00:04:54,200
页号和页真号是可以查表可得的

106
00:04:54,200 --> 00:04:57,220
那我们一般在转换的过程当中啊

107
00:04:57,220 --> 00:05:00,260
是将用户程序调入内存

108
00:05:00,260 --> 00:05:03,760
所以逻辑地址是已知的

109
00:05:03,760 --> 00:05:05,440
我们要了解的是

110
00:05:05,440 --> 00:05:08,660
逻辑地址转物理地址的情况下

111
00:05:08,660 --> 00:05:12,000
首先取出业内地址不变

112
00:05:12,000 --> 00:05:15,080
根据逻辑地址的页号查

113
00:05:15,080 --> 00:05:16,720
得出验证号

114
00:05:16,720 --> 00:05:19,400
从而进行拼接的过程

115
00:05:19,400 --> 00:05:22,130
那接下来我们看一个例子

116
00:05:22,170 --> 00:05:26,050
假设页式存储系统当中啊

117
00:05:26,050 --> 00:05:29,300
每个页的大小是4 KB 

118
00:05:29,300 --> 00:05:34,130
那页面大小知道了有什么用呢

119
00:05:34,130 --> 00:05:37,440
我们假设现在有一个诶

120
00:05:37,440 --> 00:05:40,760
页面大小的存储区间

121
00:05:41,430 --> 00:05:45,150
这个存储区间容量是多少呢

122
00:05:45,150 --> 00:05:48,110
总容量4 KB 

123
00:05:51,480 --> 00:05:54,540
那看到总容量这个参数

124
00:05:54,540 --> 00:05:56,320
大家能想到什么

125
00:05:56,320 --> 00:05:59,260
在主存编址计算的时候

126
00:05:59,260 --> 00:06:00,600
我们曾经提到

127
00:06:00,600 --> 00:06:06,320
总容量是等于存储单元个数

128
00:06:08,370 --> 00:06:11,170
乘以编制内容的吧

129
00:06:14,100 --> 00:06:17,820
那现在没有告诉我们编制内

130
00:06:17,820 --> 00:06:20,110
默认按字节编址

131
00:06:20,110 --> 00:06:25,270
也就是说默认每个存储单元放一个字节

132
00:06:25,270 --> 00:06:28,970
总共有4 K 字节的总容量

133
00:06:28,970 --> 00:06:30,570
存储容量诶

134
00:06:30,570 --> 00:06:32,910
它的存储个数有多少个啊

135
00:06:32,910 --> 00:06:34,110
4 K 个

136
00:06:34,110 --> 00:06:38,870
也就是说现在我们的存储单元有4 K 哎

137
00:06:38,870 --> 00:06:42,470
这4 K 个单元其实就是4096吧

138
00:06:42,470 --> 00:06:45,230
对于4096个单元

139
00:06:45,230 --> 00:06:48,890
如果要对它进行地址编号的话

140
00:06:48,890 --> 00:06:52,210
是0~4095

141
00:06:53,960 --> 00:06:58,550
那看到这个编制需要的个数

142
00:06:58,550 --> 00:07:00,390
我们能够看到什么呢

143
00:07:00,390 --> 00:07:02,310
我们需要延伸到

144
00:07:02,310 --> 00:07:05,250
至少需要多少位二进

145
00:07:05,250 --> 00:07:10,380
才能表示这么多个不同的地址呢

146
00:07:10,400 --> 00:07:15,840
那每一个位置放置的其实应该是比特位

147
00:07:15,840 --> 00:07:18,080
也就是二进制的形式

148
00:07:18,080 --> 00:07:22,580
一个位置能够放映零或一两种情况

149
00:07:22,580 --> 00:07:25,050
多少个位置能放40

150
00:07:25,050 --> 00:07:26,290
六种情况呢

151
00:07:26,290 --> 00:07:29,490
应该是二的12次方

152
00:07:30,070 --> 00:07:33,890
所以啊，我们根据这里的4 K

153
00:07:33,890 --> 00:07:35,410
能够看到的

154
00:07:35,410 --> 00:07:37,520
应该是这个容量

155
00:07:37,520 --> 00:07:41,650
需要用12位二进制来表示

156
00:07:41,650 --> 00:07:46,350
这么多个不同的存储单元的编码

157
00:07:46,350 --> 00:07:47,860
那如果说

158
00:07:47,860 --> 00:07:51,580
唉，我们4096个需要二的12次方

159
00:07:51,580 --> 00:07:52,660
大家不了解

160
00:07:52,660 --> 00:07:56,000
可以呢，把4095展开

161
00:07:56,000 --> 00:07:57,540
大家会发现啊

162
00:07:57,540 --> 00:08:01,540
4095其实是12个一，哎

163
00:08:01,540 --> 00:08:04,310
这样的二进制转换出来的

164
00:08:04,310 --> 00:08:08,140
那我们对于这个12位二进制

165
00:08:08,140 --> 00:08:10,460
作为业内地址大小

166
00:08:10,460 --> 00:08:13,520
大家呢，要能够理解这个过程

167
00:08:13,520 --> 00:08:18,070
那4 KB 用到的是12位二进制

168
00:08:18,070 --> 00:08:22,750
1 KB 需要多少位二进制来表示呢

169
00:08:22,750 --> 00:08:24,200
唉，其实一样的

170
00:08:24,200 --> 00:08:29,330
还是呢，把它直接转换成二的十次方来看的话

171
00:08:29,330 --> 00:08:32,360
需要十位二进制来表示

172
00:08:32,360 --> 00:08:33,490
这就是啊

173
00:08:33,490 --> 00:08:38,900
关于页面大小与页内地址长度之间的关系

174
00:08:38,900 --> 00:08:40,890
那如果考试出现

175
00:08:40,890 --> 00:08:43,090
诶，2 KB 、8 KB 大小

176
00:08:43,090 --> 00:08:45,830
大家呢要能够学会转换

177
00:08:45,830 --> 00:08:49,220
那这个页内地址的长度知道了

178
00:08:49,220 --> 00:08:52,720
现在告诉我们逻辑地址如下所示的话

179
00:08:52,720 --> 00:08:54,850
我们数一数

180
00:08:54,850 --> 00:09:00,660
注意低位的12位是我们的业内地址长度

181
00:09:00,660 --> 00:09:04,360
那后面的低位是业内地址

182
00:09:04,360 --> 00:09:06,120
上面的高位是什么

183
00:09:06,120 --> 00:09:09,890
就是我们的一号逻辑页号

184
00:09:09,890 --> 00:09:12,010
幺零是不是10号页啊

185
00:09:12,010 --> 00:09:12,870
不是啊

186
00:09:12,870 --> 00:09:15,330
这里是二进制的形式

187
00:09:15,330 --> 00:09:19,010
那转换成十进制其实就是二

188
00:09:19,790 --> 00:09:25,770
将二哎找到这个二的页号查表可得

189
00:09:25,770 --> 00:09:29,180
它所对应的页针号是六

190
00:09:29,180 --> 00:09:32,630
所以新的物理地址当

191
00:09:32,630 --> 00:09:35,230
高位的液真号是六

192
00:09:35,230 --> 00:09:38,180
转换成二进制110

193
00:09:38,180 --> 00:09:40,920
第一位业内地址不变

194
00:09:40,920 --> 00:09:43,870
仍然是这12位业内地址

195
00:09:43,870 --> 00:09:46,660
那它所对应的物理地址呢

196
00:09:46,660 --> 00:09:48,420
诶，就有了

197
00:09:50,640 --> 00:09:52,940
110、1110

198
00:09:52,940 --> 00:09:55,710
还有呢，110、11110

199
00:09:55,710 --> 00:09:58,400
这里呢，后面是它的业内地址

200
00:09:58,400 --> 00:10:00,590
上面呢是它的业证号

201
00:10:00,590 --> 00:10:05,250
那这就是呢，逻辑地址向物理地址转换的过程

202
00:10:05,250 --> 00:10:08,500
对于这种啊，转换过程当中呢

203
00:10:08,500 --> 00:10:12,350
我们会发现页面它的大小4 KB 

204
00:10:12,350 --> 00:10:16,880
其实相对来说是比较小的一个存储容量呢

205
00:10:16,880 --> 00:10:19,500
那我们一般一个文件几十个 G 

206
00:10:19,500 --> 00:10:21,720
那这种 KB 大小啊

207
00:10:21,720 --> 00:10:26,120
相对来说呢，是较少、较小的一个容量单位

208
00:10:26,120 --> 00:10:28,410
那这种调用方式啊

209
00:10:28,410 --> 00:10:31,070
我们在调用的过程当中

210
00:10:31,070 --> 00:10:33,050
如果页面用了

211
00:10:33,050 --> 00:10:34,190
那肯定呢，就

212
00:10:34,190 --> 00:10:35,730
诶，容量占用了

213
00:10:35,730 --> 00:10:37,960
如果不用下一第四呢

214
00:10:37,960 --> 00:10:40,300
新的页面可能就掉进去了

215
00:10:40,300 --> 00:10:41,980
那在这个过程当中

216
00:10:41,980 --> 00:10:43,800
我们的内存啊

217
00:10:43,800 --> 00:10:48,780
如果中间存在一些空余的空间没有用

218
00:10:48,780 --> 00:10:52,250
那说明一定是小于页面大小的

219
00:10:52,250 --> 00:10:56,280
否则的话，页面会往里面来进行调用

220
00:10:56,280 --> 00:10:58,220
那这种方式，诶

221
00:10:58,220 --> 00:11:01,440
我们的内存利用率非常高

222
00:11:01,440 --> 00:11:04,380
它如果有一些空闲碎片的话

223
00:11:04,380 --> 00:11:06,680
碎片呢，会比较小

224
00:11:06,680 --> 00:11:09,920
分配起来管理起来呢，很简单

225
00:11:09,920 --> 00:11:13,240
那正是呢，页式存储它的优点

226
00:11:13,240 --> 00:11:15,730
它也有一定的缺点啊

227
00:11:15,730 --> 00:11:18,720
因为我们这里划分的太过细碎

228
00:11:18,720 --> 00:11:21,150
所以呢，在这个过程当中啊

229
00:11:21,150 --> 00:11:23,330
容易呢产生系统开销

230
00:11:23,330 --> 00:11:25,860
因为有不停的进进出出

231
00:11:25,860 --> 00:11:28,340
所以呢，增加了系统的开销

232
00:11:28,340 --> 00:11:31,190
并且可能会产生抖动现象

233
00:11:31,190 --> 00:11:32,750
那抖动现象的话

234
00:11:32,750 --> 00:11:35,750
目前在我们软件设计师考试当中

235
00:11:35,750 --> 00:11:37,230
并没有涉及

236
00:11:37,230 --> 00:11:40,270
大家了解到，对于抖动的话

237
00:11:40,270 --> 00:11:42,530
它指的是呢

238
00:11:42,620 --> 00:11:45,880
如果我们给某一个程序啊

239
00:11:45,880 --> 00:11:47,920
分配三个内存页面

240
00:11:47,920 --> 00:11:51,330
那它呢，可能会产生的确认中断次数

241
00:11:51,330 --> 00:11:55,630
唉，与我们到四个页面分配给程序的话

242
00:11:55,630 --> 00:11:58,520
相对来说可能会更少一些

243
00:11:58,520 --> 00:11:59,620
也就是说

244
00:11:59,620 --> 00:12:04,400
即时给程序增加了一些更多的资源

245
00:12:04,400 --> 00:12:07,040
并没有有效地提高它的效率

246
00:12:07,040 --> 00:12:09,410
这种呢，就叫做抖动现象

247
00:12:09,410 --> 00:12:11,650
当然，这个听起来比较抽象

248
00:12:11,650 --> 00:12:12,950
我们也可以啊

249
00:12:12,950 --> 00:12:15,470
直接把里抖动理解为呢

250
00:12:15,470 --> 00:12:17,240
某一个页面诶

251
00:12:17,240 --> 00:12:19,220
经常性的掉入内存

252
00:12:19,220 --> 00:12:20,680
然后呢被淘汰

253
00:12:20,680 --> 00:12:22,820
再次被调入、被淘汰

254
00:12:22,820 --> 00:12:26,520
这种情况呢，也可以理解为呢抖动现象

255
00:12:26,520 --> 00:12:30,780
那就是呢页式存储它的调用过程

256
00:12:30,810 --> 00:12:32,770
在这个过程当中

257
00:12:32,770 --> 00:12:33,870
我们会发现

258
00:12:33,870 --> 00:12:36,070
哎，当某一个程序啊

259
00:12:36,070 --> 00:12:39,130
我们会不会把整个内存都分配给它呢

260
00:12:39,130 --> 00:12:39,900
不会

261
00:12:39,900 --> 00:12:43,710
我们一般只会给它分配一定的程序页里面

262
00:12:43,710 --> 00:12:45,170
比如说分配三个

263
00:12:45,170 --> 00:12:47,720
四个内存页面给我们的程序

264
00:12:47,720 --> 00:12:49,230
那够不够用呢

265
00:12:49,230 --> 00:12:52,060
一般是不会百分百够用的

266
00:12:52,060 --> 00:12:55,120
那我们既然不够用的话就存在呢

267
00:12:55,120 --> 00:12:57,960
有一些页面想要使用的时候

268
00:12:57,960 --> 00:12:59,190
它不在内存

269
00:12:59,190 --> 00:13:02,810
这个过程我们就说呢，产生了中断

270
00:13:03,550 --> 00:13:06,550
那中断哎，产生了缺页

271
00:13:06,550 --> 00:13:07,550
中断

272
00:13:08,160 --> 00:13:10,800
那缺页的话怎么办呢

273
00:13:10,800 --> 00:13:13,810
要把缺的页面调到内存当中去

274
00:13:13,810 --> 00:13:17,610
那既然内存页面已经分配给程序了呀

275
00:13:17,610 --> 00:13:19,470
里面原本有内容

276
00:13:19,470 --> 00:13:21,420
那我们要怎么办呢

277
00:13:21,420 --> 00:13:23,580
比如说我们一个程序

278
00:13:23,580 --> 00:13:26,400
它有0~56个页面

279
00:13:26,400 --> 00:13:30,130
现在呢，对应的页证号也就是内存

280
00:13:30,130 --> 00:13:33,070
我们只分配了四个页面给它

281
00:13:33,070 --> 00:13:36,390
那现在，哎，我这四个页面用完了之后

282
00:13:36,390 --> 00:13:38,630
我现在要用3号页的数据啊

283
00:13:38,630 --> 00:13:42,040
那这个时候我们就说3号页不在内存

284
00:13:42,040 --> 00:13:44,050
我们会产生雀跃

285
00:13:44,050 --> 00:13:45,690
终端产生缺页

286
00:13:45,690 --> 00:13:47,510
中断的话会将呢

287
00:13:47,510 --> 00:13:50,080
已有的页面淘汰出去

288
00:13:50,080 --> 00:13:52,700
将新的页面呢调入进来

289
00:13:52,700 --> 00:13:55,470
从而呢解决缺页的问题

290
00:13:55,470 --> 00:13:59,560
那我们前面看到的页表比较呢，简洁

291
00:13:59,560 --> 00:14:03,090
只有页号和页真号的对应关系

292
00:14:03,090 --> 00:14:04,750
但真正的页表的话

293
00:14:04,750 --> 00:14:07,420
其实有更多的一些参数可用

294
00:14:07,420 --> 00:14:10,430
比如说呢，它会用状态位，诶

295
00:14:10,430 --> 00:14:13,850
一来表示我们的页面在内存

296
00:14:13,850 --> 00:14:16,180
零表示不再内存

297
00:14:16,180 --> 00:14:17,950
会有呢访问位

298
00:14:17,950 --> 00:14:21,850
表示呢最近页面有没有被访问到

299
00:14:21,850 --> 00:14:24,860
还有呢，修改位来记录呢

300
00:14:24,860 --> 00:14:27,040
在最近的时间段内

301
00:14:27,040 --> 00:14:30,240
有没有呢对页面进行修改

302
00:14:30,240 --> 00:14:33,390
注意，访问位和修改位

303
00:14:33,390 --> 00:14:37,310
都是在一定的时间段内来进行判断的

304
00:14:37,310 --> 00:14:39,730
那这个时间的话是由呢

305
00:14:39,730 --> 00:14:42,140
我们，哎，操作系统设定过的

306
00:14:42,140 --> 00:14:45,050
不需要呢程序员去操心了

307
00:14:45,050 --> 00:14:48,510
也就是说我们在这个过程当

308
00:14:48,510 --> 00:14:52,440
可能呢会存在有一些数据诶

309
00:14:52,440 --> 00:14:56,020
有一些页面虽然没有被访问

310
00:14:56,020 --> 00:14:58,910
他指的只是最近没有被访问

311
00:14:58,910 --> 00:15:01,730
但是在更长的时间里面

312
00:15:01,730 --> 00:15:04,160
他可能呢有被修改

313
00:15:04,160 --> 00:15:06,660
这两个是不同的概念

314
00:15:06,660 --> 00:15:09,480
大家呢不要混淆来记忆了

315
00:15:09,480 --> 00:15:13,100
那这个复杂的页表有什么用呢

316
00:15:13,100 --> 00:15:17,970
首先我们看到3号页它不在内存当中

317
00:15:17,970 --> 00:15:20,670
那既然我们要把它调入内存

318
00:15:20,670 --> 00:15:22,830
就要淘汰其他页面吧

319
00:15:22,830 --> 00:15:28,240
那其他页面按照什么依据来淘汰呢

320
00:15:28,240 --> 00:15:34,140
注意，第一个淘汰的原则是访问位为零

321
00:15:39,620 --> 00:15:42,240
为什么是访问位为零啊

322
00:15:42,240 --> 00:15:45,200
我们在讲层次化存储体系的时候

323
00:15:45,200 --> 00:15:47,620
提到一个很重要的理论

324
00:15:47,620 --> 00:15:49,690
叫做呢局部性原理

325
00:15:49,690 --> 00:15:54,260
也就是说在访问位为一的情况下

326
00:15:54,260 --> 00:15:56,780
这个页面刚刚被访问了

327
00:15:56,780 --> 00:15:59,810
很有可能立即会被访问

328
00:15:59,810 --> 00:16:03,380
这就是它的时间局部性吧

329
00:16:03,380 --> 00:16:05,960
那依据局部性原理来看

330
00:16:05,960 --> 00:16:07,880
访问位唯一的是

331
00:16:07,880 --> 00:16:11,700
我们很可能接下来还要用到的数据

332
00:16:11,700 --> 00:16:13,200
那我们淘汰的话

333
00:16:13,200 --> 00:16:14,930
诶，很可能还要用啊

334
00:16:14,930 --> 00:16:18,260
所以不会去淘汰这些唯一的页面了

335
00:16:18,260 --> 00:16:20,580
那我们优先淘汰的就是呢

336
00:16:20,580 --> 00:16:23,350
访问位为零的页面

337
00:16:23,350 --> 00:16:26,430
那如果说极端一些的情况，哎

338
00:16:26,430 --> 00:16:30,590
假设现在多个访问位为零

339
00:16:34,160 --> 00:16:37,060
我们呢，会有第二个哎

340
00:16:37,060 --> 00:16:38,100
淘汰原则

341
00:16:38,100 --> 00:16:38,900
注意啊

342
00:16:38,900 --> 00:16:41,400
多个访问位为零才会考虑啊

343
00:16:41,400 --> 00:16:43,680
如果只有一个直接淘汰

344
00:16:43,680 --> 00:16:46,840
访问位为零的页面就可以了

345
00:16:47,030 --> 00:16:49,230
多个访问位为零

346
00:16:49,230 --> 00:16:53,630
那我们呢，就淘汰修改位为零的

347
00:16:56,440 --> 00:17:00,560
那这里为什么优先淘汰修改位为零呢

348
00:17:00,560 --> 00:17:03,570
哎，因为在页面淘汰的过程当中

349
00:17:03,570 --> 00:17:06,270
如果修改为唯一的话

350
00:17:06,270 --> 00:17:08,990
说明页面有一些变动

351
00:17:08,990 --> 00:17:11,800
如果这样的页面要淘汰掉

352
00:17:11,800 --> 00:17:15,510
我们同时呢还要去修改程序文件

353
00:17:15,510 --> 00:17:20,180
也就是说它的花销成本会更大一些

354
00:17:20,180 --> 00:17:22,359
那我们尽量呢放在最后

355
00:17:22,359 --> 00:17:25,160
再去淘汰高成本的页面

356
00:17:25,160 --> 00:17:30,000
那这种呢就是我们对于页面淘汰的简单依据

357
00:17:30,000 --> 00:17:34,860
首先最重要的第一个原则是访问位为零

358
00:17:34,860 --> 00:17:38,450
那一般呢到这个原则就足够了

359
00:17:38,450 --> 00:17:42,550
如果真的碰到了多个访问位为零的

360
00:17:42,550 --> 00:17:46,400
再考虑呢修改位为零的原则

361
00:17:46,400 --> 00:17:50,570
那这是呢，页面淘汰的简单宜居

362
00:17:50,570 --> 00:17:52,870
对于页面置换来说

363
00:17:52,870 --> 00:17:55,450
其实它有多种算法

364
00:17:55,970 --> 00:17:58,490
那这种算法当中啊

365
00:17:58,490 --> 00:17:59,850
第一种叫做呢

366
00:17:59,850 --> 00:18:00,870
最优算法

367
00:18:00,870 --> 00:18:03,490
它也叫做理想型

368
00:18:06,340 --> 00:18:11,220
对于一个事件没有发生之前

369
00:18:11,220 --> 00:18:15,310
我们能不能决定到底谁是最优呢

370
00:18:15,310 --> 00:18:17,440
其实是决定不了的

371
00:18:17,440 --> 00:18:20,640
所以我们说啊，最优算法它是理想型

372
00:18:20,640 --> 00:18:23,200
一般是用在程序，诶

373
00:18:23,200 --> 00:18:24,900
执行完成之后

374
00:18:24,900 --> 00:18:26,120
我们知道呢

375
00:18:26,120 --> 00:18:28,200
什么样的情况才是最优

376
00:18:28,200 --> 00:18:32,780
那一般拿来呢，判断我们当前选择的淘汰算法

377
00:18:32,780 --> 00:18:36,100
A 与最优算法之间进行对比

378
00:18:36,100 --> 00:18:37,240
来进行呢

379
00:18:37,240 --> 00:18:39,890
做一些判定性的工作

380
00:18:39,890 --> 00:18:42,840
第二种算法呢，叫随机算法

381
00:18:42,840 --> 00:18:45,140
那这就是呢，万事看缘分

382
00:18:45,140 --> 00:18:46,180
听天由命呢

383
00:18:46,180 --> 00:18:48,620
哎，我们随机呢，淘汰一些页面

384
00:18:48,620 --> 00:18:50,640
有可能他真的不用了

385
00:18:50,640 --> 00:18:52,760
有可能立马呢，就要用

386
00:18:52,760 --> 00:18:55,150
那这种方式呢，相对来说

387
00:18:55,150 --> 00:18:58,060
呃，稳定性非常差

388
00:18:58,060 --> 00:19:02,120
第三种呢，叫做先进先出算法啊

389
00:19:02,120 --> 00:19:04,550
它呢，有可能会产生抖动

390
00:19:04,550 --> 00:19:07,260
我们前面解释了一下什么是抖动啊

391
00:19:07,260 --> 00:19:09,100
那他的淘汰依据呢

392
00:19:09,100 --> 00:19:11,860
谁先进来就优先淘汰谁

393
00:19:11,860 --> 00:19:15,990
比如说4321这一大串的序列当中

394
00:19:15,990 --> 00:19:20,260
我们如果用三个页面进行分析的话

395
00:19:20,260 --> 00:19:25,000
首先4号页面、3号页面、2号页面放进去了

396
00:19:25,000 --> 00:19:27,040
接下来要用一号页面

397
00:19:27,040 --> 00:19:28,040
没地方放呢

398
00:19:28,040 --> 00:19:29,090
淘汰谁呢

399
00:19:29,090 --> 00:19:32,140
4号页面先进，先进先出

400
00:19:32,140 --> 00:19:34,680
那淘汰四，放入一

401
00:19:34,680 --> 00:19:38,230
那接下来刚好又要用4号页面了

402
00:19:38,230 --> 00:19:39,010
那怎么办

403
00:19:39,010 --> 00:19:40,470
虽然它已经能

404
00:19:40,470 --> 00:19:41,520
唉，淘汰了

405
00:19:41,520 --> 00:19:44,860
那我们呢，就只能再次的去掉入

406
00:19:44,860 --> 00:19:47,630
那在一、二、三三个页面当中

407
00:19:47,630 --> 00:19:49,610
谁先进3号先进

408
00:19:49,610 --> 00:19:52,310
淘汰三，掉入四

409
00:19:52,490 --> 00:19:55,350
那完了，接下来又要用三了

410
00:19:55,350 --> 00:19:56,510
哎，很尴尬

411
00:19:56,510 --> 00:19:57,930
刚刚淘汰掉了，对吧

412
00:19:57,930 --> 00:20:01,330
所以呢，哎，我们只能把二淘汰出去

413
00:20:01,330 --> 00:20:03,760
放入呢，3号页面

414
00:20:03,760 --> 00:20:07,020
那这个过程呢，就是先进先出

415
00:20:07,020 --> 00:20:11,400
判断依据是它进入我们内存的时间

416
00:20:11,400 --> 00:20:12,580
相对来说

417
00:20:12,580 --> 00:20:15,540
如果给它多增加一个页面

418
00:20:15,540 --> 00:20:18,720
最终呢，缺页的次数会更多一些

419
00:20:18,720 --> 00:20:21,330
大家可以呢，自己去试着，诶

420
00:20:21,330 --> 00:20:23,670
把一些呢，页面调入进去

421
00:20:23,670 --> 00:20:24,830
再淘汰出来

422
00:20:24,830 --> 00:20:28,750
比一下呢，他们的缺页次数有多少

423
00:20:28,750 --> 00:20:30,790
呃，当然这个确认的话

424
00:20:30,790 --> 00:20:33,190
目前在软件设计师考试当中

425
00:20:33,190 --> 00:20:36,870
并没有涉及到第四种

426
00:20:36,870 --> 00:20:38,590
最近最少使用

427
00:20:38,590 --> 00:20:40,890
那这种 LIU 算法的话

428
00:20:40,890 --> 00:20:43,690
就是呢，基于局部性原理来的了

429
00:20:43,690 --> 00:20:46,080
那这种呢，他会考虑啊

430
00:20:46,080 --> 00:20:49,390
根据我们的使用规律来判断

431
00:20:49,390 --> 00:20:53,200
然后呢，优先去淘汰最近没有用到的

432
00:20:53,200 --> 00:20:56,340
与我们前面讲到的简单判定原则呢

433
00:20:56,340 --> 00:20:58,420
基本上是一致的

434
00:20:58,420 --> 00:21:01,960
那局部性原理大家可以呢，再回忆一下

435
00:21:01,960 --> 00:21:07,420
分时间局部性、空间局部性、时间局部性刚刚用

436
00:21:07,420 --> 00:21:09,190
立马呢，可能又要用

437
00:21:09,190 --> 00:21:10,550
空间局部性

438
00:21:10,550 --> 00:21:12,050
刚刚用了一个空间

439
00:21:12,050 --> 00:21:15,490
很可能呢，要访问它的相邻空间

440
00:21:15,490 --> 00:21:16,530
这就是呢

441
00:21:16,530 --> 00:21:18,670
局部性原理的内容

442
00:21:19,080 --> 00:21:21,980
那关于页式存储的内容

443
00:21:21,980 --> 00:21:24,450
我们需要大家掌握的主要就是呢

444
00:21:24,450 --> 00:21:26,240
诶，它的地址转

445
00:21:26,240 --> 00:21:29,370
以及呢，页面淘汰的原则

446
00:21:29,370 --> 00:21:33,250
下面呢，我们看一下关于页式存储

447
00:21:33,250 --> 00:21:35,590
在软件设计师考试当中

448
00:21:35,590 --> 00:21:37,740
它的考察题型

449
00:21:37,740 --> 00:21:40,050
下面给了我们一道例题

450
00:21:40,050 --> 00:21:42,010
那某一个操作系统呢

451
00:21:42,010 --> 00:21:44,270
它采用分页存储管理

452
00:21:44,270 --> 00:21:48,440
下图给了进程 A 、进程 B 它的页表结构

453
00:21:48,440 --> 00:21:52,290
如果物理页的大小是1 K 字节

454
00:21:52,290 --> 00:21:56,150
那看到这个1 K 字节大到大家想到什么

455
00:21:56,280 --> 00:22:02,000
要想到它的页内地址大小是二的十次方

456
00:22:02,000 --> 00:22:04,450
也就是十位二进制

457
00:22:04,450 --> 00:22:09,420
那么对于进程 A 中逻辑地址1024

458
00:22:09,420 --> 00:22:11,360
这个十进制的变量，唉

459
00:22:11,360 --> 00:22:15,280
应该放在几号物理液当中呢

460
00:22:15,280 --> 00:22:18,710
那假设进程 A 它的逻辑页四

461
00:22:18,710 --> 00:22:23,660
与进程 B 它的逻辑五要共享物理四的话

462
00:22:23,660 --> 00:22:28,800
我们呢，应该如何来填写这两个页表呢

463
00:22:28,800 --> 00:22:30,740
首先看第一问

464
00:22:30,740 --> 00:22:33,460
这道题有一个陷阱

465
00:22:33,460 --> 00:22:36,470
大家自己做题的时候呢，要仔细

466
00:22:36,470 --> 00:22:39,510
首先我们在做地址转换的时候

467
00:22:39,510 --> 00:22:42,320
是以什么样的进制来表示啊

468
00:22:42,320 --> 00:22:45,680
因为业内地址是十位二进制

469
00:22:45,680 --> 00:22:48,490
所以我们要用二进制来表示

470
00:22:48,490 --> 00:22:52,310
那一、零、二、四是个十进制

471
00:22:52,310 --> 00:22:55,280
转换成二进制是多少呢

472
00:22:55,280 --> 00:22:56,680
大家思考一下

473
00:22:56,680 --> 00:23:00,970
应该是1×2的十次方吧

474
00:23:00,970 --> 00:23:05,080
那它后面所跟随的有多少个零呢

475
00:23:05,080 --> 00:23:08,300
这是很多同学啊，容易做错的

476
00:23:12,020 --> 00:23:16,500
1024转换成二进制

477
00:23:16,500 --> 00:23:19,370
后面会跟随十个零

478
00:23:19,370 --> 00:23:23,340
才会有呢1×2的十次方取值

479
00:23:23,340 --> 00:23:26,180
那找到这个划分之后

480
00:23:26,180 --> 00:23:30,630
业内地址长度为十位二进制

481
00:23:30,630 --> 00:23:36,780
所以它的业内地址刚好是起始位置全零吧

482
00:23:36,780 --> 00:23:40,390
那这种情况下它的页号是多少呢

483
00:23:40,390 --> 00:23:42,010
应该是

484
00:23:42,010 --> 00:23:45,270
转换成物理地址来看的话

485
00:23:45,270 --> 00:23:47,090
查表可得

486
00:23:47,090 --> 00:23:52,280
一号逻辑页对应的物理页是三

487
00:23:52,280 --> 00:23:54,260
所以幺幺哎

488
00:23:54,260 --> 00:23:56,240
这是它的叶真号

489
00:23:56,240 --> 00:23:58,920
拼接上十个零

490
00:24:01,840 --> 00:24:04,320
这就是它的物理地址吧

491
00:24:04,320 --> 00:24:07,360
那我们现在有没有要求大家求地址呢

492
00:24:07,360 --> 00:24:09,700
没有问的是几号物理块

493
00:24:09,700 --> 00:24:14,420
所以呢，应该是存放在3号物理块的位置上

494
00:24:14,420 --> 00:24:15,860
那我们现在呢

495
00:24:15,860 --> 00:24:20,150
说到进程 A 和进程 B 要共享物理四

496
00:24:20,150 --> 00:24:22,370
很多看很多同学啊

497
00:24:22,370 --> 00:24:24,510
看到共享直接就懵了

498
00:24:24,510 --> 00:24:27,620
我们不用考虑如何来实现共享吧

499
00:24:27,620 --> 00:24:29,540
我们分开来看的话

500
00:24:29,540 --> 00:24:35,720
进程 A 它的逻辑思用的是几号物理

501
00:24:35,720 --> 00:24:39,440
唉，用的是我们的物理四

502
00:24:39,440 --> 00:24:43,350
所以4号逻辑页对应物理页四吧

503
00:24:43,350 --> 00:24:45,580
那再来看进程 B 

504
00:24:45,580 --> 00:24:49,490
它的逻辑五也要用到物理四吧

505
00:24:49,490 --> 00:24:52,820
所以它仍然能填写的是四

506
00:24:52,820 --> 00:24:54,110
如何来共享

507
00:24:54,110 --> 00:24:54,950
我们知道吗

508
00:24:54,950 --> 00:24:56,030
不需要知道

509
00:24:56,030 --> 00:24:57,370
我们只需要呢

510
00:24:57,370 --> 00:25:01,790
把对应关系填写到列表当中即可

511
00:25:01,790 --> 00:25:04,550
那也许它共享的是一个呢

512
00:25:04,550 --> 00:25:08,640
唉，大家都要用到的用户、程序、函数等等

513
00:25:08,640 --> 00:25:10,960
那说明大家用到的都是呢

514
00:25:10,960 --> 00:25:13,380
4号物理液这个位置上

515
00:25:13,380 --> 00:25:15,920
那它具体是如何共享的

516
00:25:15,920 --> 00:25:17,070
我们需要知道吗

517
00:25:17,070 --> 00:25:18,200
不需要知道

518
00:25:18,200 --> 00:25:20,720
只要呢，我们了解到，哎

519
00:25:20,720 --> 00:25:24,160
进程 A 4号逻辑页对应物理四就行了

520
00:25:24,160 --> 00:25:25,400
唉，进程 B 的话

521
00:25:25,400 --> 00:25:26,280
它的4号

522
00:25:26,280 --> 00:25:30,160
5号逻辑页对应的也是物理四就可以了

523
00:25:30,160 --> 00:25:34,240
没有必要呢，知道它具体的实现逻辑

524
00:25:34,240 --> 00:25:37,330
那这些呢，就是我们给大家提到

525
00:25:37,330 --> 00:25:38,110
关于啊

526
00:25:38,110 --> 00:25:41,130
夜视存储需要大家掌握的内容
