1
00:00:00,000 --> 00:00:02,800
接下来，我们看一下磁盘管理

2
00:00:02,800 --> 00:00:06,500
在软件设计师考试真题当中的体现

3
00:00:06,500 --> 00:00:09,570
首先看到呢，下面这道题

4
00:00:09,570 --> 00:00:13,310
假设呢，磁盘块与缓冲区大小相同

5
00:00:13,310 --> 00:00:17,850
每个盘块读入缓冲区的时间是15微秒

6
00:00:17,850 --> 00:00:22,110
由缓冲区送到用户区的时间是五微秒

7
00:00:22,110 --> 00:00:24,400
在用户区系统当中啊

8
00:00:24,400 --> 00:00:28,280
对每个数据块处理的时间呢，是一微秒

9
00:00:28,280 --> 00:00:30,300
若用户需要呢

10
00:00:30,300 --> 00:00:33,940
将大小十个盘块的 doctor 1文件呢

11
00:00:33,940 --> 00:00:37,890
逐块的从磁盘读入缓冲区

12
00:00:37,890 --> 00:00:40,970
并送至用户区进行处理

13
00:00:40,970 --> 00:00:46,030
那么，采用单缓冲区需要花费多少时间

14
00:00:46,030 --> 00:00:49,380
双缓冲区需要花费多少时间呢

15
00:00:49,380 --> 00:00:50,810
这类问题啊

16
00:00:50,810 --> 00:00:52,870
很多同学在做题的时候

17
00:00:52,870 --> 00:00:54,980
存在两个维度的思维

18
00:00:54,980 --> 00:00:57,800
唉，错误。一个呢，是想得太简单

19
00:00:57,800 --> 00:01:00,200
一个呢，是想得太复杂

20
00:01:00,200 --> 00:01:03,710
这道题本身啊，其实是没有图示的

21
00:01:03,710 --> 00:01:08,950
但是呢，它的实质是由两个电路图来决定的

22
00:01:08,950 --> 00:01:13,090
首先呢，看到对于单缓冲区的情况来看的话

23
00:01:13,090 --> 00:01:19,940
我们呀，会从磁盘将相应的数据读到缓冲区

24
00:01:19,940 --> 00:01:23,820
那这个时间是15微秒

25
00:01:23,830 --> 00:01:26,930
那读到缓冲区之后

26
00:01:26,930 --> 00:01:32,230
接下来要把缓冲区的数据送到用户工作区

27
00:01:32,230 --> 00:01:33,590
或者说用户区

28
00:01:33,590 --> 00:01:35,760
那这个传送的过程呢

29
00:01:35,760 --> 00:01:37,750
需要五微秒

30
00:01:37,750 --> 00:01:39,990
那传完了之后

31
00:01:39,990 --> 00:01:41,830
这个数据还要处理吧

32
00:01:41,830 --> 00:01:44,690
处理的时间呢，是一微秒

33
00:01:44,690 --> 00:01:47,340
针对这个过程而言啊

34
00:01:47,340 --> 00:01:50,200
首先单缓冲区当中

35
00:01:50,200 --> 00:01:53,780
数据是逐块读到缓冲区的

36
00:01:53,780 --> 00:01:56,120
那缓冲区有一个特点

37
00:01:56,120 --> 00:01:57,300
大家还记得吗

38
00:01:57,300 --> 00:02:02,440
同一时刻只能以允许一个进程进行读或学

39
00:02:02,440 --> 00:02:03,860
读或者写吧

40
00:02:03,860 --> 00:02:08,620
能不能，诶，我在传送五微秒的时候

41
00:02:08,620 --> 00:02:11,700
同时写第二个数据进去啊

42
00:02:11,700 --> 00:02:14,110
那我们如何来区分

43
00:02:14,110 --> 00:02:16,550
有没有把需要的数据覆盖掉呢

44
00:02:16,550 --> 00:02:18,590
其实是没有办法做到的

45
00:02:18,590 --> 00:02:19,540
咳

46
00:02:19,540 --> 00:02:21,340
所以在这里啊

47
00:02:21,340 --> 00:02:27,560
我们要求使用缓冲区的过程一定是独立的

48
00:02:27,560 --> 00:02:32,020
那如果要求缓冲区的使用是独立的

49
00:02:32,020 --> 00:02:35,900
用户处理的时间需不需要独立呢

50
00:02:35,900 --> 00:02:39,650
诶，需不需要跟缓冲区的处理放一块儿分析呢

51
00:02:39,650 --> 00:02:40,940
就不用了

52
00:02:40,940 --> 00:02:43,280
那在这个过程当中啊

53
00:02:43,280 --> 00:02:47,650
我们可以将传送的过程分成两个部分

54
00:02:47,650 --> 00:02:51,760
一个部分是使用缓冲区

55
00:02:54,720 --> 00:02:57,060
写入15微秒

56
00:02:57,060 --> 00:02:59,380
读进读到用户区

57
00:02:59,380 --> 00:03:01,360
读出是五微秒

58
00:03:01,360 --> 00:03:04,180
那这是呢，使用缓冲区

59
00:03:04,180 --> 00:03:08,820
当第一个数据使用完缓冲区之后

60
00:03:08,820 --> 00:03:12,620
对第一个数据进行处理

61
00:03:12,620 --> 00:03:18,290
同时注意在这个一微秒处理的过程当中

62
00:03:18,290 --> 00:03:22,780
我们可以同时读入第二个数据块了

63
00:03:22,780 --> 00:03:24,430
为什么可以同时

64
00:03:24,430 --> 00:03:26,730
因为缓冲区，诶

65
00:03:26,730 --> 00:03:30,250
我们的第一个数据块不需要用它了

66
00:03:30,250 --> 00:03:32,900
所以在这里我们发现呢

67
00:03:32,900 --> 00:03:36,010
数据的处理过程分成了两个阶段

68
00:03:36,010 --> 00:03:39,150
并且这两个阶段之间

69
00:03:39,150 --> 00:03:41,570
可以形成一个什么样的过程啊

70
00:03:41,570 --> 00:03:43,860
是不是一个流水线的过程啊

71
00:03:43,860 --> 00:03:49,160
那这里就构成了一个两两段的流水线

72
00:03:49,160 --> 00:03:50,240
时间呢

73
00:03:50,240 --> 00:03:53,440
哎，分别是15+5加一

74
00:03:53,440 --> 00:03:55,300
这是流水线借力

75
00:03:55,300 --> 00:03:59,990
那接下来每隔一个流水线周期

76
00:03:59,990 --> 00:04:01,830
最长段是20吧

77
00:04:01,830 --> 00:04:05,300
哎，所以是20乘以 N 减一，呃

78
00:04:05,300 --> 00:04:07,720
一共是十个数据盘块

79
00:04:07,720 --> 00:04:10,000
所以呢，是10-1

80
00:04:10,000 --> 00:04:12,870
那总的时间是多少

81
00:04:12,870 --> 00:04:16,420
就应该呢，是201

82
00:04:16,420 --> 00:04:20,380
这是呢，单缓冲区的情况

83
00:04:20,380 --> 00:04:22,720
那对于单缓冲区

84
00:04:22,720 --> 00:04:23,880
我们要知

85
00:04:23,880 --> 00:04:27,360
缓冲区是不能同时呢

86
00:04:27,360 --> 00:04:30,600
对第一个数据块进行传送

87
00:04:30,600 --> 00:04:33,500
第二个数据块进行输入的

88
00:04:33,500 --> 00:04:38,250
所以它们之间一定是顺序执行

89
00:04:38,250 --> 00:04:42,090
当第一个数据块完成这两个步骤之后

90
00:04:42,090 --> 00:04:46,980
才可以开始第二个数据块的输入和传送

91
00:04:46,980 --> 00:04:49,660
这个过程呢，一定要理解

92
00:04:49,660 --> 00:04:52,060
那这是单缓冲区

93
00:04:52,060 --> 00:04:53,600
双缓冲区

94
00:04:53,600 --> 00:04:56,850
很多同学啊，看到这里会想得很复杂

95
00:04:56,850 --> 00:04:59,470
那我们15、五和一之间

96
00:04:59,470 --> 00:05:03,390
是不是可以形成更复杂的一个流水线呢

97
00:05:03,390 --> 00:05:05,210
其实并没有

98
00:05:05,210 --> 00:05:08,110
对于双缓冲区而言啊

99
00:05:08,110 --> 00:05:11,140
它其实也是一种呢，固定的电路

100
00:05:11,140 --> 00:05:12,950
我们的数据啊

101
00:05:12,950 --> 00:05:18,750
它在缓冲区当中是选择缓冲区一

102
00:05:18,750 --> 00:05:21,360
或者缓冲区二的

103
00:05:21,360 --> 00:05:27,620
那能不能同时向两个缓冲区送数据

104
00:05:27,620 --> 00:05:29,700
或者传送出去

105
00:05:29,700 --> 00:05:30,560
数据呢

106
00:05:30,560 --> 00:05:31,640
并不能

107
00:05:31,640 --> 00:05:33,580
它的这种电路啊

108
00:05:33,580 --> 00:05:35,760
在输入的过程当中

109
00:05:35,760 --> 00:05:40,040
只能选择一个缓冲区开始输入

110
00:05:40,040 --> 00:05:43,380
不能同时向两个缓冲区输入啊

111
00:05:43,380 --> 00:05:46,770
但我们可以实现什么样的情况呢

112
00:05:46,770 --> 00:05:50,950
原本缓冲区的时间太长了吧

113
00:05:51,150 --> 00:05:55,650
所以我们想把缓冲区的使用拆分开

114
00:05:55,650 --> 00:05:58,000
如何来拆分呢

115
00:05:58,000 --> 00:06:03,920
同一时刻对缓冲区二进行输入

116
00:06:03,920 --> 00:06:07,640
对缓冲区一进行输出

117
00:06:07,640 --> 00:06:11,160
形成两段并行的电路

118
00:06:11,160 --> 00:06:13,350
那在这个过程当中

119
00:06:13,350 --> 00:06:15,190
我们就会就会发现呢

120
00:06:15,190 --> 00:06:17,630
哎，这个地方是数据块一

121
00:06:17,630 --> 00:06:20,130
这个地方是数据块二吧

122
00:06:20,130 --> 00:06:26,330
那整个过程在传输数据块二的同时

123
00:06:26,330 --> 00:06:31,560
可以将数据块一传送到用户区

124
00:06:31,560 --> 00:06:36,310
那传送完了我们会发现这个时间还有冗余吧

125
00:06:36,310 --> 00:06:37,930
那我们还可以呢

126
00:06:37,930 --> 00:06:41,060
哎，再对它进行处理的一微秒

127
00:06:41,060 --> 00:06:45,460
那这样其实就将整个数据的时间

128
00:06:45,460 --> 00:06:47,610
划分成了三段

129
00:06:47,610 --> 00:06:52,130
一个段是使用缓冲区一

130
00:06:56,180 --> 00:07:00,420
然后呢，使用缓冲区二

131
00:07:04,380 --> 00:07:08,020
最后呢，才是处理的过程

132
00:07:08,890 --> 00:07:10,890
那这种划分

133
00:07:10,890 --> 00:07:13,770
我们就将呢，硬件和阶段呢

134
00:07:13,770 --> 00:07:16,150
形成了新的一个步骤

135
00:07:16,150 --> 00:07:18,450
结果我们来看一下啊

136
00:07:18,450 --> 00:07:21,320
首先对于单缓冲区的话

137
00:07:21,320 --> 00:07:24,030
数据块一送入缓冲区

138
00:07:24,030 --> 00:07:27,410
并且从缓冲区送入用户区

139
00:07:27,410 --> 00:07:29,380
接下来处理数据

140
00:07:29,380 --> 00:07:32,800
数据块二从什么时候开始输入呢

141
00:07:32,800 --> 00:07:37,450
从我们用完缓冲区之后才能输入

142
00:07:37,450 --> 00:07:40,790
然后呢，接着输出和处理

143
00:07:40,790 --> 00:07:43,570
那我们分析完两条指令

144
00:07:43,570 --> 00:07:45,930
或者说两条数据块之后啊

145
00:07:45,930 --> 00:07:47,690
我们会发现，诶

146
00:07:47,690 --> 00:07:51,300
这个地方好像形成了一个流水线吧

147
00:07:51,300 --> 00:07:55,750
那这个流水线其实只分了两段

148
00:07:55,750 --> 00:08:00,490
一段呢，诶，是我们的数据传输的过程

149
00:08:00,490 --> 00:08:01,760
15+5

150
00:08:01,760 --> 00:08:05,050
还有一段呢，就是数据处理的过程

151
00:08:05,050 --> 00:08:05,970
以为秒

152
00:08:05,970 --> 00:08:07,810
那这就是我们呢

153
00:08:07,810 --> 00:08:10,570
前面所讲到的流水线，哎

154
00:08:10,570 --> 00:08:12,370
15+5加一

155
00:08:12,370 --> 00:08:17,340
加上10-1乘以流水线最长的一段

156
00:08:17,340 --> 00:08:18,780
15+5

157
00:08:19,470 --> 00:08:24,750
那接下来对于我们的双缓冲区来看的话

158
00:08:24,750 --> 00:08:28,270
首先数据块一送入缓冲区

159
00:08:28,270 --> 00:08:32,289
然后数据块二也可以呢

160
00:08:32,289 --> 00:08:34,630
接着送入缓冲区二了

161
00:08:34,630 --> 00:08:37,730
在这个同时 A 缓冲区一

162
00:08:37,730 --> 00:08:40,419
将数据送入用户区域

163
00:08:40,419 --> 00:08:44,330
那这个过程使用的都是缓冲区一

164
00:08:44,330 --> 00:08:48,780
而这里使用的都是呢，缓冲区二

165
00:08:48,780 --> 00:08:53,590
那这里形成了一个新的流水线的形式吧

166
00:08:53,590 --> 00:08:57,920
我们会发现它的准并行过程当中啊

167
00:08:57,920 --> 00:09:00,200
后面两部分都是呢

168
00:09:00,200 --> 00:09:02,920
与第一部分来进行并行的

169
00:09:02,920 --> 00:09:06,040
那在新的流水线当中

170
00:09:06,040 --> 00:09:11,740
它的并行过程分成的是三个段的准并行了吧

171
00:09:11,740 --> 00:09:14,930
针对这三个段而言的话

172
00:09:14,930 --> 00:09:18,910
哎，我们是15+5加

173
00:09:19,210 --> 00:09:21,350
加上10-1

174
00:09:21,350 --> 00:09:23,450
最长段是多少呢

175
00:09:23,450 --> 00:09:25,810
不再是15+5了

176
00:09:25,810 --> 00:09:28,010
而是呢，只有15

177
00:09:28,010 --> 00:09:33,130
所以最终的结果应该呢，是156

178
00:09:33,130 --> 00:09:34,990
很多同学这道题啊

179
00:09:34,990 --> 00:09:37,350
会想到同时送入呢

180
00:09:37,350 --> 00:09:38,670
哎，缓冲区一

181
00:09:38,670 --> 00:09:39,770
缓冲区二

182
00:09:39,770 --> 00:09:43,050
同时自从缓冲区一、二读数据

183
00:09:43,050 --> 00:09:46,700
那这个过程其实没有呢，这么的

184
00:09:46,700 --> 00:09:47,750
呃，复杂了

185
00:09:47,750 --> 00:09:52,070
它相对来说的话是一个线路切换的过程

186
00:09:52,070 --> 00:09:55,030
那它的具体计算过程啊

187
00:09:55,030 --> 00:09:57,390
给大家做了一个简单的总结

188
00:09:57,390 --> 00:10:00,960
整个数据的处理过程其实分了三个部分

189
00:10:00,960 --> 00:10:02,920
一个呢，是送入缓冲区

190
00:10:02,920 --> 00:10:04,340
一个是送入用户区

191
00:10:04,340 --> 00:10:06,680
还有一个呢，就是处理数据

192
00:10:06,680 --> 00:10:09,290
那么在单缓冲区当中啊

193
00:10:09,290 --> 00:10:12,390
我们会发现呢，缓冲区它比较特殊

194
00:10:12,390 --> 00:10:15,580
所以啊，整个使用缓冲区的时间呢

195
00:10:15,580 --> 00:10:17,960
应该划分成一个阶段

196
00:10:17,960 --> 00:10:21,190
然后呢，再加上处理时间的一毫秒

197
00:10:21,190 --> 00:10:24,150
从而形成了一个流水线的结构

198
00:10:24,150 --> 00:10:26,680
总时间呢，是201

199
00:10:26,680 --> 00:10:29,110
如果是双缓冲区

200
00:10:29,110 --> 00:10:31,450
它的特殊点在于呢

201
00:10:31,450 --> 00:10:33,650
将读入缓冲区二

202
00:10:33,650 --> 00:10:36,980
从缓冲区区一读入用户区

203
00:10:36,980 --> 00:10:39,140
这两个阶段进行了拆分

204
00:10:39,140 --> 00:10:41,320
有了一个并发的过程吧

205
00:10:41,320 --> 00:10:45,660
那整个阶段呢，可以分为三个阶段了

206
00:10:45,660 --> 00:10:47,550
一个是读入缓冲区

207
00:10:47,550 --> 00:10:50,020
一个呢是送入用户区

208
00:10:50,020 --> 00:10:53,110
最后呢，是处理时间的一微秒

209
00:10:53,110 --> 00:10:55,590
那它形成的流水线，唉

210
00:10:55,590 --> 00:10:59,120
就应该呢是156微秒

211
00:10:59,120 --> 00:11:02,280
我们呢，回到前面的选项当中来看

212
00:11:02,280 --> 00:11:06,000
第二空选择的应该呢是 C 选项

213
00:11:06,000 --> 00:11:09,350
这就是在磁盘存储时间当中

214
00:11:09,350 --> 00:11:13,010
单缓冲区和双缓冲区的区别

215
00:11:13,010 --> 00:11:14,740
我们来看下一道题

216
00:11:14,740 --> 00:11:18,130
假设磁盘 B 位于15号柱面

217
00:11:18,130 --> 00:11:21,580
进程的请求序列如下表所示

218
00:11:21,580 --> 00:11:26,410
那我们如果采用最短1 B 调度算法

219
00:11:26,410 --> 00:11:29,100
它的响应序列应该是什么呢

220
00:11:29,100 --> 00:11:31,020
哎，最短一臂调度

221
00:11:31,020 --> 00:11:32,440
我们首先呀

222
00:11:32,440 --> 00:11:36,800
将磁盘它的1 B 位置记录下来

223
00:11:36,800 --> 00:11:38,900
这是初始位置

224
00:11:38,900 --> 00:11:40,740
唉，我们不用这个一了

225
00:11:40,740 --> 00:11:44,170
有初始位置

226
00:11:45,630 --> 00:11:48,710
应该在15号柱面

227
00:11:49,130 --> 00:11:54,070
那15号柱面其实就是磁盘的磁道号吧

228
00:11:54,070 --> 00:11:59,140
那现在下面的表格当中有请求的序列号

229
00:11:59,140 --> 00:12:02,370
相应的柱面号、磁头号、扇区号

230
00:12:02,370 --> 00:12:04,450
其实我们只看什么就行了

231
00:12:04,450 --> 00:12:07,040
只看柱面号就可以了

232
00:12:07,040 --> 00:12:09,060
磁头号和扇区号

233
00:12:09,060 --> 00:12:12,150
目前是没有要求我们去识别的

234
00:12:12,150 --> 00:12:15,430
那对于柱面申请来看的话

235
00:12:15,430 --> 00:12:19,000
12号柱面有哪些请求呢

236
00:12:19,000 --> 00:12:21,620
哎，我们发现有一和五

237
00:12:22,310 --> 00:12:27,150
接下来19号柱面哎，有二和四

238
00:12:29,380 --> 00:12:33,360
然后23号柱面有3号请求

239
00:12:33,360 --> 00:12:36,190
28号柱面有6号请求

240
00:12:36,190 --> 00:12:40,320
那我们现在以最短一臂调度算法来看的话

241
00:12:40,320 --> 00:12:43,440
诶，在初始15号的情况下

242
00:12:43,440 --> 00:12:47,860
谁离他最近12相差有39

243
00:12:47,860 --> 00:12:51,400
相差有四、23、28就更大了吧

244
00:12:51,400 --> 00:12:55,620
所以离它最近的是12号竹面

245
00:12:55,620 --> 00:12:59,150
那我们优先响应请求的应该是

246
00:12:59,150 --> 00:13:02,120
一号申请和5号申请

247
00:13:02,120 --> 00:13:06,120
到底是一五还是五一都是可以的

248
00:13:06,120 --> 00:13:09,960
那其他选项就已经能被排除了

249
00:13:09,960 --> 00:13:11,580
那响应呢

250
00:13:11,580 --> 00:13:12,780
一五之后啊

251
00:13:12,780 --> 00:13:15,580
12号柱面离他最近的是谁呢

252
00:13:15,580 --> 00:13:18,480
哎，应该是19号柱面

253
00:13:18,480 --> 00:13:22,300
所以接下来响应二四或者呢，四二

254
00:13:22,300 --> 00:13:26,640
然后最近的是3号申请的23号柱面

255
00:13:26,640 --> 00:13:30,900
最后呢，是28号柱面的6号申请

256
00:13:30,900 --> 00:13:34,100
因所以选择的是 B 选项

257
00:13:34,100 --> 00:13:40,380
那这里如果是一、五、四、二、三、六可以吗

258
00:13:40,380 --> 00:13:42,220
仍然是可以的

259
00:13:42,220 --> 00:13:45,100
我们在这里并没有严格的区分

260
00:13:45,100 --> 00:13:49,020
同一个柱面上扇区的先后顺序

261
00:13:49,020 --> 00:13:50,740
那这里呢，注意一下

262
00:13:50,740 --> 00:13:54,290
按柱面来进行响应就可以了

263
00:13:54,290 --> 00:13:55,330
那这是呢

264
00:13:55,330 --> 00:13:58,850
关于移臂调度算法的考察

265
00:14:02,680 --> 00:14:05,180
下面我们来看一下呢

266
00:14:05,180 --> 00:14:08,080
关于优化分布的题型

267
00:14:08,080 --> 00:14:12,350
这类题型近几年在软件设计师考试呢

268
00:14:12,350 --> 00:14:14,740
已经出现的比较少了

269
00:14:14,740 --> 00:14:18,460
还是呢，要求大家了解一下它的分析过程

270
00:14:18,460 --> 00:14:20,690
这道题技巧性比较强

271
00:14:20,690 --> 00:14:22,310
但是听懂了之后啊

272
00:14:22,310 --> 00:14:25,380
这类问题的难度呢，并不是很大

273
00:14:25,380 --> 00:14:27,620
首先看到，假设呢

274
00:14:27,620 --> 00:14:29,840
某磁盘的每个磁道啊

275
00:14:29,840 --> 00:14:32,220
都可以划分成11个物理块

276
00:14:32,220 --> 00:14:35,080
每个块呢，都存放了一个逻辑记录

277
00:14:35,080 --> 00:14:37,560
那它相应的这些逻辑记录啊

278
00:14:37,560 --> 00:14:39,440
都在同一个磁道上

279
00:14:39,440 --> 00:14:41,540
要不要考虑寻道时间呢

280
00:14:41,540 --> 00:14:42,300
不需要了

281
00:14:42,300 --> 00:14:44,210
因为没有跨越此道

282
00:14:44,210 --> 00:14:46,190
存放顺序如下

283
00:14:46,190 --> 00:14:48,370
那物理块的顺序1~10

284
00:14:48,370 --> 00:14:51,570
对应逻辑记录呢，0~10

285
00:14:51,570 --> 00:14:57,800
那现在如果磁盘旋转周期是33 ms 

286
00:14:57,800 --> 00:15:00,970
那我们想一想，一周33 ms 

287
00:15:00,970 --> 00:15:03,740
那一周一共有多少个记录啊

288
00:15:03,740 --> 00:15:06,770
一个磁道只有11个记录吧

289
00:15:06,770 --> 00:15:09,180
它是匀速转动的

290
00:15:09,180 --> 00:15:11,720
所以每一个数据块

291
00:15:11,720 --> 00:15:17,580
它的转动时间都是33 ms 除以11的

292
00:15:18,220 --> 00:15:20,940
这个时间是固定的

293
00:15:20,940 --> 00:15:25,820
那当前磁头呢，是处于二零的开始位置

294
00:15:25,820 --> 00:15:29,210
若系统啊，使用单缓冲区，诶

295
00:15:29,210 --> 00:15:33,570
出现了单缓冲区的顺序来处理这些记录

296
00:15:33,570 --> 00:15:37,380
每个记录的处理时间是3 ms 

297
00:15:37,380 --> 00:15:39,520
诶，感觉是不是有点熟悉啊

298
00:15:39,520 --> 00:15:42,890
跟我们刚刚计算的3 ms 其实是一样的

299
00:15:42,890 --> 00:15:45,510
那我们这个处理11个记录的

300
00:15:45,510 --> 00:15:47,840
最长时间是多少呢

301
00:15:47,840 --> 00:15:49,700
我们先来看一下

302
00:15:49,700 --> 00:15:52,140
简单的，诶，出发

303
00:15:52,140 --> 00:15:55,790
首先从二零的起始位置

304
00:15:55,790 --> 00:15:59,590
那我们现在要读二零怎么读

305
00:15:59,590 --> 00:16:02,200
转动的过程就是读的过程

306
00:16:02,200 --> 00:16:04,640
那转完一个数据

307
00:16:04,640 --> 00:16:06,510
就是读完一个数据块吧

308
00:16:06,510 --> 00:16:08,810
此时时间是多少

309
00:16:08,810 --> 00:16:11,550
针对二零来看

310
00:16:11,720 --> 00:16:16,960
读的时间其实就是33 ms 除以三

311
00:16:16,960 --> 00:16:18,780
除以11个数据块吧

312
00:16:18,780 --> 00:16:20,720
3 ms 的时间

313
00:16:21,030 --> 00:16:23,070
那读完了之后

314
00:16:23,070 --> 00:16:25,510
我们读到缓冲区

315
00:16:25,510 --> 00:16:28,180
使用缓冲区来处理

316
00:16:28,180 --> 00:16:30,690
这个处理时间是多少呢

317
00:16:30,690 --> 00:16:32,860
还是3 ms 

318
00:16:32,860 --> 00:16:36,910
那我们能不能同时往缓冲区读 R 1呀

319
00:16:36,910 --> 00:16:37,650
不能

320
00:16:37,650 --> 00:16:42,270
那我们只能呢，读加上处理3 ms 

321
00:16:43,130 --> 00:16:47,150
这个处理完了才会呢，看 R 1

322
00:16:47,150 --> 00:16:51,560
那这个处理 I 0需要3 ms 的话

323
00:16:51,560 --> 00:16:55,100
磁盘的磁头会不会停下来

324
00:16:55,340 --> 00:16:57,140
并不会停下来

325
00:16:57,140 --> 00:17:00,490
磁盘会持续地匀速转动

326
00:17:00,490 --> 00:17:05,420
所以此时磁头并不在二零结束位置

327
00:17:05,420 --> 00:17:08,810
而是在 I 1的结束位置

328
00:17:08,810 --> 00:17:11,250
这个点大家理解之后啊

329
00:17:11,250 --> 00:17:15,420
基本上呢，前面这一空大家呢就能够理解了

330
00:17:15,420 --> 00:17:18,050
因为处理完 R 0的时候

331
00:17:18,050 --> 00:17:22,119
磁头已经到了 R 1的结束位置了

332
00:17:22,119 --> 00:17:26,510
那 R 1要想开始读怎么办

333
00:17:26,510 --> 00:17:30,570
旋转延迟时间多少呢

334
00:17:30,570 --> 00:17:33,920
从 R 1的结束到 R 1的开始

335
00:17:33,920 --> 00:17:36,160
正式呢，十个数据

336
00:17:36,160 --> 00:17:38,890
也就是30 ms 的时间吧

337
00:17:38,890 --> 00:17:43,070
再加上读 R 1本身的时间

338
00:17:43,070 --> 00:17:46,390
也就是呢，33 ms 

339
00:17:46,900 --> 00:17:50,650
同样处理时间3 ms 

340
00:17:50,650 --> 00:17:53,820
处理完 R 1我们的磁头在哪

341
00:17:53,820 --> 00:17:56,630
在 R 2的结束位置吧

342
00:17:56,630 --> 00:18:01,580
那我接下来逻辑上连续必须连续去处理呀

343
00:18:01,580 --> 00:18:05,340
所以接下来处理 R 2怎么办诶

344
00:18:05,340 --> 00:18:12,590
旋转延迟时间加上读取时间33 ms 

345
00:18:12,590 --> 00:18:15,890
再加上处理时间3 ms 

346
00:18:15,890 --> 00:18:17,910
那依此类推

347
00:18:17,910 --> 00:18:22,470
二、三、二四、二、5~20都是这个样子吧

348
00:18:23,390 --> 00:18:25,190
那我们会发现

349
00:18:25,190 --> 00:18:27,300
除了二零以外

350
00:18:27,300 --> 00:18:31,230
剩下的 R 1到20的时间都是

351
00:18:31,230 --> 00:18:33,390
33+3吧

352
00:18:33,390 --> 00:18:37,130
那这个时间乘以十就是呢

353
00:18:37,130 --> 00:18:39,270
1~10的处理时间

354
00:18:39,270 --> 00:18:39,630
哎

355
00:18:39,630 --> 00:18:41,120
应该是360

356
00:18:41,120 --> 00:18:44,230
再加上二零的时间6 ms 

357
00:18:44,230 --> 00:18:47,930
就是呢，366 ms 

358
00:18:47,930 --> 00:18:51,470
那这是我们啊，平常的处理情况

359
00:18:51,470 --> 00:18:52,890
那我们会发现

360
00:18:52,890 --> 00:18:55,090
这里面很大一部分的时

361
00:18:55,090 --> 00:18:56,630
都浪费在哪里啊

362
00:18:56,630 --> 00:18:58,890
旋转延迟的时间了吧

363
00:18:58,890 --> 00:19:02,710
能不能把旋转延迟给抛弃掉呢

364
00:19:02,710 --> 00:19:03,720
那我们呢

365
00:19:03,720 --> 00:19:05,660
唉，在第二问的时

366
00:19:05,660 --> 00:19:09,410
可以呢，对信息存储进行优化分布

367
00:19:09,410 --> 00:19:13,210
也就是说数据块的位置我们可以打乱了

368
00:19:13,210 --> 00:19:16,330
哎，只要呢，让结果更小一些

369
00:19:16,330 --> 00:19:18,990
处理时间更少一些就行

370
00:19:18,990 --> 00:19:22,820
那我希望它不再出现旋转延迟吧

371
00:19:22,820 --> 00:19:25,840
那我不想要旋转延迟的话

372
00:19:25,840 --> 00:19:29,220
如何来放置数据块的位置呢

373
00:19:29,540 --> 00:19:32,620
首先处理完二零之后

374
00:19:32,620 --> 00:19:35,300
我希望接下来是 I 1

375
00:19:35,300 --> 00:19:37,450
那读完 R 1

376
00:19:37,450 --> 00:19:38,570
处理完 R 1

377
00:19:38,570 --> 00:19:40,670
我希望它是 R 2

378
00:19:40,670 --> 00:19:42,120
那读完 R 2

379
00:19:42,120 --> 00:19:43,180
处理完 R 2

380
00:19:43,180 --> 00:19:46,980
我希望是 R 3、 R 4、 R 5

381
00:19:46,980 --> 00:19:49,560
那此时转了多久啊

382
00:19:49,560 --> 00:19:52,680
读完 R 5处理完啊

383
00:19:52,680 --> 00:19:56,100
五应该是一圈多一些吧

384
00:19:56,100 --> 00:19:57,700
结束了吗

385
00:19:57,700 --> 00:19:58,750
没有

386
00:19:58,750 --> 00:20:02,480
所以接下来我们 R 5读完、处理

387
00:20:02,480 --> 00:20:07,930
放的是 R 6、 R 7、 R 8、 R 9、 R 1

388
00:20:07,930 --> 00:20:09,520
到20

389
00:20:09,520 --> 00:20:11,280
读完处理完

390
00:20:11,280 --> 00:20:12,580
我们会发现

391
00:20:12,580 --> 00:20:17,140
它非常巧合地回到了我们的起点

392
00:20:17,140 --> 00:20:21,410
那回到起点它是转了几圈啊

393
00:20:21,410 --> 00:20:24,060
刚好转了两圈

394
00:20:24,060 --> 00:20:25,120
所以啊

395
00:20:25,120 --> 00:20:28,660
这个时候它就形成了一个呢

396
00:20:28,660 --> 00:20:30,400
很巧妙的分布

397
00:20:30,400 --> 00:20:32,190
结果可以呢

398
00:20:32,190 --> 00:20:36,670
通过两圈将所有的数据块读完、处

399
00:20:36,670 --> 00:20:40,910
快处理完一圈时间33 ms 

400
00:20:40,910 --> 00:20:43,390
两圈时间就是呢

401
00:20:43,390 --> 00:20:45,160
66 ms 

402
00:20:45,160 --> 00:20:48,370
那这就是呢，优化分布之后啊

403
00:20:48,370 --> 00:20:51,050
对数据的处理时间

404
00:20:51,250 --> 00:20:53,870
有些同学可能会考虑，诶

405
00:20:53,870 --> 00:20:56,430
那会不会处理时间变成4 ms 

406
00:20:56,430 --> 00:20:57,560
5 ms 了

407
00:20:57,560 --> 00:21:00,430
这里啊，一定是一个成倍的关系

408
00:21:00,430 --> 00:21:02,990
才会让大家去进行计算

409
00:21:02,990 --> 00:21:07,440
毕竟我们考的是相应的知识理论

410
00:21:07,440 --> 00:21:10,600
并不是让大家呢，去做一些呃

411
00:21:10,600 --> 00:21:12,990
非常变态的计算问题啊

412
00:21:12,990 --> 00:21:16,490
所以呢，了解到这种啊，处理顺

413
00:21:16,490 --> 00:21:19,730
以及呢，优化分布之后它的好处

414
00:21:19,730 --> 00:21:23,740
那这种题型呢，基本上就没有问题了

415
00:21:23,740 --> 00:21:26,310
就是呢，关于磁盘管理

416
00:21:26,310 --> 00:21:30,760
需要大家呢掌握的一些内容和考察的题型

417
00:21:30,760 --> 00:21:32,200
大家回去之后呢

418
00:21:32,200 --> 00:21:33,260
可以自己啊

419
00:21:33,260 --> 00:21:35,800
再做一些题目巩固一下
