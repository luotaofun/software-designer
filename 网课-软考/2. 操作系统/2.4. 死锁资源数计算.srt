1
00:00:00,000 --> 00:00:04,030
下面我们来看一下死锁资源数的计算

2
00:00:04,030 --> 00:00:05,940
死锁资源数计算啊

3
00:00:05,940 --> 00:00:09,140
在我们的软件设计师考试当中呢

4
00:00:09,140 --> 00:00:11,480
考察的唉，有一定的频率

5
00:00:11,480 --> 00:00:12,780
但是呢，不太多

6
00:00:12,780 --> 00:00:15,730
一般会考到一分左右的分值

7
00:00:15,730 --> 00:00:18,300
那我们在这里会给大家介绍到

8
00:00:18,300 --> 00:00:20,080
死锁的一些概念内容

9
00:00:20,080 --> 00:00:24,080
然后呢，带大家看一下死所计算的模型

10
00:00:24,080 --> 00:00:27,580
帮助大家呢，来掌握这类计算题

11
00:00:27,580 --> 00:00:31,370
首先我们来看一下什么是死锁问题

12
00:00:31,370 --> 00:00:33,180
所谓的死锁啊

13
00:00:33,180 --> 00:00:35,340
它是指两个以上的进程

14
00:00:35,340 --> 00:00:39,650
它们相互呢，都要求对方已经占用的资源

15
00:00:39,650 --> 00:00:42,000
导致呢，没办法持续下去了

16
00:00:42,000 --> 00:00:43,700
没办法运行下去了

17
00:00:43,700 --> 00:00:45,980
从而呢，就产生了死锁

18
00:00:45,980 --> 00:00:47,840
对于死锁的产生啊

19
00:00:47,840 --> 00:00:49,200
它有四大条件

20
00:00:49,200 --> 00:00:52,400
这四大条件都是必不可少的

21
00:00:52,400 --> 00:00:55,060
那第一个条件呢，是互斥

22
00:00:55,060 --> 00:00:56,650
什么是互斥呢

23
00:00:56,650 --> 00:00:59,200
我们为什么会形成死锁

24
00:00:59,200 --> 00:01:00,900
因为对于进程

25
00:01:00,900 --> 00:01:02,700
对于资源的访问啊

26
00:01:02,700 --> 00:01:05,830
进程呢，同一时刻只能让一个进程用

27
00:01:05,830 --> 00:01:08,490
其他进程必须排队去等

28
00:01:08,490 --> 00:01:10,150
那这个过程当中

29
00:01:10,150 --> 00:01:12,590
互斥所对应的反义词呢

30
00:01:12,590 --> 00:01:13,770
应该是说共享

31
00:01:13,770 --> 00:01:15,780
如果一个资源是共享的

32
00:01:15,780 --> 00:01:17,160
大家就不用等了

33
00:01:17,160 --> 00:01:19,270
也不会呢有思索了

34
00:01:19,270 --> 00:01:21,380
比如说呢，大家都呼吸空气

35
00:01:21,380 --> 00:01:24,520
没有说让人等着排队来呼吸吧

36
00:01:24,520 --> 00:01:26,940
所以大家呢，同一片天空下

37
00:01:26,940 --> 00:01:28,500
大家一起来呼吸

38
00:01:28,500 --> 00:01:30,840
是不会呢产生死锁

39
00:01:30,840 --> 00:01:32,360
憋死人的问题了

40
00:01:32,360 --> 00:01:33,550
所以在这里啊

41
00:01:33,550 --> 00:01:36,500
互斥呢，是死锁的第一个条件

42
00:01:36,500 --> 00:01:39,340
如果推翻了互斥条件的话

43
00:01:39,340 --> 00:01:42,280
那死锁也会呢，不复存在

44
00:01:42,280 --> 00:01:45,620
第二个条件呢，是保持和等待

45
00:01:45,620 --> 00:01:47,620
对于进程来说啊

46
00:01:47,620 --> 00:01:49,840
它占据了资源之后

47
00:01:49,840 --> 00:01:51,360
一旦给他分配

48
00:01:51,360 --> 00:01:53,220
他就不会放弃

49
00:01:53,220 --> 00:01:54,870
如果资源不够

50
00:01:54,870 --> 00:01:56,770
它会持续等待

51
00:01:56,770 --> 00:01:59,430
所以才会呢，形成死锁

52
00:01:59,430 --> 00:02:02,470
如果打破这个条件

53
00:02:02,490 --> 00:02:05,490
一旦自己资源不足的话

54
00:02:05,490 --> 00:02:07,770
就放弃手上的工作了

55
00:02:07,770 --> 00:02:09,930
哎，比如说我拼积木的时候

56
00:02:09,930 --> 00:02:11,760
就差一个正方形了

57
00:02:11,760 --> 00:02:13,130
怎么都拿不到

58
00:02:13,130 --> 00:02:14,450
那我呢，等了一会儿

59
00:02:14,450 --> 00:02:15,170
我不想等

60
00:02:15,170 --> 00:02:16,130
我就放弃了

61
00:02:16,130 --> 00:02:17,610
把所有的积木呢

62
00:02:17,610 --> 00:02:20,140
就还给了共享中心，诶

63
00:02:20,140 --> 00:02:21,880
给资源分配中心去了

64
00:02:21,880 --> 00:02:24,240
那大家呢，就可以拿到一些资

65
00:02:24,240 --> 00:02:26,310
继续去进行分配了吧

66
00:02:26,310 --> 00:02:28,420
所以，保持和等待啊

67
00:02:28,420 --> 00:02:32,080
也是呢，形成死锁的 A 4大条件之一

68
00:02:32,080 --> 00:02:35,500
一旦打破保持和等待也可以呢

69
00:02:35,500 --> 00:02:36,860
避免死锁

70
00:02:36,860 --> 00:02:39,210
第三个条件，不剥夺

71
00:02:39,210 --> 00:02:41,510
跟我们的保持等待相反呢

72
00:02:41,510 --> 00:02:43,730
那我呢，在拼积木的时

73
00:02:43,730 --> 00:02:45,210
就差一个正方形

74
00:02:45,210 --> 00:02:46,170
我就完成了

75
00:02:46,170 --> 00:02:47,520
那怎么办呢

76
00:02:47,520 --> 00:02:48,400
我不够

77
00:02:48,400 --> 00:02:50,520
那我去抢其他小朋友的啊

78
00:02:50,520 --> 00:02:51,880
不能欺负小朋友啊

79
00:02:51,880 --> 00:02:53,370
那我们在这里呢

80
00:02:53,370 --> 00:02:56,590
如果可以剥夺别人的资源

81
00:02:56,590 --> 00:02:59,890
也能够让自己的进程啊，成功完成

82
00:02:59,890 --> 00:03:02,410
从而呢，避免死锁问题

83
00:03:02,410 --> 00:03:03,670
不剥夺呢

84
00:03:03,670 --> 00:03:06,690
也是死锁的四大条件之一

85
00:03:06,690 --> 00:03:07,390
注意啊

86
00:03:07,390 --> 00:03:10,190
曾经呢，在考试当中不一定是软设啊

87
00:03:10,190 --> 00:03:12,190
其他科目当中也出现过

88
00:03:12,190 --> 00:03:14,130
那对于四大条件

89
00:03:14,130 --> 00:03:16,090
给大家一个剥夺条件

90
00:03:16,090 --> 00:03:18,420
它是不是死所形成的条件啊

91
00:03:18,420 --> 00:03:20,730
不是因为不剥夺

92
00:03:20,730 --> 00:03:22,790
所以呢，才会思索

93
00:03:22,790 --> 00:03:26,570
这里呢，注意一下第四个条件

94
00:03:26,570 --> 00:03:27,670
环路等待

95
00:03:27,670 --> 00:03:29,230
什么是环路啊

96
00:03:29,230 --> 00:03:31,480
环路是一个币圈

97
00:03:31,480 --> 00:03:33,130
唉，我等着张三

98
00:03:33,130 --> 00:03:34,390
张三等着我

99
00:03:34,390 --> 00:03:36,450
那我们形成了一个闭环

100
00:03:36,450 --> 00:03:38,430
那我等着你的正方形

101
00:03:38,430 --> 00:03:40,090
你等着我的三角形

102
00:03:40,090 --> 00:03:42,570
那这个过程当中死抱着不放手

103
00:03:42,570 --> 00:03:45,120
那我们现在呢，就会形成死锁

104
00:03:45,120 --> 00:03:47,550
如果说破坏了环路

105
00:03:47,550 --> 00:03:49,850
由第三方来介入了

106
00:03:49,850 --> 00:03:51,410
唉，我们在这里呢

107
00:03:51,410 --> 00:03:53,350
有另外一个同学

108
00:03:53,350 --> 00:03:55,190
他有一个呢，新的积木

109
00:03:55,190 --> 00:03:57,130
或者呢，有新的资源释放

110
00:03:57,130 --> 00:04:00,000
那我们等待不是相互等待的话

111
00:04:00,000 --> 00:04:03,400
别人成功完成也会把资源释放出来

112
00:04:03,400 --> 00:04:06,550
从而呢，打破我们的死锁情况

113
00:04:06,550 --> 00:04:08,470
所以环路等待啊

114
00:04:08,470 --> 00:04:11,340
也是死锁的四大条件之一

115
00:04:11,340 --> 00:04:14,420
那这四大条件同时满足

116
00:04:14,420 --> 00:04:16,019
才会形成死锁

117
00:04:16,019 --> 00:04:19,820
打破任意条件都可以避免死锁

118
00:04:19,820 --> 00:04:22,440
所以死锁的处理当中啊

119
00:04:22,440 --> 00:04:24,400
如果要预防死锁

120
00:04:24,400 --> 00:04:26,830
可以呢打破四大条件

121
00:04:26,830 --> 00:04:30,480
那可以呢有序地去分配资源

122
00:04:30,480 --> 00:04:34,710
当某一个诶进程它需要一些资源的话

123
00:04:34,710 --> 00:04:36,940
我先给 PE 1进程分配

124
00:04:36,940 --> 00:04:39,220
P 1用完了再给 P 2去分配

125
00:04:39,220 --> 00:04:41,960
就叫做呢有序资源分配的方式

126
00:04:41,960 --> 00:04:42,960
第二种呢

127
00:04:42,960 --> 00:04:44,420
哎，静态资源分配

128
00:04:44,420 --> 00:04:45,020
就是呢

129
00:04:45,020 --> 00:04:49,240
根据已已知的需要的资源数来进行分配

130
00:04:49,240 --> 00:04:51,380
可以避免死锁

131
00:04:51,910 --> 00:04:54,410
那死锁它的避免的话

132
00:04:54,410 --> 00:04:57,550
一般呢，是从四大条件以外来考虑的

133
00:04:57,550 --> 00:05:02,030
可以呢，通过银行家算法来解决思索问题

134
00:05:02,030 --> 00:05:03,550
它还可以啊

135
00:05:03,550 --> 00:05:06,270
利用一些呢，软件方式来检测

136
00:05:06,270 --> 00:05:10,490
然后呢，人工的人为的去解除死锁

137
00:05:10,490 --> 00:05:13,010
最后呢，可以不予理睬啊

138
00:05:13,010 --> 00:05:14,850
鸵鸟策略不予理睬

139
00:05:14,850 --> 00:05:16,480
这种情况下呢

140
00:05:16,480 --> 00:05:19,300
在某些状况下也可以呢

141
00:05:19,300 --> 00:05:20,990
将死锁问题解决掉

142
00:05:20,990 --> 00:05:24,800
它在整个不予理睬的过程当中啊

143
00:05:24,800 --> 00:05:27,330
时间长了可以等到一些呢

144
00:05:27,330 --> 00:05:28,850
其他的资源释放

145
00:05:28,850 --> 00:05:31,170
从而呢，得到一个呢，诶

146
00:05:31,170 --> 00:05:33,150
解决死锁的方案

147
00:05:33,150 --> 00:05:35,920
那这是死锁的处理过程

148
00:05:35,920 --> 00:05:39,660
我们在资源进行分配的时候啊

149
00:05:39,660 --> 00:05:42,150
它本身呢，有一定的特点

150
00:05:42,150 --> 00:05:45,440
进程是资源分配和调度的单位

151
00:05:45,440 --> 00:05:47,900
并且是独立占有资源

152
00:05:47,900 --> 00:05:49,940
独立拥有资源的单位

153
00:05:49,940 --> 00:05:52,680
一旦进程执行完成了

154
00:05:52,680 --> 00:05:54,880
它所独立占有的资源啊

155
00:05:54,880 --> 00:05:56,650
会释放出去

156
00:05:56,650 --> 00:06:00,000
所以我们在进行资源分配考虑的时候

157
00:06:00,000 --> 00:06:00,740
就是呢

158
00:06:00,740 --> 00:06:04,620
让某一些进程完成之后把资源释放出去

159
00:06:04,620 --> 00:06:09,030
从而让其他进程也可以拿到一些资源

160
00:06:09,030 --> 00:06:10,890
从而呢，执行下去

161
00:06:10,890 --> 00:06:14,140
直到将所有进程执行完成

162
00:06:14,140 --> 00:06:14,940
啊

163
00:06:14,940 --> 00:06:17,620
那进程管理它本身呢

164
00:06:17,620 --> 00:06:20,970
就是对我们进程的调度来进行管理

165
00:06:20,970 --> 00:06:22,760
如果说涉及不当

166
00:06:22,760 --> 00:06:25,320
可能呢，就形成了四大条件

167
00:06:25,320 --> 00:06:28,490
然后呢，产生了死锁这个过程

168
00:06:28,490 --> 00:06:30,730
进程等待一件不可能的事情

169
00:06:30,730 --> 00:06:32,550
对于系统来说的话

170
00:06:32,550 --> 00:06:36,060
诶，它耗费的时间、资源就会比较多

171
00:06:36,060 --> 00:06:38,660
那很多都是呢，站着不用

172
00:06:38,660 --> 00:06:41,450
相对来说呢，还是比较浪费的

173
00:06:41,450 --> 00:06:44,170
那我们如何来进行设计呢

174
00:06:44,170 --> 00:06:46,150
这里啊，涉及到一个呢

175
00:06:46,150 --> 00:06:48,880
死锁资源数的计算问题

176
00:06:48,880 --> 00:06:53,950
我们需要考虑系统在什么样的情况下会死锁

177
00:06:53,950 --> 00:06:57,630
什么样的情况下不可能发生死锁

178
00:06:57,630 --> 00:06:59,500
下面我们来看一个例子

179
00:06:59,500 --> 00:07:02,980
假设现在系统当中啊，有五个进程

180
00:07:02,980 --> 00:07:04,060
a 、 b 、 c 、 d 、 e 

181
00:07:04,060 --> 00:07:08,020
那这五个进程都需要四个系统资源

182
00:07:08,020 --> 00:07:12,030
如果系统当中至少有多少个资源的时候

183
00:07:12,030 --> 00:07:14,470
系统不可能发生死锁呢

184
00:07:14,470 --> 00:07:18,100
唉，假设我们现在有 N 个资源的话

185
00:07:18,100 --> 00:07:20,790
假设系统当中有 N 个资源

186
00:07:20,790 --> 00:07:23,010
以一个表格的形式来看

187
00:07:23,010 --> 00:07:27,600
我们这里呢有 ABCD 、 E 5个进程

188
00:07:27,600 --> 00:07:30,440
每个进程都需要四个资源

189
00:07:30,440 --> 00:07:33,140
那在资源分配的过程当中

190
00:07:33,140 --> 00:07:34,880
我们一个一个来尝试

191
00:07:34,880 --> 00:07:38,690
如果说啊，给 A 分配一个资源

192
00:07:38,690 --> 00:07:40,850
两个资源、三个资源

193
00:07:40,850 --> 00:07:44,940
在此时 N 等于三的情况下

194
00:07:44,940 --> 00:07:48,140
系统能不能完成某一个进程啊

195
00:07:48,140 --> 00:07:52,150
不可能，它不足以支持任何一个进程

196
00:07:52,150 --> 00:07:55,760
所以 N 小于四的时候

197
00:07:55,760 --> 00:07:59,220
此时系统一定死锁

198
00:08:02,390 --> 00:08:03,930
有没有例外

199
00:08:03,930 --> 00:08:04,970
没有例外

200
00:08:04,970 --> 00:08:08,890
它不足以支持任何一个进程完成

201
00:08:08,890 --> 00:08:14,320
那如果在这个基础上额外增加一个资源呢

202
00:08:14,320 --> 00:08:16,350
那在这种情况下

203
00:08:16,350 --> 00:08:21,360
有可能让系统完成某一个进程

204
00:08:21,360 --> 00:08:23,080
从而呢释放资

205
00:08:23,080 --> 00:08:27,510
再分配给第二个、第三个、第四个、第五个进程吧

206
00:08:27,510 --> 00:08:28,690
也就是说

207
00:08:28,690 --> 00:08:32,370
当 N 大于等于四的情况下

208
00:08:32,370 --> 00:08:35,370
它可能会避免死锁

209
00:08:42,700 --> 00:08:46,480
是不是一定能避免呢

210
00:08:46,480 --> 00:08:47,500
并不是

211
00:08:47,500 --> 00:08:49,580
分配给某一个进程

212
00:08:49,580 --> 00:08:52,240
是其中一种分配方案吧

213
00:08:52,240 --> 00:08:54,920
还有其他的分配方案

214
00:08:54,920 --> 00:08:56,950
比如说呢，大家考虑一下

215
00:08:56,950 --> 00:08:59,550
这是最乐观的分配情况

216
00:08:59,550 --> 00:09:02,060
最悲观的分配情况是什么啊

217
00:09:02,060 --> 00:09:06,770
这四个资源平均分配给了 ABCD 

218
00:09:06,980 --> 00:09:10,720
每一个进程到手的只有一个资源吧

219
00:09:10,720 --> 00:09:13,300
那此时会产生什么情况呢

220
00:09:13,300 --> 00:09:15,630
哎，可能会死锁

221
00:09:15,630 --> 00:09:18,640
所以 N 大于等于四的时

222
00:09:18,640 --> 00:09:20,140
可能避免死锁

223
00:09:20,140 --> 00:09:23,080
也可能形成死锁

224
00:09:23,190 --> 00:09:26,210
在这个四个资源的基础

225
00:09:26,210 --> 00:09:27,170
再来看的话

226
00:09:27,170 --> 00:09:28,330
五个资源

227
00:09:28,330 --> 00:09:32,920
六、七、八、九、十、11、12、13、14、1

228
00:09:32,920 --> 00:09:34,920
都是这种情况吧

229
00:09:34,920 --> 00:09:36,780
最悲观的情况

230
00:09:36,780 --> 00:09:40,400
每一个进程都缺一个资源

231
00:09:40,400 --> 00:09:42,570
并且缺的是，诶

232
00:09:42,570 --> 00:09:45,970
当前五个进程手上的这一个资源

233
00:09:45,970 --> 00:09:49,390
那这个情况浪费就比较大了

234
00:09:49,390 --> 00:09:55,100
此时我们的资源数是小于等于15的

235
00:09:55,100 --> 00:09:59,210
那这种情况下同样可能形成死锁

236
00:09:59,210 --> 00:10:01,340
可能呢，避免死锁

237
00:10:01,340 --> 00:10:04,220
也就是说在4~15之间啊

238
00:10:04,220 --> 00:10:06,740
他的状况其实是一样的

239
00:10:06,740 --> 00:10:08,860
并不能百分百避免

240
00:10:08,860 --> 00:10:10,990
思索什么样的情况下

241
00:10:10,990 --> 00:10:13,250
可以百分百避免死锁呢

242
00:10:13,250 --> 00:10:17,430
在此基础上额外增加一个资源

243
00:10:17,430 --> 00:10:21,080
这个资源无论给哪一个进程

244
00:10:21,080 --> 00:10:24,110
都能让我们的进程执行完成吧

245
00:10:24,110 --> 00:10:28,330
从而释放出资源给其他进程

246
00:10:28,330 --> 00:10:31,160
那这个情况就是属于呢

247
00:10:31,160 --> 00:10:34,720
N 在15+1的基础上

248
00:10:35,190 --> 00:10:38,770
只要它超过了15+1

249
00:10:38,770 --> 00:10:42,070
那它不可能形成死锁了

250
00:10:45,280 --> 00:10:47,680
所以我们在这里呀

251
00:10:47,680 --> 00:10:52,090
可以将资源数分成了三个范围

252
00:10:52,090 --> 00:10:53,410
第一个范围

253
00:10:53,410 --> 00:10:58,900
当资源小于每个进程所需的资源数的时候

254
00:10:58,900 --> 00:11:01,620
唉，每个进程需要四个资源的话

255
00:11:01,620 --> 00:11:04,000
当资源数小于四

256
00:11:04,000 --> 00:11:06,160
它是必定死锁的

257
00:11:06,160 --> 00:11:07,420
没办法避免

258
00:11:07,420 --> 00:11:10,470
那如果资源数到了四个

259
00:11:10,470 --> 00:11:13,130
那他呢，可能分配给一个进程

260
00:11:13,130 --> 00:11:15,450
从而呢，支持进程的执行吧

261
00:11:15,450 --> 00:11:18,340
也有可能呢，诶，平均分配了

262
00:11:18,340 --> 00:11:20,220
所以是可能死锁

263
00:11:20,220 --> 00:11:22,770
也可能避免死锁的情况

264
00:11:22,770 --> 00:11:24,500
到哪里结束呢

265
00:11:24,500 --> 00:11:27,840
诶，到我们15个资源结束

266
00:11:27,840 --> 00:11:32,140
15是最悲宽平均分配的情况吧

267
00:11:32,140 --> 00:11:34,330
那在这个过程当中呢

268
00:11:34,330 --> 00:11:36,210
是可能死锁

269
00:11:36,210 --> 00:11:38,130
可能正常执行的

270
00:11:38,130 --> 00:11:43,300
只要在15个资源基础上再增加一个资源

271
00:11:43,300 --> 00:11:45,200
它就呢，不可能死锁了

272
00:11:45,200 --> 00:11:46,540
只要超过16

273
00:11:46,540 --> 00:11:48,120
它就不可能死锁

274
00:11:48,120 --> 00:11:50,630
那我们在计算的过程当中啊

275
00:11:50,630 --> 00:11:53,920
其实是可以有一个公式的

276
00:11:53,920 --> 00:11:57,410
不可能死锁的条件是什么呢

277
00:11:57,410 --> 00:11:59,530
如果 M 个进程

278
00:11:59,530 --> 00:12:03,360
每个进程都需要 W 的资源的话

279
00:12:03,360 --> 00:12:06,490
当前最悲观的情况是

280
00:12:06,490 --> 00:12:12,020
每一个进程都已经拿到了 W 减一个资源

281
00:12:12,020 --> 00:12:14,080
在这种情况下

282
00:12:14,080 --> 00:12:16,880
只要额外引入一个资源

283
00:12:16,880 --> 00:12:18,780
就不可能死锁了

284
00:12:18,780 --> 00:12:22,470
所以资源数只要呢大于这个公式

285
00:12:22,470 --> 00:12:25,670
就可以完全的避免死锁

286
00:12:25,670 --> 00:12:27,100
那这就是呢

287
00:12:27,100 --> 00:12:29,340
死锁资源数的计算

288
00:12:29,340 --> 00:12:31,040
大家在考试啊

289
00:12:31,040 --> 00:12:33,890
做题的时候需要注意题目

290
00:12:33,890 --> 00:12:37,880
问你的到底是哪形成死锁的资源数

291
00:12:37,880 --> 00:12:39,540
还是避免死锁

292
00:12:39,540 --> 00:12:42,880
不可能形成死锁的资源数计算

293
00:12:42,880 --> 00:12:44,400
一定要审题

294
00:12:44,400 --> 00:12:47,420
可能呢，会存在这种误导的陷阱

295
00:12:47,420 --> 00:12:50,200
不要呢，看到题目直接呢，就列公式

296
00:12:50,200 --> 00:12:51,820
求了个答案啊

297
00:12:52,200 --> 00:12:55,340
下面呢，我们来看一下，呃

298
00:12:55,340 --> 00:12:56,460
我们的词组

299
00:12:56,460 --> 00:13:00,000
资源数在软件设计师真题当中的体现

300
00:13:00,000 --> 00:13:02,250
某个计算机系统当中啊

301
00:13:02,250 --> 00:13:05,550
互斥资源 R 1共呢，有八个，唉

302
00:13:05,550 --> 00:13:08,640
给了我们总数 N 是等于八的

303
00:13:08,640 --> 00:13:12,680
那现在系统当中有三个进程

304
00:13:12,890 --> 00:13:17,570
每一个进程都需要哪二个资源

305
00:13:17,830 --> 00:13:23,350
该系统可能会发生死锁的最小 I 值是什么

306
00:13:23,350 --> 00:13:27,120
注意，这里问的是会发生死锁

307
00:13:27,120 --> 00:13:28,620
那我们首先呢

308
00:13:28,620 --> 00:13:33,140
可以尝试将选项代入进去去计算

309
00:13:33,140 --> 00:13:37,880
那如果每个进程，三个进程

310
00:13:37,880 --> 00:13:42,100
每个进程都需要一个资源

311
00:13:42,100 --> 00:13:46,280
那此时三个进程1+1加一，诶

312
00:13:46,280 --> 00:13:48,770
只要有三个资源就够用了吧

313
00:13:48,770 --> 00:13:51,000
所以这里会不会发生死锁

314
00:13:51,000 --> 00:13:52,740
不可能死锁

315
00:13:52,740 --> 00:13:56,080
那 B 选项 I 等于二的话

316
00:13:56,080 --> 00:13:59,590
三个进程 I 等于二

317
00:13:59,590 --> 00:14:03,790
那2+2加二只需要六个资源

318
00:14:03,790 --> 00:14:05,350
就足够支撑了吧

319
00:14:05,350 --> 00:14:08,230
所以它也不可能死锁

320
00:14:08,390 --> 00:14:10,070
再来看，哎

321
00:14:10,070 --> 00:14:14,690
如果说三个资源 I 等于三的话

322
00:14:14,690 --> 00:14:19,360
3+3加三看起来好像不够啊

323
00:14:19,360 --> 00:14:22,220
八个资源不够平均分配呀

324
00:14:22,220 --> 00:14:23,760
但是注意啊

325
00:14:23,760 --> 00:14:26,460
我们在分配的过程当中

326
00:14:26,460 --> 00:14:30,320
可以得到3+3加二吧

327
00:14:31,640 --> 00:14:34,880
那八拆成3+3加二

328
00:14:34,880 --> 00:14:38,540
我们会发现进程一完成了

329
00:14:38,540 --> 00:14:41,160
所以资源可以释放

330
00:14:41,160 --> 00:14:43,980
然后呢，进程二也完成了

331
00:14:43,980 --> 00:14:45,900
资源也可以释放

332
00:14:45,900 --> 00:14:50,500
进程三缺少的那一个资源还是问题吗

333
00:14:50,500 --> 00:14:52,220
就不是问题了

334
00:14:52,220 --> 00:14:53,580
所以在这里

335
00:14:53,580 --> 00:14:57,640
C 等于三也不可能形成死锁

336
00:14:57,640 --> 00:14:59,710
那只有进程啊

337
00:14:59,710 --> 00:15:04,270
每个进程需要四个资源的时候才可能思索

338
00:15:04,270 --> 00:15:08,920
那这是啊，将选项代入来进行验证

339
00:15:09,220 --> 00:15:13,580
我们同样呢，也可以根据公式来计算

340
00:15:13,580 --> 00:15:15,560
那我们之前的公式呢

341
00:15:15,560 --> 00:15:20,380
是 W 减一乘以 M 加

342
00:15:20,380 --> 00:15:22,380
小于等于 N 

343
00:15:22,380 --> 00:15:24,410
在这个过程当中

344
00:15:24,410 --> 00:15:27,450
I 是一个未知数

345
00:15:27,970 --> 00:15:29,830
多少个进程呢

346
00:15:29,830 --> 00:15:33,590
三个进程加一小于等于八

347
00:15:33,590 --> 00:15:37,490
所以我们可以推导出 I 减一

348
00:15:37,490 --> 00:15:43,370
它是呢小于等于7÷3的

349
00:15:43,570 --> 00:15:44,970
那我们啊

350
00:15:44,970 --> 00:15:47,540
对这个公式接着往下推导

351
00:15:47,540 --> 00:15:49,380
I 是小于，哎

352
00:15:49,380 --> 00:15:51,320
这是二点几吧

353
00:15:51,720 --> 00:15:55,370
所以再加上一就是三点几

354
00:15:55,370 --> 00:15:58,180
那这个公式表示什么含义啊

355
00:15:58,180 --> 00:16:03,420
表示当 I 在小于等于三点几的情况下

356
00:16:03,420 --> 00:16:06,500
它是不可能思索的

357
00:16:06,960 --> 00:16:08,180
注意啊

358
00:16:08,180 --> 00:16:11,860
这个公式求的是不可能死锁

359
00:16:11,860 --> 00:16:15,600
所以 I 等于一不会死锁

360
00:16:15,600 --> 00:16:17,740
I 等于二不会死锁

361
00:16:17,740 --> 00:16:21,160
I 等于三也不会死锁

362
00:16:21,160 --> 00:16:24,720
所以呀，我们根据这个公式求出的是

363
00:16:24,720 --> 00:16:26,360
避免死锁的总数

364
00:16:26,360 --> 00:16:29,160
那把这些呢值求出来之后

365
00:16:29,160 --> 00:16:31,640
只有大于三才会思索

366
00:16:31,640 --> 00:16:34,600
所以这道题呢，选择 D 选项

367
00:16:34,600 --> 00:16:35,930
做题的时候呢

368
00:16:35,930 --> 00:16:39,490
要看清楚题目问的到底是死

369
00:16:39,490 --> 00:16:42,050
还是呢，不会发生死锁

370
00:16:42,050 --> 00:16:43,620
那这一类计算啊

371
00:16:43,620 --> 00:16:45,600
可以呢，直接带公式

372
00:16:45,600 --> 00:16:48,650
也可以呢，尝试平均分配

373
00:16:48,650 --> 00:16:50,660
他的整个思路啊

374
00:16:50,660 --> 00:16:51,740
就是说呢

375
00:16:51,740 --> 00:16:54,170
在资源分配的情况下

376
00:16:54,170 --> 00:16:56,440
最悲观的情况去考虑

377
00:16:56,440 --> 00:16:58,480
解决了最悲观的情

378
00:16:58,480 --> 00:17:00,640
就解决了死锁的问题

379
00:17:00,640 --> 00:17:02,600
那最悲观是

380
00:17:02,600 --> 00:17:06,859
每一个进程都抱着缺少一个资源的情况

381
00:17:06,859 --> 00:17:08,720
来相互等待

382
00:17:08,720 --> 00:17:12,990
将所有进程所需资源减一进行累加

383
00:17:12,990 --> 00:17:17,130
那这个数呢，是可能形成死锁最悲观的情况

384
00:17:17,130 --> 00:17:19,440
所以在此基础上

385
00:17:19,440 --> 00:17:21,720
只要再增加一个资源

386
00:17:21,720 --> 00:17:24,180
就可以百分百避免死锁

387
00:17:24,180 --> 00:17:26,569
不可能产生死锁了

388
00:17:26,569 --> 00:17:30,020
那这些呢，就是要求大家了解到的

389
00:17:30,020 --> 00:17:31,420
所的一些概念

390
00:17:31,420 --> 00:17:35,320
以及呢，掌握的死锁资源数计算问题
