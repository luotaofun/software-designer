1
00:00:00,000 --> 00:00:04,900
接下来，我们来看一下在进程调度当中

2
00:00:04,900 --> 00:00:08,490
信号量与 PV 操作的结合考察

3
00:00:08,490 --> 00:00:11,320
在软件设计师考试当中啊

4
00:00:11,320 --> 00:00:15,030
PV 操作几乎呢，每次考试都会考到

5
00:00:15,030 --> 00:00:18,530
然而它考察的方向呢，会有所不同

6
00:00:18,530 --> 00:00:23,170
其中呢，也有可能会出现信号量与 PV 操作

7
00:00:23,170 --> 00:00:25,480
它的结合分析可以呢

8
00:00:25,480 --> 00:00:28,120
体现在我们的语言描述

9
00:00:28,120 --> 00:00:30,960
或者呢，体现在流程图当中

10
00:00:30,960 --> 00:00:34,250
让大家来判断相应的信号量

11
00:00:34,250 --> 00:00:36,450
哪些是同步信号量

12
00:00:36,450 --> 00:00:38,720
哪些是互斥信号量

13
00:00:38,720 --> 00:00:40,850
他们的初值是多少

14
00:00:40,850 --> 00:00:43,670
给出了一些缺失的位置

15
00:00:43,670 --> 00:00:46,170
让大家呢，补充 PV 操作

16
00:00:46,170 --> 00:00:49,880
从而实现一些合理的进程调度

17
00:00:49,880 --> 00:00:51,580
那这是我们在这里啊

18
00:00:51,580 --> 00:00:54,090
会给大家讲到的内容

19
00:00:54,090 --> 00:00:58,200
下面我们先来看简单的互斥模型

20
00:00:58,200 --> 00:01:01,370
我们前面分析了什么是互斥

21
00:01:01,370 --> 00:01:04,780
互斥它是对临界资源的

22
00:01:04,780 --> 00:01:06,660
诶，一个互斥访问

23
00:01:06,660 --> 00:01:08,340
那访问的时候

24
00:01:08,340 --> 00:01:13,310
要求只能在同一时刻让一个进程访问吧

25
00:01:13,310 --> 00:01:16,120
类似于我们有一个小房间

26
00:01:16,120 --> 00:01:20,340
而同一时刻只能允许一个人在里面

27
00:01:20,340 --> 00:01:21,980
如何来保证呢

28
00:01:21,980 --> 00:01:24,510
进去的时候就把门锁上

29
00:01:24,510 --> 00:01:26,970
那其他人就进不去了

30
00:01:26,970 --> 00:01:31,190
这就是呢， PV 在互斥当中的作用

31
00:01:31,270 --> 00:01:34,310
下面看这个简单的互斥模型

32
00:01:34,310 --> 00:01:39,050
假设呢，多个进程共享了一台打印机

33
00:01:39,050 --> 00:01:44,330
那现在打印机就是典型的临界资源吧

34
00:01:44,330 --> 00:01:48,330
同一时刻只能让一个进程来用

35
00:01:48,330 --> 00:01:50,590
那我们将所有的进程啊

36
00:01:50,590 --> 00:01:52,070
实体化来看的话

37
00:01:52,070 --> 00:01:54,870
假设房间有一台打印机

38
00:01:54,870 --> 00:01:56,980
每个人要打印之前啊

39
00:01:56,980 --> 00:01:59,880
需要进到房间来使用打印机

40
00:01:59,880 --> 00:02:02,160
在这个过程当中

41
00:02:02,160 --> 00:02:05,660
如果没有任意的操作

42
00:02:05,660 --> 00:02:08,139
那进程一使用打印机

43
00:02:08,139 --> 00:02:09,930
然后呢，有后续代码

44
00:02:09,930 --> 00:02:13,340
进程二同时过来使用打印机

45
00:02:13,340 --> 00:02:16,000
然后呢，执行后续代码

46
00:02:16,000 --> 00:02:18,440
那对于临界资源的访问

47
00:02:18,440 --> 00:02:21,040
是不是已经呢，错开

48
00:02:21,040 --> 00:02:24,780
我们对每一个硬件临界资源

49
00:02:24,780 --> 00:02:27,940
它的同一时刻只允许一个人访问啊

50
00:02:27,940 --> 00:02:30,380
那现在很显然出现问题了吧

51
00:02:30,380 --> 00:02:33,560
同一时刻有多个进程在使用打印机了

52
00:02:33,560 --> 00:02:34,530
怎么办呢

53
00:02:34,530 --> 00:02:38,500
唉，我们用之前把资源呢，锁起来

54
00:02:38,500 --> 00:02:40,300
我去打印的时候呢

55
00:02:40,300 --> 00:02:41,520
我就先把打印机

56
00:02:41,520 --> 00:02:43,460
诶，这个房间锁起来

57
00:02:43,460 --> 00:02:45,100
不让大家进去了

58
00:02:45,100 --> 00:02:47,010
如何来锁啊

59
00:02:47,010 --> 00:02:51,200
锁定资源用到的就是 P 操作

60
00:02:51,200 --> 00:02:55,440
所以使用打印机之前先用呢

61
00:02:55,440 --> 00:02:59,160
PS 将资源申请占用

62
00:02:59,160 --> 00:03:01,490
然后呢，加上了锁

63
00:03:01,490 --> 00:03:03,190
用完之后啊

64
00:03:03,190 --> 00:03:05,250
立即呢，就可以解

65
00:03:05,250 --> 00:03:08,000
把打印机释放出去

66
00:03:08,000 --> 00:03:10,230
如果有人在排队的话

67
00:03:10,230 --> 00:03:11,190
还可以呢

68
00:03:11,190 --> 00:03:12,590
通知别人一声吧

69
00:03:12,590 --> 00:03:14,610
诶，我用完了，张三

70
00:03:14,610 --> 00:03:16,430
你过来接着用吧

71
00:03:16,430 --> 00:03:17,360
这就是呢

72
00:03:17,360 --> 00:03:22,780
PV 操作在互斥模型当中的一种呢形式

73
00:03:23,100 --> 00:03:24,960
那我们会发现

74
00:03:24,960 --> 00:03:26,580
针对 PV 来看

75
00:03:26,580 --> 00:03:29,370
它们一定是成对存在的

76
00:03:29,370 --> 00:03:31,560
有枷锁就有解锁

77
00:03:31,560 --> 00:03:35,220
你也不能无缘无故的一直释放资源吧

78
00:03:35,220 --> 00:03:37,340
释放的前提是有呢

79
00:03:37,340 --> 00:03:39,590
枷锁这样的一个过程

80
00:03:39,590 --> 00:03:43,910
所以啊，它们之间一定是成对存在的

81
00:03:43,910 --> 00:03:47,100
那我们现在的信号量 S 是什么呢

82
00:03:47,100 --> 00:03:53,030
唉，这个 S 应该指的是资源、打印机、资源

83
00:03:53,030 --> 00:03:56,110
所以 S 它的初值啊

84
00:03:56,110 --> 00:03:58,310
是打印机的数量

85
00:03:58,310 --> 00:04:02,090
一台打印机初值就是唯一的

86
00:04:02,090 --> 00:04:05,510
如果它有多台打印机

87
00:04:05,510 --> 00:04:07,150
M 台打印机

88
00:04:07,150 --> 00:04:09,880
它的初值呢就是 M 

89
00:04:09,880 --> 00:04:12,560
用在互斥模型当中呢

90
00:04:12,560 --> 00:04:16,790
这种信号量我们也叫做互斥信号量

91
00:04:16,790 --> 00:04:21,399
那我们在互斥的模型当中会发现 PV 操作

92
00:04:21,399 --> 00:04:26,580
它是在某一个进程当中成对存在的

93
00:04:26,580 --> 00:04:31,010
后面我们再来看一下哎，同步模型

94
00:04:31,010 --> 00:04:34,990
同步模型相对就复杂了一些

95
00:04:35,510 --> 00:04:41,090
同步模型会涉及到多个进程之间啊

96
00:04:41,090 --> 00:04:43,680
有一个顺序的协调

97
00:04:43,680 --> 00:04:46,870
那相互之间会协调吧

98
00:04:46,870 --> 00:04:48,850
相互之间的影响

99
00:04:48,850 --> 00:04:52,700
如何控制进程 A 和进程 B 之间

100
00:04:52,700 --> 00:04:55,080
能够很好地实现并发呢

101
00:04:55,080 --> 00:04:57,240
这个就是同步模型

102
00:04:57,240 --> 00:05:01,120
也可以呢，用 PV 操作来实现

103
00:05:01,120 --> 00:05:04,440
那下面是一个典型的同步模型

104
00:05:04,440 --> 00:05:07,140
生产者消费者问题

105
00:05:07,140 --> 00:05:10,460
什么是生产者消费者问题呢

106
00:05:10,460 --> 00:05:16,240
我们啊，在日常生活当中会购买一些产品

107
00:05:16,240 --> 00:05:21,310
那产品的来源是由生产者生产之后

108
00:05:21,310 --> 00:05:23,190
送到市场去的

109
00:05:23,190 --> 00:05:29,210
而每一次购买会从市场当中购买相应的产品

110
00:05:29,210 --> 00:05:30,690
进行消费

111
00:05:30,690 --> 00:05:33,820
就是呢，消费者这个过程啊

112
00:05:33,820 --> 00:05:36,820
就叫做生产者消费者问题

113
00:05:36,820 --> 00:05:40,130
那我们中间是不是有一个过渡的地方

114
00:05:40,130 --> 00:05:41,880
叫做呢，市场

115
00:05:41,880 --> 00:05:45,740
这个市场啊，就是缓冲区

116
00:05:45,740 --> 00:05:50,390
单个空间的缓冲区叫做单缓冲区

117
00:05:50,390 --> 00:05:52,570
会不会有多个空间的呢

118
00:05:52,570 --> 00:05:55,910
也有可以存在多缓冲区

119
00:05:55,910 --> 00:05:59,530
那这里涉及到的单或者多

120
00:05:59,530 --> 00:06:04,540
指的其实是缓冲区的空间资源啊

121
00:06:04,540 --> 00:06:06,760
类似于什么呢

122
00:06:06,760 --> 00:06:10,100
大家平常停车的时候会有停车场

123
00:06:10,100 --> 00:06:11,130
停车位吧

124
00:06:11,130 --> 00:06:14,430
一个停车场有100个停车位

125
00:06:14,430 --> 00:06:18,470
那这个地方就有100个空间资

126
00:06:18,470 --> 00:06:20,920
可以呢，让汽车去使用

127
00:06:20,920 --> 00:06:22,850
那这个时候就是呢

128
00:06:22,850 --> 00:06:26,150
空间为100的缓冲区

129
00:06:26,150 --> 00:06:27,750
如果一个车位啊

130
00:06:27,750 --> 00:06:29,880
只能让一辆车去用

131
00:06:29,880 --> 00:06:34,360
那这一个车位就叫做呢单缓冲区

132
00:06:34,360 --> 00:06:37,520
这是呢，缓冲区的一个意义

133
00:06:37,520 --> 00:06:41,520
那针对生产者和消费者而言

134
00:06:41,520 --> 00:06:45,880
生产者会生产产品送到缓冲区

135
00:06:45,880 --> 00:06:48,930
消费者会取出产品

136
00:06:48,930 --> 00:06:51,020
然后呢进行消费

137
00:06:51,020 --> 00:06:55,160
那如果不做任何限制的话

138
00:06:55,160 --> 00:06:59,590
我们在分析 PV 的时候都是先忽略 PV 

139
00:06:59,590 --> 00:07:02,380
再根据相应的问题

140
00:07:02,380 --> 00:07:06,550
从而呢，添加 PV 来解决问题

141
00:07:06,550 --> 00:07:09,120
涉及到多个进程的时候

142
00:07:09,120 --> 00:07:11,160
我们在分析的时候啊

143
00:07:11,160 --> 00:07:14,400
它的进程并发应该是呢

144
00:07:14,400 --> 00:07:17,120
从任意一个进程先开始

145
00:07:17,120 --> 00:07:20,450
都可以得到相同的结果

146
00:07:20,450 --> 00:07:26,180
那我们假设从生产者进程开始看的话

147
00:07:26,520 --> 00:07:30,280
如果说生产者和消费者并发

148
00:07:30,280 --> 00:07:31,990
我们的脑海里啊

149
00:07:31,990 --> 00:07:35,480
很难去形成一个同步流动的过程吧

150
00:07:35,480 --> 00:07:39,950
但我们现在呢，把它当成先后执行的顺序

151
00:07:39,950 --> 00:07:43,240
相对来说逻辑会更清晰一些

152
00:07:43,240 --> 00:07:46,390
先执行生产者进程的话

153
00:07:46,390 --> 00:07:51,150
那我们生产一个产品送到缓冲区

154
00:07:51,150 --> 00:07:52,470
送完之

155
00:07:52,470 --> 00:07:56,550
接着又生产一个产品送到缓冲区

156
00:07:56,550 --> 00:07:59,120
那现在市场只有一个摊位

157
00:07:59,120 --> 00:08:01,150
只有一个停车位的时候

158
00:08:01,150 --> 00:08:03,750
我们不停地把车子停进去

159
00:08:03,750 --> 00:08:04,870
可不可能啊

160
00:08:04,870 --> 00:08:06,450
会爆仓

161
00:08:06,450 --> 00:08:08,950
所以我们在这个时候啊

162
00:08:08,950 --> 00:08:13,360
每当产品要送到缓冲区之前

163
00:08:13,360 --> 00:08:18,270
一定要先检查这个缓冲区能不能用

164
00:08:18,270 --> 00:08:19,460
也就是说

165
00:08:19,460 --> 00:08:24,360
缓冲区它是否存在空闲的空间资源

166
00:08:24,360 --> 00:08:26,380
让我们来使用吧

167
00:08:26,380 --> 00:08:30,450
如果说，诶，这个产品还没有被拿走的话

168
00:08:30,450 --> 00:08:32,120
单看生产者

169
00:08:32,120 --> 00:08:35,659
我们第二个生产者就会呢，阻塞了

170
00:08:35,659 --> 00:08:39,350
到什么时候才有新的空间资源呢

171
00:08:39,350 --> 00:08:44,000
到消费者将产品取走之后

172
00:08:44,000 --> 00:08:47,430
才会有空间资源的释放吧

173
00:08:47,430 --> 00:08:54,290
那这个过程 PV 操作就存在于两个进程当中

174
00:08:54,290 --> 00:08:55,860
那这种呢

175
00:08:55,860 --> 00:09:01,180
成对的 PV 在不同的进程当中实现成对

176
00:09:01,180 --> 00:09:05,590
从而呢，形成了我们的同步模型

177
00:09:05,590 --> 00:09:10,340
那同样，我们对于消费者来说的话

178
00:09:10,340 --> 00:09:11,720
在这里呀

179
00:09:11,720 --> 00:09:15,680
它也会涉及到相应的资源检查

180
00:09:15,680 --> 00:09:18,960
要分析的过程当中啊

181
00:09:18,960 --> 00:09:22,950
啊，消费者能不能无条件消费

182
00:09:22,950 --> 00:09:23,880
不可能

183
00:09:23,880 --> 00:09:28,200
他必须先检查有没有东西吧

184
00:09:28,200 --> 00:09:31,570
那这个过程是不能无中生有的

185
00:09:31,570 --> 00:09:34,360
先检查有没有产品

186
00:09:34,360 --> 00:09:37,340
用什么来检查资源是否足够呢

187
00:09:37,340 --> 00:09:41,050
诶， P 操作来检查资源是否足够

188
00:09:41,050 --> 00:09:44,140
那如果说资源不足的话

189
00:09:44,140 --> 00:09:47,030
什么时候才有产品给他消费呢

190
00:09:47,030 --> 00:09:51,040
应该是产品送到缓冲区之后

191
00:09:51,040 --> 00:09:54,330
才有了相应的一个产品啊

192
00:09:54,330 --> 00:09:56,950
能够呢，被消费者使用

193
00:09:56,950 --> 00:10:00,070
所以送产品到缓冲区

194
00:10:00,070 --> 00:10:03,080
是一个释放资源的过程

195
00:10:03,080 --> 00:10:06,320
同样，这里的 PV 也是呢

196
00:10:06,320 --> 00:10:08,620
存在于不同的进程

197
00:10:08,620 --> 00:10:12,250
从而呢，形成了同步模型

198
00:10:12,250 --> 00:10:17,150
那这里如果单纯从 S 2来看的话

199
00:10:17,150 --> 00:10:20,870
我们发现是可以先做 V 操作

200
00:10:20,870 --> 00:10:23,170
再做 P 操作的

201
00:10:23,280 --> 00:10:24,800
也就是说

202
00:10:24,800 --> 00:10:28,280
PV 操作一定是成对存在的

203
00:10:28,280 --> 00:10:31,980
但是它没有固定的先后顺序

204
00:10:31,980 --> 00:10:36,090
并不是一定要先加锁才会呢，后解锁

205
00:10:36,090 --> 00:10:39,420
我们也可以先释放资源

206
00:10:39,420 --> 00:10:43,160
然后呢，再检查资源是否足够

207
00:10:43,160 --> 00:10:47,860
足够的话直接往下去执行就可以了

208
00:10:47,860 --> 00:10:49,010
那这是呢

209
00:10:49,010 --> 00:10:50,630
同步模型

210
00:10:50,630 --> 00:10:54,010
这里面涉及到两个信号量

211
00:10:54,010 --> 00:10:55,930
s 1、 s 2

212
00:10:55,930 --> 00:11:02,270
那我们每一次枷锁都在使用资源之前解锁

213
00:11:02,270 --> 00:11:03,470
都是呢，唉

214
00:11:03,470 --> 00:11:06,710
资源释放之后立马就解锁

215
00:11:06,710 --> 00:11:08,570
那这种情况呢

216
00:11:08,570 --> 00:11:13,200
可以让我们资源锁定占用的时间啊，更少

217
00:11:13,200 --> 00:11:16,870
对于资源的利用率呢，会更高一些

218
00:11:16,870 --> 00:11:17,930
也可以啊

219
00:11:17,930 --> 00:11:22,150
防止啊，在大概率上呢，避免死锁问题

220
00:11:22,150 --> 00:11:23,890
那这里的信号量

221
00:11:23,890 --> 00:11:27,130
S 1是在送缓冲区之前

222
00:11:27,130 --> 00:11:28,420
那我们呢

223
00:11:28,420 --> 00:11:32,490
S 1它是针对缓冲区资源来的

224
00:11:32,490 --> 00:11:37,290
而 S 2是产品送到之后才有的

225
00:11:37,290 --> 00:11:41,600
所以 S 2针对的是产品资源

226
00:11:41,600 --> 00:11:43,950
那它们之间的初值

227
00:11:43,950 --> 00:11:47,330
缓冲区初始有几个空间可用

228
00:11:47,330 --> 00:11:48,690
一个空间

229
00:11:48,690 --> 00:11:52,000
所以 S 1初值为一

230
00:11:52,000 --> 00:11:54,080
S 2表示产品的话

231
00:11:54,080 --> 00:11:55,560
初始情况下

232
00:11:55,560 --> 00:11:57,660
唉，我们有没有产品啊

233
00:11:57,660 --> 00:11:58,260
没有

234
00:11:58,260 --> 00:12:02,860
所以 S 2的初值是等于零的

235
00:12:03,010 --> 00:12:05,750
那这里由于 S 1

236
00:12:05,750 --> 00:12:10,650
S 2都是在两个进程之间形成的 PV 吧

237
00:12:10,650 --> 00:12:13,010
所以这两个信号量啊

238
00:12:13,010 --> 00:12:16,730
其实都是同步信号量

239
00:12:18,380 --> 00:12:20,600
哪些是互斥信号量

240
00:12:20,600 --> 00:12:22,420
哪些是同步信号量

241
00:12:22,420 --> 00:12:25,600
它们的初值又是如何来判断的

242
00:12:25,600 --> 00:12:27,620
这是需要大家掌握的

243
00:12:27,620 --> 00:12:31,250
考试当中呢，也曾经考察过大家

244
00:12:31,250 --> 00:12:33,670
那我们讲了一个互斥模型

245
00:12:33,670 --> 00:12:35,430
讲了一个同步模型

246
00:12:35,430 --> 00:12:37,960
他们是不是一定独立存在呢

247
00:12:37,960 --> 00:12:40,320
并不是也可以啊

248
00:12:40,320 --> 00:12:42,320
综合存在

249
00:12:42,320 --> 00:12:46,870
那我们后面呢，再来看一下综合的模型

250
00:12:46,870 --> 00:12:49,260
什么样综合的模型呢

251
00:12:49,260 --> 00:12:51,780
那我们刚刚提到了

252
00:12:51,780 --> 00:12:54,620
缓冲区、生产者、消费者问题吧

253
00:12:54,620 --> 00:12:56,770
那在这个过程当中

254
00:12:56,770 --> 00:13:00,270
缓冲区其实我们前面提到过

255
00:13:00,270 --> 00:13:01,240
缓冲区

256
00:13:01,240 --> 00:13:04,260
它也是典型的临界资源

257
00:13:04,260 --> 00:13:06,010
类似于什么呢

258
00:13:06,010 --> 00:13:09,610
如果针对一个停车位来看的话

259
00:13:09,610 --> 00:13:13,300
有没有一边停一边出这样的过程啊

260
00:13:13,300 --> 00:13:14,100
没有吧

261
00:13:14,100 --> 00:13:15,820
要么就是有车出去

262
00:13:15,820 --> 00:13:17,720
要么呢，就是有车进来

263
00:13:17,720 --> 00:13:19,870
并不能同时执行

264
00:13:19,870 --> 00:13:21,240
缓冲区啊

265
00:13:21,240 --> 00:13:23,720
它是典型的临界资源

266
00:13:23,720 --> 00:13:26,890
同一时刻只能让一个人用

267
00:13:26,890 --> 00:13:28,790
要么生产者用

268
00:13:28,790 --> 00:13:31,000
要么呢消费者用

269
00:13:31,000 --> 00:13:32,440
那也就是说

270
00:13:32,440 --> 00:13:36,740
除了我们这里成对的同步模型 PV 以外

271
00:13:36,740 --> 00:13:39,530
我们还要针对缓冲

272
00:13:39,530 --> 00:13:42,480
控制对缓冲区的执行

273
00:13:42,480 --> 00:13:47,250
不能让两个进程同时使用缓冲区

274
00:13:47,250 --> 00:13:50,350
那如何避免同时使用呢

275
00:13:50,350 --> 00:13:55,410
在每一次使用缓冲区的过程当中都加锁

276
00:13:55,410 --> 00:13:57,870
用完之后立马解锁

277
00:13:57,870 --> 00:14:02,610
这个用不仅仅是送产品到缓冲区

278
00:14:02,610 --> 00:14:07,180
也包括从缓冲区取产品的过程

279
00:14:07,180 --> 00:14:09,780
所以送缓冲区，哎

280
00:14:09,780 --> 00:14:13,160
送产品到缓冲区之前 P 、 S 

281
00:14:13,160 --> 00:14:16,500
然后呢，送完之后 v

282
00:14:16,500 --> 00:14:19,880
形成一个呢成对的 PV 操作

283
00:14:19,880 --> 00:14:23,940
那很明显这一对 PV 是在同一个进程当中了吧

284
00:14:23,940 --> 00:14:26,960
这就是典型的互斥

285
00:14:27,250 --> 00:14:30,530
同样，消费者进程当中

286
00:14:30,530 --> 00:14:32,910
从缓冲区取产品

287
00:14:32,910 --> 00:14:34,710
也是使用缓冲区

288
00:14:34,710 --> 00:14:36,650
用之前 P 操作

289
00:14:36,650 --> 00:14:38,900
用之后 V 操作

290
00:14:38,900 --> 00:14:41,150
那这个 S 是什么

291
00:14:41,150 --> 00:14:46,370
S 信号量控制的是对临界资源的访问

292
00:14:46,370 --> 00:14:49,320
也就是对缓冲区的访问

293
00:14:49,320 --> 00:14:52,680
同一时刻只能让一个进程用

294
00:14:52,680 --> 00:14:57,280
那这里啊，可以理解为访问权

295
00:14:58,840 --> 00:15:03,940
当一个进程拿到临界资源访问权的时候

296
00:15:03,940 --> 00:15:06,990
其他进程就不能再去拿了

297
00:15:06,990 --> 00:15:10,870
那只允许一个人用访问权的初值呢

298
00:15:10,870 --> 00:15:12,630
就是等于一的

299
00:15:12,630 --> 00:15:15,250
允许一个进程使用

300
00:15:15,250 --> 00:15:20,710
此时我们 S 1、 S 2是同步信号量吧

301
00:15:20,710 --> 00:15:25,020
S 1是我们相应的缓冲区空间

302
00:15:25,020 --> 00:15:28,720
S 2是我们产品的初值

303
00:15:28,720 --> 00:15:31,110
它的初值是等于零的

304
00:15:31,110 --> 00:15:34,770
单缓冲区初值呢，是等于一的

305
00:15:34,770 --> 00:15:38,610
那这里的 S 是互斥信号量

306
00:15:38,610 --> 00:15:42,930
代表的是对临界资源的访问权限

307
00:15:42,930 --> 00:15:45,640
初值呢，是等于一的

308
00:15:45,640 --> 00:15:49,920
那如果这里啊，不再是单缓冲区

309
00:15:49,920 --> 00:15:55,360
而是空间为 M 的缓冲区

310
00:15:58,720 --> 00:16:02,780
此时我们要调整哪里呢

311
00:16:02,780 --> 00:16:06,590
所有的 PV 其实都没有变化

312
00:16:06,590 --> 00:16:10,920
变化的是空间资源的初值

313
00:16:10,920 --> 00:16:13,010
也就是 S 1

314
00:16:13,010 --> 00:16:16,750
初值从一变成了 M 

315
00:16:20,700 --> 00:16:24,490
此时每当送一个产品

316
00:16:24,490 --> 00:16:26,590
唉，如果 M 等于二的话

317
00:16:26,590 --> 00:16:30,040
我们有两个空间的缓冲区

318
00:16:30,040 --> 00:16:32,180
放下一个产品之后

319
00:16:32,180 --> 00:16:36,120
诶，接下来第二个进程仍然可以放

320
00:16:36,120 --> 00:16:39,270
那这里呢，就是它的空间资源

321
00:16:39,270 --> 00:16:43,680
也就是呢，我们说到的 S 1的取值

322
00:16:43,680 --> 00:16:47,380
那到底用的是什么样的缓冲区

323
00:16:47,380 --> 00:16:49,910
初值到底是多少

324
00:16:49,910 --> 00:16:50,810
都会呢

325
00:16:50,810 --> 00:16:53,850
根据题意来进行定义

326
00:16:53,850 --> 00:16:57,370
这个已经是比较复杂的 PV 模型了

327
00:16:57,370 --> 00:16:59,230
既涉及到了互斥

328
00:16:59,230 --> 00:17:02,530
也涉及到了同步模型

329
00:17:03,710 --> 00:17:08,730
后面我们呢，来看一下信号量与 PV 操作

330
00:17:08,730 --> 00:17:12,170
在我们软件设计师考试当中

331
00:17:12,170 --> 00:17:14,670
它的具体考察形式

332
00:17:14,670 --> 00:17:17,470
那这道题题干很长啊

333
00:17:17,470 --> 00:17:18,829
告诉我们呢

334
00:17:18,829 --> 00:17:23,109
假设我们现在有一个铁路自动售票系统

335
00:17:23,109 --> 00:17:26,750
它有呢 N 个售票终端

336
00:17:26,750 --> 00:17:30,100
该系统为每个售票终端呢

337
00:17:30,100 --> 00:17:32,360
都可以创建一个进程

338
00:17:32,360 --> 00:17:36,990
那进程有 P 1、 P 2到 PN 管理车票

339
00:17:36,990 --> 00:17:38,410
它的销售过程

340
00:17:38,410 --> 00:17:43,680
假设 TJJ 的取值是等于一到 M 的

341
00:17:43,680 --> 00:17:49,940
那这里的 T 接单元存放的是某日某趟车票

342
00:17:49,940 --> 00:17:52,410
它的剩余票数

343
00:17:52,410 --> 00:17:55,330
tap 呢，是 pi 进程

344
00:17:55,330 --> 00:17:58,490
它的临时工作单元

345
00:17:58,510 --> 00:18:01,710
X 是我们的用户

346
00:18:01,710 --> 00:18:04,010
它的购票张数

347
00:18:04,010 --> 00:18:06,870
那 P 进程， pi 进程

348
00:18:06,870 --> 00:18:09,900
它的工作流程如下图所示

349
00:18:09,900 --> 00:18:16,370
用 PV 操作来实现进程之间的同步与互斥

350
00:18:16,370 --> 00:18:17,910
初始的时候

351
00:18:17,910 --> 00:18:22,360
系统应该将信号量赋值为多少呢

352
00:18:22,360 --> 00:18:26,120
那这道题我们看到的取值有哪些啊

353
00:18:26,120 --> 00:18:28,490
有 N 个进程 N 

354
00:18:28,490 --> 00:18:30,170
然后呢有一个 N 

355
00:18:30,170 --> 00:18:32,770
然后呢有 T 接单元

356
00:18:32,770 --> 00:18:35,370
然后呢，还有 temp 单元

357
00:18:35,370 --> 00:18:39,740
以及呢 X ，唉，购买票的张数

358
00:18:39,740 --> 00:18:42,720
那如果这道题啊

359
00:18:42,720 --> 00:18:45,880
在考察大家的过程当中

360
00:18:45,880 --> 00:18:49,540
再给大家一个呢，混淆项 N ，唉

361
00:18:49,540 --> 00:18:52,260
再给大家一个混淆项 X 

362
00:18:52,260 --> 00:18:55,700
很多同学就会呢，容易选错了

363
00:18:55,700 --> 00:18:57,260
那我们在这里啊

364
00:18:57,260 --> 00:19:00,220
应该呢，先看图再做题

365
00:19:00,220 --> 00:19:02,120
这个图啊

366
00:19:02,120 --> 00:19:05,040
我们呢，将它稍微放大了一下

367
00:19:05,040 --> 00:19:10,000
那题目要求我们考察的是 S 的信号量

368
00:19:10,000 --> 00:19:12,200
以及 ABC 的填空

369
00:19:12,200 --> 00:19:13,760
都是 PV 吧

370
00:19:13,760 --> 00:19:16,930
那我们首先看到，诶， pi 进程

371
00:19:16,930 --> 00:19:20,990
按用户购票的需求找到 T 接，诶

372
00:19:20,990 --> 00:19:22,710
找到存储单元 T 接

373
00:19:22,710 --> 00:19:25,670
然后呢，唉，这个 T 阶是什么

374
00:19:25,670 --> 00:19:29,270
其实是我们对存储单元 T 阶的一个命名吧

375
00:19:29,270 --> 00:19:32,210
一个存储单元的别名而已

376
00:19:32,210 --> 00:19:35,100
它并没有一定的取值

377
00:19:35,100 --> 00:19:37,280
那有了 TJ 之后

378
00:19:37,280 --> 00:19:39,720
接下来如果没有 PV 

379
00:19:39,720 --> 00:19:41,760
temp 等于 T 阶

380
00:19:41,760 --> 00:19:45,040
那我们呢，将 TJ 的内容传给 temp 

381
00:19:45,040 --> 00:19:49,680
判断 temp 的取值如果大于购票数

382
00:19:49,680 --> 00:19:52,360
那我们接下来修改 temp 值

383
00:19:52,360 --> 00:19:55,470
并且把新的 temp 值传给 TJ 

384
00:19:55,470 --> 00:19:58,460
然后呢，输出 X 张票

385
00:19:58,460 --> 00:20:01,520
否则的话 temp 小于 X 

386
00:20:01,520 --> 00:20:04,380
说明呢，唉，票数不够

387
00:20:04,380 --> 00:20:07,300
那整个过程看起来没有问题

388
00:20:07,300 --> 00:20:08,410
如果

389
00:20:08,930 --> 00:20:12,540
P 1的同时还有 P 2在执行

390
00:20:12,540 --> 00:20:14,800
我们购买车票的时候

391
00:20:14,800 --> 00:20:16,660
尤其像12306

392
00:20:16,660 --> 00:20:19,060
一般不会是一个人在买票吧

393
00:20:19,060 --> 00:20:21,820
会有很多人同时在买票啊

394
00:20:21,820 --> 00:20:26,700
那如果说我们现在剩余的票数诶

395
00:20:26,700 --> 00:20:28,840
现在是两张

396
00:20:28,840 --> 00:20:30,100
然后呢

397
00:20:30,100 --> 00:20:35,340
哎，我们 P 1进进城要购买两张车票

398
00:20:36,550 --> 00:20:41,470
然后呢， P 2进程也要购买两张车票

399
00:20:41,470 --> 00:20:44,980
那如果说不做任何 PV 操作的话

400
00:20:44,980 --> 00:20:47,340
大家都可以读到诶

401
00:20:47,340 --> 00:20:52,880
两张车票同时都可以对两张车票减二

402
00:20:52,880 --> 00:20:56,440
那两张票能不能同时买两卖两次啊

403
00:20:56,440 --> 00:20:57,480
不可能

404
00:20:57,480 --> 00:21:00,280
所以我们要控制诶

405
00:21:00,280 --> 00:21:02,950
对相应的数据的访问吧

406
00:21:02,950 --> 00:21:05,260
那我们控制的是什么呢

407
00:21:05,260 --> 00:21:08,320
我们现在之前啊，有告诉大家

408
00:21:08,320 --> 00:21:10,260
在使用资源之

409
00:21:10,260 --> 00:21:12,280
就要控制对它的访问吧

410
00:21:12,280 --> 00:21:15,830
这是典型的互斥模型

411
00:21:16,230 --> 00:21:21,090
那在互斥模型加 PX 唉

412
00:21:21,090 --> 00:21:26,410
加 PS 或者 vs 是在呢 temp 等于 TG 之前

413
00:21:26,410 --> 00:21:32,350
所以它是我们在使用 tap 单元之前所加的锁

414
00:21:32,350 --> 00:21:34,750
他枷锁意味着什么呢

415
00:21:34,750 --> 00:21:40,710
它是控制对临时工作单元的访问

416
00:21:40,710 --> 00:21:46,550
那这个临时工作单元可以理解为缓冲区

417
00:21:47,440 --> 00:21:51,820
将相应的票数送到缓冲区

418
00:21:51,820 --> 00:21:54,470
再来对它进行操作

419
00:21:54,470 --> 00:21:59,450
那缓冲区一次只能允许一个人用

420
00:21:59,450 --> 00:22:01,920
不能同时使用 TP 

421
00:22:01,920 --> 00:22:06,970
所以此时 S 信号量取值初值是多少

422
00:22:06,970 --> 00:22:09,130
应该是等于一的

423
00:22:09,130 --> 00:22:12,100
这是典型的互斥模型啊

424
00:22:12,100 --> 00:22:13,970
那在这个过程当中

425
00:22:13,970 --> 00:22:17,660
为什么存在 BC 两个填空

426
00:22:17,660 --> 00:22:21,200
不是说 PV 操作是成对存在的吗

427
00:22:21,200 --> 00:22:23,710
为什么这里有了一对二呢

428
00:22:23,710 --> 00:22:25,080
这里要注意

429
00:22:25,080 --> 00:22:28,300
我们是通过条件判断语句

430
00:22:28,300 --> 00:22:32,450
选择任意一条路径往下走吧

431
00:22:32,450 --> 00:22:35,940
能不能同时走两条路径啊

432
00:22:35,940 --> 00:22:39,300
不可能， tap 值是确定的

433
00:22:39,300 --> 00:22:41,120
X 值也是确定的

434
00:22:41,120 --> 00:22:44,940
它的条件判断只有一个结果

435
00:22:44,940 --> 00:22:47,390
那我们的 B 和 C 

436
00:22:47,390 --> 00:22:50,330
它的作用其实都是一样的

437
00:22:50,330 --> 00:22:54,910
都是呢，用完 temp 之后释放锁

438
00:22:54,910 --> 00:22:57,120
所以这个释放的过程呢

439
00:22:57,120 --> 00:22:57,480
唉

440
00:22:57,480 --> 00:23:03,500
这里是检查资源、锁定资源、锁定缓冲区的过程

441
00:23:03,700 --> 00:23:07,320
这里是释放缓冲区的过程

442
00:23:07,320 --> 00:23:10,600
B 和 C 都是释放缓冲区

443
00:23:10,600 --> 00:23:14,400
处于不同判断结果下的释放

444
00:23:14,400 --> 00:23:20,240
那如果说我们把释放锁放在两条路径

445
00:23:20,240 --> 00:23:23,840
最终的话可以呢，只写一个 vs 

446
00:23:23,840 --> 00:23:28,170
但相比于前面的两个 vs 来看的话

447
00:23:28,170 --> 00:23:31,010
它的枷锁时长啊，变长了

448
00:23:31,010 --> 00:23:32,320
所以我们一般呢

449
00:23:32,320 --> 00:23:34,320
会尽早的释放锁

450
00:23:34,320 --> 00:23:36,280
将锁呢，提前

451
00:23:36,280 --> 00:23:37,810
诶，提前释放

452
00:23:37,810 --> 00:23:39,550
对于整个系统而言

453
00:23:39,550 --> 00:23:42,670
可以呢，避免一些死锁的情况

454
00:23:42,670 --> 00:23:45,320
避免呢得对锁的占用

455
00:23:45,320 --> 00:23:47,920
所以这道题呀，我们会发现呢

456
00:23:47,920 --> 00:23:49,580
第一空选择呢

457
00:23:49,580 --> 00:23:52,430
信号量初值是等于一的

458
00:23:52,430 --> 00:23:54,760
第二空是个 P 操作

459
00:23:54,760 --> 00:23:57,440
第三空和第四、第二空当中

460
00:23:57,440 --> 00:24:00,120
B 和 C 呢，是两个 V 操作

461
00:24:00,120 --> 00:24:02,490
选择的是 D 选项

462
00:24:02,490 --> 00:24:03,630
那这里呢

463
00:24:03,630 --> 00:24:06,590
是比较简单的互斥模型

464
00:24:06,590 --> 00:24:08,970
大家呢，注意它的分

465
00:24:08,970 --> 00:24:12,800
以及呢，对临时工作单元的访问

466
00:24:12,800 --> 00:24:16,450
这些啊，就是要求大家掌握的，诶

467
00:24:16,450 --> 00:24:19,290
信号量与 PV 操作的结合分析

468
00:24:19,290 --> 00:24:20,930
它的考察题型呢

469
00:24:20,930 --> 00:24:23,190
大致就是这种互斥模型

470
00:24:23,190 --> 00:24:26,720
以及我们前面讲到的一个复杂的综合

471
00:24:26,720 --> 00:24:29,600
互斥同步模型的生产者

472
00:24:29,600 --> 00:24:30,840
消费者问题模型
