1
00:00:00,000 --> 00:00:02,980
下面我们简单来看一下架构设计

2
00:00:02,980 --> 00:00:04,840
架构设计这一部分啊

3
00:00:04,840 --> 00:00:06,720
它的备考不是呢

4
00:00:06,720 --> 00:00:08,380
很简单的一个事情

5
00:00:08,380 --> 00:00:11,100
因为本身啊，我们的高级科目当

6
00:00:11,100 --> 00:00:12,750
是有一个架构科目的

7
00:00:12,750 --> 00:00:14,530
针对架构而言的话

8
00:00:14,530 --> 00:00:17,090
它的知识内容其实非常广

9
00:00:17,090 --> 00:00:19,410
但是在我们的软试考试当中啊

10
00:00:19,410 --> 00:00:21,910
一般考察的话只考一分

11
00:00:21,910 --> 00:00:24,800
目前呢，考察的频率有一些

12
00:00:24,800 --> 00:00:26,630
但是考察非常零散

13
00:00:26,630 --> 00:00:29,300
所以备考相对来说麻烦了一些

14
00:00:29,300 --> 00:00:30,740
那我们在这里呢

15
00:00:30,740 --> 00:00:33,440
只需要大家掌握一些浅层次的分类

16
00:00:33,440 --> 00:00:35,770
和它的应用特点就可以了

17
00:00:35,770 --> 00:00:39,500
首先呢，我们了解到到底什么是架构

18
00:00:39,500 --> 00:00:41,290
那架构它本身的话

19
00:00:41,290 --> 00:00:43,430
是给我们的软件

20
00:00:43,430 --> 00:00:46,290
和我们的需求之间搭了一个桥

21
00:00:46,290 --> 00:00:47,980
搭了一个桥梁

22
00:00:47,980 --> 00:00:49,910
那这个过程的话

23
00:00:49,910 --> 00:00:51,590
不同的架构设计啊

24
00:00:51,590 --> 00:00:53,950
它是一个全局性的思想

25
00:00:53,950 --> 00:00:56,260
现在呢，经常会拿来复用

26
00:00:56,260 --> 00:00:56,980
比如说呢

27
00:00:56,980 --> 00:00:59,780
SOA 这种架构就经常会听到

28
00:00:59,780 --> 00:01:02,250
那我们在这里给大家呢

29
00:01:02,250 --> 00:01:04,230
介绍的是架构风格

30
00:01:04,230 --> 00:01:05,780
那架构风格的话

31
00:01:05,780 --> 00:01:07,920
它是传统的针对呢

32
00:01:07,920 --> 00:01:10,750
架构设计的一些特点做了归类

33
00:01:10,750 --> 00:01:13,510
那我们在做架构设计的时候啊

34
00:01:13,510 --> 00:01:18,630
它主要想要达到的就是架构级别的软件复用

35
00:01:18,630 --> 00:01:20,750
它在复用的过程当中呢

36
00:01:20,750 --> 00:01:23,400
可以解决一些呢，针对性的问题

37
00:01:23,400 --> 00:01:27,550
架构风格呢，它主要反映的是领域当中啊

38
00:01:27,550 --> 00:01:31,500
众多系统共有的一些结构和语义特性

39
00:01:31,500 --> 00:01:33,880
指导我们如何把构建呢

40
00:01:33,880 --> 00:01:36,130
组织成一个完整的系统

41
00:01:36,130 --> 00:01:37,550
架构风格呢

42
00:01:37,550 --> 00:01:39,330
它定义的过程当

43
00:01:39,330 --> 00:01:41,290
描述了系统的术语

44
00:01:41,290 --> 00:01:42,270
和一组呢

45
00:01:42,270 --> 00:01:45,280
指指导他组建的规则

46
00:01:45,280 --> 00:01:46,720
那我们在这里呢

47
00:01:46,720 --> 00:01:49,620
主要了解几类就可以了

48
00:01:49,620 --> 00:01:51,680
那下面给大家列举

49
00:01:51,680 --> 00:01:53,640
首先是分类问题

50
00:01:53,640 --> 00:01:55,970
典型的数据流风格

51
00:01:55,970 --> 00:01:59,670
包括批处理和管道过滤器调用

52
00:01:59,670 --> 00:02:01,140
返回风格呢

53
00:02:01,140 --> 00:02:04,280
它在结构化当中体现的就是主程序

54
00:02:04,280 --> 00:02:05,520
子程序的调用

55
00:02:05,520 --> 00:02:07,500
面向对象过程当中呢

56
00:02:07,500 --> 00:02:11,950
体现的就是对象与函数过程的一个调用

57
00:02:11,950 --> 00:02:14,150
还有层次结构当中

58
00:02:14,150 --> 00:02:17,000
唉，我们常说的 bs cs 架构

59
00:02:17,000 --> 00:02:20,480
这一类呢，就是属于呢典型的层次结构

60
00:02:20,480 --> 00:02:23,430
也是属于呢调用返回的风格

61
00:02:23,430 --> 00:02:25,550
独立构建风格呢

62
00:02:25,550 --> 00:02:28,660
它包括进程通信、事件驱动器

63
00:02:28,660 --> 00:02:30,810
其中事件驱动系统呢

64
00:02:30,810 --> 00:02:33,030
是影视调用的方式

65
00:02:33,030 --> 00:02:34,960
虚拟机系风格

66
00:02:34,960 --> 00:02:38,810
那其实就是我们经常听到的 java 虚拟机这种

67
00:02:38,810 --> 00:02:41,130
它包括呢解释器风格

68
00:02:41,130 --> 00:02:43,450
以及呢基于规则的系统

69
00:02:43,450 --> 00:02:45,060
专家系统这一类

70
00:02:45,060 --> 00:02:46,480
仓库风

71
00:02:46,480 --> 00:02:49,460
也叫做以数据为中心的风格

72
00:02:49,460 --> 00:02:52,460
典型应用就是数据库系统风格

73
00:02:52,460 --> 00:02:55,600
超文本系统以及呢黑板系统

74
00:02:55,600 --> 00:02:57,370
先了解分类

75
00:02:57,370 --> 00:03:02,090
后面呢我们再展开简单给大家介绍一下

76
00:03:03,320 --> 00:03:06,960
首先，数据流风格包含两大类

77
00:03:06,960 --> 00:03:08,860
一类呢，是批处理

78
00:03:08,860 --> 00:03:11,390
一类呢，是管道过滤器

79
00:03:11,390 --> 00:03:12,560
批处理啊

80
00:03:12,560 --> 00:03:16,240
它的处理数据呢，必须是完整的

81
00:03:16,240 --> 00:03:19,440
以整体的方式来进行传递

82
00:03:19,440 --> 00:03:22,590
那它是将相应的数据

83
00:03:22,590 --> 00:03:24,750
以数据流的方式

84
00:03:24,750 --> 00:03:29,400
流入到一个一个的部件当中去进行处理

85
00:03:29,400 --> 00:03:33,230
但是注意他在处理的过程当中

86
00:03:33,230 --> 00:03:36,710
每一个处理的步骤都是独立的程序

87
00:03:36,710 --> 00:03:38,850
那每一步必须呢

88
00:03:38,850 --> 00:03:41,070
在前面处理完成之后

89
00:03:41,070 --> 00:03:43,880
才能呢流入到后面位置

90
00:03:43,880 --> 00:03:45,540
那这是呢，批处理

91
00:03:45,540 --> 00:03:47,110
它是单向的

92
00:03:47,110 --> 00:03:50,110
第二种呢，叫做管道过滤器

93
00:03:50,110 --> 00:03:51,660
它的过

94
00:03:51,660 --> 00:03:55,780
相应的管道以及呢，过滤器的部分

95
00:03:55,780 --> 00:03:58,210
那这种结构当中啊

96
00:03:58,210 --> 00:04:02,930
我们是可以形成并型结果的

97
00:04:02,930 --> 00:04:04,950
那这种 B 型结构呢

98
00:04:04,950 --> 00:04:06,850
我们在数据处理的时

99
00:04:06,850 --> 00:04:08,530
可以一步一步的来

100
00:04:08,530 --> 00:04:12,380
可以一个部件只处理一个步骤

101
00:04:12,380 --> 00:04:16,130
从而呢，诶，达到最终的处理结果

102
00:04:16,130 --> 00:04:17,700
这个过程当中呢

103
00:04:17,700 --> 00:04:20,160
像我们早期的编译原理

104
00:04:20,160 --> 00:04:23,750
它的编译器就是呢，先做词法分析

105
00:04:23,750 --> 00:04:25,510
再做语法分析

106
00:04:25,510 --> 00:04:27,330
再做呢语义分析

107
00:04:27,330 --> 00:04:29,120
那这个过程当中

108
00:04:29,120 --> 00:04:31,640
前面输出的这个结

109
00:04:31,640 --> 00:04:33,560
作为后面的输入

110
00:04:33,560 --> 00:04:35,850
一步一步的来处理

111
00:04:35,850 --> 00:04:38,780
在数据传输完成之前

112
00:04:38,780 --> 00:04:41,240
是可以做并行的

113
00:04:41,240 --> 00:04:44,230
数据可以呢，是不完整的

114
00:04:44,230 --> 00:04:47,280
可以切割之后来进行分析

115
00:04:47,280 --> 00:04:50,720
那这是呢，管道过滤器的风格

116
00:04:50,720 --> 00:04:52,460
管道过滤器啊

117
00:04:52,460 --> 00:04:54,580
它的特点就是属于呢

118
00:04:54,580 --> 00:04:56,770
诶，我们能够并行

119
00:04:56,770 --> 00:04:59,090
然后呢，唉，能够啊

120
00:04:59,090 --> 00:05:01,510
在这个执行过程当中

121
00:05:01,510 --> 00:05:04,060
一步一步的来进行处理

122
00:05:04,060 --> 00:05:05,260
但是要注意

123
00:05:05,260 --> 00:05:07,120
这里的数据流风格

124
00:05:07,120 --> 00:05:10,250
对性能是没有提升的

125
00:05:10,250 --> 00:05:12,450
这是数据流风格

126
00:05:13,780 --> 00:05:16,600
再来看调用返回风格

127
00:05:16,600 --> 00:05:19,580
这种风格其实用到的非常多

128
00:05:19,580 --> 00:05:22,300
我们在写 C 语言程序的时候

129
00:05:22,300 --> 00:05:24,560
经常有一个主函数

130
00:05:24,560 --> 00:05:27,910
主程序会调用子程序的内容

131
00:05:27,910 --> 00:05:29,990
这种调用的过程呢

132
00:05:29,990 --> 00:05:33,250
就是属于我们的这个，呃

133
00:05:33,250 --> 00:05:34,750
调用返回风格

134
00:05:34,750 --> 00:05:36,590
那他的这种控制呢

135
00:05:36,590 --> 00:05:38,510
是单线程的控制

136
00:05:38,510 --> 00:05:43,290
它一对应的其实就是结构化开发的过程

137
00:05:43,290 --> 00:05:46,060
我们的结构化开发是面向过程的

138
00:05:46,060 --> 00:05:48,200
他把问题的解决过程啊

139
00:05:48,200 --> 00:05:49,750
划分成一些子步骤

140
00:05:49,750 --> 00:05:52,140
然后呢，依次来调用、执行

141
00:05:52,140 --> 00:05:55,160
直到呢，完成最终的结果

142
00:05:55,160 --> 00:05:58,940
那面向对象呢，它也有调用的过程

143
00:05:58,940 --> 00:06:04,300
它的调用啊，是将对象看作单一的一些构建

144
00:06:04,300 --> 00:06:06,970
那对象在通信的时候

145
00:06:06,970 --> 00:06:09,610
是相通过消息来交互的

146
00:06:09,610 --> 00:06:11,050
这种通信过程

147
00:06:11,050 --> 00:06:15,060
会明确哪些对象调用了哪一个数吧

148
00:06:15,060 --> 00:06:16,480
所以我们说呢

149
00:06:16,480 --> 00:06:20,710
面向对象它是显示调用的过程

150
00:06:20,710 --> 00:06:23,680
我们能够明确看到啊

151
00:06:23,680 --> 00:06:27,460
到底是谁调用了这个函数

152
00:06:27,460 --> 00:06:28,680
所以叫做呢

153
00:06:28,680 --> 00:06:29,900
显示调用

154
00:06:29,900 --> 00:06:31,190
与之对应的

155
00:06:31,190 --> 00:06:33,190
我们的事件调用的话

156
00:06:33,190 --> 00:06:36,170
是属于隐式调用的

157
00:06:36,200 --> 00:06:38,520
第三个层次结构

158
00:06:38,520 --> 00:06:43,750
层次结构在我们开发过程当中用到的非常多

159
00:06:43,750 --> 00:06:46,470
我们在讲计算机网络的时候

160
00:06:46,470 --> 00:06:49,670
曾经提到过 APIP 协议处吧

161
00:06:49,670 --> 00:06:51,960
那我们其实提到了

162
00:06:51,960 --> 00:06:55,220
对于层次它的划分有一定的优势

163
00:06:55,220 --> 00:06:57,080
也有一定的劣势

164
00:06:57,080 --> 00:06:59,300
对于层次划分来说

165
00:06:59,300 --> 00:07:01,770
我们分层之后啊

166
00:07:01,770 --> 00:07:03,440
每一个层级

167
00:07:03,440 --> 00:07:07,380
只需要与上下两层来进行交互吧

168
00:07:07,380 --> 00:07:10,000
与它相关的只有两个层次

169
00:07:10,000 --> 00:07:14,740
那这种情况下可以简化单一层次它的交互

170
00:07:14,740 --> 00:07:16,840
然后的话，制定的标准

171
00:07:16,840 --> 00:07:19,870
只需要与上下层次相关就可以了

172
00:07:19,870 --> 00:07:22,690
与高层次和最低层次的话

173
00:07:22,690 --> 00:07:25,540
就有了一个解耦的作用

174
00:07:25,540 --> 00:07:27,890
所以我们说啊，层次化结构呢

175
00:07:27,890 --> 00:07:29,240
可以解耦

176
00:07:29,240 --> 00:07:31,230
但是我们要知道

177
00:07:31,230 --> 00:07:33,090
每增加一个级别

178
00:07:33,090 --> 00:07:35,550
我们就要多做一次接口转换吧

179
00:07:35,550 --> 00:07:38,370
多做一次标准制定、协议沟通

180
00:07:38,370 --> 00:07:40,350
所以它的性能啊

181
00:07:40,350 --> 00:07:42,610
一旦呢分层过多的话

182
00:07:42,610 --> 00:07:44,250
性能上会下降

183
00:07:44,250 --> 00:07:47,200
多一个层次性能就下降一些

184
00:07:47,200 --> 00:07:48,570
那我们呢

185
00:07:48,570 --> 00:07:50,650
在划分的过程当中

186
00:07:50,650 --> 00:07:53,360
分层也是呢，非常麻烦的一个事情

187
00:07:53,360 --> 00:07:57,140
TCPIP 协议处就是针对七层模型的简化

188
00:07:57,140 --> 00:07:59,330
最初的时候划分成七层

189
00:07:59,330 --> 00:08:00,810
后面发现太多了

190
00:08:00,810 --> 00:08:01,830
又把它呢

191
00:08:01,830 --> 00:08:03,010
压缩成了

192
00:08:03,010 --> 00:08:05,170
诶，我们的四层模型

193
00:08:05,170 --> 00:08:07,030
所以这个过程当中呢

194
00:08:07,030 --> 00:08:08,790
体现的就是层次

195
00:08:08,790 --> 00:08:10,860
它的一些的优缺点

196
00:08:10,860 --> 00:08:14,090
那我们呢，简单给大家归纳一下

197
00:08:14,090 --> 00:08:16,150
对于层次风格的话

198
00:08:16,150 --> 00:08:17,770
我们呢，可以啊

199
00:08:17,770 --> 00:08:20,230
增加抽象层的设计

200
00:08:20,230 --> 00:08:22,170
那我们可以把问题呢

201
00:08:22,170 --> 00:08:23,870
放在中间的层次

202
00:08:23,870 --> 00:08:27,640
不影响上下两个层次的使用

203
00:08:27,640 --> 00:08:29,670
那越靠近底层

204
00:08:29,670 --> 00:08:31,660
抽象比级别越高

205
00:08:31,660 --> 00:08:33,179
越靠近顶层

206
00:08:33,179 --> 00:08:34,559
抽象级别越低

207
00:08:34,559 --> 00:08:37,419
每一层最多只影响两层

208
00:08:37,419 --> 00:08:39,500
也就是相邻层次

209
00:08:39,500 --> 00:08:41,120
软件复用呢

210
00:08:41,120 --> 00:08:43,020
非常强大

211
00:08:43,159 --> 00:08:48,460
因为我们只需要涉及相邻的两个层次法

212
00:08:48,460 --> 00:08:50,120
只要底层不变

213
00:08:50,120 --> 00:08:53,500
我们就可以呢，做一些迁移，诶

214
00:08:53,500 --> 00:08:55,140
移植性的操作

215
00:08:55,140 --> 00:08:58,060
那这是我们提到的关于调用

216
00:08:58,060 --> 00:09:00,100
返回这样的过程当中

217
00:09:00,100 --> 00:09:01,260
层次风格

218
00:09:01,260 --> 00:09:04,920
那层次风格它的应用拓展性非常强

219
00:09:04,920 --> 00:09:07,620
我们现在所做的开发当中啊

220
00:09:07,620 --> 00:09:11,230
最初呢，看到的其实是两层 cs 

221
00:09:11,230 --> 00:09:12,650
什么是 cs 啊

222
00:09:12,650 --> 00:09:14,490
就是一个客户端

223
00:09:14,490 --> 00:09:18,840
然后呢，与我们的数据服务器来进行交互

224
00:09:18,840 --> 00:09:23,490
那客户端与服务器之间就是呢，两层的 cs 架构

225
00:09:23,490 --> 00:09:25,710
其实最初是整体啊

226
00:09:25,710 --> 00:09:27,350
叫做集中式的架构

227
00:09:27,350 --> 00:09:29,570
一台电脑上既放服务器

228
00:09:29,570 --> 00:09:31,660
也放了我们的这个

229
00:09:31,660 --> 00:09:32,660
呃，客户端

230
00:09:32,660 --> 00:09:34,180
也就是单机系统

231
00:09:34,180 --> 00:09:35,820
有了网络之后呢

232
00:09:35,820 --> 00:09:38,280
把服务器和客户端拆开了

233
00:09:38,280 --> 00:09:39,980
划分成了两个层次

234
00:09:39,980 --> 00:09:42,330
那两个层次划分之后

235
00:09:42,330 --> 00:09:44,090
我们一旦系统要更新

236
00:09:44,090 --> 00:09:45,030
麻烦了吧

237
00:09:45,030 --> 00:09:46,670
你有100个客户端

238
00:09:46,670 --> 00:09:48,430
你要重装100次

239
00:09:48,430 --> 00:09:50,880
那业务逻辑一更新就出

240
00:09:50,880 --> 00:09:53,630
就是两端都要做调整

241
00:09:53,630 --> 00:09:56,450
后面呢，就做了三层 cs 

242
00:09:56,450 --> 00:09:58,390
把 S 和 C 之间呢

243
00:09:58,390 --> 00:10:00,760
多了一个抽象的层次

244
00:10:00,760 --> 00:10:02,320
这个层次呢

245
00:10:02,320 --> 00:10:04,340
可以处理业务逻辑

246
00:10:04,340 --> 00:10:05,960
那做业务逻辑更新的话

247
00:10:05,960 --> 00:10:07,380
修改中心层吧

248
00:10:07,380 --> 00:10:11,030
然后可以处理与数据库的连接过程

249
00:10:11,030 --> 00:10:13,240
所以数据库修改也是呢

250
00:10:13,240 --> 00:10:15,680
修改中间的抽象层就可以了

251
00:10:15,680 --> 00:10:18,140
这就是呢，三层 cs 

252
00:10:18,140 --> 00:10:20,990
那后面发现的客户端，诶

253
00:10:20,990 --> 00:10:22,930
每一次要安装不太好用

254
00:10:22,930 --> 00:10:25,950
所以又有了呢， BS 的架构

255
00:10:26,200 --> 00:10:28,140
BS 架构呢

256
00:10:28,140 --> 00:10:31,460
它的应用过程当中还是服务器

257
00:10:31,460 --> 00:10:35,280
只是在客户这个客户端的地方

258
00:10:35,280 --> 00:10:37,830
用的不再是客户端程序

259
00:10:37,830 --> 00:10:39,890
而是浏览器

260
00:10:39,890 --> 00:10:42,750
所以叫做呢， BS 的架构

261
00:10:42,750 --> 00:10:44,690
那浏览器、电脑都有

262
00:10:44,690 --> 00:10:47,480
所以就不用呢再去安装了

263
00:10:47,480 --> 00:10:50,560
那我们呢，还有混合架构

264
00:10:50,560 --> 00:10:51,960
那我们可以呢

265
00:10:51,960 --> 00:10:53,250
比如说，呃

266
00:10:53,250 --> 00:10:57,870
我们使用的时候做读写操作的时候用的是

267
00:10:57,870 --> 00:10:59,020
呃，客户端

268
00:10:59,020 --> 00:11:01,920
用查询操作的时候呢，用浏览器

269
00:11:01,920 --> 00:11:05,590
那这种情况下就是典型的混合架构

270
00:11:05,590 --> 00:11:09,820
就是呢，我们的茶写分离这样的一种结构

271
00:11:09,820 --> 00:11:12,220
当然还有其他的一些应用

272
00:11:12,220 --> 00:11:15,380
大家呢，简单了解一下就可以了

273
00:11:15,380 --> 00:11:18,420
那我们典型的 BS 架构当中啊

274
00:11:18,420 --> 00:11:21,760
还有一个呢， MVC 的这个架构风格

275
00:11:21,760 --> 00:11:23,880
也叫做呢设计模式

276
00:11:23,880 --> 00:11:26,140
它的这种设计过程的话

277
00:11:26,140 --> 00:11:28,600
就划分成了模型

278
00:11:28,600 --> 00:11:32,100
视图以及控制器三个部分

279
00:11:32,100 --> 00:11:34,430
那我们的模型部分呢

280
00:11:34,430 --> 00:11:38,380
它处理我们应用程序数据逻辑的部分

281
00:11:38,380 --> 00:11:42,330
试图呢，唉，处理的就是我们显示的阶段

282
00:11:42,330 --> 00:11:45,880
控制器处理呢与用户的交互

283
00:11:45,880 --> 00:11:50,050
从而给我们的业务逻辑做了一些划分

284
00:11:50,050 --> 00:11:52,370
达到解耦以及呢

285
00:11:52,370 --> 00:11:54,880
方便复用的这种结构

286
00:11:54,880 --> 00:11:56,090
那这就是呢

287
00:11:56,090 --> 00:11:57,550
MVC 的风格

288
00:11:57,550 --> 00:11:59,960
了解一下呢就可以了

289
00:11:59,960 --> 00:12:02,810
在截图一一这个体系当中的话

290
00:12:02,810 --> 00:12:04,310
我们呢，还有试图

291
00:12:04,310 --> 00:12:06,340
主要是 GSP 来实现的

292
00:12:06,340 --> 00:12:07,920
控制呢，就是 civil 

293
00:12:07,920 --> 00:12:09,440
而模型的话

294
00:12:09,440 --> 00:12:10,940
它有实体病

295
00:12:10,940 --> 00:12:12,160
还有呢，诶

296
00:12:12,160 --> 00:12:14,160
消息驱动病等等

297
00:12:14,160 --> 00:12:16,900
那这是 MVC 的一个简单介绍

298
00:12:16,900 --> 00:12:19,680
后面再来看到独立构建风格

299
00:12:19,680 --> 00:12:21,500
对于独立构建风格啊

300
00:12:21,500 --> 00:12:22,630
我们了解到

301
00:12:22,630 --> 00:12:25,350
呃，包含哪两类就可以了

302
00:12:25,350 --> 00:12:30,380
这里包含的是进程通信以及呢，事件驱动系统

303
00:12:30,380 --> 00:12:32,440
进程通信的话

304
00:12:32,440 --> 00:12:36,480
它划分了构建作为呢，独立的过程

305
00:12:36,480 --> 00:12:39,720
连接键呢，就是我们消息的传递

306
00:12:39,720 --> 00:12:41,800
消息传递过程当中啊

307
00:12:41,800 --> 00:12:44,370
我们的构件通常是命名过程

308
00:12:44,370 --> 00:12:46,760
消息传递呢，是点对点的

309
00:12:46,760 --> 00:12:48,920
还有呢，像远程过程调用

310
00:12:48,920 --> 00:12:53,660
这里呢，知道一下是通信进程通信就可以了

311
00:12:53,660 --> 00:12:56,290
事件驱动系统比较特殊

312
00:12:56,290 --> 00:12:58,980
它这个事件的驱动啊

313
00:12:58,980 --> 00:13:01,750
我们叫做呢隐式调用

314
00:13:01,750 --> 00:13:05,870
他是做了一个触发或者说呢，广播

315
00:13:05,870 --> 00:13:08,660
这里在我们向 java 开发

316
00:13:08,660 --> 00:13:10,020
面向对象开发的时候

317
00:13:10,020 --> 00:13:11,300
经常会有呢

318
00:13:11,300 --> 00:13:14,240
比如说一个按钮绑定一个事件

319
00:13:14,240 --> 00:13:16,230
那这个事件发生之后

320
00:13:16,230 --> 00:13:19,980
它就会呢，随之自动触发一个过程

321
00:13:19,980 --> 00:13:23,070
那这个触发有没有直接调用呢

322
00:13:23,070 --> 00:13:25,930
没有，它是触发性质的

323
00:13:25,930 --> 00:13:28,970
所以我们叫做隐式调用

324
00:13:28,970 --> 00:13:33,710
区分影视调用和显示调用的区别就可以了

325
00:13:33,710 --> 00:13:36,980
下面呢，我们再来看到虚拟机风格

326
00:13:36,980 --> 00:13:41,790
虚拟机风格呢，它跟我们的编译器非常相似

327
00:13:41,790 --> 00:13:44,650
那我们编译器的时候是有一个呢

328
00:13:44,650 --> 00:13:45,930
编译器的部件

329
00:13:45,930 --> 00:13:49,490
我们输入，哎，相应的这些呢语句

330
00:13:49,490 --> 00:13:52,240
它可以呢编译出特定

331
00:13:52,240 --> 00:13:53,690
相应的这个呢

332
00:13:53,690 --> 00:13:54,750
可执行程序

333
00:13:54,750 --> 00:13:57,190
或者其他的一些呢，中间代码

334
00:13:57,190 --> 00:13:59,130
而解释器的话

335
00:13:59,130 --> 00:14:02,160
它通常完成的就是呢

336
00:14:02,160 --> 00:14:04,120
中间的这个翻译的过程

337
00:14:04,120 --> 00:14:06,670
做一个呢解释的工作

338
00:14:06,670 --> 00:14:09,250
那我们在这里像工作流引擎

339
00:14:09,250 --> 00:14:11,400
就是属于这类应用了

340
00:14:11,400 --> 00:14:13,510
我们呢，在这个过程当

341
00:14:13,510 --> 00:14:15,170
具体如何来解释

342
00:14:15,170 --> 00:14:17,440
就是我们定义的主体

343
00:14:17,440 --> 00:14:22,630
而它的缺点呢，就是在于执行效率会比较低

344
00:14:22,630 --> 00:14:25,560
基于规则的系统同样如此

345
00:14:25,560 --> 00:14:29,680
只是说它中间是一个规则转换的过程

346
00:14:29,680 --> 00:14:32,630
主要呢，用在人工领域里面

347
00:14:32,630 --> 00:14:35,330
还有我们的这种智能决策

348
00:14:35,330 --> 00:14:38,700
商业智能决策里面可能会用到

349
00:14:38,700 --> 00:14:43,140
最后看一下呢，关于数据仓库啊

350
00:14:43,140 --> 00:14:46,610
仓库风格，以数据为中心的风格

351
00:14:46,610 --> 00:14:48,720
这种风格主要呢

352
00:14:48,720 --> 00:14:50,950
就是以数据为中心

353
00:14:50,950 --> 00:14:52,990
它的整个架构体系当中呢

354
00:14:52,990 --> 00:14:54,690
有一个核心的部分

355
00:14:54,690 --> 00:14:57,050
里面是大量的数据

356
00:14:57,050 --> 00:15:00,470
像数据库系统就是典型的这种风格

357
00:15:00,470 --> 00:15:01,800
那数据库系统

358
00:15:01,800 --> 00:15:03,140
我们的所有操

359
00:15:03,140 --> 00:15:05,460
围绕的都是数据核心吧

360
00:15:05,460 --> 00:15:06,980
这个数据过程当中

361
00:15:06,980 --> 00:15:11,150
我们还有多个可操作数据的这些元件

362
00:15:11,150 --> 00:15:13,400
叫做呢独立的处理单元

363
00:15:13,400 --> 00:15:15,680
这就是呢数据库系统

364
00:15:16,290 --> 00:15:17,970
黑板系统呢

365
00:15:17,970 --> 00:15:20,160
它就包含知识源

366
00:15:20,160 --> 00:15:22,500
黑板以及呢控制过程

367
00:15:22,500 --> 00:15:24,080
那知识源的话

368
00:15:24,080 --> 00:15:27,350
它包括的就是我们的独立计算的单元

369
00:15:27,350 --> 00:15:29,380
提供相应的知识

370
00:15:29,380 --> 00:15:32,700
而我们的黑板它很重要

371
00:15:32,700 --> 00:15:35,400
黑板是可以变化的

372
00:15:35,400 --> 00:15:38,120
我们在做修改和显示的时候

373
00:15:38,120 --> 00:15:41,120
都是通过黑板来进行控制的

374
00:15:41,120 --> 00:15:44,520
那我们在这里要注意黑板啊

375
00:15:44,520 --> 00:15:48,100
我们整个黑板它是呢

376
00:15:48,100 --> 00:15:50,600
通过知识原来响应

377
00:15:50,600 --> 00:15:55,330
然后呢，黑板的状态变化来进行控制

378
00:15:55,330 --> 00:15:57,020
那我们在这里呢

379
00:15:57,020 --> 00:16:00,860
黑板系统通常是用于解决问题

380
00:16:00,860 --> 00:16:03,060
没有确定性算法的这种

381
00:16:03,060 --> 00:16:04,910
那我们不知道到底怎么算

382
00:16:04,910 --> 00:16:08,220
但是我在黑板上，唉，写了1+1

383
00:16:08,220 --> 00:16:12,170
它会呢，根据这个1+1去找规则

384
00:16:12,170 --> 00:16:14,650
然后呢，输出等于二

385
00:16:14,650 --> 00:16:18,680
那黑板系统也可以做编译器优化

386
00:16:18,680 --> 00:16:23,570
那与我们前面讲的管道过滤器有一定的区别

387
00:16:23,570 --> 00:16:26,070
黑板系统用于编译器的话

388
00:16:26,070 --> 00:16:28,530
主要是用于一些高亮控制啊

389
00:16:28,530 --> 00:16:31,160
这种，呃，触发的过程

390
00:16:31,160 --> 00:16:36,240
它还可以用于信号处理和问题规划的地方

391
00:16:36,240 --> 00:16:38,060
超文本系统呢

392
00:16:38,060 --> 00:16:42,290
知道它是我们的仓库风格就可以了

393
00:16:42,290 --> 00:16:44,870
现代集成编译的环境呢

394
00:16:44,870 --> 00:16:48,200
一般也会呢，采用这种架构风格

395
00:16:48,200 --> 00:16:50,850
那这些就是需要大家了解到的

396
00:16:50,850 --> 00:16:52,690
关于架构它的一些呢

397
00:16:52,690 --> 00:16:54,530
基本的概念内容

398
00:16:54,530 --> 00:16:59,260
我们在这里啊，并没有给大家呢，做详细的拓展

399
00:16:59,260 --> 00:17:02,260
因为这一部分展开来讲的话

400
00:17:02,260 --> 00:17:05,380
其实是可以讲到很多的课时的

401
00:17:05,380 --> 00:17:07,980
那在我们的软件设计师考试当中呢

402
00:17:07,980 --> 00:17:09,940
它只有一到两分的考察

403
00:17:09,940 --> 00:17:11,880
出现的频率呢

404
00:17:11,880 --> 00:17:13,700
相对来说考的很明显

405
00:17:13,700 --> 00:17:16,280
所以大家呢，重在了解即可

406
00:17:16,280 --> 00:17:18,490
下面我们来看一下这一部分

407
00:17:18,490 --> 00:17:22,030
在我们软件设计师考试真题当中的体现

408
00:17:22,030 --> 00:17:27,200
那首先，数据仓它是位于该体系结构的中心

409
00:17:27,200 --> 00:17:29,690
那其他构件访问数据仓库

410
00:17:29,690 --> 00:17:32,650
并对其进行增、查、删、改等操作

411
00:17:32,650 --> 00:17:37,300
以下关于这个风格说法不正确的是谁

412
00:17:37,300 --> 00:17:39,040
那我们呢

413
00:17:39,040 --> 00:17:42,300
如果说数据仓库大家不是很了解的话

414
00:17:42,300 --> 00:17:44,050
我们以数据库为例

415
00:17:44,050 --> 00:17:48,110
如果我们现在有一个数据库系统

416
00:17:48,110 --> 00:17:49,860
那我们想一想

417
00:17:49,860 --> 00:17:52,580
这个数据库系统当中

418
00:17:52,580 --> 00:17:54,490
核心是数据库

419
00:17:54,490 --> 00:17:59,100
外面有一些处理单元可以与它进行交互吧

420
00:17:59,100 --> 00:18:03,590
那它呢，可以支持可更改和可维护性

421
00:18:03,590 --> 00:18:06,240
因为我们现在用的都是数据库

422
00:18:06,240 --> 00:18:09,340
然后呢，有可复用的知识源

423
00:18:09,340 --> 00:18:10,160
比如说呢

424
00:18:10,160 --> 00:18:12,320
我们这个核心的数据文

425
00:18:12,320 --> 00:18:13,880
可以拿来复用吧

426
00:18:13,880 --> 00:18:16,790
支持容错性和健壮性

427
00:18:16,790 --> 00:18:19,470
诶，我们的数据库甚至还可以做备份吧

428
00:18:19,470 --> 00:18:23,040
那这些过程其实都是数据库的优势

429
00:18:23,040 --> 00:18:27,300
但是要想测试一个数据库好不好

430
00:18:27,300 --> 00:18:29,880
其实很难去进行界定

431
00:18:29,880 --> 00:18:30,910
为什么呢

432
00:18:30,910 --> 00:18:34,050
因为我们在考虑这种风格的时候

433
00:18:34,050 --> 00:18:39,290
除了或还有其他的一些像超文本、黑板这些系统

434
00:18:39,290 --> 00:18:41,550
还有一个非常典型的特点

435
00:18:41,550 --> 00:18:43,790
就是操作不明确吧

436
00:18:43,790 --> 00:18:46,670
操作不明确我们还怎么去测试呢

437
00:18:46,670 --> 00:18:49,390
包括在做数据库管理的时候

438
00:18:49,390 --> 00:18:50,700
我们会发

439
00:18:50,700 --> 00:18:54,410
根据应用程序它的单一步骤

440
00:18:54,410 --> 00:18:55,490
我们还好测

441
00:18:55,490 --> 00:18:58,380
而数据库看看数据库表

442
00:18:58,380 --> 00:19:01,190
让大家去做恢复性的操作

443
00:19:01,190 --> 00:19:02,840
基本上很难去做吧

444
00:19:02,840 --> 00:19:05,320
重现这种过程是很难的

445
00:19:05,320 --> 00:19:06,970
所以经常会发现

446
00:19:06,970 --> 00:19:08,300
哎，丢了一条数据

447
00:19:08,300 --> 00:19:09,980
但是不知道怎么来丢的

448
00:19:09,980 --> 00:19:13,240
那这种呢，测试相对来说很复杂

449
00:19:13,240 --> 00:19:16,320
所以 D 选项是错误的

450
00:19:16,540 --> 00:19:19,760
后面第二空就是要求大家掌握的

451
00:19:19,760 --> 00:19:23,640
以下哪一个不属于仓库风格

452
00:19:23,640 --> 00:19:27,390
仓库风格包括数据库系统、黑板系统

453
00:19:27,390 --> 00:19:28,990
超文本系统吧

454
00:19:28,990 --> 00:19:32,640
编译器它不是我们的风格架构

455
00:19:32,640 --> 00:19:35,810
风格当中包含的是解释器吧

456
00:19:35,810 --> 00:19:39,890
解释器风格是虚拟机风格的大类

457
00:19:39,890 --> 00:19:42,750
仓库风格不包含编译器

458
00:19:42,750 --> 00:19:45,670
编译器它是一个呢，应用程序

459
00:19:45,670 --> 00:19:47,260
或者说呢，叫做

460
00:19:47,260 --> 00:19:50,180
呃，系统软件这样的一个东西

461
00:19:50,180 --> 00:19:53,620
那这是呢，关于仓库风格的考察

462
00:19:53,620 --> 00:19:55,310
下面看到呢

463
00:19:55,310 --> 00:19:56,290
唉，这道

464
00:19:56,290 --> 00:20:00,360
以下关于 cs 体系结构的优点

465
00:20:00,360 --> 00:20:03,070
叙述当中不正确的是什么

466
00:20:03,070 --> 00:20:06,670
那找的考察的是 cs 它的优点吧

467
00:20:06,670 --> 00:20:09,060
那 cs 划分之后呢

468
00:20:09,060 --> 00:20:13,460
唉，我们允允许合理的划分三层的功能

469
00:20:13,460 --> 00:20:17,180
使之在逻辑上保持相对的独立

470
00:20:17,180 --> 00:20:19,420
那我们在前面其实告诉大家了

471
00:20:19,420 --> 00:20:20,380
我们可以呢

472
00:20:20,380 --> 00:20:22,800
哎，划分成，呃，服务器

473
00:20:22,800 --> 00:20:26,140
然后我们的客户端中间用抽象层

474
00:20:26,140 --> 00:20:28,620
把业务逻辑呢，抽出来吧

475
00:20:28,620 --> 00:20:31,880
逻辑上呢，可以保持相对的独立性

476
00:20:31,880 --> 00:20:35,980
允许各层灵活地选用平台和软件

477
00:20:35,980 --> 00:20:37,920
我们的服务器和客户机

478
00:20:37,920 --> 00:20:40,030
可以使用不同的操作系统

479
00:20:40,030 --> 00:20:42,270
那比如说我们数据库服务器

480
00:20:42,270 --> 00:20:43,930
用的是数据库软件吧

481
00:20:43,930 --> 00:20:47,010
而我们在选择客户端的时候

482
00:20:47,010 --> 00:20:48,670
开发软件之后呢

483
00:20:48,670 --> 00:20:50,780
去安装的这样的一些软件

484
00:20:50,780 --> 00:20:53,430
可以灵活的去选择

485
00:20:53,430 --> 00:20:54,650
C 选项

486
00:20:54,650 --> 00:20:59,630
各层可以选择不同的开发语言进行并行开发

487
00:20:59,630 --> 00:21:02,140
这种说法也是正确的吧

488
00:21:02,140 --> 00:21:03,460
系 D 选项

489
00:21:03,460 --> 00:21:07,460
系统安装、修改、维护都只在服务器端进行

490
00:21:07,460 --> 00:21:11,790
很显然不是我们的 cs 不方便的时候

491
00:21:11,790 --> 00:21:13,770
就是呢我们修改的情况下

492
00:21:13,770 --> 00:21:15,130
更新的情况下

493
00:21:15,130 --> 00:21:19,460
客户端的更新必须呢去客户机才可以

494
00:21:19,460 --> 00:21:22,170
那这是我们给大家讲到的

495
00:21:22,170 --> 00:21:24,650
关于呢架构风格的部分

496
00:21:24,650 --> 00:21:27,490
大家呢了解架构设计的一些呢

497
00:21:27,490 --> 00:21:29,660
呃基本的概念就可以了
