1
00:00:00,000 --> 00:00:03,910
接下来我们详细来看一下模块设计这一部分

2
00:00:03,910 --> 00:00:05,500
模块设计呢

3
00:00:05,500 --> 00:00:08,240
它在我们的软件设计师考试当中

4
00:00:08,240 --> 00:00:09,780
可以说是必考

5
00:00:09,780 --> 00:00:12,060
并且考的非常多

6
00:00:12,060 --> 00:00:14,740
那它的考察分三个维度

7
00:00:14,740 --> 00:00:18,480
需要大家掌握的模块设计的一些基本原则

8
00:00:18,480 --> 00:00:22,540
以以及呢，在模块设计当中非常重要

9
00:00:22,540 --> 00:00:24,280
高类聚、低耦合

10
00:00:24,280 --> 00:00:26,640
相应的耦合性和内聚性

11
00:00:26,640 --> 00:00:29,120
需要大家呢，去进行区

12
00:00:29,120 --> 00:00:31,440
这样的不同之处

13
00:00:31,440 --> 00:00:34,500
那对于模块设计而言

14
00:00:34,500 --> 00:00:38,380
我们需要了解它的一些呢，基本原则

15
00:00:38,380 --> 00:00:39,500
那我们啊

16
00:00:39,500 --> 00:00:42,180
无论是在架构方面做设计

17
00:00:42,180 --> 00:00:44,130
还是模块方面做设计

18
00:00:44,130 --> 00:00:49,030
都会有一个适中权衡的这样的原则在

19
00:00:49,030 --> 00:00:54,260
那我们在考虑模块设计的过程当中

20
00:00:54,260 --> 00:00:58,330
模块它的大小是需要适中的

21
00:00:58,330 --> 00:01:01,370
然后呢，对于擅入善出

22
00:01:01,370 --> 00:01:04,209
一般强调多善入少善出

23
00:01:04,209 --> 00:01:07,510
但其实善入和善出

24
00:01:07,510 --> 00:01:12,030
它也有一定的数量适中的这种说法

25
00:01:12,030 --> 00:01:14,320
所以过多过

26
00:01:14,320 --> 00:01:17,700
其实呢，在这里我们都是需要呢

27
00:01:17,700 --> 00:01:19,640
做适中的这种呢

28
00:01:19,640 --> 00:01:21,880
诶，折中的涉及到

29
00:01:21,880 --> 00:01:24,160
并且在这个过程当中

30
00:01:24,160 --> 00:01:28,000
我们需要减少调用的这种深度

31
00:01:28,000 --> 00:01:29,880
那什么是调用深度

32
00:01:29,880 --> 00:01:31,900
什么是善入善出呢

33
00:01:31,900 --> 00:01:34,490
我们首先讲到的模块

34
00:01:34,490 --> 00:01:36,390
其实是在结构化设计当中

35
00:01:36,390 --> 00:01:38,300
经常用到的一种说法

36
00:01:38,300 --> 00:01:41,140
我们会把一个系统或者软件

37
00:01:41,140 --> 00:01:43,260
划分成多个子系统

38
00:01:43,260 --> 00:01:46,500
按功能呢，来分一些模块

39
00:01:46,500 --> 00:01:49,290
早期的开发一个人就够了

40
00:01:49,290 --> 00:01:52,880
那我们现今的开发一般是一个团队来做

41
00:01:52,880 --> 00:01:57,310
某一个人可能只负责其中的一个功能模块

42
00:01:57,310 --> 00:01:59,340
那模块大小只有

43
00:01:59,340 --> 00:02:02,570
就是我们所划分的规模大小

44
00:02:02,570 --> 00:02:04,330
是需要适中的

45
00:02:04,330 --> 00:02:08,720
那模块与模块之间是存在一些关系的

46
00:02:08,720 --> 00:02:12,940
比如说我们在做一些结构化开发，诶

47
00:02:12,940 --> 00:02:15,740
C 语言当中的话会有一个主函数

48
00:02:15,740 --> 00:02:21,480
那主函数可能会调用其他的功能函数

49
00:02:21,480 --> 00:02:26,360
功能函数可能还会调用其他的一些呢

50
00:02:26,360 --> 00:02:28,120
唉，功能函数

51
00:02:28,440 --> 00:02:33,930
那这种调用就存在了这种分层的关系

52
00:02:33,930 --> 00:02:39,510
我们对于主函数调用其他函数的过程呢

53
00:02:39,510 --> 00:02:42,220
唉，我们叫做删除

54
00:02:42,220 --> 00:02:46,940
而某一个模块被其他人调用

55
00:02:46,940 --> 00:02:49,010
我们叫做呢擅入

56
00:02:49,010 --> 00:02:52,600
所以这就是我们提到的善入善出的概念

57
00:02:52,600 --> 00:02:55,360
虽然这里说多善入少善出

58
00:02:55,360 --> 00:02:59,810
但是我们在考试当中还是以适中为主

59
00:02:59,810 --> 00:03:02,800
善入善出呢，都不要过大

60
00:03:02,800 --> 00:03:06,430
那其次，我们调用的这种深度

61
00:03:06,430 --> 00:03:08,110
其实就是它的分

62
00:03:08,110 --> 00:03:11,240
不要呢，分得太过，诶，深入

63
00:03:11,240 --> 00:03:14,140
然后单入口，单出口

64
00:03:14,140 --> 00:03:16,420
那我们一个模块

65
00:03:16,420 --> 00:03:21,640
它的入口和出口可以理解为，哎

66
00:03:21,640 --> 00:03:24,740
如何来调用它的调用点

67
00:03:24,740 --> 00:03:27,100
那被别人调用的这一个

68
00:03:27,100 --> 00:03:30,380
就是呢，它的这种入口、出口的概念

69
00:03:30,380 --> 00:03:31,690
那这是呢

70
00:03:31,690 --> 00:03:34,470
唉，涉及到这种说法的时候

71
00:03:34,470 --> 00:03:36,370
我们把这一部分呢

72
00:03:36,370 --> 00:03:40,420
都是作为一个适中来进行理解的

73
00:03:40,420 --> 00:03:45,250
那其次功能应该呢，是可以预测的

74
00:03:45,250 --> 00:03:46,910
我们划分模块之后

75
00:03:46,910 --> 00:03:48,590
这个模块到底是干嘛的

76
00:03:48,590 --> 00:03:51,060
是需要大家呢去理解的

77
00:03:51,060 --> 00:03:53,650
最后呢，还有一个作用域

78
00:03:53,650 --> 00:03:57,070
以及控制欲这样的东西

79
00:03:58,420 --> 00:04:02,120
这是很多同学做题碰到之后

80
00:04:02,120 --> 00:04:04,060
觉得很抽象的一个东西

81
00:04:04,060 --> 00:04:09,120
那我们在模块当中这种调用关系啊

82
00:04:09,120 --> 00:04:11,680
其实诶，比如说这个模块

83
00:04:11,680 --> 00:04:13,740
它调用了三个模块

84
00:04:13,740 --> 00:04:18,000
那此时模块本身和它调用的这些模块

85
00:04:18,000 --> 00:04:19,339
组合起来

86
00:04:19,339 --> 00:04:21,640
就是它的控制欲

87
00:04:21,640 --> 00:04:27,330
而作用域它是特定描述判定的作用

88
00:04:27,330 --> 00:04:32,710
那一个函数过程当中有了判定条件

89
00:04:32,710 --> 00:04:34,060
判定的过程

90
00:04:34,060 --> 00:04:36,780
那我们是希望这个判定啊

91
00:04:36,780 --> 00:04:41,020
作用域应该尽量在本模块内部

92
00:04:41,020 --> 00:04:45,370
那很显然作用域一般是小于控制欲的吧

93
00:04:45,370 --> 00:04:48,370
所以有这样的一个原则记住呢

94
00:04:48,370 --> 00:04:52,400
诶，我们判定的作用域尽量控制在本模块

95
00:04:52,400 --> 00:04:55,640
而控制欲是它自身以及呢

96
00:04:55,640 --> 00:04:58,760
能够调用、能够调动的这些呢

97
00:04:58,760 --> 00:05:00,320
其他模块

98
00:05:00,320 --> 00:05:03,790
那我们一般呢，在结构化开发的时候啊

99
00:05:03,790 --> 00:05:06,530
会认为呢，哎，比如说做了一个主函数

100
00:05:06,530 --> 00:05:08,770
主函数它的功能函数一

101
00:05:08,770 --> 00:05:10,190
如果没有做完

102
00:05:10,190 --> 00:05:11,870
主函数能不能运行啊

103
00:05:11,870 --> 00:05:12,830
不能啊

104
00:05:12,830 --> 00:05:14,450
所以我们会说呢

105
00:05:14,450 --> 00:05:17,130
高层依赖于低层

106
00:05:23,640 --> 00:05:26,160
或者叫做呢底层

107
00:05:27,760 --> 00:05:30,140
到了面向对象之后啊

108
00:05:30,140 --> 00:05:33,040
有一个设计原则就是呢，依赖倒置

109
00:05:33,040 --> 00:05:34,550
他的所谓倒置啊

110
00:05:34,550 --> 00:05:36,950
就是将高层依赖于低层

111
00:05:36,950 --> 00:05:38,310
这种依赖关系呢

112
00:05:38,310 --> 00:05:40,370
做了一个置换的过程

113
00:05:40,370 --> 00:05:43,320
那这是模块设计的一些基本原则

114
00:05:43,320 --> 00:05:45,990
下面呢，我们详细来看一下

115
00:05:45,990 --> 00:05:49,210
模块设计最重要的一个原则叫做呢

116
00:05:49,210 --> 00:05:51,190
高类聚、低耦合

117
00:05:51,190 --> 00:05:54,190
那什么是类聚性呢

118
00:05:54,190 --> 00:05:56,730
我们对于一个团队啊

119
00:05:56,730 --> 00:05:59,720
我们经常说团队凝聚力

120
00:05:59,720 --> 00:06:02,920
所谓的凝聚力就是一个模块

121
00:06:02,920 --> 00:06:04,660
它本身的一个呢

122
00:06:04,660 --> 00:06:06,540
内部的聚合程度

123
00:06:06,540 --> 00:06:08,500
叫做呢内聚性

124
00:06:08,500 --> 00:06:12,060
那类聚性它有高低之分

125
00:06:12,060 --> 00:06:15,270
我们在这里重点需要了解到

126
00:06:15,270 --> 00:06:18,170
内聚性最低的是巧合类聚

127
00:06:18,170 --> 00:06:21,070
最高的是功能类聚

128
00:06:21,070 --> 00:06:26,740
其次对于这些类聚的定义要有所区分

129
00:06:26,740 --> 00:06:28,150
那我们在

130
00:06:28,150 --> 00:06:30,430
诶，做一些定义理解的时候

131
00:06:30,430 --> 00:06:31,950
大家其实会发

132
00:06:31,950 --> 00:06:34,530
很多定义的命名

133
00:06:34,530 --> 00:06:37,940
跟它本身的描述是一致的

134
00:06:37,940 --> 00:06:43,640
比如说功能类聚完成的是一个单一的功能

135
00:06:43,640 --> 00:06:49,280
注意功能单一并不表示功能单纯啊

136
00:06:49,280 --> 00:06:51,980
这种说法呢，不要混淆了

137
00:06:51,980 --> 00:06:56,030
那涉及到单一功能的是功能类聚

138
00:06:56,030 --> 00:06:58,400
然后顺序类聚

139
00:06:58,400 --> 00:07:00,980
它强调的是处理元

140
00:07:00,980 --> 00:07:05,250
必须呢，按特定的顺序来执行

141
00:07:05,250 --> 00:07:07,530
那所谓的顺序

142
00:07:07,530 --> 00:07:11,140
它其实就是先后

143
00:07:11,140 --> 00:07:13,540
这种顺序是固定的

144
00:07:13,540 --> 00:07:15,160
它的元素啊

145
00:07:15,160 --> 00:07:19,790
处理元素前面的输出是后面的输入

146
00:07:19,790 --> 00:07:21,360
以此类推

147
00:07:21,360 --> 00:07:23,840
从而要求顺序执行

148
00:07:23,840 --> 00:07:26,340
就叫做顺序类聚

149
00:07:26,340 --> 00:07:27,960
与它类似

150
00:07:27,960 --> 00:07:32,490
容易混淆的还有一个过程类聚

151
00:07:32,490 --> 00:07:35,370
那过程类句的描述当中

152
00:07:35,370 --> 00:07:37,380
虽然没有过程

153
00:07:37,380 --> 00:07:43,690
但他强调的是要按照特定的次序来执行

154
00:07:43,690 --> 00:07:46,620
那特定次序是不是一定顺序呢

155
00:07:46,620 --> 00:07:47,960
就不一定了

156
00:07:47,960 --> 00:07:51,990
它可以是，哎，一个节点之

157
00:07:51,990 --> 00:07:55,370
到作为多个节点的输入

158
00:07:55,370 --> 00:07:56,370
然后呢

159
00:07:56,370 --> 00:08:01,160
唉，可以作为另一个上层节点的输入等等

160
00:08:01,160 --> 00:08:04,750
那这种过程只要是特定次序

161
00:08:04,750 --> 00:08:07,110
可以不是顺序的

162
00:08:07,110 --> 00:08:10,710
所以这种描述呢，是有区别的

163
00:08:10,710 --> 00:08:16,500
那还有一个叫做瞬时类聚或者时间类聚

164
00:08:16,500 --> 00:08:20,750
他的要求呢，是我们所包含的任务

165
00:08:20,750 --> 00:08:25,850
必须在同一个时间间隔内完成啊

166
00:08:25,850 --> 00:08:27,980
那这三种类聚呢

167
00:08:27,980 --> 00:08:30,980
是相对来说比较容易混淆

168
00:08:30,980 --> 00:08:31,840
类聚性

169
00:08:31,840 --> 00:08:34,870
大家呢，注意一下就可以了

170
00:08:34,870 --> 00:08:37,940
那除了这些类聚以外的话

171
00:08:37,940 --> 00:08:40,159
我们还需要知道呢

172
00:08:40,159 --> 00:08:43,000
诶，包括通信类聚

173
00:08:43,000 --> 00:08:46,350
它指的是我们的所有元素

174
00:08:46,350 --> 00:08:50,390
是集中在一个数据结构的区域上的

175
00:08:50,390 --> 00:08:53,720
那这个跟通信没有办法联系起来

176
00:08:53,720 --> 00:08:55,180
所以需要大家呢

177
00:08:55,180 --> 00:08:57,950
特殊的去记一下这个过程

178
00:08:57,950 --> 00:09:00,380
而逻辑类聚的话

179
00:09:00,380 --> 00:09:03,680
它的整个过程就是完成逻辑上

180
00:09:03,680 --> 00:09:05,560
相关的一组任务

181
00:09:05,560 --> 00:09:08,520
偶然类聚或者巧合类聚

182
00:09:08,520 --> 00:09:12,080
可以理解为我们中间所包含的

183
00:09:12,080 --> 00:09:13,960
这些聚起来的任务啊

184
00:09:13,960 --> 00:09:15,900
是没有关系的

185
00:09:15,900 --> 00:09:18,100
或者呢，是松散关系的

186
00:09:18,100 --> 00:09:20,690
没有任何逻辑性可言的

187
00:09:20,690 --> 00:09:21,980
那这就是呢

188
00:09:21,980 --> 00:09:24,550
类聚性它的一个区分

189
00:09:24,550 --> 00:09:26,110
那在这里的话

190
00:09:26,110 --> 00:09:29,740
对于排序了解最高和最低的

191
00:09:29,740 --> 00:09:33,560
对于定义区分顺序和过程

192
00:09:33,560 --> 00:09:35,790
然后呢和顺时类聚

193
00:09:35,790 --> 00:09:39,940
其他包括功能类聚、逻辑类

194
00:09:39,940 --> 00:09:42,800
以及呢偶然类聚、巧合类聚

195
00:09:42,800 --> 00:09:44,010
这种说法的话

196
00:09:44,010 --> 00:09:47,290
定义和名称是匹配的

197
00:09:47,290 --> 00:09:49,860
包括像通信类句

198
00:09:49,860 --> 00:09:51,160
相对来说呢

199
00:09:51,160 --> 00:09:53,660
与我们的定义描述的话

200
00:09:53,660 --> 00:09:55,150
对应性不是很强

201
00:09:55,150 --> 00:09:58,870
知道呢它是与数据结构相关的就可以了

202
00:09:58,870 --> 00:10:02,790
那这是呢对类句型它的一个呢描述

203
00:10:02,790 --> 00:10:07,200
那类聚性我们在设计过程当中强调的是

204
00:10:07,200 --> 00:10:10,620
尽可能高做高类聚

205
00:10:10,620 --> 00:10:14,270
那其次还有呢，耦合性

206
00:10:14,780 --> 00:10:17,480
耦合性指的是什么呢

207
00:10:17,480 --> 00:10:21,230
团队与团队之间的关联

208
00:10:21,230 --> 00:10:24,730
那这种关联性呢，叫做耦合

209
00:10:24,730 --> 00:10:29,810
耦合性我们强调的是尽量低耦合

210
00:10:29,810 --> 00:10:32,530
为什么要低耦合呢

211
00:10:32,530 --> 00:10:36,650
我们所谓的耦合是模块与模块

212
00:10:36,650 --> 00:10:38,900
它们之间的关联性吧

213
00:10:38,900 --> 00:10:41,940
如果关联性很强

214
00:10:41,940 --> 00:10:46,110
那当 A 模块发生变化的时候

215
00:10:46,110 --> 00:10:48,910
B 模块一定要随之改变

216
00:10:48,910 --> 00:10:53,240
否则的话，这个关联性很有可能会出现问题

217
00:10:53,240 --> 00:10:55,240
那我们想一想

218
00:10:55,240 --> 00:10:58,320
在整个软件开发当中呢

219
00:10:58,320 --> 00:11:00,980
其实有这么一条潜规则

220
00:11:00,980 --> 00:11:02,370
唉，我们啊

221
00:11:02,370 --> 00:11:05,550
包括在后面讲测试的时候会提到

222
00:11:05,550 --> 00:11:09,560
当你在程序当中修改了一个 bug 

223
00:11:09,560 --> 00:11:12,320
很可能会引入更多的 bug 

224
00:11:12,320 --> 00:11:16,580
也就是说，一旦某一个模块发生变化的话

225
00:11:16,580 --> 00:11:20,380
我们需要呢，测试所有与之相关的模块

226
00:11:20,380 --> 00:11:21,730
那想一想

227
00:11:21,730 --> 00:11:23,270
耦合度越高

228
00:11:23,270 --> 00:11:24,610
紧密程度越高

229
00:11:24,610 --> 00:11:27,410
是不是越容易受它影响啊

230
00:11:27,410 --> 00:11:30,600
所以我们尽可能的让它们变成

231
00:11:30,600 --> 00:11:33,240
耦合性较低的这种关系

232
00:11:33,240 --> 00:11:35,270
那就是呢， D 耦合

233
00:11:35,270 --> 00:11:39,210
耦合性最低的是非直接耦合

234
00:11:39,210 --> 00:11:42,490
最高的是内容耦合

235
00:11:42,490 --> 00:11:44,870
那耦合性同样呢

236
00:11:44,870 --> 00:11:47,470
我们要区别它的具体定义

237
00:11:47,470 --> 00:11:49,390
在考试当中啊

238
00:11:49,390 --> 00:11:52,570
对于内聚性和耦合性的考察

239
00:11:52,570 --> 00:11:56,190
主要是给大家一个情景或者定义

240
00:11:56,190 --> 00:11:57,780
直接问大家

241
00:11:57,780 --> 00:12:02,710
就是哪一种耦合或者哪一种类聚方式

242
00:12:02,710 --> 00:12:05,150
偶尔呢，也会出现，哎

243
00:12:05,150 --> 00:12:06,970
选择类聚方式之后

244
00:12:06,970 --> 00:12:11,470
问大家这种类聚方式或者耦合方式的特点

245
00:12:11,750 --> 00:12:14,250
那我们详细来看一下

246
00:12:14,250 --> 00:12:16,850
这里给大家列举的一些耦合

247
00:12:16,850 --> 00:12:19,110
那这些耦合方

248
00:12:19,110 --> 00:12:21,200
同样的我们会发现

249
00:12:21,200 --> 00:12:26,150
定义当中很多都是与名称直接相关的

250
00:12:26,150 --> 00:12:27,160
这种定义

251
00:12:27,160 --> 00:12:30,180
根据它的定义抽出来它的名字

252
00:12:30,180 --> 00:12:32,160
所以我们会发现，哎

253
00:12:32,160 --> 00:12:36,160
非直接耦合指的就是模块没有直接关系

254
00:12:36,160 --> 00:12:37,440
其次呢

255
00:12:37,440 --> 00:12:39,160
唉，还有比较

256
00:12:39,160 --> 00:12:42,180
呃，明显的像我们的控制耦合

257
00:12:42,180 --> 00:12:47,260
就是呢传递里面的控制模块内部的逻辑信息

258
00:12:47,260 --> 00:12:50,970
其实可以理解为它传递了控制信息

259
00:12:50,970 --> 00:12:53,820
那公共耦合是指的是呢

260
00:12:53,820 --> 00:12:57,420
模块使用了同一个公共数据环境

261
00:12:57,420 --> 00:13:00,990
那这里呢是有直接对应关系的

262
00:13:00,990 --> 00:13:04,160
比较容易混淆的是什么呢

263
00:13:04,160 --> 00:13:06,910
数据耦合和标记耦合

264
00:13:06,910 --> 00:13:08,890
这两个在考试当中啊

265
00:13:08,890 --> 00:13:10,580
也喜欢考大家

266
00:13:10,580 --> 00:13:14,970
那我们说耦合是模块与模块之间的关系吧

267
00:13:14,970 --> 00:13:16,780
那数据耦合

268
00:13:16,780 --> 00:13:22,130
它是借助参数表来传递减单数据的

269
00:13:22,130 --> 00:13:28,120
而一组模块通过参数表传递记录信息

270
00:13:28,120 --> 00:13:32,260
或者呢，把它理解为复杂数据

271
00:13:32,260 --> 00:13:34,560
就是呢标记耦合

272
00:13:36,520 --> 00:13:41,400
如何来区分简单数据和复杂数据呢

273
00:13:41,400 --> 00:13:43,510
简单数据很明显呢

274
00:13:43,510 --> 00:13:46,500
就是一些单一的变量的传递

275
00:13:46,500 --> 00:13:48,430
而复杂数据

276
00:13:48,430 --> 00:13:54,270
它一般可以有一组相关联的数据

277
00:13:58,310 --> 00:14:02,210
一组相关数据我们应该怎么来传啊

278
00:14:02,210 --> 00:14:03,510
这种情况下

279
00:14:03,510 --> 00:14:08,070
它一般呢会通过数据结构或者结构体

280
00:14:08,070 --> 00:14:10,250
来进行传递

281
00:14:10,790 --> 00:14:15,420
结构体呢，是 C 语言当中的一种结构

282
00:14:15,420 --> 00:14:17,640
那这种结构里面的结构体

283
00:14:17,640 --> 00:14:19,600
跟我们的面向对象类啊

284
00:14:19,600 --> 00:14:21,820
有一些很相似的地方

285
00:14:21,820 --> 00:14:25,640
就是结构体当中可以包含很多的这些属性

286
00:14:25,640 --> 00:14:27,950
所以经常会用结构体呢

287
00:14:27,950 --> 00:14:30,090
来传递一组数据

288
00:14:30,090 --> 00:14:32,160
也就是复杂数据的情况

289
00:14:32,160 --> 00:14:34,510
这种情况呢，我们就说，诶

290
00:14:34,510 --> 00:14:36,980
模块之间是标记耦合的

291
00:14:36,980 --> 00:14:40,620
而单一数据传递简单数据的

292
00:14:40,620 --> 00:14:43,040
我们叫做呢，数据耦合

293
00:14:43,040 --> 00:14:45,730
注意呢，区分一下这个过程

294
00:14:45,730 --> 00:14:47,850
那除了这几种耦合方式

295
00:14:47,850 --> 00:14:50,400
还有呢，外部耦合

296
00:14:50,400 --> 00:14:53,320
模块外部怎么耦合呢

297
00:14:53,320 --> 00:14:58,010
唉，在这里会涉及到一个全局变量

298
00:14:58,010 --> 00:15:02,800
全局变量它是定义在我们的程序外部

299
00:15:02,800 --> 00:15:04,060
但是呢，唉

300
00:15:04,060 --> 00:15:06,710
所有的函数都可以用它吧

301
00:15:06,710 --> 00:15:09,520
所以这个过程我们把它叫做呢

302
00:15:09,520 --> 00:15:11,080
外部耦合

303
00:15:11,080 --> 00:15:16,210
一组模块访问的是同一全局简单变量

304
00:15:16,210 --> 00:15:20,690
而不是呢，通过参数表来传递这个数据了

305
00:15:20,690 --> 00:15:23,420
我们就称它呢，是外部耦合

306
00:15:23,420 --> 00:15:27,050
最后内容耦合它有几种说法

307
00:15:27,050 --> 00:15:29,890
一种呢，是模块直接访问

308
00:15:29,890 --> 00:15:34,480
然后呢，还有模块没有通过正常入口访问

309
00:15:34,480 --> 00:15:35,940
以及呢，唉

310
00:15:35,940 --> 00:15:39,950
模块有一部分程序代码有重叠

311
00:15:39,950 --> 00:15:42,650
或者模块有多个入口

312
00:15:42,650 --> 00:15:45,950
我们都把它叫做内容耦合

313
00:15:45,950 --> 00:15:50,130
所以大家可以依据前面的耦合方式来区分

314
00:15:50,130 --> 00:15:51,310
区分不了的

315
00:15:51,310 --> 00:15:54,750
那很有可能它就是内容耦合了

316
00:15:54,750 --> 00:16:00,980
那这是高类聚、低耦合这样的模块设计原则

317
00:16:01,400 --> 00:16:04,560
下面我们来看一下这一部分

318
00:16:04,560 --> 00:16:08,960
在软件设计师考试真题当中的体现

319
00:16:08,960 --> 00:16:11,330
某个模块当中啊

320
00:16:11,330 --> 00:16:14,660
各个处理元素都密切相关

321
00:16:14,660 --> 00:16:17,230
哎，关于呢，同一个功能的

322
00:16:17,230 --> 00:16:20,850
然后呢，必须顺序执行

323
00:16:20,850 --> 00:16:23,600
那我们下面的命名当中

324
00:16:23,600 --> 00:16:26,260
与顺序执行相关的是谁啊

325
00:16:26,260 --> 00:16:29,410
应该是顺时类聚吧

326
00:16:29,410 --> 00:16:34,800
所以这里考察的就是类聚类型当中诶

327
00:16:34,800 --> 00:16:37,100
顺序类聚的区分

328
00:16:37,100 --> 00:16:42,080
那我们与之相似的过程类句没有顺序

329
00:16:42,080 --> 00:16:44,900
而是特定次序

330
00:16:45,780 --> 00:16:47,760
不需要顺序

331
00:16:47,760 --> 00:16:50,840
但是呢，可以是特定次序

332
00:16:50,840 --> 00:16:53,020
然后时间内聚

333
00:16:53,020 --> 00:16:55,630
或者叫做瞬时类聚

334
00:16:55,630 --> 00:16:57,770
是他的所有任务

335
00:16:57,770 --> 00:17:01,650
在同一时间间隔内完成

336
00:17:06,099 --> 00:17:07,800
逻辑类聚呢

337
00:17:07,800 --> 00:17:11,819
哎，与逻辑相关的、有逻辑关联性的

338
00:17:12,490 --> 00:17:15,369
放在同一个模块当中

339
00:17:15,730 --> 00:17:18,470
就叫做呢逻辑类聚

340
00:17:18,470 --> 00:17:23,069
那这是我们给大家提到的类聚类型的区分

341
00:17:23,069 --> 00:17:26,490
顺序类聚和我们的过程类句

342
00:17:26,490 --> 00:17:28,460
不要呢混淆了

343
00:17:28,460 --> 00:17:30,870
接下来再来看到呢

344
00:17:30,870 --> 00:17:33,130
对偶合类型的考察

345
00:17:33,130 --> 00:17:36,800
模块 A ，将学生信息，唉

346
00:17:36,800 --> 00:17:40,440
也就是学生姓名、学号、手机

347
00:17:40,440 --> 00:17:42,600
放在一个结构体当中

348
00:17:42,600 --> 00:17:43,920
传递给模块 B 

349
00:17:43,920 --> 00:17:47,340
那 ab 之间的耦合类型应该是什么呢

350
00:17:47,340 --> 00:17:50,260
首先我们传递给 B 的是什么

351
00:17:50,260 --> 00:17:51,790
学生信息吧

352
00:17:51,790 --> 00:17:54,450
传递的是数据吗

353
00:17:54,450 --> 00:17:57,670
唉，我们的数据耦合

354
00:17:57,670 --> 00:17:59,870
它是简单数据

355
00:17:59,870 --> 00:18:01,300
通过参数表达

356
00:18:01,300 --> 00:18:04,240
这个数据显然不是简单的

357
00:18:04,240 --> 00:18:06,940
它包含了一组数据

358
00:18:06,940 --> 00:18:08,990
通过结构体来传输

359
00:18:08,990 --> 00:18:10,640
所以它是呢

360
00:18:10,640 --> 00:18:13,320
标记耦合、控制耦合

361
00:18:13,320 --> 00:18:16,330
理解为呢，传递的是控制信息

362
00:18:16,330 --> 00:18:18,840
内容耦合有多种描述

363
00:18:18,840 --> 00:18:22,310
可以呢直接访问或者非正常入口，诶

364
00:18:22,310 --> 00:18:26,050
或者呢有多个入口这样的一些呢特点

365
00:18:26,050 --> 00:18:31,240
那我们这道题考察的就是对耦合方式的诶

366
00:18:31,240 --> 00:18:31,840
区分

367
00:18:31,840 --> 00:18:35,100
注意标记耦合和数据耦合

368
00:18:35,100 --> 00:18:37,100
不要呢混淆了

369
00:18:37,380 --> 00:18:42,350
下面看到呢，对模块其他设计原则的考察

370
00:18:42,350 --> 00:18:45,390
良好的启发式设计

371
00:18:45,390 --> 00:18:48,760
原则上应该不包括哪个选项

372
00:18:48,760 --> 00:18:51,220
所以我们这里考察的是设计原则

373
00:18:51,220 --> 00:18:54,340
注意找的是不包括 A 选项

374
00:18:54,340 --> 00:18:56,830
提高模块独立性

375
00:18:56,830 --> 00:19:00,240
那这里的独立性其实就可以呢

376
00:19:00,240 --> 00:19:04,060
把它理解为内聚性的说法

377
00:19:04,480 --> 00:19:05,880
高类聚

378
00:19:05,880 --> 00:19:09,910
所以呢，提高内聚性就是提高了独立性

379
00:19:09,910 --> 00:19:12,310
这个说法呢是正确的

380
00:19:12,310 --> 00:19:15,650
包括诶，降低它的关联性

381
00:19:15,650 --> 00:19:20,120
其实就是它的这种能 A 耦合性的说法

382
00:19:20,120 --> 00:19:22,600
模块接口的复杂性

383
00:19:22,600 --> 00:19:25,460
模块接口可以理解为

384
00:19:25,460 --> 00:19:28,490
模块与模块之间的关联性吧

385
00:19:28,490 --> 00:19:31,680
所以这个过程我们可以把接口呢

386
00:19:31,680 --> 00:19:34,500
理解为它的耦合性

387
00:19:37,460 --> 00:19:41,160
D 偶合说法也是正确的

388
00:19:41,160 --> 00:19:43,320
那 B 和 C 当中啊

389
00:19:43,320 --> 00:19:44,820
大家容易

390
00:19:44,820 --> 00:19:47,640
作为混淆项的是 C 选项

391
00:19:47,640 --> 00:19:51,690
因为作用域和控制欲这种说法呢

392
00:19:51,690 --> 00:19:53,280
很容易记混

393
00:19:53,280 --> 00:19:57,120
作用域是判定它的作用范围

394
00:19:57,120 --> 00:20:01,580
而我们的控制欲是模块本身

395
00:20:01,580 --> 00:20:04,450
以及它能够调用的具体范围

396
00:20:04,450 --> 00:20:07,840
那我们呢，在前面描述了一个设计原则

397
00:20:07,840 --> 00:20:11,400
作用域尽量的控制在本模块内

398
00:20:11,400 --> 00:20:14,970
那显然这个范围会更小一些

399
00:20:14,970 --> 00:20:17,630
应该是在控制范围内的

400
00:20:17,630 --> 00:20:19,950
这个说法也是正确的

401
00:20:19,950 --> 00:20:23,390
模块规模是不是越小越好呢

402
00:20:23,390 --> 00:20:25,780
不是，我们说到过

403
00:20:25,780 --> 00:20:27,900
其他的原则当中

404
00:20:27,900 --> 00:20:31,190
都会有适中的思想在里面

405
00:20:31,190 --> 00:20:34,030
过大或者过小都不好

406
00:20:34,030 --> 00:20:36,310
除了高类聚、低耦合

407
00:20:36,310 --> 00:20:40,420
其他呢，我们在判断的时候以适中为标准

408
00:20:40,420 --> 00:20:43,060
相对来说呢，更稳妥一些

409
00:20:43,060 --> 00:20:44,500
那这是对呢

410
00:20:44,500 --> 00:20:48,990
其他的我们的模块设计原则的考察

411
00:20:48,990 --> 00:20:51,860
以上呢，就是给大家介绍到的

412
00:20:51,860 --> 00:20:54,370
模块设计需要大家了解的内容

413
00:20:54,370 --> 00:20:56,520
这一部分在考试当中啊

414
00:20:56,520 --> 00:20:58,780
经常考这样的一些选择题

415
00:20:58,780 --> 00:21:01,760
而选择题当中出现的概念

416
00:21:01,760 --> 00:21:03,800
会有一些呢易混淆的点

417
00:21:03,800 --> 00:21:05,750
需要大家呢去注意

418
00:21:05,750 --> 00:21:08,880
那看起来好像记忆的内容比较多

419
00:21:08,880 --> 00:21:12,580
大家呢，可以利用老师刚刚讲到的一些名词

420
00:21:12,580 --> 00:21:14,890
与定义之间的匹配关系

421
00:21:14,890 --> 00:21:15,680
然后呢

422
00:21:15,680 --> 00:21:20,020
再去记一些特殊的这种定义就可以了啊

423
00:21:20,020 --> 00:21:23,210
那这些呢，就是模块设计的部分
