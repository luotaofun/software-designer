1
00:00:00,000 --> 00:00:02,260
接下来我们来了解一下

2
00:00:02,260 --> 00:00:04,700
在软件开发过程当中呢

3
00:00:04,700 --> 00:00:07,610
常用的一些软件开发方法

4
00:00:07,610 --> 00:00:12,380
软件开发方法在我们软件设计师的考察当中

5
00:00:12,380 --> 00:00:15,870
它出现的频率并不是很高

6
00:00:15,870 --> 00:00:17,660
但是这一部分呢

7
00:00:17,660 --> 00:00:20,200
是在我们软件开发当中啊

8
00:00:20,200 --> 00:00:22,780
具有一定全局性的一些概念

9
00:00:22,780 --> 00:00:25,720
所以大家呢，还是需要去了解一下

10
00:00:25,720 --> 00:00:27,760
首先呢，我们看到啊

11
00:00:27,760 --> 00:00:30,180
在软件开发方法当中

12
00:00:30,180 --> 00:00:34,300
我们常用的主要呢，有结构化原型

13
00:00:34,300 --> 00:00:37,880
还有面向对象结构化开发

14
00:00:37,880 --> 00:00:43,050
他的思想呢，是比较早期的结构化开发方法啊

15
00:00:43,050 --> 00:00:46,670
它是呢，面向过程的一种开发方法

16
00:00:49,580 --> 00:00:52,780
在面向过程开发方法当中呢

17
00:00:52,780 --> 00:00:56,080
我们是先知道某一个问题

18
00:00:56,080 --> 00:00:57,650
它的解决方案

19
00:00:57,650 --> 00:00:59,430
把这个解决方案呢

20
00:00:59,430 --> 00:01:03,070
唉，按我们的方案一步一步的去实现

21
00:01:03,070 --> 00:01:05,090
就是呢，结构化开发

22
00:01:05,090 --> 00:01:09,410
那结构化它的基本思想呢，是用户至上

23
00:01:09,410 --> 00:01:12,170
并且啊，它有一个很大的特点

24
00:01:12,170 --> 00:01:14,070
就是会呢，自顶向

25
00:01:14,070 --> 00:01:16,630
逐步来进行分解、求精

26
00:01:16,630 --> 00:01:18,440
它的大致过程呢

27
00:01:18,440 --> 00:01:22,600
跟我们软件的生命周期基本上是一致的

28
00:01:22,600 --> 00:01:25,520
并且他的这种生命周期啊

29
00:01:25,520 --> 00:01:28,640
会严格区分他的工作阶段

30
00:01:28,640 --> 00:01:31,960
也就是说做了规划再做计划

31
00:01:31,960 --> 00:01:34,840
再去呢做我们的设计工作

32
00:01:34,840 --> 00:01:38,960
设计完了唉，再去做我们的实现工作

33
00:01:38,960 --> 00:01:42,080
那我们在这个阶段当中啊

34
00:01:42,080 --> 00:01:45,520
每一个阶段都有它特定的任

35
00:01:45,520 --> 00:01:48,280
以及呢，相应的产物

36
00:01:48,280 --> 00:01:49,870
这个产物呢

37
00:01:49,870 --> 00:01:53,580
一般会以文档的形式来形成

38
00:01:53,580 --> 00:01:54,630
比如说呢

39
00:01:54,630 --> 00:01:57,250
哎，我们一般结构化开

40
00:01:57,250 --> 00:01:59,090
它的生命周期呀

41
00:01:59,090 --> 00:02:02,170
大概呢，就是啊规划

42
00:02:02,790 --> 00:02:06,840
或者说计划阶段会得到呢一个计划书

43
00:02:06,840 --> 00:02:10,139
然后呢会进入需求分析阶段

44
00:02:10,139 --> 00:02:13,080
得到需求规格说明书

45
00:02:13,080 --> 00:02:15,160
需求分析结束之后

46
00:02:15,160 --> 00:02:17,050
会进入设计阶段

47
00:02:17,050 --> 00:02:20,040
它有概要设计和详细设计

48
00:02:20,040 --> 00:02:21,900
有概要设计说明书

49
00:02:21,900 --> 00:02:23,610
详细设计说明书

50
00:02:23,610 --> 00:02:26,110
然后再去进行实现

51
00:02:26,110 --> 00:02:28,360
也就是编码的过程

52
00:02:28,360 --> 00:02:33,060
那此时我们就会得到一个呢源码的文件

53
00:02:33,060 --> 00:02:36,030
到后面呢，还有测试阶段

54
00:02:36,030 --> 00:02:39,390
会有测试报告、测试用例等等

55
00:02:39,390 --> 00:02:40,750
测试计划等等

56
00:02:40,750 --> 00:02:44,730
那测试之后后面还会进入运维阶段

57
00:02:44,730 --> 00:02:49,170
那这个过程当中有运维相应的说明书

58
00:02:49,170 --> 00:02:54,710
所以每一个阶段都有它特定的任务以及结果

59
00:02:54,710 --> 00:02:56,930
严格区分各个阶段

60
00:02:56,930 --> 00:03:00,530
那它是一个工程化的一个开发方法

61
00:03:00,530 --> 00:03:05,720
每一步呢，都会产本身标准化的文档资料

62
00:03:05,720 --> 00:03:07,840
所以结构化开发啊

63
00:03:07,840 --> 00:03:10,500
它其实是非常严谨的

64
00:03:10,500 --> 00:03:12,830
那它适用于呢

65
00:03:12,830 --> 00:03:15,930
需求明确的项目

66
00:03:18,800 --> 00:03:22,380
如果需求不明确的话

67
00:03:22,380 --> 00:03:25,340
我们啊，在开发过程当中

68
00:03:25,340 --> 00:03:29,710
很有可能编码测试交给用户测试

69
00:03:29,710 --> 00:03:32,000
发现需求有问题

70
00:03:32,000 --> 00:03:33,510
那这种情况下

71
00:03:33,510 --> 00:03:35,970
整个项目是需要推倒重来的

72
00:03:35,970 --> 00:03:37,960
所以结构化开发方法

73
00:03:37,960 --> 00:03:41,710
它一定是针对需求明确的这样的项目

74
00:03:41,710 --> 00:03:47,480
那它的整个开发过程具有整体性、全局性、工程化

75
00:03:47,480 --> 00:03:49,250
所以它非常适合呢

76
00:03:49,250 --> 00:03:50,690
做一些科研工作

77
00:03:50,690 --> 00:03:51,050
诶

78
00:03:51,050 --> 00:03:52,450
做一些呢，呃

79
00:03:52,450 --> 00:03:55,800
类似于我们去研研究软件开发过程的时候

80
00:03:55,800 --> 00:03:57,860
做一些呢论文性质的东西

81
00:03:57,860 --> 00:04:00,460
因为每一步都会有特定的产物

82
00:04:00,460 --> 00:04:01,830
非常明确

83
00:04:01,830 --> 00:04:05,820
那需求明确这个要求高不高呢

84
00:04:05,820 --> 00:04:08,200
其实在软件开发过程当中

85
00:04:08,200 --> 00:04:10,750
这个要求还是比较高的

86
00:04:10,750 --> 00:04:14,400
因为我们啊，如果做个开发的同学就知道呢

87
00:04:14,400 --> 00:04:18,540
我们的用户在提出需求的时候

88
00:04:18,540 --> 00:04:22,180
本身可能他自己都不知道自己想要什么

89
00:04:22,180 --> 00:04:27,190
所以需求本身是具有渐进明晰性的

90
00:04:34,480 --> 00:04:38,120
那需求不明确的时候怎么办呢

91
00:04:38,120 --> 00:04:41,770
我们需要帮助用户来明确需求

92
00:04:41,770 --> 00:04:44,220
所以我们还有第二种方法

93
00:04:44,220 --> 00:04:46,620
叫叫、叫做圆形方法

94
00:04:46,620 --> 00:04:51,180
圆形方法适用于需求不明确

95
00:04:53,480 --> 00:04:55,140
我们可以呢

96
00:04:55,140 --> 00:04:59,680
利用圆形法帮助用户来明确需求

97
00:04:59,680 --> 00:05:02,460
那所谓的圆形方法

98
00:05:02,460 --> 00:05:05,700
它有一种呢演化迭代的思想在里面

99
00:05:05,700 --> 00:05:07,840
比如说呢，最简单的圆形

100
00:05:07,840 --> 00:05:10,420
我们可以给用户展示一个呢

101
00:05:10,420 --> 00:05:12,370
美工做出来的界面

102
00:05:12,370 --> 00:05:13,680
让用户知道呢

103
00:05:13,680 --> 00:05:13,880
诶

104
00:05:13,880 --> 00:05:15,620
我这个界面某一个按钮

105
00:05:15,620 --> 00:05:17,400
可以实现什么样的菜单

106
00:05:17,400 --> 00:05:18,650
什么样的功能

107
00:05:18,650 --> 00:05:20,630
那讲解完成之后

108
00:05:20,630 --> 00:05:21,950
用户就会发现，诶

109
00:05:21,950 --> 00:05:24,940
你这个界面到底符不符合我的要求吧

110
00:05:24,940 --> 00:05:27,760
那如果说我有一些新的想

111
00:05:27,760 --> 00:05:28,720
你没有提到的

112
00:05:28,720 --> 00:05:30,310
我就可以补充说明

113
00:05:30,310 --> 00:05:33,140
那这种界面圆形的话

114
00:05:33,140 --> 00:05:35,360
它的成本其实是非常小的

115
00:05:35,360 --> 00:05:37,720
我们可以一天就做出一个来吧

116
00:05:37,720 --> 00:05:39,780
那这个过程当中呢

117
00:05:39,780 --> 00:05:44,190
我们这个界面可以帮助用户去明确需求

118
00:05:44,190 --> 00:05:46,010
这就是呢原型法

119
00:05:46,010 --> 00:05:48,650
他的思想他是，诶，嗯

120
00:05:48,650 --> 00:05:53,120
主要是为了帮助用户明确需求的啊

121
00:05:53,120 --> 00:05:57,410
第三种方法叫做面向对象的方法

122
00:05:57,410 --> 00:06:02,010
面向对象它适用于复杂的大项目

123
00:06:07,200 --> 00:06:12,420
我们的结构化，它尤其不适合做复杂项目啊

124
00:06:12,420 --> 00:06:15,690
因为复杂项目它的变数太多了

125
00:06:15,690 --> 00:06:18,250
然而呢，什么叫需求明确

126
00:06:18,250 --> 00:06:19,610
我们一般会认为

127
00:06:19,610 --> 00:06:22,470
做二次开发或者已有行业经验的话

128
00:06:22,470 --> 00:06:24,060
就叫做需求明确

129
00:06:24,060 --> 00:06:26,140
面向对象的方法呢

130
00:06:26,140 --> 00:06:28,870
它适合复杂的大项目开发

131
00:06:28,870 --> 00:06:33,660
它本身这种思想就是认为呢，万物皆对象

132
00:06:33,660 --> 00:06:35,920
他在做开发的过程当中

133
00:06:35,920 --> 00:06:38,980
即使我没有明确解题的过程

134
00:06:38,980 --> 00:06:40,670
解决问题的过程

135
00:06:40,670 --> 00:06:42,570
但是我可以把解

136
00:06:42,570 --> 00:06:44,810
或者说把问题本身呢

137
00:06:44,810 --> 00:06:46,450
抽象成一些对象

138
00:06:46,450 --> 00:06:49,450
然后呢，去模拟它的这样的一个过程

139
00:06:49,450 --> 00:06:51,250
所以说，面向对象啊

140
00:06:51,250 --> 00:06:56,030
它所面向的是对现实世界抽象出对象

141
00:06:56,030 --> 00:06:57,440
它的关键呢

142
00:06:57,440 --> 00:07:01,720
是在于建立一个全面、合理、统一的模型

143
00:07:01,720 --> 00:07:04,220
这也是它的难度所在

144
00:07:04,220 --> 00:07:09,470
那它也有相应的规划、区、分析、设计、实现等等过程

145
00:07:09,470 --> 00:07:12,370
但是这些过程当中

146
00:07:12,370 --> 00:07:16,710
它的界限不明确与严格区分

147
00:07:16,710 --> 00:07:21,000
工作阶段的结构化方法还是呢，有区别的

148
00:07:21,000 --> 00:07:24,660
那它的整个过程啊，是迭代

149
00:07:24,660 --> 00:07:25,420
并且呢

150
00:07:25,420 --> 00:07:30,240
无间隙的相互之间可以有一些交叠的过程

151
00:07:30,240 --> 00:07:32,730
在做面向对象的过程当中

152
00:07:32,730 --> 00:07:35,610
它还有一类呢，比较好的特点

153
00:07:35,610 --> 00:07:38,160
叫做呢，具有更好的复用性

154
00:07:38,160 --> 00:07:40,590
我们可以复用父类、子类

155
00:07:40,590 --> 00:07:43,690
然后呢，去复用一些呢解决方案

156
00:07:43,690 --> 00:07:45,810
复用一些构件等等

157
00:07:45,810 --> 00:07:47,250
所以面向对象啊

158
00:07:47,250 --> 00:07:49,560
它本身在开发的过程当中呢

159
00:07:49,560 --> 00:07:52,980
把某一个项目复用到另一个项目当中去呢

160
00:07:52,980 --> 00:07:55,260
复用性是非常强的

161
00:07:55,260 --> 00:07:58,210
那这是面向对象它的过程

162
00:07:58,210 --> 00:07:59,950
最后还有一个说法呢

163
00:07:59,950 --> 00:08:02,460
叫做面向服务的开发方法

164
00:08:02,460 --> 00:08:05,400
那所谓的面向服务啊

165
00:08:05,400 --> 00:08:07,990
它所面向的服务本身呢

166
00:08:07,990 --> 00:08:11,910
可以理解为是更高级别的一个抽象

167
00:08:11,910 --> 00:08:14,540
更高级别的面向对象的方法

168
00:08:14,540 --> 00:08:17,900
它的抽象级别包括操作、服务

169
00:08:17,900 --> 00:08:19,550
还有业务流程

170
00:08:19,550 --> 00:08:22,950
目前在软件设计师考试当中，呃

171
00:08:22,950 --> 00:08:25,130
面向服务的考察方式呢

172
00:08:25,130 --> 00:08:27,000
目前还没有出现过

173
00:08:27,000 --> 00:08:30,960
它一般会出现在高级科目细分架构当中呢

174
00:08:30,960 --> 00:08:32,169
作为一种

175
00:08:32,169 --> 00:08:35,140
呃，我们的这种系统分析的方法

176
00:08:35,140 --> 00:08:36,220
或者设计的方法

177
00:08:36,220 --> 00:08:38,380
架构设计的方法来出现

178
00:08:38,380 --> 00:08:39,380
所以这里呢

179
00:08:39,380 --> 00:08:42,460
了解有面这样服务的方法就可以了

180
00:08:42,460 --> 00:08:45,290
重点掌握前面三种方法

181
00:08:45,290 --> 00:08:46,350
它们的特点

182
00:08:46,350 --> 00:08:49,510
适用场景和不适用的场景

183
00:08:49,510 --> 00:08:51,770
从而呢加以区分

184
00:08:51,770 --> 00:08:54,390
下面我们来看一下这一部分

185
00:08:54,390 --> 00:08:57,830
在我们软件设计师真题当中的考察

186
00:08:58,350 --> 00:09:00,530
首先下面这道题

187
00:09:00,530 --> 00:09:05,490
若用户需求不明确且经常发生变化的话

188
00:09:05,490 --> 00:09:09,890
但是呢，系统规模不太大且不太复杂

189
00:09:09,890 --> 00:09:11,910
我们适合采用什么呢

190
00:09:11,910 --> 00:09:15,970
看到需求不明确经常发生变化

191
00:09:15,970 --> 00:09:18,710
我们在这里第 A 个选择的

192
00:09:18,710 --> 00:09:21,570
优先选择的就是圆形方法

193
00:09:21,570 --> 00:09:24,720
那对于数据处理领域的问题

194
00:09:24,720 --> 00:09:26,580
系统规模不太

195
00:09:26,580 --> 00:09:28,910
并且不太复杂

196
00:09:28,910 --> 00:09:31,290
需求变化也不大的话

197
00:09:31,290 --> 00:09:32,890
哎，需求不变的

198
00:09:32,890 --> 00:09:36,100
我们选择结构化的开发方法

199
00:09:36,100 --> 00:09:38,670
如果是复杂的大项目

200
00:09:38,670 --> 00:09:41,310
没有提到需求是否明确

201
00:09:41,310 --> 00:09:44,130
我们会选择面向对象

202
00:09:44,130 --> 00:09:45,580
JACKSON 方法呢

203
00:09:45,580 --> 00:09:48,220
我们前面没有提到这种方法

204
00:09:48,220 --> 00:09:50,700
它是能面向数据结构的

205
00:09:50,700 --> 00:09:53,980
知道它面向数据结构就可以了

206
00:09:58,880 --> 00:10:01,340
那这是我们呢，给大家介

207
00:10:01,340 --> 00:10:04,380
介绍到的软件开发方法的内容
