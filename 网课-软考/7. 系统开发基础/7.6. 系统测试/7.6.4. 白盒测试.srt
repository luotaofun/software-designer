1
00:00:00,000 --> 00:00:03,920
下面我们展开来看一下白盒测试这一部分

2
00:00:03,920 --> 00:00:06,290
白盒测试是我们软件设计师

3
00:00:06,290 --> 00:00:08,029
考试当中的重点内容

4
00:00:08,029 --> 00:00:10,290
考察频率呢，比较高

5
00:00:10,290 --> 00:00:11,980
并且在后面啊

6
00:00:11,980 --> 00:00:15,260
可能还会呢，结合 Mark CAB 环路复杂

7
00:00:15,260 --> 00:00:17,250
一起来考察大家

8
00:00:17,250 --> 00:00:20,550
那针对白盒测试这个部分啊

9
00:00:20,550 --> 00:00:24,590
我们呢，需要了解到它的这种呢，测试的分类

10
00:00:24,590 --> 00:00:29,230
其中逻辑覆盖是我们需要掌握的重点

11
00:00:29,230 --> 00:00:31,660
那在我们的考试当中

12
00:00:31,660 --> 00:00:35,140
考察较多的是语句覆盖

13
00:00:35,140 --> 00:00:40,470
判定覆盖、条件覆盖、判定条件覆盖以及路径覆盖

14
00:00:40,470 --> 00:00:42,270
其他覆盖的方式

15
00:00:42,270 --> 00:00:45,640
在我们考试当中出现的比较少

16
00:00:45,640 --> 00:00:48,450
那大家呢，可以自己啊

17
00:00:48,450 --> 00:00:49,630
会看一

18
00:00:49,630 --> 00:00:53,060
给大家列举的定义和它的特点

19
00:00:53,060 --> 00:00:57,160
我们简单给大家介绍一下常考的几种

20
00:00:57,160 --> 00:00:59,950
首先，针对语句覆盖

21
00:00:59,950 --> 00:01:03,150
我们在程序流程图当中

22
00:01:03,150 --> 00:01:08,350
它的结构是包括开始输入输出 E 以及呢

23
00:01:08,350 --> 00:01:09,520
语句部分

24
00:01:09,520 --> 00:01:11,660
其中语句覆盖

25
00:01:11,660 --> 00:01:17,220
它考虑的是只有矩形框表示的语句部分

26
00:01:17,220 --> 00:01:20,390
只要这些语句被覆盖，诶

27
00:01:20,390 --> 00:01:22,780
被执行就可以了

28
00:01:22,780 --> 00:01:26,450
那语句覆盖就是针对每条语句

29
00:01:26,450 --> 00:01:28,280
至少要执行一次

30
00:01:28,280 --> 00:01:31,220
对于判定等等这些内容

31
00:01:31,220 --> 00:01:33,320
一概不需要去关注

32
00:01:33,320 --> 00:01:37,060
所以它的这种覆盖呢，是非常弱的

33
00:01:37,060 --> 00:01:38,540
最弱的一种呢

34
00:01:38,540 --> 00:01:39,880
逻辑覆盖

35
00:01:39,880 --> 00:01:41,490
判定覆盖

36
00:01:41,490 --> 00:01:42,610
顾名思义

37
00:01:42,610 --> 00:01:45,780
它所针对的就是判定

38
00:01:45,780 --> 00:01:51,250
那一个判定最终的结果会有两个分支

39
00:01:51,250 --> 00:01:52,690
一个真值

40
00:01:52,690 --> 00:01:54,530
一个呢假值

41
00:01:54,530 --> 00:01:58,550
所以判定覆盖也叫做分支覆盖

42
00:01:58,550 --> 00:02:02,330
那我们要求设计测试用例的时候

43
00:02:02,330 --> 00:02:07,260
至少每一个判定结果的真值和假值

44
00:02:07,260 --> 00:02:09,880
都需要呢，至少走一次

45
00:02:09,960 --> 00:02:14,840
那既然说至少要获得一次真值和假值的话

46
00:02:14,840 --> 00:02:16,470
其实我们可以发现

47
00:02:16,470 --> 00:02:19,950
每一个针对单一的判定来看啊

48
00:02:19,950 --> 00:02:22,250
它是不是至少需要两个测试用例

49
00:02:22,250 --> 00:02:24,810
才能同时覆盖真值和价值啊

50
00:02:24,810 --> 00:02:26,330
那这个地方呢

51
00:02:26,330 --> 00:02:28,410
我们的判定覆盖啊

52
00:02:28,410 --> 00:02:32,160
它是比语句覆盖要更加呢

53
00:02:32,160 --> 00:02:33,560
逻辑性更强一些

54
00:02:33,560 --> 00:02:35,410
逻辑覆盖更强一点

55
00:02:35,410 --> 00:02:37,770
但是呢，比较特殊的是

56
00:02:37,770 --> 00:02:40,070
它的判定可以简单

57
00:02:40,070 --> 00:02:41,450
也可以复杂

58
00:02:41,450 --> 00:02:44,660
判定里面呢，是关系表达式

59
00:02:44,660 --> 00:02:47,100
里面可以是一个表达式

60
00:02:47,100 --> 00:02:49,980
也可以是多个表达式的，诶

61
00:02:49,980 --> 00:02:52,340
它的与或运算这种情况

62
00:02:52,340 --> 00:02:54,810
所以它可以是单个条件

63
00:02:54,810 --> 00:02:58,310
也可以是多个条件的组合

64
00:02:58,310 --> 00:03:01,520
那针对这个内部条件

65
00:03:01,520 --> 00:03:04,860
我们还有呢，条件覆盖的考虑

66
00:03:04,860 --> 00:03:06,420
条件覆盖的话

67
00:03:06,420 --> 00:03:10,910
它是要求，唉，判定当中的每个逻辑条

68
00:03:10,910 --> 00:03:11,950
分别呢

69
00:03:11,950 --> 00:03:15,840
至少取一次真值、一次价值

70
00:03:15,840 --> 00:03:17,760
那这种情况的话

71
00:03:17,760 --> 00:03:20,960
我们要注意条件和判定覆盖

72
00:03:20,960 --> 00:03:23,760
它们是没有包含关系的啊

73
00:03:23,760 --> 00:03:27,290
不要呢，认为判定一定包含条件

74
00:03:27,290 --> 00:03:29,350
或者条件一定包含判定

75
00:03:29,350 --> 00:03:32,470
它们是独立的两个维度

76
00:03:32,470 --> 00:03:35,930
而下一个判定条件覆盖

77
00:03:35,930 --> 00:03:41,690
它是同同时包含判定和条件覆盖两种情况的

78
00:03:41,690 --> 00:03:45,160
所以它比前面二者的这个呢

79
00:03:45,160 --> 00:03:49,400
唉，逻辑覆盖强度啊，会更强一些

80
00:03:49,680 --> 00:03:55,200
它要求每个条件的所有可能真假值

81
00:03:55,200 --> 00:03:56,870
至少出现一次

82
00:03:56,870 --> 00:03:59,580
并且每个判定的真假值呢

83
00:03:59,580 --> 00:04:01,580
也至少出现一次

84
00:04:01,580 --> 00:04:05,760
同时满足条件覆盖和判定覆盖

85
00:04:05,760 --> 00:04:09,430
最后，唉，我们还有一个路径覆盖

86
00:04:09,430 --> 00:04:10,810
路径覆盖呢

87
00:04:10,810 --> 00:04:16,279
它是覆盖被测试程序当中所有可能的路径

88
00:04:16,279 --> 00:04:19,360
那只要有一个节点不一样

89
00:04:19,360 --> 00:04:21,120
我们说它呢，就是一个

90
00:04:21,120 --> 00:04:22,520
诶，可能的路径

91
00:04:22,520 --> 00:04:25,330
一条不一样的可能路径

92
00:04:25,330 --> 00:04:27,860
除了这五个覆盖以外

93
00:04:27,860 --> 00:04:29,100
这五个覆盖啊

94
00:04:29,100 --> 00:04:31,220
大家是一定要掌握的

95
00:04:31,220 --> 00:04:34,480
剩下的覆盖呢，大家了解一下就行了

96
00:04:34,480 --> 00:04:36,610
条件组合覆盖

97
00:04:36,610 --> 00:04:37,810
它是呢，唉

98
00:04:37,810 --> 00:04:40,960
我们所有判定当中所有的条件

99
00:04:40,960 --> 00:04:45,440
它的各种可能值的组合都至少出现一次

100
00:04:45,440 --> 00:04:47,980
跟真假值的次数无关

101
00:04:47,980 --> 00:04:50,920
所有不同组合，只要组合不一样

102
00:04:50,920 --> 00:04:52,710
就需要呢，出现一次

103
00:04:52,710 --> 00:04:54,540
但这个覆盖的话

104
00:04:54,540 --> 00:04:56,220
如果以这种形式

105
00:04:56,220 --> 00:04:59,720
它会同时满足判定条件

106
00:04:59,720 --> 00:05:03,850
还有判定条件覆盖的基本路径覆盖呢

107
00:05:03,850 --> 00:05:06,720
它涉及到独立路径的查找

108
00:05:06,720 --> 00:05:08,790
这种情况下的话

109
00:05:08,790 --> 00:05:10,650
我们只需要啊

110
00:05:10,650 --> 00:05:12,950
结合环路复杂度来看

111
00:05:12,950 --> 00:05:15,130
环路复杂度的个数呢

112
00:05:15,130 --> 00:05:17,010
与基本路径的个数

113
00:05:17,010 --> 00:05:18,370
测试用例的个数啊

114
00:05:18,370 --> 00:05:19,510
是一样的

115
00:05:19,510 --> 00:05:20,870
我们在后面呢

116
00:05:20,870 --> 00:05:24,850
会教大家如何计算环路复杂度

117
00:05:24,850 --> 00:05:26,690
最后，循环覆盖

118
00:05:26,690 --> 00:05:29,530
注意的是对循环当中的条件

119
00:05:29,530 --> 00:05:31,130
诶，来进行验证

120
00:05:31,130 --> 00:05:33,100
那如果有数组的话

121
00:05:33,100 --> 00:05:37,280
注意一个测试用例可能会验证多个条件

122
00:05:37,280 --> 00:05:40,820
那这是我们给大家介绍到的逻辑覆盖

123
00:05:40,820 --> 00:05:43,400
看文字比较抽象

124
00:05:43,400 --> 00:05:47,820
下面呢，我们以示例的形式让大家区分呢

125
00:05:47,820 --> 00:05:49,820
前面介绍到的语

126
00:05:49,820 --> 00:05:53,540
覆盖、判定覆盖、条件覆盖、判定条件覆

127
00:05:53,540 --> 00:05:55,880
以及路径覆盖

128
00:05:55,880 --> 00:05:56,890
好

129
00:05:56,890 --> 00:05:59,270
下面看到这个例子

130
00:05:59,270 --> 00:06:06,190
对于一个判定 X 大于零与 Y 小于等于五

131
00:06:06,190 --> 00:06:10,280
那这个情况下，它包含两个条件

132
00:06:10,280 --> 00:06:13,560
条件一是 X 大于等于零

133
00:06:13,560 --> 00:06:16,960
条件二是 Y 小于等于五

134
00:06:16,960 --> 00:06:21,280
它们的与的结果来作为判定一

135
00:06:21,280 --> 00:06:24,060
那我们分别呢，记录一下，唉

136
00:06:24,060 --> 00:06:27,380
条件一、条件二和判定一

137
00:06:27,380 --> 00:06:28,850
记录之后

138
00:06:28,850 --> 00:06:32,690
唉，我们的整个程序流程呢，如下所示

139
00:06:32,690 --> 00:06:35,720
给大家一个简单的程序流程图

140
00:06:35,720 --> 00:06:39,010
开始判定到语句结束

141
00:06:39,010 --> 00:06:40,990
其中谁是语句啊

142
00:06:40,990 --> 00:06:43,790
我们只有唯一的一个语句

143
00:06:43,790 --> 00:06:45,250
要注意区分

144
00:06:45,250 --> 00:06:49,570
那我们在分析它的覆盖情况的时候

145
00:06:49,570 --> 00:06:52,830
一般呢，可以结合测试用例

146
00:06:52,830 --> 00:06:54,760
如果没有测试用例

147
00:06:54,760 --> 00:06:57,460
可以尝试自己去写一写

148
00:06:57,460 --> 00:07:00,520
下面给了大家四个测试用例

149
00:07:00,520 --> 00:07:05,760
其中第一个测试用例 X 等于一

150
00:07:05,760 --> 00:07:09,790
那有没有满足 X 大于等于零呢

151
00:07:09,790 --> 00:07:11,210
哎，满足

152
00:07:11,210 --> 00:07:14,120
所以条件一是真值

153
00:07:14,120 --> 00:07:15,640
Y 等于一

154
00:07:15,640 --> 00:07:16,840
有没有满足

155
00:07:16,840 --> 00:07:18,940
Y 小于等于五呢

156
00:07:18,940 --> 00:07:20,160
也满足

157
00:07:20,160 --> 00:07:23,100
所以它也是真值

158
00:07:23,480 --> 00:07:26,840
两个条件做与操作

159
00:07:26,840 --> 00:07:29,650
二者同时真才为真

160
00:07:29,650 --> 00:07:31,940
二者只要有一个为假

161
00:07:31,940 --> 00:07:33,940
结果呢就为假

162
00:07:34,810 --> 00:07:38,290
接下来第二个测试用例

163
00:07:38,290 --> 00:07:41,970
X 等于一条件一增值

164
00:07:41,970 --> 00:07:44,370
Y 等于六条件二

165
00:07:44,370 --> 00:07:47,430
价值判定结果是价值

166
00:07:47,430 --> 00:07:50,040
第三个测试用例

167
00:07:50,040 --> 00:07:53,810
X 等于一条件一是价值了

168
00:07:53,810 --> 00:07:57,120
Y 等于一条件二是真值

169
00:07:57,120 --> 00:07:59,390
结果也是假值

170
00:07:59,390 --> 00:08:01,450
第四个测试用例

171
00:08:01,450 --> 00:08:04,810
X 等于一条件一为假

172
00:08:04,810 --> 00:08:08,110
Y 等于六条件二为假

173
00:08:08,110 --> 00:08:11,510
那最终结果也是价值

174
00:08:11,510 --> 00:08:14,640
那这是针对四个测试用例啊

175
00:08:14,640 --> 00:08:16,100
它的真假

176
00:08:16,100 --> 00:08:18,860
我们写了一个呢，真值表

177
00:08:19,790 --> 00:08:22,390
看到真值表之后

178
00:08:22,390 --> 00:08:24,570
我们结合真值表呢

179
00:08:24,570 --> 00:08:27,380
来看一下它的执行过程

180
00:08:27,380 --> 00:08:32,260
第一个测试用例判定结果是真值吧

181
00:08:32,260 --> 00:08:37,970
所以它的执行过程走了左侧这条路径

182
00:08:37,970 --> 00:08:40,429
有没有覆盖语句呢

183
00:08:40,429 --> 00:08:41,450
没有

184
00:08:41,450 --> 00:08:44,270
而我们的二、三、四

185
00:08:44,270 --> 00:08:49,210
它所走的都是右侧这条判定的路径吧

186
00:08:49,210 --> 00:08:51,750
从而覆盖了语句一

187
00:08:51,750 --> 00:08:56,130
所以满足语句覆盖的有哪些呢

188
00:08:56,130 --> 00:09:01,950
二、三、四只需要其中一个测试用例就可以了啊

189
00:09:01,950 --> 00:09:03,520
不需要选择多个

190
00:09:03,520 --> 00:09:05,560
只需要其中的一个

191
00:09:05,560 --> 00:09:09,240
那第二个关于判定覆盖

192
00:09:09,760 --> 00:09:14,200
判定覆盖是针对判定的结果

193
00:09:14,200 --> 00:09:18,670
至少取一次真值、一次价值吧

194
00:09:18,670 --> 00:09:23,160
所以真值一用力一定要存在

195
00:09:23,160 --> 00:09:28,730
其次，我们可以放入二或三或四

196
00:09:29,250 --> 00:09:33,390
只要有两个测试用例就足够了

197
00:09:33,390 --> 00:09:36,450
再多，那我们就认为它呢，冗余了

198
00:09:36,450 --> 00:09:37,290
不需要了

199
00:09:37,290 --> 00:09:41,310
所以至少需要一、二或者一、三或者一

200
00:09:41,310 --> 00:09:44,040
来满足判定覆盖

201
00:09:44,040 --> 00:09:46,890
而条件覆盖的结果

202
00:09:46,890 --> 00:09:49,900
我们需要哪些测试用例呢

203
00:09:49,900 --> 00:09:53,720
条件一、二分别取真、假值

204
00:09:53,720 --> 00:09:59,100
那我们测试用例一和测试用例四的组合

205
00:09:59,100 --> 00:10:00,990
能不能达到要求啊

206
00:10:00,990 --> 00:10:01,970
可以

207
00:10:01,970 --> 00:10:04,990
那此时条件一的真值假值

208
00:10:04,990 --> 00:10:08,080
条件二的真值假值是满足的

209
00:10:08,080 --> 00:10:10,940
还有没有其他的情况呢

210
00:10:10,940 --> 00:10:11,880
有

211
00:10:11,880 --> 00:10:16,090
测试用二、三组合起来

212
00:10:16,090 --> 00:10:19,710
同样条件一取了真值假值

213
00:10:19,710 --> 00:10:22,820
条件二取了真值价值

214
00:10:22,820 --> 00:10:24,940
所以这种情况下

215
00:10:24,940 --> 00:10:27,740
它也是满足条件覆盖的

216
00:10:27,740 --> 00:10:30,380
那我们根据这里其实可以发现

217
00:10:30,380 --> 00:10:33,590
条件覆盖跟判定覆盖一样吗

218
00:10:33,590 --> 00:10:34,940
它是不一样

219
00:10:34,940 --> 00:10:36,800
没有包含关系的

220
00:10:36,800 --> 00:10:40,410
但它们之间可以有交叉

221
00:10:40,410 --> 00:10:45,310
那这是我们提到的判定覆盖和条件覆盖

222
00:10:45,310 --> 00:10:47,230
如果条件啊

223
00:10:47,230 --> 00:10:49,870
如果一个判定只有一个条件的话

224
00:10:49,870 --> 00:10:52,310
我们的判定结果和条件结果

225
00:10:52,310 --> 00:10:54,370
其实是一模一样的

226
00:10:54,370 --> 00:10:56,420
多条件组合的时候呢

227
00:10:56,420 --> 00:10:58,460
其实才会有这种区分

228
00:10:58,460 --> 00:11:02,810
那同时满足判定覆盖条件覆盖的话

229
00:11:02,810 --> 00:11:06,870
哎，如果是测试用例一和四

230
00:11:07,260 --> 00:11:11,300
既满足判定也满足条件吧

231
00:11:11,300 --> 00:11:15,000
所以可以满足判定条件覆盖

232
00:11:15,000 --> 00:11:17,950
那如果要求满足条件覆盖

233
00:11:17,950 --> 00:11:19,400
我们需要二三

234
00:11:19,400 --> 00:11:22,870
此时大家的结果都是，哎

235
00:11:22,870 --> 00:11:24,810
判定结果都是假值吧

236
00:11:24,810 --> 00:11:30,620
所以还需要一个判定真值来满足判定覆盖

237
00:11:30,620 --> 00:11:35,960
那一、二、三也可以作为判定条件覆盖的结果

238
00:11:35,960 --> 00:11:37,740
但是这种组合的话

239
00:11:37,740 --> 00:11:40,540
我们说测试用例个数多了就没有呢

240
00:11:40,540 --> 00:11:41,860
这种必要了

241
00:11:41,860 --> 00:11:44,010
最后，路径覆盖

242
00:11:44,010 --> 00:11:45,930
我们有几条路径呢

243
00:11:45,930 --> 00:11:48,290
把节点标注出来

244
00:11:48,290 --> 00:11:50,310
哎，一、二、三、四

245
00:11:50,560 --> 00:11:55,600
在这里可以有一、二、四这条路径

246
00:11:55,600 --> 00:11:59,430
可以有123、四这条路径

247
00:11:59,430 --> 00:12:02,670
所以总共有两条路径

248
00:12:02,670 --> 00:12:06,120
那我们需要两个测试用例

249
00:12:06,120 --> 00:12:09,380
其中，唉，我们的 Y 这里呢

250
00:12:09,380 --> 00:12:11,390
Y 分支是一条路径

251
00:12:11,390 --> 00:12:14,500
N 分之一呢，是另一条路径

252
00:12:14,500 --> 00:12:20,850
所以它跟我们的判定测试用例也是呢，一样的

253
00:12:20,850 --> 00:12:23,440
那这是我们给大家讲到的

254
00:12:23,440 --> 00:12:25,320
以右图为例啊

255
00:12:25,320 --> 00:12:28,600
这个例子当中给大家呢，介绍了一

256
00:12:28,600 --> 00:12:30,320
几种逻辑覆

257
00:12:30,320 --> 00:12:31,730
它的分析过程

258
00:12:31,730 --> 00:12:34,900
我们可以通过均值表来进行判定

259
00:12:34,900 --> 00:12:38,910
这种方式呢，相对来说会比较明确一些

260
00:12:38,910 --> 00:12:42,030
接下来我们来看一下白盒测试

261
00:12:42,030 --> 00:12:44,330
在我们软件设计师考试

262
00:12:44,330 --> 00:12:46,670
历年真题当中的体现

263
00:12:46,670 --> 00:12:48,760
下面的试题告诉我们呢

264
00:12:48,760 --> 00:12:50,720
用白盒测试方法

265
00:12:50,720 --> 00:12:54,750
对如图所示的程序流程图来进行测试

266
00:12:54,750 --> 00:12:57,870
若要满足分支覆盖的话

267
00:12:57,870 --> 00:13:00,610
至少需要多少个测试用例呢

268
00:13:00,610 --> 00:13:04,430
那这道题考察的就是分支覆盖

269
00:13:04,430 --> 00:13:07,820
分支覆盖就是呢判定覆盖

270
00:13:07,820 --> 00:13:13,470
它所考察的是针对图示当中它的判定结果

271
00:13:13,470 --> 00:13:16,910
最终呢，各取一次真假值

272
00:13:16,910 --> 00:13:20,520
那这道题后面还有一个提问

273
00:13:20,520 --> 00:13:24,110
正确的测试用例对应该是谁

274
00:13:24,110 --> 00:13:28,640
那这里其实对我们前面的一个空

275
00:13:28,640 --> 00:13:30,090
是有所帮助的

276
00:13:30,090 --> 00:13:32,680
首先我们要知道第二空

277
00:13:32,680 --> 00:13:37,620
它的正确测试用例对是对谁来说正确的

278
00:13:37,620 --> 00:13:40,780
是对分支覆盖正确的吧

279
00:13:40,780 --> 00:13:45,660
所以如果根据第二空选项来看

280
00:13:45,660 --> 00:13:47,440
两个测试用例

281
00:13:47,440 --> 00:13:52,160
就可以达到分支覆盖的正确测试用例对了

282
00:13:52,160 --> 00:13:53,780
那我们第一扣

283
00:13:53,780 --> 00:13:58,340
其实选择两个测试用例就足够了吧

284
00:13:58,340 --> 00:14:00,250
一个测试用例可能吗

285
00:14:00,250 --> 00:14:04,380
我们要知道判定它是有一真一假的吧

286
00:14:04,380 --> 00:14:07,660
这个一真一假是相违背的

287
00:14:07,660 --> 00:14:10,930
所以如果只有一个测试用例

288
00:14:10,930 --> 00:14:15,210
它是不可能同时满足不同的真假值

289
00:14:15,210 --> 00:14:18,660
一个测试用例肯定是错的

290
00:14:18,660 --> 00:14:22,430
那现在两个测试用例对可以达到要求

291
00:14:22,430 --> 00:14:26,070
所以至少需要两个测试用例

292
00:14:26,070 --> 00:14:30,910
那我们在分析下面的测试用例对的时候

293
00:14:30,910 --> 00:14:35,340
可以呢，画出它的真值表来进行分析

294
00:14:35,340 --> 00:14:38,740
包括对前面的分支覆盖

295
00:14:38,740 --> 00:14:43,880
如果没有给出测试用例对的这个这个第二空

296
00:14:43,880 --> 00:14:48,930
那我们同样呢，要自己去尝试写测试用例对

297
00:14:48,930 --> 00:14:51,320
那我们在这里首先看到呢

298
00:14:51,320 --> 00:14:56,280
测试用例它的格式是输入 XABX 

299
00:14:56,280 --> 00:14:58,200
输出 X 值

300
00:14:58,200 --> 00:15:02,040
我们的判定其实有两个

301
00:15:02,040 --> 00:15:06,190
那一般两个判定要想同时满足真假值

302
00:15:06,190 --> 00:15:09,480
应该是四个测试用例来进行的

303
00:15:09,480 --> 00:15:14,080
但是呢，由于第一个判定结束之后

304
00:15:14,080 --> 00:15:17,030
会影响第二个判定的结果

305
00:15:17,030 --> 00:15:20,350
所以此时它们是相互影响的

306
00:15:20,350 --> 00:15:23,380
不需要有四个测试用例了

307
00:15:23,380 --> 00:15:26,620
那我们来验证一下，看一看

308
00:15:26,860 --> 00:15:29,780
首先第一个判定呢

309
00:15:29,780 --> 00:15:32,760
它是包含了两个条件的

310
00:15:32,760 --> 00:15:35,410
或那只要有一个为真

311
00:15:35,410 --> 00:15:37,950
那最终的结果呢，就是为真

312
00:15:37,950 --> 00:15:41,290
我们以第一个选项的第一个测试用例

313
00:15:41,290 --> 00:15:42,360
来看一看

314
00:15:42,360 --> 00:15:45,410
A 等于一的时候是否满

315
00:15:45,410 --> 00:15:46,350
A 大于二

316
00:15:46,350 --> 00:15:47,470
A 不满足

317
00:15:47,470 --> 00:15:49,220
所以是一个价值

318
00:15:49,220 --> 00:15:51,710
B 等于三是否满足

319
00:15:51,710 --> 00:15:54,590
满足了只要有一个为真

320
00:15:54,590 --> 00:15:57,620
最终的判定结果为真

321
00:15:57,620 --> 00:16:01,570
所以我们走了第一个真分支

322
00:16:01,570 --> 00:16:06,510
那 X 输入是等于三的 X 

323
00:16:06,510 --> 00:16:10,560
它的新的取值是 X 除以 A 

324
00:16:10,560 --> 00:16:13,000
也就是3÷1

325
00:16:13,000 --> 00:16:17,500
所以它的结果 X 还是等于三

326
00:16:17,500 --> 00:16:19,720
那接着往下来看

327
00:16:19,720 --> 00:16:22,260
A 等于五满足吗

328
00:16:22,260 --> 00:16:23,760
不满足

329
00:16:23,820 --> 00:16:26,820
X 大于三满足吗

330
00:16:26,820 --> 00:16:28,490
也不满足

331
00:16:28,490 --> 00:16:32,680
最终它的结果是一个 NO 分支

332
00:16:32,680 --> 00:16:35,810
所以走的是下面的 NO 分之

333
00:16:35,810 --> 00:16:38,800
那这是第一个测试用例

334
00:16:38,800 --> 00:16:43,860
它所对应的分支结果是 Y 以及 NO 

335
00:16:44,440 --> 00:16:47,960
再来看第二个测试用例

336
00:16:48,010 --> 00:16:51,170
A 等于五的情况下

337
00:16:51,170 --> 00:16:54,180
我们来看一下 A 等于五

338
00:16:54,180 --> 00:16:57,460
第一个条件是满足的吧

339
00:16:57,460 --> 00:17:00,480
所以这里呢应该是 Y 

340
00:17:01,320 --> 00:17:04,119
B 等于二的情况下

341
00:17:04,119 --> 00:17:06,200
不满足 B 等于三

342
00:17:06,200 --> 00:17:09,950
最终的结果还是 Y 分之

343
00:17:09,950 --> 00:17:13,829
那第一个判定它是 Y 分之

344
00:17:13,829 --> 00:17:19,490
接下来 X 是等于 X 15÷5

345
00:17:19,490 --> 00:17:21,430
它是等于三的

346
00:17:21,430 --> 00:17:25,000
那这个情况下， A 等于

347
00:17:25,000 --> 00:17:28,569
满足了 X 大于三

348
00:17:28,569 --> 00:17:31,930
仍然不满足它是等于三的

349
00:17:31,930 --> 00:17:36,140
所以最终的结果海是 NO 分之

350
00:17:36,140 --> 00:17:39,070
那这种情况下来看唉

351
00:17:39,070 --> 00:17:41,890
对于 A 选项的两个测试用例

352
00:17:41,890 --> 00:17:44,930
第一个判定只有 Y 存在

353
00:17:44,930 --> 00:17:46,850
缺少了 NO 判定吧

354
00:17:46,850 --> 00:17:50,510
第二个判定结果只有 NO 分之

355
00:17:50,510 --> 00:17:51,980
没有 Y 分之

356
00:17:51,980 --> 00:17:56,910
所以在这里无法满足分支覆盖

357
00:17:57,770 --> 00:18:01,110
那我们再来看对 B 选项

358
00:18:01,110 --> 00:18:02,930
我们来分析一下

359
00:18:04,080 --> 00:18:07,920
B 选项当中的两个测试用例

360
00:18:07,920 --> 00:18:11,660
首先 A 等于一不满足要求

361
00:18:11,660 --> 00:18:15,270
B 等于一也不满足要求

362
00:18:15,270 --> 00:18:16,910
同时取 NO 

363
00:18:16,910 --> 00:18:19,510
那分支判定的结果

364
00:18:19,510 --> 00:18:22,790
第一个判定是 NO 分支

365
00:18:22,790 --> 00:18:25,190
那接下来 NO 分支之后

366
00:18:25,190 --> 00:18:26,570
A 等于五吗

367
00:18:26,570 --> 00:18:27,910
不满足

368
00:18:27,910 --> 00:18:30,520
那 X 大于三吗

369
00:18:30,520 --> 00:18:34,400
也不满足与的结果也是呢

370
00:18:34,400 --> 00:18:34,980
NO 分

371
00:18:34,980 --> 00:18:38,580
之所以这是第一个测试用例

372
00:18:38,580 --> 00:18:42,340
再来看第二个测试用例的情况

373
00:18:42,830 --> 00:18:46,850
A 等于五的情况下大于二了吗

374
00:18:46,850 --> 00:18:48,390
大于了

375
00:18:48,900 --> 00:18:50,920
B 1等于三吗

376
00:18:50,920 --> 00:18:51,620
没有

377
00:18:51,620 --> 00:18:54,380
但只要有一个是真

378
00:18:54,380 --> 00:18:57,800
最终的结果就是呢，真分。之

379
00:18:57,800 --> 00:19:01,830
所以第一个判定结果是真值

380
00:19:01,830 --> 00:19:03,890
接下来再来看

381
00:19:03,890 --> 00:19:07,600
X 等于 X 除以 A 

382
00:19:07,600 --> 00:19:10,690
X 等于20÷5

383
00:19:10,690 --> 00:19:13,200
所以它是等于四的

384
00:19:13,200 --> 00:19:17,880
那接下来 A 等于五满足要求了

385
00:19:17,930 --> 00:19:22,080
X 大于三也满足要求了

386
00:19:22,080 --> 00:19:24,850
同时存在 Y 的话

387
00:19:24,850 --> 00:19:28,320
这个与的结果才是呢真分值

388
00:19:28,320 --> 00:19:32,850
所以第二个判定结果也是呢，真分之

389
00:19:32,850 --> 00:19:36,210
那我们会发现第一个判定有真值

390
00:19:36,210 --> 00:19:37,130
有假值

391
00:19:37,130 --> 00:19:40,580
第二个判定也有真值、有价值吧

392
00:19:40,580 --> 00:19:45,320
这种情况下就满足了分支覆盖

393
00:19:45,320 --> 00:19:49,980
那就是满足分支覆盖的测试用例

394
00:19:49,980 --> 00:19:54,380
其他的选项测试用例我们可以看一下

395
00:19:54,380 --> 00:19:58,320
把相应的真假值列出来

396
00:19:58,450 --> 00:20:03,740
首先测试用例的格式是 ABX 输出 X 

397
00:20:03,740 --> 00:20:06,850
然后判断 X 大于二

398
00:20:06,850 --> 00:20:09,680
B 等于三是否满足

399
00:20:09,680 --> 00:20:12,300
再来求判定结果

400
00:20:12,300 --> 00:20:17,420
第一个判定 A 大于二或者 B 等于三

401
00:20:17,420 --> 00:20:20,760
那这个情况下再来求

402
00:20:20,760 --> 00:20:25,900
如果第一个判定是 Y 分之的话

403
00:20:25,900 --> 00:20:28,330
修改 X 的值

404
00:20:28,330 --> 00:20:31,220
那修改之后的结果呢

405
00:20:31,220 --> 00:20:33,010
给大家列出来了

406
00:20:33,010 --> 00:20:35,970
接下来判断 A 等于五

407
00:20:35,970 --> 00:20:37,430
X 大于

408
00:20:37,430 --> 00:20:42,840
是否满足两个条件做与操作

409
00:20:42,840 --> 00:20:44,180
做完之后

410
00:20:44,180 --> 00:20:47,240
这是第二个判定的结果

411
00:20:47,240 --> 00:20:52,820
那 A 选项只有判定一的 Y 和判定二的 NO 

412
00:20:52,820 --> 00:20:57,350
B 选项可以同时满足 Y 和 NO 分支

413
00:20:57,350 --> 00:21:00,900
所以它是能满足分支覆盖的

414
00:21:00,900 --> 00:21:06,070
C 选项对于判定一只有真值没有假值

415
00:21:06,070 --> 00:21:10,550
对于判定二只有价值没有真值

416
00:21:10,550 --> 00:21:13,390
所以不满足分支覆盖

417
00:21:13,390 --> 00:21:16,080
那对于 D 选项来看

418
00:21:16,080 --> 00:21:19,970
第一个判定只有真值没有价值

419
00:21:19,970 --> 00:21:24,020
所以在这里仍然不满足要求

420
00:21:24,020 --> 00:21:27,450
因为第一个判定不满足分支覆盖

421
00:21:27,450 --> 00:21:31,120
那这就是呢，对白盒测试用例

422
00:21:31,120 --> 00:21:34,830
它结合流程图的一个考察

423
00:21:34,830 --> 00:21:37,400
注意区分分支覆盖

424
00:21:37,400 --> 00:21:41,490
条件覆盖以及条件判定覆盖

425
00:21:41,490 --> 00:21:43,920
那就是呢白盒测试用例

426
00:21:43,920 --> 00:21:45,020
它的一个呢

427
00:21:45,020 --> 00:21:47,220
需要大家掌握的内容
