1
00:00:00,000 --> 00:00:04,320
接下来我们简单看一下在系统测试当中

2
00:00:04,320 --> 00:00:07,780
对我们软件测试阶段的一个划分

3
00:00:07,780 --> 00:00:09,520
那这种考察呢

4
00:00:09,520 --> 00:00:12,120
主要会涉及到阶段当

5
00:00:12,120 --> 00:00:14,080
一些特殊的测试

6
00:00:14,080 --> 00:00:16,520
它需要完成的任务

7
00:00:16,520 --> 00:00:17,890
在这里啊

8
00:00:17,890 --> 00:00:21,550
我们主要呢，是结合 V 模型来看的

9
00:00:21,550 --> 00:00:23,890
V 模型它的典型特点呢

10
00:00:23,890 --> 00:00:26,170
就是测试贯穿始终

11
00:00:26,170 --> 00:00:29,260
它的左侧是瀑布模型的阶段

12
00:00:29,260 --> 00:00:31,820
从需求分析到概要设计

13
00:00:31,820 --> 00:00:34,740
详细设计以及编码过程

14
00:00:34,740 --> 00:00:37,400
那右侧的测试阶段

15
00:00:37,400 --> 00:00:39,450
我们简单画了一个箭头

16
00:00:39,450 --> 00:00:40,730
什么意思呢

17
00:00:40,730 --> 00:00:42,890
注意我们这个箭头啊

18
00:00:42,890 --> 00:00:46,300
不是实施相应的测试

19
00:00:46,300 --> 00:00:50,890
而是呢，唉，我们在需求分析阶段的时

20
00:00:50,890 --> 00:00:52,970
所获取的需求

21
00:00:52,970 --> 00:00:57,470
是我们做系统测试以及验收测试

22
00:00:57,470 --> 00:01:00,120
非常重要的一个依据

23
00:01:00,120 --> 00:01:03,100
所以我们在需求分析的时候呢

24
00:01:03,100 --> 00:01:06,810
就要考虑 Y 完成整个系统之后，诶

25
00:01:06,810 --> 00:01:10,060
如何来验证系统它的功

26
00:01:10,060 --> 00:01:12,780
以及呢，交付给用户的时候

27
00:01:12,780 --> 00:01:16,930
如何来让用户做验收测试

28
00:01:16,930 --> 00:01:19,490
那我们在需求分析阶段

29
00:01:19,490 --> 00:01:22,910
就会做好相应的测试用例的设计

30
00:01:22,910 --> 00:01:26,160
以及呢测试计划的撰写

31
00:01:26,160 --> 00:01:30,360
那这个是呢，需求分析阶段做的概要

32
00:01:30,360 --> 00:01:33,220
设计阶段我们所做的工作是什么呢

33
00:01:33,220 --> 00:01:36,590
是对系统的体系结构来进行划分

34
00:01:36,590 --> 00:01:40,030
哪些系统划分成子系统之后

35
00:01:40,030 --> 00:01:42,970
哪些子系统分别对应哪些呢

36
00:01:42,970 --> 00:01:43,700
功能

37
00:01:43,700 --> 00:01:45,920
子系统与子系统之间

38
00:01:45,920 --> 00:01:48,960
它们的这种呢接口调用的关系

39
00:01:48,960 --> 00:01:51,460
那做完这些设计之后

40
00:01:51,460 --> 00:01:56,580
我们就要考虑好如何来进行集成测试

41
00:01:56,580 --> 00:02:01,720
也就是测试模块与模块间的连接性

42
00:02:01,720 --> 00:02:03,480
这种呢集成

43
00:02:03,480 --> 00:02:05,840
那做完概要设计

44
00:02:05,840 --> 00:02:08,280
针对模块内部的时候

45
00:02:08,280 --> 00:02:10,580
我们会做呢详细设计

46
00:02:10,580 --> 00:02:12,670
这种详细设计

47
00:02:12,670 --> 00:02:16,870
会涉及我们模块内部的数据结构

48
00:02:16,870 --> 00:02:18,030
还有一些路径

49
00:02:18,030 --> 00:02:19,900
那这种情况下

50
00:02:19,900 --> 00:02:21,800
我们呢就要考虑好

51
00:02:21,800 --> 00:02:26,250
如何对模块来进行单元测试

52
00:02:26,250 --> 00:02:28,930
所以左侧的阶段

53
00:02:28,930 --> 00:02:33,370
我们在该阶段要做好相应的测试计划

54
00:02:33,370 --> 00:02:36,420
以及呢，一些测试用例的设计

55
00:02:36,420 --> 00:02:39,730
而最终真正的测试过程

56
00:02:39,730 --> 00:02:42,490
从场常规阶段来看的话

57
00:02:42,490 --> 00:02:45,750
是编码结束之后

58
00:02:46,030 --> 00:02:48,650
当代码写完之后

59
00:02:48,650 --> 00:02:51,170
我们会进行单元测试

60
00:02:51,170 --> 00:02:56,070
单元测试呢，是我们唯一可能自己检测自己的

61
00:02:56,070 --> 00:02:59,460
一般来说我们会避免自己测试自己的代码

62
00:02:59,460 --> 00:03:02,850
单元测试的话，一般是由自己来测试的啊

63
00:03:02,850 --> 00:03:05,360
它主要针对的是模块内

64
00:03:05,360 --> 00:03:09,030
测试模块的功能、性能以及接口

65
00:03:09,030 --> 00:03:11,310
唉，这里也提到了接口

66
00:03:11,310 --> 00:03:12,520
但是要注意

67
00:03:12,520 --> 00:03:17,140
我们模块与模块之间由接口连接

68
00:03:17,140 --> 00:03:21,840
但是接口在模块内部也存在一个部分吧

69
00:03:21,840 --> 00:03:24,110
所以单元测试的时候

70
00:03:24,110 --> 00:03:29,500
对于内部的这个接口位置也要来进行测试

71
00:03:29,500 --> 00:03:32,030
这就是呢，单元测试

72
00:03:32,030 --> 00:03:36,440
而集成测试就是模块测试结束之后

73
00:03:36,440 --> 00:03:38,820
把我们的这些模块

74
00:03:38,820 --> 00:03:40,490
诶，拼接起来

75
00:03:40,490 --> 00:03:42,740
这个拼接的过程

76
00:03:42,740 --> 00:03:48,060
主要测试的就是模块之间的这个接口

77
00:03:48,060 --> 00:03:51,210
那对于集成测试来说的话

78
00:03:51,210 --> 00:03:53,300
它有多种方式

79
00:03:53,300 --> 00:03:56,900
我们一般模块会划分成多个吧

80
00:03:56,900 --> 00:04:01,030
并且模块间它是有相应调用关系的

81
00:04:01,030 --> 00:04:04,530
比如说主模块会调用一些呢

82
00:04:04,530 --> 00:04:07,810
下面的子模块、功能模块

83
00:04:07,810 --> 00:04:11,380
那在这个调用的过程当中

84
00:04:11,380 --> 00:04:16,510
我们在测试的时候可以自顶向下来测试

85
00:04:16,510 --> 00:04:19,970
也可以自底向上来测试

86
00:04:19,970 --> 00:04:23,030
那自底向上比较好理解

87
00:04:23,030 --> 00:04:25,570
我们先把功能模块做好

88
00:04:25,570 --> 00:04:29,010
最后呢，再做我们的这个主模块

89
00:04:29,010 --> 00:04:32,550
要调用的东西都已经提前做好了吧

90
00:04:32,550 --> 00:04:34,810
这种方式比较好理解

91
00:04:34,810 --> 00:04:38,710
那自顶向下做主函数调用的时候

92
00:04:38,710 --> 00:04:41,770
功能函数还没写好怎么办呢

93
00:04:41,770 --> 00:04:48,210
这种情况下，我们会在下面写一些装模块啊

94
00:04:48,210 --> 00:04:51,260
所谓的装模块就是呢

95
00:04:51,260 --> 00:04:53,140
完成相应功能

96
00:04:53,140 --> 00:04:55,140
基本功能的一个呢

97
00:04:55,140 --> 00:04:56,670
模式性的东西

98
00:04:56,670 --> 00:04:59,710
那这种装模块有没有完成

99
00:04:59,710 --> 00:05:01,880
真的完成具体功能啊

100
00:05:01,880 --> 00:05:02,650
没有

101
00:05:02,650 --> 00:05:05,930
它只是拿来做接口测试的

102
00:05:05,930 --> 00:05:08,230
所以我们说呢，这种过程当中

103
00:05:08,230 --> 00:05:09,940
我们有一个打桩啊

104
00:05:09,940 --> 00:05:12,990
先把下面呢，写成装模块测试呢

105
00:05:12,990 --> 00:05:15,030
上面的调用过程

106
00:05:15,030 --> 00:05:18,950
那自底向上和自顶向下

107
00:05:18,950 --> 00:05:22,870
还有两个方向同同时做测试的

108
00:05:22,870 --> 00:05:26,410
那这种情况我们叫做呢，三明治

109
00:05:26,410 --> 00:05:26,670
诶

110
00:05:26,670 --> 00:05:27,920
类似于啊

111
00:05:27,920 --> 00:05:28,980
两个汉堡

112
00:05:28,980 --> 00:05:31,180
中间呢夹一个夹心

113
00:05:31,180 --> 00:05:34,440
这种就是呢，三明治的集成方式

114
00:05:34,440 --> 00:05:37,690
这是集成测试它的方向

115
00:05:37,690 --> 00:05:40,700
那集成测试做完了之后

116
00:05:40,700 --> 00:05:44,430
其实是了解了模块和它们之间的调用吧

117
00:05:44,430 --> 00:05:49,300
它的整个系统其实不仅仅包括这一部分

118
00:05:49,300 --> 00:05:53,060
我们后面还需要呢，做系统测试

119
00:05:53,060 --> 00:05:55,700
它是在真实环境下

120
00:05:55,700 --> 00:05:59,450
来验证我们完整的软件配置

121
00:05:59,450 --> 00:06:01,010
这样的配置项啊

122
00:06:01,010 --> 00:06:04,430
能不能跟系统做正确的连接

123
00:06:04,430 --> 00:06:10,200
那这个过程是针对系统整体来进行的测试

124
00:06:10,200 --> 00:06:14,020
那我们后面呢，还有确认测试

125
00:06:14,020 --> 00:06:18,200
确认测试它其实分为两个维度

126
00:06:18,200 --> 00:06:20,740
一个是，诶，我们大家做开发

127
00:06:20,740 --> 00:06:23,950
做完之后是不是直接交给用户来确认啊

128
00:06:23,950 --> 00:06:24,740
不可能

129
00:06:24,740 --> 00:06:27,920
我们肯定是内部做好确认之后

130
00:06:27,920 --> 00:06:30,700
再拿到用户那里去做测试吧

131
00:06:30,700 --> 00:06:35,510
所以确认测试它包含内部的确认测试

132
00:06:35,510 --> 00:06:38,250
还包含外部用户的

133
00:06:38,250 --> 00:06:41,060
也就是验收测试

134
00:06:41,060 --> 00:06:45,060
那内部确认测试主体就是我们开发人员

135
00:06:45,060 --> 00:06:46,000
项目团队

136
00:06:46,000 --> 00:06:50,980
而对于外部的验收测试主体其实是用户

137
00:06:50,980 --> 00:06:53,240
像一些试运行的过程

138
00:06:53,240 --> 00:06:56,720
它就可以理解为呢，验收测试

139
00:06:56,820 --> 00:07:00,600
那我们内部在做确认测试的时候

140
00:07:00,600 --> 00:07:04,290
还可以分为埃尔法测试和贝塔测试

141
00:07:04,290 --> 00:07:09,610
埃尔法测试指的就是在开发环境下的测试

142
00:07:09,980 --> 00:07:12,260
我们在哪里做开发

143
00:07:12,260 --> 00:07:13,870
就在哪里做测试

144
00:07:13,870 --> 00:07:16,520
但开发环境和我们使用环境

145
00:07:16,520 --> 00:07:18,580
可能会存存在区别呀

146
00:07:18,580 --> 00:07:20,480
比如说网速不一样

147
00:07:20,480 --> 00:07:22,390
比如说运营商不一样

148
00:07:22,390 --> 00:07:27,000
这种情况下就需要再进行用户环境的测试

149
00:07:27,000 --> 00:07:29,040
也就是贝塔测试

150
00:07:29,040 --> 00:07:32,520
这是呢，对测试它的一个简单分类

151
00:07:32,520 --> 00:07:33,770
确认测试

152
00:07:33,770 --> 00:07:39,380
它就是验证软件与我们需求是否一致

153
00:07:39,380 --> 00:07:41,140
那我们在这里呢

154
00:07:41,140 --> 00:07:43,920
主要了解到验收测试

155
00:07:43,920 --> 00:07:47,150
它是呢比较典型的确认测试

156
00:07:47,150 --> 00:07:49,890
最后还有一种特殊的测试

157
00:07:49,890 --> 00:07:52,220
叫做回归测试

158
00:07:52,220 --> 00:07:56,450
回归测试它所针对的是变更

159
00:07:56,450 --> 00:07:59,490
我们在前面曾经提到过一种思想

160
00:07:59,490 --> 00:08:02,150
当大家修改了一个 bug 之后

161
00:08:02,150 --> 00:08:04,420
很可能会引入新的 bug 吧

162
00:08:04,420 --> 00:08:07,700
所以针对每一次修改变更

163
00:08:07,700 --> 00:08:12,780
一定要对它进行111个针对性的测试

164
00:08:12,780 --> 00:08:16,660
这里的针对性测试呢，就是回归测试

165
00:08:16,660 --> 00:08:18,720
那针对这个阶段

166
00:08:18,720 --> 00:08:21,860
以及一些特殊的测试的含义呢

167
00:08:21,860 --> 00:08:25,880
大家要了解到一些特殊测试它的任务

168
00:08:25,880 --> 00:08:28,950
这一部分在我们软件设计师考试当中

169
00:08:28,950 --> 00:08:30,810
考察并不是很多

170
00:08:30,810 --> 00:08:33,460
但是呢，需要大家去了解

171
00:08:33,460 --> 00:08:36,700
那下面呢，我们来看一下这一部分

172
00:08:36,700 --> 00:08:40,299
在软件设计师考试真题当中的体现

173
00:08:40,299 --> 00:08:44,850
下图啊， A 是一个模块的层次结构图的实例

174
00:08:44,850 --> 00:08:46,260
而图 B 呢

175
00:08:46,260 --> 00:08:51,230
它是我们对整个结构图进行集成测试的顺序

176
00:08:51,230 --> 00:08:54,490
所以考察的是集成测试

177
00:08:54,490 --> 00:08:56,720
针对这个集成测试而言

178
00:08:56,720 --> 00:09:00,750
我们采用了什么样的测试策略呢

179
00:09:00,750 --> 00:09:03,530
这个策略的优点不包括什么

180
00:09:03,530 --> 00:09:06,870
首先第一空来判断它的策略

181
00:09:06,870 --> 00:09:09,070
这个策略自底向上

182
00:09:09,070 --> 00:09:10,670
自顶向下，三明治

183
00:09:10,670 --> 00:09:14,430
还有呢，一次性做所有的测试工作

184
00:09:14,430 --> 00:09:17,160
那我们首先呢，看到，诶

185
00:09:17,160 --> 00:09:19,440
在测试顺序当中

186
00:09:19,440 --> 00:09:22,640
首先测试了我们的 A 模块

187
00:09:22,640 --> 00:09:26,460
并且同时测试了第一 G 啊

188
00:09:26,460 --> 00:09:28,000
EFG 模块

189
00:09:28,000 --> 00:09:29,750
这种情况下

190
00:09:29,750 --> 00:09:32,760
两个方向同时测试的

191
00:09:32,760 --> 00:09:33,920
我们叫做呢

192
00:09:33,920 --> 00:09:37,760
三明治这样的测试策略、集成策略

193
00:09:37,760 --> 00:09:40,250
那这种策略的优点

194
00:09:40,250 --> 00:09:41,970
我们呢，如果不知道

195
00:09:41,970 --> 00:09:45,110
可以呢，看一下四下面的四个选项

196
00:09:45,110 --> 00:09:47,250
简单的了解一下

197
00:09:47,250 --> 00:09:51,040
本题的四个选项其实不是特别严谨啊

198
00:09:51,040 --> 00:09:54,640
我们只能呢，找到最合适的一个选项而已

199
00:09:54,640 --> 00:09:56,610
那首先 A 选项

200
00:09:56,610 --> 00:10:00,110
由于我们较早的测试了底

201
00:10:00,110 --> 00:10:02,110
以及呢，这个高层

202
00:10:02,110 --> 00:10:06,590
所以我们较早地验证了主要的控制点

203
00:10:06,590 --> 00:10:08,650
和他的判断点吧

204
00:10:08,650 --> 00:10:11,260
那这中间我们同

205
00:10:11,260 --> 00:10:14,780
同时进行了底层模块的测试

206
00:10:14,780 --> 00:10:18,000
所以较早验证了底层模块

207
00:10:18,000 --> 00:10:21,400
并且，唉，原本自底向上的话

208
00:10:21,400 --> 00:10:25,630
我们是只有一个模块按层次来进行并行吧

209
00:10:25,630 --> 00:10:28,640
自底向上、自顶向下都是如此

210
00:10:28,640 --> 00:10:30,680
而三明治形

211
00:10:30,680 --> 00:10:36,560
我们可以同时进行 A 、 EF 、 G 两个层次的并行

212
00:10:36,560 --> 00:10:40,430
所以这个并行的程度还是比较高的

213
00:10:40,430 --> 00:10:44,630
最后呢， D 选项这种说法呢，不是很合适了

214
00:10:44,630 --> 00:10:49,190
他说呢，我们可以有较少的驱动模块和桩模块

215
00:10:49,190 --> 00:10:51,520
但是从本题来看的话

216
00:10:51,520 --> 00:10:55,140
我们会发现如果自顶向下的情况下

217
00:10:55,140 --> 00:10:57,720
A 模块还是要做驱动模块

218
00:10:57,720 --> 00:11:00,180
B ， CD 吧，要做装模块 B 、 C 、 D 吧

219
00:11:00,180 --> 00:11:03,120
那 E 、 F 、 G 做我们的，呃

220
00:11:03,120 --> 00:11:05,640
底层自底向下来测试的话

221
00:11:05,640 --> 00:11:09,590
还是要写他高层的 BCD 驱动模块

222
00:11:09,590 --> 00:11:13,480
这样才能够呢进行相关的接口测试

223
00:11:13,480 --> 00:11:16,810
所以在这种情况下来看的话

224
00:11:16,810 --> 00:11:19,850
这个工作量并不是最少的

225
00:11:19,850 --> 00:11:22,990
所以这种较少的工作量的说

226
00:11:22,990 --> 00:11:23,870
本身呢

227
00:11:23,870 --> 00:11:26,710
还与我们这种测试的技术相关

228
00:11:26,710 --> 00:11:30,140
所以在这里相比四个选项来看

229
00:11:30,140 --> 00:11:32,590
这个选项呢是最不合适的

230
00:11:32,590 --> 00:11:34,020
所以我们在这里呢

231
00:11:34,020 --> 00:11:35,700
第二孔选择它的

232
00:11:35,700 --> 00:11:37,500
策略优点的情况下

233
00:11:37,500 --> 00:11:40,230
不包括的应该是 D 选项

234
00:11:40,230 --> 00:11:41,990
那综合来看

235
00:11:41,990 --> 00:11:45,190
这一部分在我们软件设计师考试当中

236
00:11:45,190 --> 00:11:47,940
考察的频率呢不是很高

237
00:11:47,940 --> 00:11:51,010
所以大家呢可以拓展去了解一

238
00:11:51,010 --> 00:11:53,750
一些呢特殊的测试的阶段

239
00:11:53,750 --> 00:11:56,550
他们的一些任务和特点
