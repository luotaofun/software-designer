1
00:00:00,000 --> 00:00:03,600
我们首先来了解到系统测试当中

2
00:00:03,600 --> 00:00:06,550
测试的一些基本概念以及分类

3
00:00:06,550 --> 00:00:08,390
有很多同学可能会觉得

4
00:00:08,390 --> 00:00:10,490
这一部分有什么好讲的呢

5
00:00:10,490 --> 00:00:12,790
在做测试的过程当中啊

6
00:00:12,790 --> 00:00:14,010
我们需要呢

7
00:00:14,010 --> 00:00:16,250
诶，根据测试的一些思

8
00:00:16,250 --> 00:00:19,890
去遵循一些呢基本的、原则性的东西

9
00:00:19,890 --> 00:00:20,920
比如说呢

10
00:00:20,920 --> 00:00:23,420
大家首先考虑一个问题啊

11
00:00:23,420 --> 00:00:26,480
我们在做软件测试的时候

12
00:00:26,480 --> 00:00:31,410
它的目的是验证软件的正确性

13
00:00:31,410 --> 00:00:32,509
还是呢

14
00:00:32,509 --> 00:00:36,890
哎，找到一个没有发现的错误

15
00:00:43,200 --> 00:00:46,280
有很多同学都会认为呀

16
00:00:46,280 --> 00:00:49,380
软件测试如果找不到 bug 了

17
00:00:49,380 --> 00:00:51,500
说明这个软件是正确的呀

18
00:00:51,500 --> 00:00:54,610
但其实在我们软件测试当中啊

19
00:00:54,610 --> 00:00:59,650
它的目的还是能找到一个从未发现的错误

20
00:00:59,650 --> 00:01:02,150
那这是我们测试人员

21
00:01:02,150 --> 00:01:04,580
他的角度上去看到的一些东西

22
00:01:04,580 --> 00:01:06,910
有没有不存在错误

23
00:01:06,910 --> 00:01:08,850
完全正确的软件呢

24
00:01:08,850 --> 00:01:11,910
其实我们目前行业上都会认为

25
00:01:11,910 --> 00:01:15,360
所有的软件都会存在 bug 

26
00:01:15,360 --> 00:01:17,440
除非它是没有代码的

27
00:01:17,440 --> 00:01:20,660
有代码就有可能存在一些问题

28
00:01:20,660 --> 00:01:21,730
所以说啊

29
00:01:21,730 --> 00:01:25,190
正确性它是无法来进行验证的

30
00:01:25,190 --> 00:01:28,030
这是我们软件测试的一个目的

31
00:01:28,030 --> 00:01:31,580
那测试需要遵循什么样的一些原则呢

32
00:01:31,580 --> 00:01:32,580
首先的话

33
00:01:32,580 --> 00:01:36,190
测试应该尽早不断的进行测试

34
00:01:36,190 --> 00:01:40,270
那我们是不是一定要等到编码结束之后

35
00:01:40,270 --> 00:01:41,500
再来测试呢

36
00:01:41,500 --> 00:01:44,290
像我们现在有一些开发模型当中

37
00:01:44,290 --> 00:01:45,670
尤其像敏捷

38
00:01:45,670 --> 00:01:48,550
就会有呢，去测试驱动开发吧

39
00:01:48,550 --> 00:01:50,190
先写测试代码

40
00:01:50,190 --> 00:01:54,590
那我们会尽尽量的把测试的这个过程啊

41
00:01:54,590 --> 00:01:55,830
提前去做

42
00:01:55,830 --> 00:01:57,650
早一点发现问题

43
00:01:57,650 --> 00:01:59,730
才能早一点解决问题

44
00:01:59,730 --> 00:02:02,890
防止像滚雪球一样越滚越大

45
00:02:02,890 --> 00:02:05,670
这个问题影响面积越来越大

46
00:02:05,670 --> 00:02:09,590
所以要尽早不断地进行测试啊

47
00:02:09,590 --> 00:02:11,510
那代码没有完成

48
00:02:11,510 --> 00:02:13,110
我们如何来测试呢

49
00:02:13,110 --> 00:02:15,490
其实我们在开发的过程当中

50
00:02:15,490 --> 00:02:18,120
可以边开发进行一些测试工作

51
00:02:18,120 --> 00:02:20,540
包括在代码开始之前

52
00:02:20,540 --> 00:02:23,520
我们在做需求分析的时候

53
00:02:23,520 --> 00:02:25,780
都可以去做一些呢

54
00:02:25,780 --> 00:02:28,900
验证测试相关的测试计划

55
00:02:28,900 --> 00:02:31,700
和测试用例的一些设计和制定

56
00:02:31,700 --> 00:02:33,710
所以他的思想呢

57
00:02:33,710 --> 00:02:37,120
应该是尽早的不断地进行测试

58
00:02:37,120 --> 00:02:39,930
在整个软件开发过程当中

59
00:02:39,930 --> 00:02:43,590
尽可能不断的来验证我们的软件

60
00:02:43,590 --> 00:02:44,610
做一些呢

61
00:02:44,610 --> 00:02:45,750
唉，软件验证

62
00:02:45,750 --> 00:02:47,820
软件评审这样的一些工作

63
00:02:47,820 --> 00:02:50,300
那我们在测试的时候

64
00:02:50,300 --> 00:02:53,500
由于人会存在一些惯性思维

65
00:02:53,500 --> 00:02:57,530
所以我们的程序员要尽量能避免自己

66
00:02:57,530 --> 00:02:59,240
测试自己的程序

67
00:02:59,240 --> 00:03:00,710
那有一些小公司

68
00:03:00,710 --> 00:03:03,190
那可能团队只有一个人自己

69
00:03:03,190 --> 00:03:03,940
自己测

70
00:03:03,940 --> 00:03:06,610
最后会发现送到用户那里去之后

71
00:03:06,610 --> 00:03:08,690
一大堆的问题没有发现吧

72
00:03:08,690 --> 00:03:10,440
所以一般来说啊

73
00:03:10,440 --> 00:03:11,860
一个团队要有呢

74
00:03:11,860 --> 00:03:14,790
独立的测试人员会更好一些

75
00:03:14,790 --> 00:03:18,270
那我们的程序员是不是就不会去测试了呢

76
00:03:18,270 --> 00:03:20,590
我们在做单元测试的时候

77
00:03:20,590 --> 00:03:24,300
其实会由程序员自己来测试更多一些

78
00:03:24,300 --> 00:03:28,460
那这是呢关于测试人员的角度

79
00:03:28,460 --> 00:03:31,990
我们在进行测试的时

80
00:03:31,990 --> 00:03:33,980
会涉及测试用例

81
00:03:33,980 --> 00:03:37,940
测试用例的格式一般是输入数据

82
00:03:37,940 --> 00:03:39,730
以及它的结果

83
00:03:39,730 --> 00:03:43,230
也就是说我们在设计测试用例的时候

84
00:03:43,230 --> 00:03:44,810
要考虑输入

85
00:03:44,810 --> 00:03:47,300
还要预测它的输出

86
00:03:47,300 --> 00:03:51,850
最后验证跟我们的这个输出是否相符

87
00:03:51,850 --> 00:03:54,930
那考虑输入数据的时候

88
00:03:54,930 --> 00:03:58,650
既要考虑有效的、合理的数据

89
00:03:58,650 --> 00:04:02,030
也要选择无效、不合理的数据

90
00:04:02,030 --> 00:04:04,750
为什么要有这种情况呢

91
00:04:04,750 --> 00:04:08,290
大家想一想自己使用的一些软件的时候啊

92
00:04:08,290 --> 00:04:10,910
自己站在用户的角度

93
00:04:10,910 --> 00:04:14,560
当你呢，不小心录入了一个错误数据

94
00:04:14,560 --> 00:04:17,890
比如说，诶，输入姓名或者输入年龄的时候

95
00:04:17,890 --> 00:04:20,690
不小心呢，把它梳成了年龄的地方

96
00:04:20,690 --> 00:04:22,440
不小心输成了字母

97
00:04:22,440 --> 00:04:24,270
那这个过程当中

98
00:04:24,270 --> 00:04:27,510
如果没有对这里进行设定

99
00:04:27,510 --> 00:04:30,380
很有可能他就抛出了一个异常吧

100
00:04:30,380 --> 00:04:33,830
那这种异常会在我们的界面当中

101
00:04:33,830 --> 00:04:35,750
跳出一个弹窗

102
00:04:35,750 --> 00:04:38,980
里面一大堆看不懂的英文

103
00:04:38,980 --> 00:04:43,120
那你要指着用户来读懂出现了什么异常吗

104
00:04:43,120 --> 00:04:45,410
显然这个是不对的吧

105
00:04:45,410 --> 00:04:49,500
那我们在这里考虑到这种非法输入

106
00:04:49,500 --> 00:04:53,020
如果给他一个合理的中文提示

107
00:04:53,020 --> 00:04:56,810
对于用户来说，感受会更友好一些

108
00:04:56,810 --> 00:05:00,110
或者说一个不小心错误的数据

109
00:05:00,110 --> 00:05:02,070
让整个系统崩掉了

110
00:05:02,070 --> 00:05:04,100
这种设计肯定呢

111
00:05:04,100 --> 00:05:05,800
这种细节系统啊

112
00:05:05,800 --> 00:05:07,260
肯定是有问题的

113
00:05:07,260 --> 00:05:09,550
所以我们在测试的时

114
00:05:09,550 --> 00:05:13,210
也要呢选择有效、合理的数据

115
00:05:13,210 --> 00:05:17,850
还要呢选择无效、不合理的数据去进行验证

116
00:05:18,200 --> 00:05:20,840
那我们一旦发生错误

117
00:05:20,840 --> 00:05:22,540
发现一些错误的时

118
00:05:22,540 --> 00:05:24,030
要进行修改吧

119
00:05:24,030 --> 00:05:27,060
我们在前面其实也提到过一种思想

120
00:05:27,060 --> 00:05:29,720
在进行程序修改的时候

121
00:05:29,720 --> 00:05:31,980
当你修改了一个 bug 

122
00:05:31,980 --> 00:05:34,720
很有可能会引入更多的 bug 吧

123
00:05:34,720 --> 00:05:37,560
这也是测试当中的一种思想

124
00:05:37,560 --> 00:05:43,510
那每一次修改我们都需要呢进行回归测试

125
00:05:43,510 --> 00:05:48,310
那这也是回归特测试它的一个呢特殊的应用

126
00:05:48,310 --> 00:05:52,190
那我们呢，最后还要了解到一个原则

127
00:05:52,190 --> 00:05:54,400
尚未发现的错误量

128
00:05:54,400 --> 00:05:58,150
与已发现的错误量是成正比的

129
00:05:58,150 --> 00:06:01,190
那假设我们有一个 A 软件

130
00:06:01,190 --> 00:06:03,260
有一个 B 软件

131
00:06:03,260 --> 00:06:06,160
那 A 软件我们在测试的时候

132
00:06:06,160 --> 00:06:08,420
发现了1000个错误

133
00:06:08,420 --> 00:06:11,630
B 软件我们发现了十个错误

134
00:06:11,630 --> 00:06:14,160
那针对用户来看的话

135
00:06:14,160 --> 00:06:17,140
你想要选择哪一种软件啊

136
00:06:17,140 --> 00:06:19,550
一般会选择错误较少的吧

137
00:06:19,550 --> 00:06:21,510
你会不会认

138
00:06:21,510 --> 00:06:24,670
当我们发现1000个错误之后

139
00:06:24,670 --> 00:06:27,810
那 A 软件剩下的错误就不多了呢

140
00:06:27,810 --> 00:06:29,370
并不会这样去想

141
00:06:29,370 --> 00:06:30,950
我们会认为啊

142
00:06:30,950 --> 00:06:33,490
既然你发现了1000个错误

143
00:06:33,490 --> 00:06:36,140
说明你这个软件写的肯定有问题

144
00:06:36,140 --> 00:06:38,210
那我们待发现的

145
00:06:38,210 --> 00:06:42,330
我们会怀疑它还存在1000个错误在这里

146
00:06:42,330 --> 00:06:45,850
而 B 软件测试只发现了错误

147
00:06:45,850 --> 00:06:49,790
我们会怀疑未发现的错误还有十个

148
00:06:49,790 --> 00:06:51,960
所以待发现的

149
00:06:51,960 --> 00:06:55,100
它与我们已经发现的错误数量呢

150
00:06:55,100 --> 00:06:56,840
是成正比的

151
00:06:56,840 --> 00:06:58,290
你找得越多

152
00:06:58,290 --> 00:07:01,860
我们怀疑剩下的也就能越多

153
00:07:01,860 --> 00:07:05,410
所以这里有一个呢，成正比的思想

154
00:07:05,410 --> 00:07:07,070
并且要知道

155
00:07:07,070 --> 00:07:11,610
错误五是没有办法把它全部找出来

156
00:07:11,610 --> 00:07:15,010
穷尽找到错误的这种思想呢

157
00:07:15,010 --> 00:07:16,980
基本上是做不到的

158
00:07:16,980 --> 00:07:19,360
那这是我们给大家介绍到的

159
00:07:19,360 --> 00:07:23,620
软件测试它的一些思想和原则

160
00:07:23,620 --> 00:07:27,550
那我们接下来再来看一下

161
00:07:27,550 --> 00:07:30,280
关于软件测试它的分类

162
00:07:30,280 --> 00:07:33,270
我们在这里只简单介绍分类

163
00:07:33,270 --> 00:07:36,110
不介绍呢它的具体的应用

164
00:07:36,110 --> 00:07:39,090
那我们在进行软件测试分类的时候

165
00:07:39,090 --> 00:07:41,030
第一个维度的划分呢

166
00:07:41,030 --> 00:07:46,030
是根据是否人工还是呢机器的参与

167
00:07:46,030 --> 00:07:48,530
人工怎么来测试呢

168
00:07:48,530 --> 00:07:51,450
哎，其实我们在做程序开发的时候

169
00:07:51,450 --> 00:07:53,730
程序最终都是运行起来的吧

170
00:07:53,730 --> 00:07:57,370
那这种运行的程序是跑在机器上的

171
00:07:57,370 --> 00:08:00,650
但人工如何来判断

172
00:08:00,650 --> 00:08:03,440
我们相应的程序有没有错误呢

173
00:08:03,440 --> 00:08:05,740
大家其实可以结合

174
00:08:05,740 --> 00:08:08,460
我们软件设计师考试的过程

175
00:08:08,460 --> 00:08:12,130
我们的软件设计师考试是有 C 代码填空

176
00:08:12,130 --> 00:08:14,690
和面向对象程序开发的吧

177
00:08:14,690 --> 00:08:18,390
这一类考察是笔试的形式

178
00:08:18,390 --> 00:08:20,320
没有进行机制

179
00:08:20,320 --> 00:08:24,520
也就是说我们在分析代码缺失的时候

180
00:08:24,520 --> 00:08:27,020
有没有考虑机器运行呢

181
00:08:27,020 --> 00:08:29,930
在这里机器是不参与的

182
00:08:29,930 --> 00:08:33,659
纯粹靠大家的大脑来思考哦

183
00:08:33,659 --> 00:08:36,350
那我们大脑在思考的时候

184
00:08:36,350 --> 00:08:38,010
我们会对着代码

185
00:08:38,010 --> 00:08:41,210
首先呢，哎，大家可能会看一下代码

186
00:08:41,210 --> 00:08:45,790
敲完之后检查一下有没有一些基本的错误

187
00:08:45,790 --> 00:08:48,860
这种呢，就叫做桌前检查

188
00:08:48,860 --> 00:08:51,880
比如说大家现在有时候看到西塞的题库

189
00:08:51,880 --> 00:08:54,720
也会去看一看这个代码有没有问题吧

190
00:08:54,720 --> 00:08:56,320
然后呢

191
00:08:56,470 --> 00:08:58,350
代码审查

192
00:08:58,350 --> 00:09:02,590
这个审就意味着有其他人的参与

193
00:09:02,590 --> 00:09:05,600
来审查你的代码是否有问题

194
00:09:05,600 --> 00:09:07,740
最后代码走查

195
00:09:07,740 --> 00:09:11,840
这个走就是我们在分析题目的时候

196
00:09:11,840 --> 00:09:16,460
用脑袋来思考他的这个执行逻辑，诶

197
00:09:16,460 --> 00:09:18,690
预想它的执行过程

198
00:09:18,690 --> 00:09:23,340
然后呢，来判断其中是否存在一些问题

199
00:09:23,340 --> 00:09:27,870
那这一些测试我们都叫做呢静态测试

200
00:09:27,870 --> 00:09:30,380
纯人工来测试的

201
00:09:30,380 --> 00:09:32,730
没有机器的参与

202
00:09:32,730 --> 00:09:36,030
那机器运行过程当中的测试

203
00:09:36,030 --> 00:09:38,470
我们叫做动态测试

204
00:09:38,470 --> 00:09:43,500
动态测试可以分为黑和白盒以及灰盒

205
00:09:43,500 --> 00:09:45,100
黑盒测

206
00:09:45,100 --> 00:09:48,790
它类似于给了大家一个黑匣子

207
00:09:48,790 --> 00:09:52,200
那我们只要考虑手伸进

208
00:09:52,200 --> 00:09:54,120
能够拿出来什么

209
00:09:54,120 --> 00:09:55,580
输入一个东西

210
00:09:55,580 --> 00:09:57,390
输出来什么

211
00:09:57,390 --> 00:10:00,010
具体里面是如何来实现的

212
00:10:00,010 --> 00:10:01,410
不需要去了解

213
00:10:01,410 --> 00:10:05,000
那这种情况就叫做黑盒测试

214
00:10:05,000 --> 00:10:09,790
白盒测试要考虑箱子是透明的

215
00:10:09,790 --> 00:10:13,930
具体这个输入是如何到达这个输出的

216
00:10:13,930 --> 00:10:16,070
他走了哪条路径

217
00:10:16,070 --> 00:10:17,970
经过了什么样的过程

218
00:10:17,970 --> 00:10:21,450
就是呢白盒测试的过程

219
00:10:21,870 --> 00:10:27,040
灰盒测试的思想是结合了黑盒和白盒测试

220
00:10:27,040 --> 00:10:28,980
目前在我们考试当中

221
00:10:28,980 --> 00:10:32,640
是没有出现过灰盒这样的一个考察的

222
00:10:32,640 --> 00:10:36,930
那我们针对黑盒和白盒测试展开来看的话

223
00:10:36,930 --> 00:10:40,350
黑盒的测试方法包

224
00:10:40,350 --> 00:10:46,280
等价类划分、边界值分析、还有错误推测和因果图

225
00:10:46,280 --> 00:10:50,740
其中等价类划分和边界值分析

226
00:10:50,740 --> 00:10:52,040
我们稍后呢

227
00:10:52,040 --> 00:10:55,680
在黑盒测试相关的知识内容当中

228
00:10:55,680 --> 00:10:57,340
来给大家进行介绍

229
00:10:57,340 --> 00:11:02,440
那错误推测它是依据经验来推测的

230
00:11:02,440 --> 00:11:05,570
我们有很多经验比较丰富的程序员

231
00:11:05,570 --> 00:11:07,770
一看到你写的代码

232
00:11:07,770 --> 00:11:10,650
它主要完成什么样的业务逻辑的话

233
00:11:10,650 --> 00:11:13,150
基本上呢就会指出哪

234
00:11:13,150 --> 00:11:15,310
哪里是最容易出错的

235
00:11:15,310 --> 00:11:17,090
那这种其实就是呢

236
00:11:17,090 --> 00:11:19,280
错误有推测的一种

237
00:11:19,280 --> 00:11:21,040
因果图呢

238
00:11:21,040 --> 00:11:23,780
它也是呢鱼骨图的形式

239
00:11:23,780 --> 00:11:27,080
他在分析我们各个诶

240
00:11:27,080 --> 00:11:28,780
结果产生的时

241
00:11:28,780 --> 00:11:30,570
有多种原因

242
00:11:30,570 --> 00:11:33,360
那再根据呢，结果反

243
00:11:33,360 --> 00:11:36,320
它的出现是由于什么样的原因

244
00:11:36,320 --> 00:11:38,900
从而呢，找到问题的所在

245
00:11:38,900 --> 00:11:41,420
就叫做呢因果图

246
00:11:41,540 --> 00:11:43,820
白盒测试的方法呢

247
00:11:43,820 --> 00:11:46,100
相对来说就比较复杂了

248
00:11:46,100 --> 00:11:50,710
我们的白盒测试包括基本路径测试

249
00:11:50,710 --> 00:11:51,930
循环测试

250
00:11:51,930 --> 00:11:54,250
以及呢逻辑覆盖测试

251
00:11:54,250 --> 00:12:00,170
其中，逻辑覆盖测试是我们考试当中的重点

252
00:12:00,170 --> 00:12:03,390
其他的基本路径和循环覆盖

253
00:12:03,390 --> 00:12:06,320
基本上还没有涉及到

254
00:12:06,320 --> 00:12:08,130
那我们在后面呢

255
00:12:08,130 --> 00:12:11,560
也会展开在白盒测试的部分

256
00:12:11,560 --> 00:12:15,500
给大家来介绍这些呢，测试方法

257
00:12:15,500 --> 00:12:17,750
那在这里我们先呢

258
00:12:17,750 --> 00:12:21,130
掌握它的归类就可以了

259
00:12:21,130 --> 00:12:23,990
下面我们来看一下这一部分

260
00:12:23,990 --> 00:12:27,910
在软件设计师考试真题当中的体现

261
00:12:27,910 --> 00:12:31,510
以下关于软件测试的叙述当中

262
00:12:31,510 --> 00:12:33,250
不正确的是谁

263
00:12:33,250 --> 00:12:37,000
注意，我们找的是错误的选项

264
00:12:37,000 --> 00:12:41,110
首先， A 选项在设计测试用例的时候

265
00:12:41,110 --> 00:12:42,810
我们要考虑输入

266
00:12:42,810 --> 00:12:45,460
还要考虑预期的输出吧

267
00:12:45,460 --> 00:12:47,620
这个说法是正确的

268
00:12:47,620 --> 00:12:52,840
B 选项软件测试的目的是验证软件的正确性

269
00:12:52,840 --> 00:12:55,970
这是一个典型的错误说法

270
00:12:55,970 --> 00:12:58,430
我们无法验证一个软件

271
00:12:58,430 --> 00:13:00,570
它是百分百正确的

272
00:13:00,570 --> 00:13:01,580
C 选项

273
00:13:01,580 --> 00:13:05,860
我们在测试的时候要考虑合理的输入条件

274
00:13:05,860 --> 00:13:08,190
还要考虑 D 选项，诶

275
00:13:08,190 --> 00:13:10,730
不合理的这个输入条件吧

276
00:13:10,730 --> 00:13:14,690
都应该包括在我们的测试用例当中

277
00:13:14,690 --> 00:13:16,120
去进行测试

278
00:13:16,120 --> 00:13:19,540
所以 A 、 C 、 D 的说法都是正确的

279
00:13:19,540 --> 00:13:23,400
B 选项呢，是典型的错误说法

280
00:13:24,090 --> 00:13:27,580
下面再来看招聘系统

281
00:13:27,580 --> 00:13:30,100
要求求职的人年龄呢

282
00:13:30,100 --> 00:13:32,770
在20~60岁之间

283
00:13:32,770 --> 00:13:36,720
学历呢，是本科、硕士或者博士

284
00:13:36,720 --> 00:13:39,630
专业是计算机科学与技术

285
00:13:39,630 --> 00:13:42,340
通信工程或者电子工程

286
00:13:42,340 --> 00:13:45,790
其中谁不是好的测试用例

287
00:13:45,790 --> 00:13:50,090
这道题考察的是对测试用例的设计

288
00:13:50,090 --> 00:13:52,070
我们前面只是告诉大家

289
00:13:52,070 --> 00:13:53,030
测试用例

290
00:13:53,030 --> 00:13:56,730
它会考虑输入以及输出结果的设计吧

291
00:13:56,730 --> 00:14:00,620
那在这里我们只看到了输入过程

292
00:14:00,620 --> 00:14:02,900
对于输入来看的话

293
00:14:02,900 --> 00:14:04,810
如果不不是啊

294
00:14:04,810 --> 00:14:07,730
很理解测试用例它的设计思想

295
00:14:07,730 --> 00:14:11,000
我们其实可以对比看一看它们的区别

296
00:14:11,000 --> 00:14:15,120
首先， A 选项，20，本科电子工程

297
00:14:15,120 --> 00:14:17,460
这是一个能合法的

298
00:14:17,460 --> 00:14:20,020
也叫做有效的测试用例

299
00:14:20,020 --> 00:14:23,060
第二个选项，18岁

300
00:14:23,060 --> 00:14:26,060
哎，他是在20~60之间吗

301
00:14:26,060 --> 00:14:26,900
不满足

302
00:14:26,900 --> 00:14:28,570
这是一个错误点

303
00:14:28,570 --> 00:14:33,180
然后呢，学历和他的这个专业是正确的

304
00:14:33,180 --> 00:14:35,340
那有了一个错误的

305
00:14:35,340 --> 00:14:38,870
它是属于呢无效的测试用例

306
00:14:38,870 --> 00:14:40,590
再来看 C 选项

307
00:14:40,590 --> 00:14:42,530
A 18岁错误的

308
00:14:42,530 --> 00:14:44,950
大专也是错误的

309
00:14:44,950 --> 00:14:48,070
此时有两个错误点了

310
00:14:48,070 --> 00:14:51,370
它也是一种呢无效的测试用例

311
00:14:51,370 --> 00:14:54,970
D 选项25硕士生物学

312
00:14:54,970 --> 00:14:58,290
其中生物学是它的错误位置吧

313
00:14:58,290 --> 00:15:00,670
那我们分析之后会发现诶

314
00:15:00,670 --> 00:15:01,750
对比一下

315
00:15:01,750 --> 00:15:06,740
C 选项是唯一出现两个错误地方的测试用例

316
00:15:06,740 --> 00:15:09,660
为什么说这种测试用例不好呢

317
00:15:09,660 --> 00:15:11,520
我们在验证的时候

318
00:15:11,520 --> 00:15:14,320
B 选项验证的是年龄

319
00:15:14,320 --> 00:15:17,350
D 选项验证的是专业

320
00:15:17,350 --> 00:15:20,180
而 C 选项它只是错误

321
00:15:20,180 --> 00:15:23,210
却无法找到错误的位置

322
00:15:23,210 --> 00:15:26,840
它就没有起到验证的这个作用

323
00:15:26,840 --> 00:15:30,120
所以我们在设计无效测试用例的时候

324
00:15:30,120 --> 00:15:35,210
一般呢一个测试用例至多只覆盖一个错误点

325
00:15:35,210 --> 00:15:37,050
这个地方呢，注意一下

326
00:15:37,050 --> 00:15:39,730
是关于测试用例的设计
