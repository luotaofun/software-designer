1
00:00:00,000 --> 00:00:02,460
接下来我们展开来看一下

2
00:00:02,460 --> 00:00:05,410
Mark caber 环路复杂度的计算

3
00:00:05,410 --> 00:00:08,100
那这一类计算问题非常简单

4
00:00:08,100 --> 00:00:11,600
但是在我们软件设计师考试当中经常出现

5
00:00:11,600 --> 00:00:13,500
所以它非常重要

6
00:00:13,500 --> 00:00:15,580
那它的考察一方面呢

7
00:00:15,580 --> 00:00:17,550
是给大家一个节点图

8
00:00:17,550 --> 00:00:21,030
让大家判断相应图示的环图复杂度

9
00:00:21,030 --> 00:00:22,180
也有可能呢

10
00:00:22,180 --> 00:00:27,550
会出现结合白盒测试一起考察的题型

11
00:00:27,550 --> 00:00:31,290
那这种题型就可能会出现伪代码形式

12
00:00:31,290 --> 00:00:33,270
程序流程图形式等等

13
00:00:33,270 --> 00:00:35,770
那需要呢，做一定的转换

14
00:00:35,770 --> 00:00:38,770
下面我们来看一下它的计算过程

15
00:00:38,770 --> 00:00:40,240
环路复杂度啊

16
00:00:40,240 --> 00:00:41,900
它是对我们程序

17
00:00:41,900 --> 00:00:44,320
或者说软件规模的一种估算

18
00:00:44,320 --> 00:00:46,860
这种估算体现的是复杂度

19
00:00:46,860 --> 00:00:48,960
而复杂度的过程呢

20
00:00:48,960 --> 00:00:53,500
尤其是一些判定结果会影响程序的复杂度

21
00:00:53,500 --> 00:00:57,850
那我们最终呢，它的体现是可以直接呢

22
00:00:57,850 --> 00:01:00,770
通过环来体现复杂度的

23
00:01:00,770 --> 00:01:02,480
那什么是环

24
00:01:02,480 --> 00:01:06,140
首先左侧给了大家一个程序流程图

25
00:01:06,140 --> 00:01:07,600
简单来说

26
00:01:07,600 --> 00:01:09,780
环路它顾名思义呢

27
00:01:09,780 --> 00:01:13,530
就是属独立的这种环路路径

28
00:01:13,530 --> 00:01:16,380
那显然这里有四个环吧

29
00:01:16,380 --> 00:01:21,770
而顺序过程它的默认环路复杂度是一的

30
00:01:21,770 --> 00:01:25,280
所以程序本身的环路复杂度是一

31
00:01:25,280 --> 00:01:27,230
加上四个独立环路

32
00:01:27,230 --> 00:01:30,370
它的总体复杂度其实是五

33
00:01:30,370 --> 00:01:32,650
这是数圈的形式

34
00:01:32,650 --> 00:01:34,900
但是数圈的情况下

35
00:01:34,900 --> 00:01:38,350
如果出现一些交叉交错的情况

36
00:01:38,350 --> 00:01:41,120
很多同学其实是数不清权的

37
00:01:41,120 --> 00:01:42,260
那怎么办呢

38
00:01:42,260 --> 00:01:45,060
有没有统一的这种公式呢

39
00:01:45,060 --> 00:01:46,230
是有的

40
00:01:46,230 --> 00:01:48,990
所以我们接下来给大家介绍到

41
00:01:48,990 --> 00:01:53,410
就是呢，通过公式来计算环路复杂度

42
00:01:53,870 --> 00:01:57,270
环路复杂度它的计算公式啊

43
00:01:57,270 --> 00:01:58,570
就是呢，哎

44
00:01:58,570 --> 00:02:00,550
下面这个标识

45
00:02:00,550 --> 00:02:02,750
M 减 N 加二

46
00:02:02,750 --> 00:02:07,630
它是等于边的个数减去点的个

47
00:02:07,630 --> 00:02:08,660
加上二

48
00:02:08,660 --> 00:02:12,870
这个边我们一般呢，指的是有向弧

49
00:02:12,870 --> 00:02:14,430
环路复杂度

50
00:02:14,430 --> 00:02:16,070
它的计算对象

51
00:02:16,070 --> 00:02:20,150
针对的其实是右侧这种节点图

52
00:02:20,150 --> 00:02:23,290
那这是一个单向的节点图

53
00:02:23,290 --> 00:02:26,850
节点与节点之间有一个呢，有向弧

54
00:02:26,850 --> 00:02:28,520
这种情况呢

55
00:02:28,520 --> 00:02:30,840
弧的个数就是边的个数

56
00:02:30,840 --> 00:02:33,200
节点的个数就是点的个数

57
00:02:33,200 --> 00:02:35,220
从而来进行求取

58
00:02:35,220 --> 00:02:38,720
那我们既然知道这个公式之后

59
00:02:38,720 --> 00:02:40,930
接下来的问题就是在于

60
00:02:40,930 --> 00:02:43,050
如何得到这个节点

61
00:02:43,050 --> 00:02:44,910
比较，诶，明确呢

62
00:02:44,910 --> 00:02:50,120
这种情况下涉及将流程图转换为节点图

63
00:02:50,120 --> 00:02:53,740
流程图往节点图转换的时候

64
00:02:53,740 --> 00:02:58,470
那节点一、节点二、三、四比较明确吧

65
00:02:58,470 --> 00:03:03,440
但这后面的一些节点和线到底有多少

66
00:03:03,440 --> 00:03:07,180
唉，这是一根线还是两根线

67
00:03:07,180 --> 00:03:08,390
这是一根线

68
00:03:08,390 --> 00:03:09,690
又是两根线呢

69
00:03:09,690 --> 00:03:10,990
这种情况下

70
00:03:10,990 --> 00:03:13,620
很多同学容易产生歧义吧

71
00:03:13,620 --> 00:03:18,730
所以我们在这里将模糊不清的全部呢

72
00:03:18,730 --> 00:03:23,230
这种焦点全部把它呢，标出来啊

73
00:03:23,280 --> 00:03:25,140
标出来之后

74
00:03:25,140 --> 00:03:28,840
那这个线路就非常清晰了吧

75
00:03:28,840 --> 00:03:32,880
虽然我们看似增加了一些节点

76
00:03:32,880 --> 00:03:37,390
但同同时增加的还有有向弧的个数

77
00:03:37,390 --> 00:03:41,690
那这个增加的数量其实是等同的

78
00:03:41,690 --> 00:03:46,900
所以在减法公式当中是不影响结果的

79
00:03:46,900 --> 00:03:50,240
那我们把焦点标注清楚之后

80
00:03:50,240 --> 00:03:52,960
剩下的这种计算过程

81
00:03:52,960 --> 00:03:55,960
唉，只要把焦点标明确了

82
00:03:55,960 --> 00:03:59,960
大家在数数的时候就不会呢存在疑

83
00:03:59,960 --> 00:04:02,230
或者呢，二异性的地方了

84
00:04:02,230 --> 00:04:04,600
那这种计算呢，唉

85
00:04:04,600 --> 00:04:07,270
我们数一数边的个数

86
00:04:07,270 --> 00:04:08,180
那这里

87
00:04:08,180 --> 00:04:13,320
一、二、三、四、五、六、七、八、九、十、11、12、13、14、15

88
00:04:13,320 --> 00:04:14,730
15条边

89
00:04:14,730 --> 00:04:16,190
12个节点

90
00:04:16,190 --> 00:04:19,209
加上二就是等于呢五的

91
00:04:19,209 --> 00:04:21,899
这就是它的环路复杂度

92
00:04:21,899 --> 00:04:25,060
代入公式计算的结果

93
00:04:25,060 --> 00:04:29,070
那如果出现的是伪代码

94
00:04:29,070 --> 00:04:31,350
我们可能还需要多一步

95
00:04:31,350 --> 00:04:34,240
代码转程序流程图的过程吧

96
00:04:34,240 --> 00:04:38,040
最终呢，求取的是节点图的计算

97
00:04:38,040 --> 00:04:39,950
那我们在考试当中

98
00:04:39,950 --> 00:04:44,210
很多同学一进考场就很激动啊

99
00:04:44,210 --> 00:04:45,130
很紧张

100
00:04:45,130 --> 00:04:47,460
然后呢，公式不记得了

101
00:04:47,460 --> 00:04:50,440
到底是边检点还是点减边

102
00:04:50,440 --> 00:04:53,410
很容易呢，出现一些错误的理解

103
00:04:53,410 --> 00:04:54,800
我们在这里啊

104
00:04:54,800 --> 00:04:58,560
建议大家直接的画两个节点

105
00:04:59,230 --> 00:05:01,230
这种情况下

106
00:05:01,230 --> 00:05:08,170
边减点加二的结果应该是等于 A 1的

107
00:05:08,170 --> 00:05:13,170
而如果是点减去边加上二的话

108
00:05:13,170 --> 00:05:17,130
它的结果是等于三的

109
00:05:17,130 --> 00:05:21,090
我们说对于一个顺序执行过程来看

110
00:05:21,090 --> 00:05:23,820
环路复杂度应该是一吧

111
00:05:23,820 --> 00:05:26,990
所以大家记清楚加二

112
00:05:26,990 --> 00:05:29,250
然后边和点的位置

113
00:05:29,250 --> 00:05:33,060
可以临时画图来进行验证

114
00:05:33,060 --> 00:05:35,430
那这就是我们提到的

115
00:05:35,430 --> 00:05:38,480
环路复杂度的计算过程

116
00:05:38,480 --> 00:05:41,970
下面我们来看一下环路复杂度计算

117
00:05:41,970 --> 00:05:46,380
在我们软件设计师考试当中真题的体现

118
00:05:46,380 --> 00:05:49,080
下面这道题告诉我们呢

119
00:05:49,080 --> 00:05:51,960
采用环路复杂度 Mark CAB 度量法

120
00:05:51,960 --> 00:05:55,130
来计算下图程序的环路复杂度

121
00:05:55,130 --> 00:05:58,960
那这里给出的是明确的节点图吧

122
00:05:58,960 --> 00:06:01,160
所以大家数一

123
00:06:01,160 --> 00:06:06,240
一、二、三、四、五、六、七、八、九、十、11

124
00:06:06,240 --> 00:06:08,120
一共有11

125
00:06:08,120 --> 00:06:12,140
边减去十个节点加二

126
00:06:12,140 --> 00:06:15,630
总数应该是等于三的

127
00:06:15,630 --> 00:06:17,550
数圈的情况下

128
00:06:17,550 --> 00:06:21,950
唉，一、二加上整个程序自身的复杂度

129
00:06:21,950 --> 00:06:25,870
三，环路复杂度应该是等于三

130
00:06:25,870 --> 00:06:31,300
记住公式是边减去点加上二

131
00:06:31,960 --> 00:06:36,600
那这是呢对节点图它的求取过程

132
00:06:36,600 --> 00:06:39,010
下面我们呢再来看

133
00:06:39,010 --> 00:06:43,530
如果采用白盒测试方法来进行测试的话

134
00:06:43,530 --> 00:06:46,500
我们需要满足条件覆盖

135
00:06:46,500 --> 00:06:49,990
那我们至少需要多少个测试用例呢

136
00:06:49,990 --> 00:06:53,670
然后采用 Mark CAB 度量法来计

137
00:06:53,670 --> 00:06:56,580
程序的环路复杂性应该为多少

138
00:06:56,580 --> 00:07:00,370
那这里求的是两个结合考察吧

139
00:07:00,370 --> 00:07:02,910
一个是白盒测试的条件覆盖

140
00:07:02,910 --> 00:07:06,000
另一个呢是环路复杂度的计算

141
00:07:06,000 --> 00:07:09,500
并且给我们的是一个伪代码

142
00:07:09,500 --> 00:07:12,050
那这个伪代码当中呢

143
00:07:12,050 --> 00:07:14,650
我们从开始

144
00:07:15,640 --> 00:07:18,280
程序开始之后

145
00:07:18,280 --> 00:07:21,360
接下来 int max 

146
00:07:25,080 --> 00:07:31,090
然后判断如如果 I 大于 J 的话

147
00:07:31,090 --> 00:07:34,450
接下来哎满足要求的话

148
00:07:34,450 --> 00:07:38,100
我们接下来判断的是 I 大于 K 

149
00:07:38,100 --> 00:07:44,320
如果满足我们就能是返回 max 等于 I 

150
00:07:44,320 --> 00:07:48,440
否则的话返回 max 等于 K 

151
00:07:48,780 --> 00:07:52,820
前面 I 大于 J 的 else 

152
00:07:53,600 --> 00:07:55,700
如果不满足

153
00:07:55,700 --> 00:07:58,810
判断 J 是否大于 K 

154
00:07:58,810 --> 00:08:02,660
如果满足 max 等于 J 

155
00:08:02,660 --> 00:08:06,460
否则的话 max 等于 K 

156
00:08:08,320 --> 00:08:11,800
那这地方是不是得到了一个

157
00:08:11,800 --> 00:08:14,340
简单的程序流程图啊

158
00:08:14,340 --> 00:08:16,040
但是我们会发

159
00:08:16,040 --> 00:08:17,460
这个程序流程图

160
00:08:17,460 --> 00:08:19,280
看起来是开放性质的吧

161
00:08:19,280 --> 00:08:22,750
它没有一个唯一的这种呢出口

162
00:08:22,750 --> 00:08:25,830
我们在这里呢，会发现它很奇怪

163
00:08:25,830 --> 00:08:31,970
所以最终啊，它这里还缺少了一个解结束语句

164
00:08:32,650 --> 00:08:37,360
那把这个程序流程图画出来之后

165
00:08:37,360 --> 00:08:40,750
再来呢，判断它的白盒测

166
00:08:40,750 --> 00:08:44,290
以及呢环路复杂度的计算公式

167
00:08:44,290 --> 00:08:46,910
那这里其实没有交点吧

168
00:08:46,910 --> 00:08:48,730
交点就在这个位置

169
00:08:48,730 --> 00:08:51,370
所以我们呢，可以直接来

170
00:08:51,370 --> 00:08:54,030
节点的个数和边的个数

171
00:08:54,030 --> 00:08:58,760
那我们首先看到白盒测试当中条件覆盖

172
00:08:58,760 --> 00:09:02,650
那这里每一个判定都是单条件的

173
00:09:02,650 --> 00:09:05,850
所以条件覆盖和判定覆盖的结果

174
00:09:05,850 --> 00:09:07,730
是一模一样的

175
00:09:07,730 --> 00:09:12,320
那我们在这里设计测试用例结果的时候

176
00:09:12,320 --> 00:09:15,000
应该是输入 IJ 、 K 

177
00:09:15,000 --> 00:09:18,310
然后呢返回一个 max 值

178
00:09:18,310 --> 00:09:21,260
那我们在做测试的时候

179
00:09:21,260 --> 00:09:24,510
要想满足 I 大于 J 的话

180
00:09:24,510 --> 00:09:28,000
唉，我们可以设定 I 是等于一的

181
00:09:28,000 --> 00:09:29,820
J 是等于零的

182
00:09:29,820 --> 00:09:33,480
那就 I 大于 J 满足第一个 Y 分之

183
00:09:33,480 --> 00:09:35,810
那接下来再看呢

184
00:09:35,810 --> 00:09:38,250
I 还要大于 K 

185
00:09:38,250 --> 00:09:40,620
那这种情况下就是呢

186
00:09:40,620 --> 00:09:43,340
一返回的是一

187
00:09:43,340 --> 00:09:46,880
走的是这一条分支吧

188
00:09:46,890 --> 00:09:50,570
这种情况下满足的判

189
00:09:50,570 --> 00:09:53,030
如果写一、二、三，哎

190
00:09:53,030 --> 00:09:56,090
三个判定结果是 Y 

191
00:09:56,090 --> 00:09:58,870
Y 以及呢，不需要

192
00:09:59,020 --> 00:10:01,420
这是第一个测试用例

193
00:10:01,420 --> 00:10:05,180
那我们接下来还想要一个测试用例

194
00:10:05,180 --> 00:10:08,290
返回 max 等于 K ，哎

195
00:10:08,290 --> 00:10:10,530
同样一大于零

196
00:10:10,530 --> 00:10:13,090
满足相应条件之后

197
00:10:13,090 --> 00:10:15,600
一有没有大于 K 呢

198
00:10:15,600 --> 00:10:16,640
没有

199
00:10:16,640 --> 00:10:20,030
那这种情况下 K 等于二

200
00:10:20,030 --> 00:10:22,410
我们会返回 K 的值

201
00:10:22,410 --> 00:10:24,090
我们这里返回 I 吧

202
00:10:24,090 --> 00:10:25,140
返回 K 

203
00:10:25,140 --> 00:10:27,680
这样来看会比较明确一些

204
00:10:27,680 --> 00:10:31,780
那两个测试当中它的条件

205
00:10:31,780 --> 00:10:33,280
两个判定当中

206
00:10:33,280 --> 00:10:37,980
这两个条件的结果分别是 Y 和 NO 

207
00:10:37,980 --> 00:10:39,690
以及呢，不需要

208
00:10:39,690 --> 00:10:43,860
那这是我们左侧这半边的走法吧

209
00:10:43,860 --> 00:10:45,900
再来看右侧

210
00:10:45,900 --> 00:10:49,080
I 大于 J 不满足的情况下

211
00:10:49,080 --> 00:10:52,000
那我们可以写零一

212
00:10:52,160 --> 00:10:56,280
同时 J 大于 K 满足了

213
00:10:56,280 --> 00:10:58,620
那我们 K 如果是一

214
00:10:58,620 --> 00:11:00,340
返回的就是 J 

215
00:11:00,340 --> 00:11:04,320
那这种情况下走的就是 NO 和 Y 

216
00:11:04,320 --> 00:11:07,040
第一个判定是 NO 

217
00:11:07,040 --> 00:11:10,110
第二个判定不需要

218
00:11:10,110 --> 00:11:13,440
第三个判定是 Y 分之

219
00:11:13,440 --> 00:11:17,310
接下来再找第四个，哎，零和一

220
00:11:17,310 --> 00:11:19,240
我们要求第二

221
00:11:19,240 --> 00:11:22,730
第三个判定结果是 low 分支的情况下

222
00:11:22,730 --> 00:11:25,180
应该是 K 最大吧

223
00:11:25,180 --> 00:11:29,100
所以，唉，这里写二返回一个 K 值

224
00:11:29,100 --> 00:11:33,140
那这个测试用例它所满足的条件

225
00:11:33,140 --> 00:11:34,960
一是 low 分之

226
00:11:34,960 --> 00:11:39,430
条件二没有走条件三是 NO 分之

227
00:11:39,430 --> 00:11:45,340
每一个条件它的真假值全部覆盖了一下吧

228
00:11:45,340 --> 00:11:49,560
这种情况所满足的就是条件覆盖

229
00:11:49,560 --> 00:11:52,220
一共有四个测试用例

230
00:11:52,220 --> 00:11:55,050
那为什么四个测试用例就可以满

231
00:11:55,050 --> 00:11:57,380
三个条件的真假值啊

232
00:11:57,380 --> 00:12:02,980
因为第一个条件影响了二、三条件的选择

233
00:12:02,980 --> 00:12:07,920
所以最终我们判定的其实是二、三的覆盖吧

234
00:12:07,920 --> 00:12:09,630
所以这种情况下

235
00:12:09,630 --> 00:12:13,010
它的白盒测试条件

236
00:12:13,010 --> 00:12:16,290
分支条件覆盖所需要的测试用

237
00:12:16,290 --> 00:12:18,000
个数呢是四个

238
00:12:18,000 --> 00:12:20,600
那它的环路复杂度的话

239
00:12:20,600 --> 00:12:25,010
我们数一数节点和边的个数当

240
00:12:25,010 --> 00:12:31,660
边有一、二、三、四、五、六、七、八、九、十、11、12

241
00:12:32,380 --> 00:12:33,980
节点的个数

242
00:12:33,980 --> 00:12:39,860
一、二、三、四、五、六、七、八、九、10+2

243
00:12:39,860 --> 00:12:42,280
结果就是等于四的

244
00:12:42,280 --> 00:12:46,480
所以这里环路复杂度也是呢，等于四的

245
00:12:46,480 --> 00:12:49,000
那我们这里写起来比较混乱吧

246
00:12:49,000 --> 00:12:50,550
后面给大家呢

247
00:12:50,550 --> 00:12:54,040
画出来一个比较明确的程序流程图

248
00:12:54,040 --> 00:12:57,060
那这里所涉及的就是呢

249
00:12:57,060 --> 00:12:59,960
前面伪代码的程序流程图

250
00:12:59,960 --> 00:13:03,390
以及转换之后的节点图

251
00:13:03,390 --> 00:13:08,640
那我们会发现节点图省略了一个节点

252
00:13:08,640 --> 00:13:12,020
省略了开始节点以及一个箭头

253
00:13:12,020 --> 00:13:16,460
这种省略节点的个数和边的个数

254
00:13:16,460 --> 00:13:18,040
省略是一致的

255
00:13:18,040 --> 00:13:21,750
所以不影响最后的计算结果

256
00:13:21,750 --> 00:13:25,520
那如果大家平常在分析题目的时候

257
00:13:25,520 --> 00:13:28,560
不确定到底要不要省略的话

258
00:13:28,560 --> 00:13:30,420
那直接把它写全

259
00:13:30,420 --> 00:13:33,730
就不要呢想着省略的问题了

260
00:13:33,730 --> 00:13:34,730
那这是呢

261
00:13:34,730 --> 00:13:36,630
关于环路复杂度

262
00:13:36,630 --> 00:13:38,030
它的考察

263
00:13:38,030 --> 00:13:41,360
要求大家掌握相应的计算题型

264
00:13:41,360 --> 00:13:44,040
以及呢，它的转换过

265
00:13:44,040 --> 00:13:47,130
也要呢，能够自己去进行转换

266
00:13:47,130 --> 00:13:50,830
那这是呢，关于我们软件测试啊

267
00:13:50,830 --> 00:13:53,710
当中环路复杂度的一个呢，知识内容
