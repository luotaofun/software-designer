1
00:00:00,000 --> 00:00:01,540
下面我们看到呢

2
00:00:01,540 --> 00:00:04,950
敏捷开发它对应的开发模型

3
00:00:04,950 --> 00:00:07,030
那敏捷方法的话

4
00:00:07,030 --> 00:00:08,350
它也是呢

5
00:00:08,350 --> 00:00:11,550
在某些教程当中属于开发模型，模

6
00:00:11,550 --> 00:00:14,120
某些教程当中呢，属于开发方法

7
00:00:14,120 --> 00:00:17,320
但是在我们的软设这个科目当中呢

8
00:00:17,320 --> 00:00:19,950
是把它归于开发模型当中的

9
00:00:19,950 --> 00:00:22,160
近几年的考察情况来看呢

10
00:00:22,160 --> 00:00:25,000
敏捷开发出现的也是呢，比较多了

11
00:00:25,000 --> 00:00:27,440
因为它最近几年来看啊

12
00:00:27,440 --> 00:00:30,140
在我们的，呃，软件开发行业呢

13
00:00:30,140 --> 00:00:32,720
应用的也是呢，越来越多

14
00:00:32,720 --> 00:00:35,020
那所谓的敏捷啊

15
00:00:35,020 --> 00:00:38,650
它具有一些呢，小步快跑的思想

16
00:00:38,650 --> 00:00:41,580
适合于小项目、小团队

17
00:00:41,580 --> 00:00:43,370
他强调，通过呢

18
00:00:43,370 --> 00:00:46,790
尽可能早的给我们的用户呢

19
00:00:46,790 --> 00:00:50,020
提交持续的、有价值的软件

20
00:00:50,020 --> 00:00:52,720
从而呢，让业用户觉得满意

21
00:00:52,720 --> 00:00:56,310
那它的基本原则给大家呢，列了一些

22
00:00:56,310 --> 00:00:58,860
包括像短平快的会议

23
00:00:58,860 --> 00:01:00,080
可以理解为呢

24
00:01:00,080 --> 00:01:01,500
站立会议

25
00:01:01,500 --> 00:01:03,750
想一想让大家都站着开会

26
00:01:03,750 --> 00:01:06,710
那你的发言是不是会尽可能的简短啊

27
00:01:06,710 --> 00:01:07,630
那想一想

28
00:01:07,630 --> 00:01:08,940
如果是100个人

29
00:01:08,940 --> 00:01:11,020
其实这个就实现不了了

30
00:01:11,020 --> 00:01:13,790
所以它适合于小项目、小团队

31
00:01:13,790 --> 00:01:15,130
那我们基本上呢

32
00:01:15,130 --> 00:01:16,330
每天会开一次会

33
00:01:16,330 --> 00:01:18,200
大家站着汇报一下工作

34
00:01:18,200 --> 00:01:18,860
大概呢

35
00:01:18,860 --> 00:01:22,160
每个人控制在12分钟左右就差不多了

36
00:01:22,160 --> 00:01:23,920
那这种情况下

37
00:01:23,920 --> 00:01:25,780
会议的效率会特别高

38
00:01:25,780 --> 00:01:29,120
从而呢，避免一些无效的、冗余的会议

39
00:01:29,120 --> 00:01:31,430
其次，小型版本发布

40
00:01:31,430 --> 00:01:32,970
它所强调的

41
00:01:32,970 --> 00:01:35,210
尽可能早地给用户呢，提

42
00:01:35,210 --> 00:01:38,090
可交付版本较少的文档呢

43
00:01:38,090 --> 00:01:41,730
是只保留最需要的这部分文档

44
00:01:41,730 --> 00:01:45,150
其他呢，可以减少的尽可能减少

45
00:01:45,150 --> 00:01:48,690
那这里呢，可以节约一些呢，工作的时间

46
00:01:48,690 --> 00:01:50,100
合作为重

47
00:01:50,100 --> 00:01:52,680
包括呢，团队内部应该呢

48
00:01:52,680 --> 00:01:55,590
相互尊重、相互沟通、相互合作

49
00:01:55,590 --> 00:01:59,730
那我们与用户之间呢，也要相互合作

50
00:01:59,730 --> 00:02:03,210
那客户会直接参与

51
00:02:03,210 --> 00:02:04,320
那我们啊

52
00:02:04,320 --> 00:02:06,360
谁用这个系统，谁呢

53
00:02:06,360 --> 00:02:08,750
就配合项目开发的工作

54
00:02:08,750 --> 00:02:10,370
那一旦有改变

55
00:02:10,370 --> 00:02:13,280
立马双方就可以沟通达成一致吧

56
00:02:13,280 --> 00:02:14,960
像有一些开发过程

57
00:02:14,960 --> 00:02:16,380
给甲方提个需求

58
00:02:16,380 --> 00:02:17,560
你提了诶

59
00:02:17,560 --> 00:02:19,880
等个两三天才达到一个

60
00:02:19,880 --> 00:02:21,300
才得到一个回复

61
00:02:21,300 --> 00:02:22,290
到底改不改

62
00:02:22,290 --> 00:02:23,420
那改成什么样

63
00:02:23,420 --> 00:02:24,360
又是三天

64
00:02:24,360 --> 00:02:26,130
那整个项目就会呢

65
00:02:26,130 --> 00:02:28,200
呃，经常性的延期

66
00:02:28,200 --> 00:02:32,020
那这个过程其实是让人很难受的一个过程了

67
00:02:32,020 --> 00:02:33,210
自动化测试

68
00:02:33,210 --> 00:02:35,210
它是将测试的工作呢

69
00:02:35,210 --> 00:02:36,930
诶，交给自动化测试

70
00:02:36,930 --> 00:02:39,440
那它可以提高测试的效率

71
00:02:39,440 --> 00:02:41,300
适应性计划调整

72
00:02:41,300 --> 00:02:44,480
它是一个强调变化的这种呢模型

73
00:02:44,480 --> 00:02:47,040
我们在前面所想到的都是呢

74
00:02:47,040 --> 00:02:49,380
很担心做需求变更的

75
00:02:49,380 --> 00:02:51,930
而对于敏捷方法来说呢

76
00:02:51,930 --> 00:02:54,310
它会做适应性的一些计划调整

77
00:02:54,310 --> 00:02:55,630
一旦有变化

78
00:02:55,630 --> 00:02:59,190
就立马呢，做出相应的调整计划

79
00:02:59,790 --> 00:03:02,710
结对编程它比较有意思

80
00:03:02,710 --> 00:03:07,370
它是呢，让至少两个人作为呢，一对进行编程

81
00:03:07,370 --> 00:03:08,760
一个人写的时候

82
00:03:08,760 --> 00:03:10,440
另一个人去看

83
00:03:10,440 --> 00:03:12,240
那相当于这段代码

84
00:03:12,240 --> 00:03:14,180
它会包含两个人的思想吧

85
00:03:14,180 --> 00:03:17,910
大家呢，这两个人都很熟悉这个代码的思路

86
00:03:17,910 --> 00:03:19,590
那大家可以想一想

87
00:03:19,590 --> 00:03:20,930
一般别人写代码

88
00:03:20,930 --> 00:03:22,350
我们在旁边看，诶

89
00:03:22,350 --> 00:03:23,850
如果是自己熟悉的

90
00:03:23,850 --> 00:03:25,940
是不是很容易就发现问题了

91
00:03:25,940 --> 00:03:27,340
所以这个过程啊

92
00:03:27,340 --> 00:03:29,340
可以快速地发现了一些

93
00:03:29,340 --> 00:03:31,560
能够尽早发现的问题

94
00:03:31,560 --> 00:03:34,500
并且它其实还有一个维度

95
00:03:34,500 --> 00:03:36,720
是为了防止人员流失

96
00:03:36,720 --> 00:03:40,710
我们在做谈团队沟通的时候啊

97
00:03:40,710 --> 00:03:45,650
一般新来的人员是很很慢的进行磨合

98
00:03:45,650 --> 00:03:48,880
所以我们一旦有人员流失的话

99
00:03:48,880 --> 00:03:50,680
如果是结对编程

100
00:03:50,680 --> 00:03:52,860
我们至少还会保留一个

101
00:03:52,860 --> 00:03:55,500
对这一段代码非常熟悉的人

102
00:03:55,500 --> 00:03:58,240
从而呢，避免重新交接

103
00:03:58,240 --> 00:04:00,020
磨合的这个过程

104
00:04:00,020 --> 00:04:01,920
那这是呢，结对编程

105
00:04:01,920 --> 00:04:04,440
其次，测试驱动开发

106
00:04:04,440 --> 00:04:07,000
我们会先写测试代码

107
00:04:07,000 --> 00:04:11,880
然后呢，根据测试的一些设计来做开发工作

108
00:04:11,880 --> 00:04:13,490
持续集

109
00:04:13,490 --> 00:04:17,390
它是呢，做，呃，小版本的一些呢，修改

110
00:04:17,390 --> 00:04:21,010
可以按日甚至按小时的去发布

111
00:04:21,010 --> 00:04:21,959
新版本

112
00:04:21,959 --> 00:04:23,090
重构的话

113
00:04:23,090 --> 00:04:25,210
它所涉及到的是一个

114
00:04:25,210 --> 00:04:27,130
呃，比较全局的思想

115
00:04:27,130 --> 00:04:29,310
它可以对我们的设计工作

116
00:04:29,310 --> 00:04:31,990
代码的程序开发工作呢

117
00:04:31,990 --> 00:04:34,220
做一个重新的思考和

118
00:04:34,220 --> 00:04:36,270
诶，重新的构造过程

119
00:04:36,270 --> 00:04:37,860
就叫做呢重构

120
00:04:37,860 --> 00:04:40,920
那这是呢，敏捷方法的一些基本原则

121
00:04:40,920 --> 00:04:41,900
大家听一听

122
00:04:41,900 --> 00:04:43,460
熟悉一下

123
00:04:43,620 --> 00:04:45,620
在考试当中呢

124
00:04:45,620 --> 00:04:49,080
我们一般会涉及到具体的敏捷开发

125
00:04:49,080 --> 00:04:51,220
那具体的敏捷开发呢

126
00:04:51,220 --> 00:04:52,840
涉及到一些模型

127
00:04:52,840 --> 00:04:57,480
常考的，我们软设当中常考的是极限编程

128
00:04:57,480 --> 00:05:00,630
极限编程简称 XP 

129
00:05:00,630 --> 00:05:02,770
不是我们的 XP 系统了

130
00:05:02,770 --> 00:05:05,860
极限编程它的主要思想呢

131
00:05:05,860 --> 00:05:07,360
在于四大价值观

132
00:05:07,360 --> 00:05:10,540
五大原则和12大最佳实践

133
00:05:10,540 --> 00:05:12,350
那简单来看

134
00:05:12,350 --> 00:05:14,750
它肯定是符合我们前面讲到的

135
00:05:14,750 --> 00:05:16,450
一些基本原则的

136
00:05:16,450 --> 00:05:18,330
那对于四大价值观

137
00:05:18,330 --> 00:05:20,570
它会强调沟通

138
00:05:20,570 --> 00:05:23,050
内部沟通和外部沟通

139
00:05:23,050 --> 00:05:27,340
强调尽可能简单的去做一些呢设计工作

140
00:05:27,340 --> 00:05:30,610
然后呢强调有问题积极反馈

141
00:05:30,610 --> 00:05:34,160
它其实也是与沟通有一方面的关联

142
00:05:34,160 --> 00:05:36,850
然后勇于面对变化

143
00:05:36,850 --> 00:05:38,750
有变化的勇气

144
00:05:38,750 --> 00:05:45,160
五大原则强调快速进行反馈

145
00:05:45,160 --> 00:05:46,760
做简单的假设

146
00:05:46,760 --> 00:05:48,040
逐步进行修改

147
00:05:48,040 --> 00:05:51,400
提倡更改以及呢优质工作

148
00:05:51,400 --> 00:05:53,020
那他们这一些啊

149
00:05:53,020 --> 00:05:55,240
四大价值观、五大原则

150
00:05:55,240 --> 00:05:59,380
最终呢会体现在12大最佳实践当中

151
00:05:59,380 --> 00:06:02,600
那这些呢，我们首先给大家提一个

152
00:06:02,600 --> 00:06:06,080
是很多开发人员都想要的是什

153
00:06:06,080 --> 00:06:07,780
优质工作

154
00:06:08,390 --> 00:06:12,190
为了保证工作的质量和效率

155
00:06:12,190 --> 00:06:15,140
建议每周工作40小时

156
00:06:15,140 --> 00:06:17,650
也就是说5×8不要加班

157
00:06:17,650 --> 00:06:21,410
因为加班的话，它的效率其实是不可避免的

158
00:06:21,410 --> 00:06:24,090
呃，效率会有所呢降低

159
00:06:24,090 --> 00:06:26,800
所以虽然我们现在很多说996

160
00:06:26,800 --> 00:06:28,620
但其实像敏捷的话

161
00:06:28,620 --> 00:06:29,740
他就强调呢

162
00:06:29,740 --> 00:06:32,740
每周工作40小时就可以了

163
00:06:32,740 --> 00:06:35,290
然后呢，对于沟通的话

164
00:06:35,290 --> 00:06:37,650
我们团队内部，诶

165
00:06:37,650 --> 00:06:38,880
强调沟

166
00:06:38,880 --> 00:06:39,860
尽可能的

167
00:06:39,860 --> 00:06:41,500
诶，我们做结对编程

168
00:06:41,500 --> 00:06:43,480
那我们在前面介绍过了

169
00:06:43,480 --> 00:06:46,510
让至少两个人作为一组方便呢

170
00:06:46,510 --> 00:06:49,180
唉，我们两个人对代码都很熟悉

171
00:06:49,180 --> 00:06:50,260
一个写一个看

172
00:06:50,260 --> 00:06:51,860
尽快发现问题

173
00:06:51,860 --> 00:06:55,520
并且可以呢，避免人员流失导致的磨合

174
00:06:55,520 --> 00:06:56,750
熟悉过程

175
00:06:56,750 --> 00:07:00,950
然后呢，唉，强调团队外部的沟

176
00:07:00,950 --> 00:07:02,810
现场客户

177
00:07:03,280 --> 00:07:07,620
让系统最终啊，这个使用的用户代表呢

178
00:07:07,620 --> 00:07:11,220
哎，全程配合我们的开发团队

179
00:07:11,220 --> 00:07:15,260
那这个过程当中有问题就积极反馈了

180
00:07:15,260 --> 00:07:18,320
这是我们呢，之前提到的结对编程

181
00:07:18,320 --> 00:07:20,160
还有现场客户

182
00:07:20,160 --> 00:07:22,750
那其他的看一下呢

183
00:07:22,750 --> 00:07:25,480
诶，我们强调计划游戏

184
00:07:25,480 --> 00:07:28,250
那这个计划游戏其实就是呢

185
00:07:28,250 --> 00:07:30,130
快速的去制定计划

186
00:07:30,130 --> 00:07:32,370
应对呢，我们的变化

187
00:07:32,370 --> 00:07:34,930
有应对变化的勇气

188
00:07:34,930 --> 00:07:37,590
然后提倡更改

189
00:07:37,590 --> 00:07:41,700
小型发布指的是呢，我们的系统啊

190
00:07:41,700 --> 00:07:44,140
设计之后要尽可能的，唉

191
00:07:44,140 --> 00:07:47,660
要能够尽可能早的去交付给用户

192
00:07:47,660 --> 00:07:50,820
隐喻是沟通的一种方式

193
00:07:50,820 --> 00:07:54,700
要找到合适的比喻来传达信息

194
00:07:54,700 --> 00:07:58,650
让沟通的双方尽量相互理解

195
00:07:58,650 --> 00:08:00,660
设计简单，诶

196
00:08:00,660 --> 00:08:03,020
简单设计的这个思想就是呢

197
00:08:03,020 --> 00:08:05,240
只处理当前需求

198
00:08:05,240 --> 00:08:08,460
使我们的设计保持简单

199
00:08:08,460 --> 00:08:13,370
测试先行与测试驱动开发其实很相似

200
00:08:13,370 --> 00:08:15,290
先写测试代码

201
00:08:15,290 --> 00:08:19,220
然后呢，再编写我们的具体程序

202
00:08:19,220 --> 00:08:21,870
还有持续集成

203
00:08:21,870 --> 00:08:24,290
按日甚至按小时

204
00:08:24,290 --> 00:08:27,470
来给客户提供可运行的版本

205
00:08:27,470 --> 00:08:30,470
这两种说法与我们啊

206
00:08:30,470 --> 00:08:32,650
结构化开发的一些思想

207
00:08:32,650 --> 00:08:34,960
还有面向对象的一些思想呢

208
00:08:34,960 --> 00:08:37,230
可能会存在一些呢

209
00:08:37,230 --> 00:08:38,850
理解的偏差

210
00:08:38,850 --> 00:08:41,559
所以在这里呢，给大家标注了一下

211
00:08:41,559 --> 00:08:43,200
那这是敏捷呢

212
00:08:43,200 --> 00:08:46,300
它所包含的一些最佳时间

213
00:08:46,660 --> 00:08:47,940
除此以外

214
00:08:47,940 --> 00:08:53,140
重构、重新审视需求以及设计

215
00:08:53,140 --> 00:08:55,800
重新明确地去描述他们

216
00:08:55,800 --> 00:08:58,220
以符合新的这样的一些呢

217
00:08:58,220 --> 00:09:00,090
或者现有的这些需求

218
00:09:00,090 --> 00:09:04,200
其实就是从思想上把我们的程序呢，推倒重来

219
00:09:04,200 --> 00:09:06,120
有这样的一个过程

220
00:09:06,120 --> 00:09:07,490
集体代码

221
00:09:07,490 --> 00:09:11,010
所有制就意味着这个代码大家都可以看到

222
00:09:11,010 --> 00:09:13,390
都可以呢去做一些修改

223
00:09:13,390 --> 00:09:18,530
强调团队合作、团队开发编码标准

224
00:09:18,530 --> 00:09:23,110
按照一定的标准、结构标准呢来做开发

225
00:09:23,110 --> 00:09:26,680
那这个过程如果有统一的制式

226
00:09:26,680 --> 00:09:29,140
那我们在做开发的过程当中

227
00:09:29,140 --> 00:09:31,500
大家遵循统一的原则

228
00:09:31,500 --> 00:09:34,770
在后期做沟通、阅读代码

229
00:09:34,770 --> 00:09:38,140
然后测试、维护的工作的情况下

230
00:09:38,140 --> 00:09:39,920
其实大家都可以呢

231
00:09:39,920 --> 00:09:43,360
减少很多不必要的沟通工作了

232
00:09:43,360 --> 00:09:48,020
所以有编码标准其实是一件比较好的事情

233
00:09:48,020 --> 00:09:51,330
那这是极限编程给大家提到的

234
00:09:51,330 --> 00:09:53,480
12大最佳实践

235
00:09:53,480 --> 00:09:56,680
可以结合这些12大最佳实践

236
00:09:56,680 --> 00:09:58,900
然后四大价值观、五大原则

237
00:09:58,900 --> 00:10:01,630
大家呢，结合起来去使用

238
00:10:01,630 --> 00:10:05,650
我们在考试当中会不会让大家去默写呀

239
00:10:05,650 --> 00:10:06,830
不可能

240
00:10:06,830 --> 00:10:10,960
它的考察形式其实还是选择题的形式

241
00:10:10,960 --> 00:10:13,340
比如说给大家一个呢

242
00:10:13,340 --> 00:10:16,940
相应的原则或者价值观或者实践的描述

243
00:10:16,940 --> 00:10:19,760
问大家到底是对的还是错的

244
00:10:19,760 --> 00:10:24,360
那这些思想其实最终都是在小步快跑的

245
00:10:24,360 --> 00:10:26,210
敏捷思想范围内吧

246
00:10:26,210 --> 00:10:29,100
所以呢，了解一些特殊的地方

247
00:10:29,100 --> 00:10:31,060
了解了它的统一思想

248
00:10:31,060 --> 00:10:34,190
能够去区分判定就可以了

249
00:10:34,190 --> 00:10:36,320
那这是极限编程

250
00:10:36,320 --> 00:10:39,100
还有没有其他的敏捷方法呢

251
00:10:39,100 --> 00:10:41,060
其实比较多

252
00:10:41,060 --> 00:10:44,900
我们大致呢，给大家列了一

253
00:10:44,900 --> 00:10:47,790
关于敏捷开发的方法

254
00:10:47,790 --> 00:10:51,820
那目前在我们软件设计师考试当中呢

255
00:10:51,820 --> 00:10:55,010
考察较多的是这两种

256
00:10:55,010 --> 00:10:58,370
极限编程和并列征求法

257
00:10:58,370 --> 00:11:02,120
极限编程我们刚刚已经解释了四大价值观

258
00:11:02,120 --> 00:11:05,090
五大原则和12大最佳实践

259
00:11:05,090 --> 00:11:07,000
并列征求法

260
00:11:07,000 --> 00:11:08,540
它的特点呢

261
00:11:08,540 --> 00:11:12,430
其实类似于一个橄榄球的运动会

262
00:11:12,430 --> 00:11:14,460
那橄榄球队的话

263
00:11:14,460 --> 00:11:18,780
我们呢，会把球队也分成了不同的组

264
00:11:18,780 --> 00:11:21,980
来并行追逐某一个球吧

265
00:11:21,980 --> 00:11:25,530
那我们所谓的并列征求法

266
00:11:25,530 --> 00:11:30,320
它也是呢，划分成多个自组织自制的小

267
00:11:30,320 --> 00:11:33,980
来并行的递增实现产品

268
00:11:33,980 --> 00:11:37,370
那我们在实现的过程当中

269
00:11:37,370 --> 00:11:38,970
诶，既然分组了

270
00:11:38,970 --> 00:11:40,900
说明任务会变小啦

271
00:11:40,900 --> 00:11:45,470
我们会呢，按需求的优先级来排

272
00:11:45,470 --> 00:11:47,480
我们实现的顺序

273
00:11:47,480 --> 00:11:51,860
然后每30天一次称为一个呢迭代

274
00:11:51,860 --> 00:11:53,750
称为一次呢冲刺

275
00:11:53,750 --> 00:11:55,490
那我们这个仍然呢

276
00:11:55,490 --> 00:11:58,670
会有一些短平快的日常会议

277
00:11:58,670 --> 00:12:01,520
来进行沟通和协调

278
00:12:01,520 --> 00:12:05,200
从而呢，达到并行开发的过程

279
00:12:05,200 --> 00:12:08,630
那这是呢，并列征求法的特点

280
00:12:08,630 --> 00:12:10,990
强调分组并行

281
00:12:10,990 --> 00:12:17,340
然后呢，30天一轮冲刺来进行实现的过程

282
00:12:17,340 --> 00:12:18,660
除此以外呢

283
00:12:18,660 --> 00:12:20,960
像水晶方法的话

284
00:12:20,960 --> 00:12:22,930
水晶方法有一个系列

285
00:12:22,930 --> 00:12:25,370
那他强调的是以人为本

286
00:12:25,370 --> 00:12:30,060
认为呢，人对软件质量有很重要的影响

287
00:12:30,060 --> 00:12:31,060
因此，诶

288
00:12:31,060 --> 00:12:35,380
我们要随着项目质量和开发人员的素质提高

289
00:12:35,380 --> 00:12:37,380
来提高我们相应的东西

290
00:12:37,380 --> 00:12:40,900
所以要强强调我们开发人员的素质

291
00:12:40,900 --> 00:12:43,120
那我们可以呢，更好的交流

292
00:12:43,120 --> 00:12:45,740
经常性的去进行交付

293
00:12:45,740 --> 00:12:48,780
那每一个项目都有一同一套

294
00:12:48,780 --> 00:12:53,380
不同的这种应对策略约定或者方法论

295
00:12:53,380 --> 00:12:55,060
因为人不一样了

296
00:12:55,060 --> 00:12:57,920
那我们这个方法论就会做修改

297
00:12:58,230 --> 00:13:01,470
这是水晶系列的方法

298
00:13:01,690 --> 00:13:03,870
功能驱动开发

299
00:13:03,870 --> 00:13:06,910
强调把我们的程序员分为

300
00:13:06,910 --> 00:13:09,920
首席程序员和类程序员

301
00:13:09,920 --> 00:13:12,050
那首席程序员

302
00:13:12,050 --> 00:13:15,830
像现在的一些项目经理或者呢架构师

303
00:13:15,830 --> 00:13:18,350
可以呢担任这样的一些角色

304
00:13:18,350 --> 00:13:21,190
因为我们其实在行业的

305
00:13:21,190 --> 00:13:23,410
当前的行业情况来看

306
00:13:23,410 --> 00:13:25,870
如果项目经理不会技术的话

307
00:13:25,870 --> 00:13:28,010
他的可接受程度会非常低

308
00:13:28,010 --> 00:13:31,100
也会呢，要求项目经理会开发啊

309
00:13:31,100 --> 00:13:33,730
那首席程序员他不敲代码

310
00:13:33,730 --> 00:13:36,150
他主要呢做一些指挥性的工作

311
00:13:36,150 --> 00:13:39,310
而类程序员才是真正的码农

312
00:13:39,310 --> 00:13:41,770
敲代码的是类程序员

313
00:13:41,770 --> 00:13:46,160
这是呢，功能驱动开发开放式源码的特点

314
00:13:46,160 --> 00:13:47,460
简称开源

315
00:13:47,460 --> 00:13:48,910
大家就很熟悉了

316
00:13:48,910 --> 00:13:51,010
它适合程序开发人员

317
00:13:51,010 --> 00:13:52,950
在地域上分布很广

318
00:13:52,950 --> 00:13:54,190
但可以呢

319
00:13:54,190 --> 00:13:57,870
诶，在线开源代码来进行开发

320
00:13:57,870 --> 00:14:00,690
最后呢，还有一个自适应开发

321
00:14:00,690 --> 00:14:01,990
它强调呢

322
00:14:01,990 --> 00:14:05,480
核心是三个非线性重叠的开发过程

323
00:14:05,480 --> 00:14:07,510
那这里强调猜

324
00:14:07,510 --> 00:14:11,060
强调猜测、合作以及学习

325
00:14:11,060 --> 00:14:13,960
它还有六个基本原则

326
00:14:13,960 --> 00:14:16,540
大家可以自己呢，再来看一看

327
00:14:16,540 --> 00:14:20,550
目前自适应开发在软件设计师考试当中

328
00:14:20,550 --> 00:14:21,840
还没有出现

329
00:14:21,840 --> 00:14:25,820
稍微呢，了解一下其他的敏捷开发方法

330
00:14:25,820 --> 00:14:29,870
那这是呢，我们提到的敏捷开发

331
00:14:29,870 --> 00:14:33,150
下面我们来看一下这一类敏捷开发

332
00:14:33,150 --> 00:14:37,030
在软件设计师考试真题当中的体现

333
00:14:37,440 --> 00:14:40,680
在敏捷过程的开发方法当中

334
00:14:40,680 --> 00:14:43,860
以下哪一个实现了迭代的方法

335
00:14:43,860 --> 00:14:47,280
其中每30天的迭代称为冲刺

336
00:14:47,280 --> 00:14:50,490
然后根据优先级来实现产品

337
00:14:50,490 --> 00:14:54,110
多个自制和自自组织和自制的小组

338
00:14:54,110 --> 00:14:57,590
可以并行递增的实现产品

339
00:14:57,590 --> 00:14:59,970
这个其实是并列征求法

340
00:14:59,970 --> 00:15:03,600
类似于我们打橄榄球的过程

341
00:15:03,600 --> 00:15:07,350
极限编程有四大价值观、五大原则

342
00:15:07,350 --> 00:15:09,140
12大最佳实践

343
00:15:09,140 --> 00:15:12,140
水晶系列方法强调以人为本

344
00:15:12,140 --> 00:15:13,120
自适应

345
00:15:13,120 --> 00:15:15,610
自适应软件开发的话

346
00:15:15,610 --> 00:15:19,130
唉，他强调我们的猜测、合作以及学习

347
00:15:19,130 --> 00:15:24,330
那这是呢，唉关于及关于啊我们的并列征求

348
00:15:24,330 --> 00:15:25,480
它的考察

349
00:15:25,480 --> 00:15:29,490
下面这道题呢是关于极限编程的考察

350
00:15:29,490 --> 00:15:34,070
以下关于极限编程 SP 的最佳时间

351
00:15:34,070 --> 00:15:36,980
12大最佳实践叙述当

352
00:15:36,980 --> 00:15:38,520
不正确的是谁

353
00:15:38,520 --> 00:15:40,520
注意找错误选项

354
00:15:40,520 --> 00:15:43,980
A 选项只处理当前需求

355
00:15:43,980 --> 00:15:46,530
使设计保持简单

356
00:15:46,530 --> 00:15:50,620
这是简单设计的描述

357
00:15:51,220 --> 00:15:53,900
所以它是正确的

358
00:15:54,520 --> 00:15:56,200
第二个选项

359
00:15:56,200 --> 00:16:00,400
B 选项编写程序之后再编写测试代码

360
00:16:00,400 --> 00:16:03,520
这里呢，说法是错误的

361
00:16:04,070 --> 00:16:08,150
我们说的是测试先行

362
00:16:10,660 --> 00:16:14,300
所以应该先写测试代码

363
00:16:14,300 --> 00:16:15,360
再写呢

364
00:16:15,360 --> 00:16:19,960
程序 C 选项可以按日甚至按小时

365
00:16:19,960 --> 00:16:23,570
为客户提交可运行的版本

366
00:16:23,570 --> 00:16:26,810
它是呢持续集成的描述

367
00:16:30,640 --> 00:16:32,360
D 选项

368
00:16:32,360 --> 00:16:38,390
系统最终用户代表应该全程配合 XP 团队

369
00:16:38,390 --> 00:16:39,730
也就是说呢

370
00:16:39,730 --> 00:16:43,710
哎，我们的用户在团队来全程配合

371
00:16:43,710 --> 00:16:47,270
这是呢现场客户他的一个要求

372
00:16:49,540 --> 00:16:55,020
所以12大最佳实践 A 、 C 、 D 的描述都是正确的

373
00:16:55,020 --> 00:16:56,740
B 选项说反了

374
00:16:56,740 --> 00:16:58,750
所以它是呢错误的选项

375
00:16:58,750 --> 00:17:01,090
那这些呢，就是给大家介绍到

376
00:17:01,090 --> 00:17:02,850
关于敏捷方法

377
00:17:02,850 --> 00:17:04,290
它的一些呢内容
