1
00:00:00,000 --> 00:00:01,560
接下来看到呢

2
00:00:01,560 --> 00:00:03,720
软件开发模型当中

3
00:00:03,720 --> 00:00:07,040
瀑布模型与 V 模型这一部分

4
00:00:07,040 --> 00:00:08,450
那瀑布模型呢

5
00:00:08,450 --> 00:00:09,730
在我们软件考试

6
00:00:09,730 --> 00:00:13,050
软件设计师考试当中出现的特别频繁

7
00:00:13,050 --> 00:00:16,650
大家呢需要重点去掌握它的适用场景

8
00:00:16,650 --> 00:00:18,990
和不能适用的场景

9
00:00:18,990 --> 00:00:24,060
瀑布模型它所应用的是典型的结构化的思想

10
00:00:24,060 --> 00:00:26,410
它是自顶向下，逐步求精

11
00:00:26,410 --> 00:00:28,830
并且每一个步骤必定呢

12
00:00:28,830 --> 00:00:31,100
是严格区分工作阶段的

13
00:00:31,100 --> 00:00:32,259
每一个阶段呢

14
00:00:32,259 --> 00:00:35,960
有他自己的这样的任务以及呢产物

15
00:00:35,960 --> 00:00:38,740
也包括呢文档性质的产物

16
00:00:38,740 --> 00:00:39,970
所以我们说啊

17
00:00:39,970 --> 00:00:43,230
瀑布模型是以文档作为驱动的

18
00:00:43,230 --> 00:00:45,760
那我结构化开发思想

19
00:00:45,760 --> 00:00:49,020
适合的就是呢需求明确的项目

20
00:00:49,020 --> 00:00:51,410
如果说需求不明确

21
00:00:51,410 --> 00:00:56,430
第一个排除的就一定呢是瀑布模型

22
00:00:56,430 --> 00:01:00,250
或者呢结构化开发这样的思想

23
00:01:01,110 --> 00:01:04,230
那对于瀑布模型来说呢

24
00:01:04,230 --> 00:01:07,010
它主要分为计划阶段

25
00:01:07,010 --> 00:01:10,950
需求分析阶段、软件设计阶段、编码阶

26
00:01:10,950 --> 00:01:13,570
以及测试和运维阶段

27
00:01:13,570 --> 00:01:17,570
那每一个阶段只有前面完成之后

28
00:01:17,570 --> 00:01:19,700
才能开始下一个阶段

29
00:01:19,700 --> 00:01:22,120
那我们在前面提到过

30
00:01:22,120 --> 00:01:25,530
软件计划阶段可以呢生成计划书

31
00:01:25,530 --> 00:01:29,830
需求分析阶段可以生成需求分析说明书

32
00:01:29,830 --> 00:01:34,340
软件设计阶段的可以生成软件设计说明书

33
00:01:34,340 --> 00:01:38,380
包括概要说明书和详细设计说明书

34
00:01:38,380 --> 00:01:41,210
编码阶段可以得到呢源代码

35
00:01:41,210 --> 00:01:44,330
测试阶段有测试计划、测试报告

36
00:01:44,330 --> 00:01:47,640
运维阶段有它的运维报告

37
00:01:47,640 --> 00:01:51,640
那每一个阶段一旦产生问题

38
00:01:51,640 --> 00:01:54,640
整个项目都会能推倒重来

39
00:01:54,640 --> 00:01:57,200
所以如果需求明确

40
00:01:57,200 --> 00:01:58,820
一个项目从头到尾

41
00:01:58,820 --> 00:02:01,420
他可能花费的时间并不是太多

42
00:02:01,420 --> 00:02:05,760
但如果一个一年交付期的项目

43
00:02:05,760 --> 00:02:08,270
你做了十个月完成之

44
00:02:08,270 --> 00:02:11,090
交给用户做确认测试

45
00:02:11,090 --> 00:02:12,450
用户告诉

46
00:02:12,450 --> 00:02:13,910
这不是我想要的

47
00:02:13,910 --> 00:02:17,590
那你整个项目基本上就崩溃了

48
00:02:17,590 --> 00:02:19,600
推倒重来之后

49
00:02:19,600 --> 00:02:20,360
很显然

50
00:02:20,360 --> 00:02:24,400
这个一年的交付期我们是不可能完成的

51
00:02:24,400 --> 00:02:26,360
所以啊，需求不明确

52
00:02:26,360 --> 00:02:30,130
一定不能选择瀑布模型去进行开发

53
00:02:30,130 --> 00:02:32,760
那整个过程当中

54
00:02:32,760 --> 00:02:35,930
每一个步骤依次向下

55
00:02:35,930 --> 00:02:39,390
这种过程类似于瀑布行云流水

56
00:02:39,390 --> 00:02:42,370
所以呢，叫做瀑布模型

57
00:02:42,730 --> 00:02:45,590
针对瀑布模型而言的话

58
00:02:45,590 --> 00:02:46,950
我们说 V 模型呢

59
00:02:46,950 --> 00:02:50,090
它属于瀑布模型的一个变种

60
00:02:50,090 --> 00:02:51,990
在 V 模型当中

61
00:02:51,990 --> 00:02:54,620
它是一个典型的 V 字结构

62
00:02:54,620 --> 00:02:58,900
左侧部分它与瀑布模型的阶段基本一致

63
00:02:58,900 --> 00:03:03,850
有需求分析、概要设计、详细设计以及编码过程

64
00:03:03,850 --> 00:03:08,220
而右侧部分是它的测试阶段

65
00:03:08,220 --> 00:03:10,410
我们将测试工作呢

66
00:03:10,410 --> 00:03:15,000
作为验证软件需求的这种确认活动

67
00:03:15,000 --> 00:03:16,970
那我们在这里

68
00:03:16,970 --> 00:03:18,310
这个 V 字形

69
00:03:18,310 --> 00:03:22,830
其实是意味着我们在做需求分析的时候

70
00:03:22,830 --> 00:03:28,030
就要去考考虑验收测试和系统测试

71
00:03:28,030 --> 00:03:29,470
它的计划

72
00:03:29,470 --> 00:03:32,300
以及呢，一些测试用例的设计

73
00:03:32,300 --> 00:03:35,320
那概要设计阶段就要考虑呢

74
00:03:35,320 --> 00:03:37,540
集成测试它的这种呢

75
00:03:37,540 --> 00:03:39,420
测试计划和测试用例

76
00:03:39,420 --> 00:03:42,690
同样详细设计阶段就要考虑呢

77
00:03:42,690 --> 00:03:45,010
唉，我们的单元测

78
00:03:45,010 --> 00:03:47,740
它的测试计划和测试目的

79
00:03:47,740 --> 00:03:50,410
所以将我们的活动啊

80
00:03:50,410 --> 00:03:52,130
验证的测试活动呢

81
00:03:52,130 --> 00:03:56,630
哎，应用于早期的软件工程活动当中去了

82
00:03:56,790 --> 00:03:59,310
那将测试，诶

83
00:03:59,310 --> 00:04:00,490
他的测试计划

84
00:04:00,490 --> 00:04:04,060
测试用例的设计尽可能的提前

85
00:04:04,060 --> 00:04:08,420
他强调的是测试贯穿始终

86
00:04:08,420 --> 00:04:11,260
这就是 V 模型它的特点

87
00:04:11,260 --> 00:04:13,680
所以测试贯穿始终

88
00:04:13,680 --> 00:04:17,810
涉及强调测试的就是呢， V 模型

89
00:04:17,810 --> 00:04:21,310
那下面我们来看一下关于瀑布模型

90
00:04:21,310 --> 00:04:22,110
V 模型

91
00:04:22,110 --> 00:04:25,630
在我们软件设计师考试真题当中的体现

92
00:04:25,630 --> 00:04:27,310
下面这道题呢

93
00:04:27,310 --> 00:04:28,510
诶，告诉我们

94
00:04:28,510 --> 00:04:31,150
开发小组想要开发一个呢

95
00:04:31,150 --> 00:04:32,670
产品控制软件

96
00:04:32,670 --> 00:04:35,500
监控产品的生产和销售

97
00:04:35,500 --> 00:04:38,060
从购买各种材料开始

98
00:04:38,060 --> 00:04:40,440
到产品的加工、销售

99
00:04:40,440 --> 00:04:44,420
全程跟踪购买材料的流程

100
00:04:44,420 --> 00:04:48,090
产品的加工过程以及销售过程

101
00:04:48,090 --> 00:04:50,800
可能会发生变化

102
00:04:50,800 --> 00:04:52,780
那这个软件的开发

103
00:04:52,780 --> 00:04:55,600
最不适宜采用什么模型呢

104
00:04:55,600 --> 00:04:57,300
涉及到变化

105
00:04:57,300 --> 00:05:00,980
第一个排除的就是不能用瀑布

106
00:05:00,980 --> 00:05:02,130
为什么呢

107
00:05:02,130 --> 00:05:07,200
因为瀑布模型难以适应变化的需求

108
00:05:07,200 --> 00:05:08,250
这就是呢

109
00:05:08,250 --> 00:05:11,230
瀑布模型它的特点

110
00:05:11,600 --> 00:05:14,740
那关于圆形增量

111
00:05:14,740 --> 00:05:16,320
还有喷泉模型

112
00:05:16,320 --> 00:05:20,400
我们在后面呢，其实会展开来给大家介绍

113
00:05:20,400 --> 00:05:24,120
原型，它是适用于需求不明确

114
00:05:24,120 --> 00:05:28,480
用以帮助呢用户来明确需求的

115
00:05:28,480 --> 00:05:32,170
喷泉模型是典型的面向对象的

116
00:05:32,170 --> 00:05:34,170
诶，这样的开发模型

117
00:05:34,170 --> 00:05:38,110
它的特点呢，是用户需求驱动迭

118
00:05:38,110 --> 00:05:40,690
无间隙增量模型

119
00:05:40,690 --> 00:05:42,410
它的优势在于啊

120
00:05:42,410 --> 00:05:46,810
可以尽可能早地提供一个可用版本给用户

121
00:05:46,810 --> 00:05:49,320
然后在这个版本的基础上

122
00:05:49,320 --> 00:05:51,900
去增加新的功能模块

123
00:05:51,900 --> 00:05:55,090
每一次交付给用户的都是呢

124
00:05:55,090 --> 00:05:57,850
可使用的软件版本

125
00:05:57,850 --> 00:06:01,730
那下面所描述的 ABD 呢

126
00:06:01,730 --> 00:06:05,530
第二空的 A 、 B 、 D 我们就不需要去了解了

127
00:06:05,530 --> 00:06:10,180
那这里对于瀑布模型为什么不能用在这里

128
00:06:10,180 --> 00:06:14,220
因为它难以适应变化的需求

129
00:06:14,220 --> 00:06:17,060
这是对瀑布模型的考察
