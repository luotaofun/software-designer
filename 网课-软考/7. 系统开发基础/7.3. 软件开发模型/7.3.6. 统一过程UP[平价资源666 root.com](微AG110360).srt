1
00:00:00,000 --> 00:00:01,700
接下来我们看到呢

2
00:00:01,700 --> 00:00:05,560
统一过程这个模型它既是属于过程

3
00:00:05,560 --> 00:00:07,150
也是属于方法的

4
00:00:07,150 --> 00:00:09,230
那我们在软件设计师考试

5
00:00:09,230 --> 00:00:12,190
如果出现 UP 和 IP 

6
00:00:12,190 --> 00:00:14,380
指的都是统一过程

7
00:00:14,380 --> 00:00:19,050
通过近十次的这种考察题型的统计啊

8
00:00:19,050 --> 00:00:20,800
我们的统一过程呢

9
00:00:20,800 --> 00:00:22,820
出现的已经比较少了

10
00:00:22,820 --> 00:00:26,300
但是综合其他软件方向的科目来看呢

11
00:00:26,300 --> 00:00:30,160
它的考察如果出现一般考得比较细致

12
00:00:30,160 --> 00:00:31,700
所以在这里还是呢

13
00:00:31,700 --> 00:00:33,270
给大家介绍一下

14
00:00:33,270 --> 00:00:36,300
那统一过程的开发

15
00:00:36,300 --> 00:00:40,060
它的典型特点呢，是用力驱动

16
00:00:40,060 --> 00:00:43,340
以架构为中心，迭代与增量的

17
00:00:43,340 --> 00:00:47,050
那它的驱动是由用力来驱动的

18
00:00:47,050 --> 00:00:48,790
那我们可以回忆一下

19
00:00:48,790 --> 00:00:51,090
瀑布模型是谁来驱动的

20
00:00:51,090 --> 00:00:53,920
是文是文档驱动的

21
00:00:53,920 --> 00:00:58,970
喷泉模型是用户需求以对象来驱动的

22
00:00:58,970 --> 00:01:02,360
那这是它的一些呢，区别性的内容

23
00:01:02,360 --> 00:01:05,180
那它是以架构为中心

24
00:01:05,180 --> 00:01:07,100
所以它的核心里面啊

25
00:01:07,100 --> 00:01:09,000
它的一些任务过程当中

26
00:01:09,000 --> 00:01:11,640
会有呢对架构模型的候选

27
00:01:11,640 --> 00:01:13,470
以及呢确认过程

28
00:01:13,470 --> 00:01:16,880
它有迭代和增量的思想在里面

29
00:01:16,880 --> 00:01:19,510
那我们在前面讲到的增量模型

30
00:01:19,510 --> 00:01:23,910
会划分一些呢核心增量来进行迭代吧

31
00:01:23,910 --> 00:01:26,330
每一轮迭代都可以

32
00:01:26,330 --> 00:01:28,660
做一次交付的动作

33
00:01:28,660 --> 00:01:30,960
那我们统一过程呢

34
00:01:30,960 --> 00:01:36,580
每一轮迭代划分成了初始、细化、构建和交付阶段

35
00:01:36,580 --> 00:01:39,800
初始也叫做呢初起

36
00:01:41,130 --> 00:01:44,250
细化也可以叫做精化

37
00:01:44,250 --> 00:01:46,370
那这些阶段当中呢

38
00:01:46,370 --> 00:01:48,980
都是翻译的区别而已

39
00:01:48,980 --> 00:01:50,920
那初始阶段

40
00:01:50,920 --> 00:01:56,030
它是呢对我们生命周期的目标来进行定义的

41
00:01:56,030 --> 00:01:57,390
这个过程呢

42
00:01:57,390 --> 00:01:59,570
唉，我们会涉及

43
00:01:59,570 --> 00:02:02,410
了解项目的范围和边界

44
00:02:02,410 --> 00:02:04,400
识别它的关键用例

45
00:02:04,400 --> 00:02:06,420
因为它是用力驱动的

46
00:02:06,420 --> 00:02:10,630
注意呢，这里还会展示系统的候选架构

47
00:02:10,630 --> 00:02:12,460
它是候选架构

48
00:02:12,460 --> 00:02:13,920
还没有明确

49
00:02:13,920 --> 00:02:15,680
什么时候明确呢

50
00:02:15,680 --> 00:02:18,260
在细化阶段进行明确

51
00:02:18,260 --> 00:02:19,500
细化阶段呢

52
00:02:19,500 --> 00:02:23,020
它所实现的就是我们生命周期的架构

53
00:02:23,680 --> 00:02:28,080
那它会确定最终的软件架构

54
00:02:28,080 --> 00:02:31,590
那在这个过程当中还会淘汰一些呢

55
00:02:31,590 --> 00:02:34,690
风险元素分析有系统的问题领域

56
00:02:34,690 --> 00:02:36,940
注意：虽然这里提到了风险

57
00:02:36,940 --> 00:02:39,220
但是并不强调风险

58
00:02:39,220 --> 00:02:42,560
只有螺旋模型才会呢强调风险

59
00:02:42,560 --> 00:02:45,370
那构建阶段它是呢

60
00:02:45,370 --> 00:02:48,730
诶展开了一个初始的系统

61
00:02:48,730 --> 00:02:53,350
注意：这是一个可使用系统的生成

62
00:02:55,940 --> 00:02:59,300
我们叫做可使用软件产品吧

63
00:03:02,080 --> 00:03:07,740
那在这个阶段建立了可使用的软件产品

64
00:03:07,740 --> 00:03:09,780
它的构建工作呢

65
00:03:09,780 --> 00:03:12,680
注意啊，这个构建是个动词

66
00:03:12,680 --> 00:03:14,480
与它同音

67
00:03:14,480 --> 00:03:16,500
还有一个名词

68
00:03:16,500 --> 00:03:20,040
它也有呢，面向构建开发的思想

69
00:03:20,040 --> 00:03:23,420
所谓的构建或者叫做组件

70
00:03:23,420 --> 00:03:27,500
它是可以理解为比类稍大一些的东西

71
00:03:27,500 --> 00:03:31,410
也以它主要啊，可以实现某一些特定的功能

72
00:03:31,410 --> 00:03:33,670
以构件来进行复用

73
00:03:33,670 --> 00:03:35,670
那在做构建开发的时候

74
00:03:35,670 --> 00:03:38,670
他会呢做一个标准的构建库

75
00:03:39,270 --> 00:03:41,150
我们会将啊

76
00:03:41,150 --> 00:03:44,470
整个公司所使用的构件呢

77
00:03:44,470 --> 00:03:47,190
都依次存在构件库当中

78
00:03:47,190 --> 00:03:49,260
那我们下一次开发的时候

79
00:03:49,260 --> 00:03:53,060
直接复用构件库里面的东西就可以了

80
00:03:53,060 --> 00:03:55,470
那如果说构建库没有呢

81
00:03:55,470 --> 00:03:59,030
哎，我们就开发剩余没有的这些构件

82
00:03:59,030 --> 00:04:01,300
那所有的构件做完呢

83
00:04:01,300 --> 00:04:03,100
就像呢搭积木一样

84
00:04:03,100 --> 00:04:05,110
把它们呢组装起来

85
00:04:05,110 --> 00:04:07,440
从而形成最终的系统

86
00:04:07,440 --> 00:04:11,770
并且呢做一些我们开发环境下的测试

87
00:04:11,770 --> 00:04:14,770
那这是构建阶段他的任务

88
00:04:14,770 --> 00:04:16,690
那构建完了之后

89
00:04:16,690 --> 00:04:19,550
下一步呢会交给用户

90
00:04:19,550 --> 00:04:22,380
那交付给用户的时候

91
00:04:22,380 --> 00:04:25,440
我们这里呢，还有一个贝塔测试

92
00:04:25,440 --> 00:04:28,970
前面呀，我们一般叫做埃尔法测试

93
00:04:28,970 --> 00:04:32,330
它是开发环境下的测试

94
00:04:34,580 --> 00:04:37,980
类似于我们在做信息系统开发的时候

95
00:04:37,980 --> 00:04:40,680
交给用户之前自己会测试一下吧

96
00:04:40,680 --> 00:04:43,680
然后呢，在用户环境下，哎

97
00:04:43,680 --> 00:04:46,720
我们会去用户的运行环境做一次测试

98
00:04:46,720 --> 00:04:49,380
那这种叫做 beta 测试

99
00:04:53,740 --> 00:04:56,620
测试之后如果可行

100
00:04:56,620 --> 00:04:58,870
我们就制作发布版本

101
00:04:58,870 --> 00:05:01,940
然后呢，给用户相应的文档定稿

102
00:05:01,940 --> 00:05:04,120
确认系统做培训和调整

103
00:05:04,120 --> 00:05:05,820
不可以怎么办呢

104
00:05:05,820 --> 00:05:07,420
哎，我们没有完成的话

105
00:05:07,420 --> 00:05:10,420
就进入下一轮的这种开发过程

106
00:05:10,420 --> 00:05:11,500
它的迭代

107
00:05:11,500 --> 00:05:13,650
这就是统一过程

108
00:05:13,650 --> 00:05:16,140
那对于统一过程来说的话

109
00:05:16,140 --> 00:05:18,940
它如果出现在考试当中

110
00:05:18,940 --> 00:05:23,090
一般呢，首先第一个维度就是考特点

111
00:05:23,090 --> 00:05:26,220
第二个维度就是考这些呢

112
00:05:26,220 --> 00:05:29,560
诶，每一个阶段它的任务

113
00:05:29,560 --> 00:05:34,260
那第三个维度可能会涉及到核心工作流

114
00:05:34,260 --> 00:05:38,390
我们目前在软设当中其实并没有考察过啊

115
00:05:38,390 --> 00:05:42,920
核心工作流包括呢，了解需求的，诶

116
00:05:42,920 --> 00:05:47,130
我们要捕获需求、有需求工作流、精化

117
00:05:47,130 --> 00:05:49,030
以及呢，唉，我们最终

118
00:05:49,030 --> 00:05:50,970
最终呢，做结构化需求

119
00:05:50,970 --> 00:05:53,820
有需求的分析工作流

120
00:05:53,820 --> 00:05:58,180
那分析之后我们会有一个设计工作吧

121
00:05:58,180 --> 00:05:59,860
那有设计工作流

122
00:05:59,860 --> 00:06:02,280
设计之后有实现工作流

123
00:06:02,280 --> 00:06:03,500
实现之后呢

124
00:06:03,500 --> 00:06:05,920
我们还有测试工作流

125
00:06:05,920 --> 00:06:06,900
那这是呢

126
00:06:06,900 --> 00:06:10,440
我们统一过程当中的五个核心工作流

127
00:06:10,440 --> 00:06:12,560
稍微呢，知道一下就行了

128
00:06:12,560 --> 00:06:14,460
目前在考试当中啊

129
00:06:14,460 --> 00:06:16,340
还没有考到这个维度啊

130
00:06:16,340 --> 00:06:17,910
就太过深入了

131
00:06:17,910 --> 00:06:19,000
那这些呢

132
00:06:19,000 --> 00:06:22,960
就是要求大家掌握的统一过程的内容
