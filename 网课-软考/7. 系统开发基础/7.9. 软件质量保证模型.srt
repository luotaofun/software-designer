1
00:00:00,000 --> 00:00:03,580
接下来我们看到软件质量保证模型

2
00:00:03,580 --> 00:00:05,680
那在这里我们主要呢

3
00:00:05,680 --> 00:00:07,800
给大家介绍到一个呢

4
00:00:07,800 --> 00:00:10,580
模型当中涉及到的属性

5
00:00:10,580 --> 00:00:12,340
以及它的子属性

6
00:00:12,340 --> 00:00:13,230
这一部分

7
00:00:13,230 --> 00:00:16,700
在我们软件设计师考试当中出现的频率

8
00:00:16,700 --> 00:00:19,240
也是呢，较高的一个知识点

9
00:00:19,240 --> 00:00:22,290
但是它的内容考察并不深入

10
00:00:22,290 --> 00:00:25,880
主要呢，掌握的是它的分类即可

11
00:00:25,880 --> 00:00:28,460
那我们简单看到这个模型啊

12
00:00:28,460 --> 00:00:30,820
它是固定的一个 i so 

13
00:00:30,820 --> 00:00:34,100
也就是我们的国际标准化组织提出来的

14
00:00:34,100 --> 00:00:36,750
IEC 9126这样的一个，呃

15
00:00:36,750 --> 00:00:38,670
它的一个呢模型

16
00:00:38,670 --> 00:00:41,650
那我们在这里主要了解的是

17
00:00:41,650 --> 00:00:45,010
质量属性和它子属性的匹配关系

18
00:00:45,010 --> 00:00:48,910
那我们呢，首先给大家简单介绍一下

19
00:00:48,910 --> 00:00:53,200
我们在考试当中考察较多的是易用性

20
00:00:53,200 --> 00:00:55,320
以及呢可移植性

21
00:00:55,320 --> 00:00:56,740
还有功能性

22
00:00:56,740 --> 00:00:58,620
它的一些呢，子属性

23
00:00:58,620 --> 00:01:00,620
那我们简单来看一看

24
00:01:00,620 --> 00:01:04,420
这几个属性当中包含哪些子属性呢

25
00:01:04,420 --> 00:01:07,420
首先，对于易用性的话

26
00:01:07,420 --> 00:01:10,250
它是针对用户来看的

27
00:01:10,250 --> 00:01:13,560
那什么样的一个系统才是好用的呢

28
00:01:13,560 --> 00:01:14,720
大家可以想一想

29
00:01:14,720 --> 00:01:17,690
大家平常在使用西塞的 app 的时候

30
00:01:17,690 --> 00:01:18,970
有没有感觉

31
00:01:18,970 --> 00:01:20,610
诶，它好操作吗

32
00:01:20,610 --> 00:01:22,110
如果不好操作

33
00:01:22,110 --> 00:01:24,180
显然我们认为它不好用

34
00:01:24,180 --> 00:01:27,830
然后如果老师告诉你，诶

35
00:01:27,830 --> 00:01:29,430
我们要做一个题

36
00:01:29,430 --> 00:01:32,100
试题在哪里、哪里、哪里位置

37
00:01:32,100 --> 00:01:35,120
那我们应该如何去提交试题

38
00:01:35,120 --> 00:01:36,320
如何去提交

39
00:01:36,320 --> 00:01:37,880
包括高级的论文

40
00:01:37,880 --> 00:01:39,100
如何提问

41
00:01:39,100 --> 00:01:42,240
那这个过程大家容易学会吗

42
00:01:42,240 --> 00:01:43,620
如果好学

43
00:01:43,620 --> 00:01:45,330
那我们也说它呢，好用

44
00:01:45,330 --> 00:01:47,510
不好学也会嫌弃它吧

45
00:01:47,510 --> 00:01:49,880
那我们的整个软件，唉

46
00:01:49,880 --> 00:01:52,540
比如说大家看到我的，我的课程

47
00:01:52,540 --> 00:01:54,720
这样的地方好理解吗

48
00:01:54,720 --> 00:01:56,960
容易理解的才好用

49
00:01:56,960 --> 00:01:58,640
如果你看到一个列表

50
00:01:58,640 --> 00:01:59,640
你根本都看不懂

51
00:01:59,640 --> 00:02:01,840
那肯定这个软件不好用

52
00:02:01,840 --> 00:02:05,580
这些都是属于易用性的

53
00:02:05,710 --> 00:02:08,289
其次，可移植性

54
00:02:08,289 --> 00:02:13,340
可移植性呢，它主要涉及的就不是用户角度了

55
00:02:13,340 --> 00:02:15,820
而是呢，开发的角度

56
00:02:15,950 --> 00:02:18,960
那我们在做开发的过程当中

57
00:02:18,960 --> 00:02:22,070
一个软件它的使用环境，诶

58
00:02:22,070 --> 00:02:24,750
会涉及到变化的情况下

59
00:02:24,750 --> 00:02:26,580
就有了可移植性

60
00:02:26,580 --> 00:02:28,390
比如说大家想一想啊

61
00:02:28,390 --> 00:02:29,990
西赛的 app 的话

62
00:02:29,990 --> 00:02:33,560
很显然它不会只在我们安卓手机上用吧

63
00:02:33,560 --> 00:02:36,440
我们还是要开发一个苹果手机来用的

64
00:02:36,440 --> 00:02:38,200
还有平板来用的吧

65
00:02:38,200 --> 00:02:39,920
这种情况下

66
00:02:39,920 --> 00:02:43,590
那我们显然要适应不同的环境

67
00:02:43,590 --> 00:02:46,650
那下载之后肯定要容易安装版

68
00:02:46,650 --> 00:02:49,450
并且容易呢来进行替换

69
00:02:49,450 --> 00:02:52,860
所以这些呢，都是属于可移植性

70
00:02:52,860 --> 00:02:53,780
它的优势

71
00:02:53,780 --> 00:02:56,700
那它需要遵循的子属性

72
00:02:56,700 --> 00:02:58,530
那对于可移植性

73
00:02:58,530 --> 00:03:02,300
我们还经常会说 java 它的可移植性比较强

74
00:03:02,300 --> 00:03:04,580
为什么可移植性比较强呢

75
00:03:04,580 --> 00:03:05,900
因为 java 有一个

76
00:03:05,900 --> 00:03:07,260
呃，虚拟环境

77
00:03:07,260 --> 00:03:09,160
那我们 java 虚拟机的话

78
00:03:09,160 --> 00:03:10,500
只要你装了虚拟机

79
00:03:10,500 --> 00:03:12,100
你就能跑 java 代码

80
00:03:12,100 --> 00:03:13,800
所以在这个过程当中

81
00:03:13,800 --> 00:03:15,440
无论你是什么操作系统

82
00:03:15,440 --> 00:03:18,390
只要你装了 java 虚拟机就可以了

83
00:03:18,390 --> 00:03:20,000
这种情况下

84
00:03:20,000 --> 00:03:23,780
那我们的适应性呢，就比较强了

85
00:03:23,780 --> 00:03:27,330
那他的这种易安装、易替换就没有呢

86
00:03:27,330 --> 00:03:28,690
去考虑太多了

87
00:03:28,690 --> 00:03:30,920
我们目前在做开发的时候

88
00:03:30,920 --> 00:03:34,040
会更多的去考虑安装是否方便

89
00:03:34,040 --> 00:03:35,790
替换是否方便

90
00:03:35,790 --> 00:03:36,780
这就是呢

91
00:03:36,780 --> 00:03:38,040
可移植性

92
00:03:38,040 --> 00:03:40,760
它需要遵从的子属性

93
00:03:40,970 --> 00:03:43,030
下面功能性

94
00:03:43,030 --> 00:03:44,540
功能性的话

95
00:03:44,540 --> 00:03:47,580
它主要是针对需求而言的

96
00:03:47,580 --> 00:03:50,080
我们在做需求分析的时候

97
00:03:50,080 --> 00:03:51,130
我们说到啊

98
00:03:51,130 --> 00:03:55,150
需求的分类包含功能它的分类吧

99
00:03:55,150 --> 00:03:58,070
那这种功能分类需要呢

100
00:03:58,070 --> 00:03:59,970
我们去进行区分

101
00:03:59,970 --> 00:04:03,390
什么样的功能才是呢，比较好的

102
00:04:03,390 --> 00:04:04,960
功能性比较好呢

103
00:04:04,960 --> 00:04:08,130
那我们需求所提出的功能

104
00:04:08,130 --> 00:04:12,310
你肯定呢，要准确地去完成它吧

105
00:04:12,310 --> 00:04:16,660
那并且我们在做开发相应功能的时候

106
00:04:16,660 --> 00:04:20,399
要考虑这个功能是否适合

107
00:04:20,399 --> 00:04:24,370
以及呢，与其他系统的互操作性

108
00:04:24,370 --> 00:04:27,110
你一个软件不让别人来访问

109
00:04:27,110 --> 00:04:30,060
这种情况下其实就不太友好了

110
00:04:30,060 --> 00:04:33,350
还有呢，安全保密性也是呢

111
00:04:33,350 --> 00:04:35,570
需要我们在开发过程当中

112
00:04:35,570 --> 00:04:38,680
从功能角度上去考虑的

113
00:04:38,680 --> 00:04:41,370
那除了这三个维度以外的话

114
00:04:41,370 --> 00:04:43,530
效率比较好理解

115
00:04:43,530 --> 00:04:45,670
我们在考虑效率的时候

116
00:04:45,670 --> 00:04:47,360
包含时间效率

117
00:04:47,360 --> 00:04:49,760
唉，我们在讲数据结构与算法的时候

118
00:04:49,760 --> 00:04:53,130
会提到时间和空间的利用率

119
00:04:53,130 --> 00:04:56,530
空间其实也是其他资源的利用率吧

120
00:04:56,530 --> 00:05:00,780
所以包含时间特性和资源利用性

121
00:05:00,780 --> 00:05:02,120
那这是呢

122
00:05:02,120 --> 00:05:04,580
效率它的两个子属性

123
00:05:04,580 --> 00:05:07,380
剩下的，诶，可维护性

124
00:05:07,380 --> 00:05:09,790
维护性它是需要呢

125
00:05:09,790 --> 00:05:12,130
我们容易去进行测试

126
00:05:12,130 --> 00:05:14,080
容易去进行修改吧

127
00:05:14,080 --> 00:05:16,390
还需要保证易分析

128
00:05:16,390 --> 00:05:18,390
注意没有易理解了

129
00:05:18,390 --> 00:05:21,420
它变成了容易分析、易理解

130
00:05:21,420 --> 00:05:24,180
是在用户角度的易用性里面

131
00:05:24,180 --> 00:05:26,970
注意呢，这里是存在一些区别的

132
00:05:26,970 --> 00:05:29,090
然后呢，维护性的话

133
00:05:29,090 --> 00:05:32,430
我们会要求这个系统尽可能稳定

134
00:05:32,620 --> 00:05:35,080
如果你做运维工作

135
00:05:35,080 --> 00:05:37,780
系统三天两头报错崩溃

136
00:05:37,780 --> 00:05:39,470
你是不是也会崩溃呢

137
00:05:39,470 --> 00:05:42,480
所以肯定是稳定性要强

138
00:05:42,480 --> 00:05:45,060
一旦出错，我们要容易呢

139
00:05:45,060 --> 00:05:46,840
去做修改、做测试

140
00:05:46,840 --> 00:05:50,490
还要呢，容易分析其中的一些问题

141
00:05:50,490 --> 00:05:54,960
最后，可靠性、可靠性和可用

142
00:05:54,960 --> 00:05:58,620
在很多角度上都没有去做

143
00:05:58,620 --> 00:06:01,010
非常细致的区分

144
00:06:01,010 --> 00:06:03,590
它主要指的是我们系统啊

145
00:06:03,590 --> 00:06:06,770
能够正常运行的这样的时间比例

146
00:06:06,770 --> 00:06:10,420
那既然能够正常运行不容易坏

147
00:06:10,420 --> 00:06:12,760
一方面呢，是不容易坏

148
00:06:12,760 --> 00:06:15,810
软件成熟就不容易坏吧

149
00:06:15,810 --> 00:06:17,690
一个经过千百次

150
00:06:17,690 --> 00:06:20,440
千万次使用的这样的一些软件

151
00:06:20,440 --> 00:06:23,310
包括呢用了很多年的这种软

152
00:06:23,310 --> 00:06:25,170
成熟性就会比较强

153
00:06:25,170 --> 00:06:27,490
然后容错性就是呢

154
00:06:27,490 --> 00:06:30,910
出现问题能够呢容纳一些错误

155
00:06:30,910 --> 00:06:32,830
并不是直接崩溃

156
00:06:32,830 --> 00:06:34,950
那软件还可以继续使用

157
00:06:34,950 --> 00:06:36,320
可靠性就好

158
00:06:36,320 --> 00:06:39,410
出现问题很快就能够修复

159
00:06:39,410 --> 00:06:41,270
也是呢可靠性好

160
00:06:41,270 --> 00:06:44,190
那这些啊就是它的质量属性

161
00:06:44,190 --> 00:06:47,010
所遵循的一些呢子属性

162
00:06:47,010 --> 00:06:49,770
那下面的依从性的说法

163
00:06:49,770 --> 00:06:54,080
可以理解为需要遵从的一些设计约束

164
00:06:54,080 --> 00:06:56,780
一些呢规则标准

165
00:06:56,780 --> 00:07:00,860
那这些质量属性如如果给大家一个子属性

166
00:07:00,860 --> 00:07:06,650
要能够知道它所属的是哪一个属性的归类

167
00:07:06,650 --> 00:07:09,930
这也是呢我们在软件设计师考试当中

168
00:07:09,930 --> 00:07:12,630
经常考察到的题型

169
00:07:13,200 --> 00:07:15,940
下面我们来看一下这一部分

170
00:07:15,940 --> 00:07:19,420
在我们软件设计师考试真题当中的体现

171
00:07:19,420 --> 00:07:25,060
那在 ISOIEC 这个软件质量模型当中

172
00:07:25,060 --> 00:07:26,950
E 使用性诶

173
00:07:26,950 --> 00:07:28,210
这个易使用

174
00:07:28,210 --> 00:07:30,920
它的子特性不包含什么

175
00:07:30,920 --> 00:07:34,010
什么样的软件易使用呢

176
00:07:34,010 --> 00:07:36,770
唉，我们要好理解，好学

177
00:07:36,770 --> 00:07:39,220
然后容易去操作吧

178
00:07:39,220 --> 00:07:40,430
易分析

179
00:07:40,430 --> 00:07:42,530
注意这两个有一些像

180
00:07:42,530 --> 00:07:44,150
但是易分析

181
00:07:44,150 --> 00:07:47,810
它是维护性的一个呢子属性

182
00:07:48,220 --> 00:07:51,610
所以这个地方呢不要搞错了

183
00:07:51,610 --> 00:07:54,320
那涉及到这些子属性

184
00:07:54,320 --> 00:07:57,100
它的归类是我们呢相应的知识点

185
00:07:57,100 --> 00:07:59,180
考察的主要题型

186
00:07:59,180 --> 00:08:01,410
这就是要求大家掌握的

187
00:08:01,410 --> 00:08:03,530
软件质量模型的内容
