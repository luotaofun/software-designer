1
00:00:00,000 --> 00:00:03,460
下面我们来看一下行为型设计模式

2
00:00:03,460 --> 00:00:05,420
行为型设计模式呢

3
00:00:05,420 --> 00:00:09,320
它的目的主要是为了解决一些值得分配

4
00:00:09,320 --> 00:00:11,540
以及呢访问问题的

5
00:00:11,540 --> 00:00:14,640
那针对行为型设计模式呢

6
00:00:14,640 --> 00:00:18,350
它存在的有11种设计模式

7
00:00:18,350 --> 00:00:21,540
这11种设计模式分别是

8
00:00:21,540 --> 00:00:23,090
职、责、念

9
00:00:23,960 --> 00:00:28,090
命令模式、解释器、迭代器、中介者

10
00:00:28,090 --> 00:00:29,250
以及呢

11
00:00:29,250 --> 00:00:33,490
备忘录、观察者、状态、策略、模板、方法

12
00:00:33,490 --> 00:00:35,580
访问者模式等等

13
00:00:35,580 --> 00:00:38,800
那针对这11种设计模式

14
00:00:38,800 --> 00:00:40,300
首先第一个维度

15
00:00:40,300 --> 00:00:45,000
大家掌握相应的中英文拼写和它的归属

16
00:00:45,000 --> 00:00:48,770
其次呢，同样根据速记关键

17
00:00:48,770 --> 00:00:52,480
可以呢，做一些简单的描述的还原

18
00:00:52,480 --> 00:00:54,750
那我们呢，来看一看

19
00:00:54,750 --> 00:00:57,970
首先来看一下职责念模式啊

20
00:00:57,970 --> 00:01:01,240
它是所谓的链式结构呢

21
00:01:01,240 --> 00:01:05,140
是将我们相应的处理人员

22
00:01:05,140 --> 00:01:06,780
或者说处理对

23
00:01:06,780 --> 00:01:08,930
形成了一定的练

24
00:01:08,930 --> 00:01:12,050
那这种面试结构就意味着

25
00:01:12,050 --> 00:01:14,290
我们在提交请求的时候

26
00:01:14,290 --> 00:01:17,020
不需要一下子提交给三个人

27
00:01:17,020 --> 00:01:19,970
而是呢，提交给其中一个人

28
00:01:19,970 --> 00:01:22,990
在层层进行提交就可以了

29
00:01:22,990 --> 00:01:26,160
那这就是呢，传递职责的过程

30
00:01:26,160 --> 00:01:28,700
我们可以呢，给多个对象

31
00:01:28,700 --> 00:01:30,840
都有呢，处理请求的机会

32
00:01:30,840 --> 00:01:34,250
而这里你给了相应机会之后

33
00:01:34,250 --> 00:01:36,720
可以减很少请求的发送者

34
00:01:36,720 --> 00:01:39,680
与所有的接收者来进行耦合吧

35
00:01:39,680 --> 00:01:41,880
那有一定的解耦作用

36
00:01:41,880 --> 00:01:44,870
将接收对象链接起来呢

37
00:01:44,870 --> 00:01:47,910
在链当中来传递这个请求

38
00:01:47,910 --> 00:01:49,690
直到有人处理为止

39
00:01:49,690 --> 00:01:51,080
类似于什么呢

40
00:01:51,080 --> 00:01:53,340
大家现在提交涨工资

41
00:01:53,340 --> 00:01:55,540
或者呢提交请假的时候

42
00:01:55,540 --> 00:01:57,910
你的小组长权限不够

43
00:01:57,910 --> 00:02:00,730
他会呢提交给上层的部门经理

44
00:02:00,730 --> 00:02:02,850
甚至呢公司经理啊

45
00:02:02,850 --> 00:02:04,650
公司总经理等等

46
00:02:04,650 --> 00:02:09,310
这种层层提交审批的过程就是呢职责链

47
00:02:10,009 --> 00:02:12,450
第二种，命令模式

48
00:02:12,450 --> 00:02:14,650
命令模式会将呢

49
00:02:14,650 --> 00:02:17,070
请求封装成对象

50
00:02:17,070 --> 00:02:20,700
那请求封装成一个对象之后

51
00:02:20,700 --> 00:02:23,840
这个对象啊是可以进行参数化

52
00:02:23,840 --> 00:02:26,490
或者说呢，可以进行唉一些记录

53
00:02:26,490 --> 00:02:29,730
然后呢进行排队进行撤销的

54
00:02:29,730 --> 00:02:31,880
那这个过程当中

55
00:02:31,880 --> 00:02:33,730
我们呢可以啊

56
00:02:33,730 --> 00:02:35,170
作为日志记录

57
00:02:35,170 --> 00:02:37,170
因为它可以将请求排队

58
00:02:37,170 --> 00:02:38,490
可以呢记录

59
00:02:38,490 --> 00:02:41,350
然后的话呢是可撤销的

60
00:02:41,350 --> 00:02:44,410
这就是呢命令模式它的特点

61
00:02:44,410 --> 00:02:46,980
第三种，解释器模式

62
00:02:46,980 --> 00:02:49,800
解释器它的典型应用呢

63
00:02:49,800 --> 00:02:53,560
跟我们的虚拟机的机制很相似

64
00:02:53,560 --> 00:02:55,170
大家有用过 java 的话

65
00:02:55,170 --> 00:02:57,890
会知道 java 它是有 java 虚拟机的

66
00:02:57,890 --> 00:03:01,000
还有呢其他的一些虚拟机的机制

67
00:03:01,000 --> 00:03:06,000
我们简单的把解释器当做一个呢编译器来看

68
00:03:06,810 --> 00:03:10,280
所谓编译器就是我们写代码的地方

69
00:03:10,280 --> 00:03:13,040
那我们将代码写在编译器界面

70
00:03:13,040 --> 00:03:15,860
编译一下会生成一定的中间代码

71
00:03:15,860 --> 00:03:17,680
或者呢可执行程

72
00:03:17,680 --> 00:03:19,110
会有一个结果吧

73
00:03:19,110 --> 00:03:22,240
所谓的解释器就是输入一定的内容

74
00:03:22,240 --> 00:03:23,850
产生一定的结果

75
00:03:23,850 --> 00:03:27,000
中间经过了怎么样的转换呢

76
00:03:27,000 --> 00:03:31,080
哎，就是解释器来写他的工作规则了

77
00:03:31,080 --> 00:03:34,310
那这里给定一种语言定义

78
00:03:34,310 --> 00:03:37,950
它的文法表示就是在解释器当中呢定义了

79
00:03:37,950 --> 00:03:39,370
唉，这样的一个解释器

80
00:03:39,370 --> 00:03:42,350
由解释器来根据文法解释

81
00:03:42,350 --> 00:03:45,210
我们输入的句子会产生什么样的结果

82
00:03:45,210 --> 00:03:47,850
这就是呢解释器模式

83
00:03:48,390 --> 00:03:51,050
第四种，迭代器模式

84
00:03:51,050 --> 00:03:52,510
迭代器模式呢

85
00:03:52,510 --> 00:03:55,050
目前在很多的开发语言当中

86
00:03:55,050 --> 00:03:57,520
都已已经包含了迭代器的接口

87
00:03:57,520 --> 00:03:59,180
可以直接去用

88
00:03:59,180 --> 00:04:00,820
比如说 java 就有

89
00:04:00,820 --> 00:04:03,010
那什么是迭代器呢

90
00:04:03,010 --> 00:04:05,890
它将我们所有的元素啊

91
00:04:05,890 --> 00:04:07,910
放到一个整体里面去了

92
00:04:07,910 --> 00:04:09,060
放进去之后

93
00:04:09,060 --> 00:04:11,420
虽然我不知道里面有什么

94
00:04:11,420 --> 00:04:16,149
但是呢，我可以根据我的需要来顺序访问

95
00:04:16,149 --> 00:04:17,160
那这种呢

96
00:04:17,160 --> 00:04:21,839
唉，能够顺序访问里面包含的各个元素

97
00:04:21,839 --> 00:04:24,130
就是呢，迭代器的作用

98
00:04:24,130 --> 00:04:27,270
比如说呢，数据库当中的数据

99
00:04:27,270 --> 00:04:29,610
也有这样的特点

100
00:04:29,610 --> 00:04:32,130
那我们在访问的时候呢

101
00:04:32,130 --> 00:04:33,610
可以按照呢

102
00:04:33,610 --> 00:04:35,890
顺序来访问

103
00:04:35,890 --> 00:04:38,890
第五种，中介者模式

104
00:04:38,890 --> 00:04:42,590
中介者跟我们的代理模式啊

105
00:04:42,590 --> 00:04:45,050
有很多同学呢，容易混淆

106
00:04:45,050 --> 00:04:49,260
注意代理模式只是提供了一种访问方式

107
00:04:49,260 --> 00:04:50,940
中介模式呢

108
00:04:50,940 --> 00:04:56,050
中介者模式是彻底改变了我们的交互

109
00:04:56,050 --> 00:04:59,990
那我们现在听到中介最常听到的是什么

110
00:04:59,990 --> 00:05:01,240
买房、买车

111
00:05:01,240 --> 00:05:03,030
还有租房中介吧

112
00:05:03,030 --> 00:05:07,710
那这种中介类似于我们有多个厂家

113
00:05:07,710 --> 00:05:10,710
然后呢，有多个购买者

114
00:05:10,710 --> 00:05:13,190
原本大家是相互沟通吧

115
00:05:13,190 --> 00:05:14,590
这样很麻烦呀

116
00:05:14,590 --> 00:05:16,490
一个人要拿好多个

117
00:05:16,490 --> 00:05:18,240
唉，最终的沟通方式

118
00:05:18,240 --> 00:05:20,620
但现在我们增加了中介者

119
00:05:20,620 --> 00:05:23,150
大家呢，都与公中介者

120
00:05:23,150 --> 00:05:26,660
来建立我们的沟通方式就可以了

121
00:05:26,660 --> 00:05:28,430
记一下中介的号码

122
00:05:28,430 --> 00:05:32,670
他可以呢，帮你联系十几20家的厂商吧

123
00:05:32,670 --> 00:05:34,910
那这种呢，就是中介者

124
00:05:34,910 --> 00:05:37,260
它可以不直接引用

125
00:05:37,260 --> 00:05:39,900
通过中介呢来进行沟通

126
00:05:39,900 --> 00:05:44,600
一个中介对象来封装一系列对象的交互

127
00:05:44,600 --> 00:05:48,120
各个对象呢，不需要显示的相互调用了

128
00:05:48,120 --> 00:05:51,800
它解决的是我们隐式调用的方式

129
00:05:51,800 --> 00:05:54,010
从而呢，达到低耦合

130
00:05:54,010 --> 00:05:57,140
独立地改变对象间的交互

131
00:05:57,140 --> 00:05:58,290
谁改了号码

132
00:05:58,290 --> 00:06:00,070
不需要通知所有人

133
00:06:00,070 --> 00:06:02,310
通知中介就可以了啊

134
00:06:02,310 --> 00:06:05,010
这是呢，中介者模式

135
00:06:06,160 --> 00:06:09,560
再来看第六种，备忘录模式

136
00:06:09,560 --> 00:06:14,060
备忘录模式呢，是做了一个备份

137
00:06:14,060 --> 00:06:16,180
备份是拿来干嘛的呢

138
00:06:16,180 --> 00:06:17,720
拿来恢复的

139
00:06:17,720 --> 00:06:19,720
像我们现在数据库啊

140
00:06:19,720 --> 00:06:22,330
还有电脑都可以去做备份

141
00:06:22,330 --> 00:06:23,810
那备份的话

142
00:06:23,810 --> 00:06:25,750
我们在数据库备份的时候

143
00:06:25,750 --> 00:06:28,880
是不是完整的去建立一个新的数据库呢

144
00:06:28,880 --> 00:06:32,320
并不是只是把数据库文件复制一下诶

145
00:06:32,320 --> 00:06:36,530
放到另一个安全性更好的地方去保存

146
00:06:36,530 --> 00:06:40,340
那这种是不破坏封装的前提

147
00:06:40,340 --> 00:06:43,100
捕获一个呢，对象的内部状态

148
00:06:43,100 --> 00:06:44,740
在这个对象之外呀

149
00:06:44,740 --> 00:06:46,490
来保存这个状态

150
00:06:46,490 --> 00:06:49,360
从而呢，可以来恢复

151
00:06:49,360 --> 00:06:52,000
可以将我们一旦对象出问题了

152
00:06:52,000 --> 00:06:52,900
我们可以将呢

153
00:06:52,900 --> 00:06:56,200
对象恢复到我们原先保存的状态

154
00:06:56,200 --> 00:06:58,580
这就是呢，备忘录模式

155
00:06:58,580 --> 00:07:01,250
第七种，观察者模式

156
00:07:01,250 --> 00:07:03,570
观察者模式的特点呢

157
00:07:03,570 --> 00:07:06,570
在于一对多的联动

158
00:07:09,100 --> 00:07:13,020
它可以啊，定义一个被观察者

159
00:07:13,020 --> 00:07:15,880
然后呢，有多个人来观察这个对象

160
00:07:15,880 --> 00:07:17,260
看起来很恐怖啊

161
00:07:17,260 --> 00:07:19,430
我们在这里呢，有一个实验对象

162
00:07:19,430 --> 00:07:22,290
然后呢，比如说一只小白鼠，诶

163
00:07:22,290 --> 00:07:23,590
呃，比如说动物园吧

164
00:07:23,590 --> 00:07:25,430
动物园里来了一只熊猫

165
00:07:25,430 --> 00:07:29,330
我们有上百个人在那里围观熊猫吧

166
00:07:29,330 --> 00:07:30,660
大家会先

167
00:07:30,660 --> 00:07:32,920
唉，我们呢去注册一下

168
00:07:32,920 --> 00:07:35,250
或者说买个门票去看熊猫

169
00:07:35,250 --> 00:07:36,310
熊猫动了

170
00:07:36,310 --> 00:07:38,910
然后呢，大家哇，它动了是不是

171
00:07:38,910 --> 00:07:40,290
那这种情况下

172
00:07:40,290 --> 00:07:41,750
一般熊猫动了

173
00:07:41,750 --> 00:07:43,780
上百个围观者都会呢

174
00:07:43,780 --> 00:07:46,420
随之产生一些反应吧

175
00:07:46,420 --> 00:07:49,260
这种呢，就是一对多的联动

176
00:07:49,260 --> 00:07:53,110
当一个对象的状态发生变化的时候

177
00:07:53,110 --> 00:07:57,650
所有依赖于它对象都会呢，得到通知

178
00:07:57,650 --> 00:07:59,820
然后呢，自动更新

179
00:07:59,820 --> 00:08:04,010
观察者模式是可以自动更新的

180
00:08:04,010 --> 00:08:05,730
诶，是不是熊猫跟你说

181
00:08:05,730 --> 00:08:07,030
你动一下你才动

182
00:08:07,030 --> 00:08:08,930
不是，是他动了

183
00:08:08,930 --> 00:08:11,530
你随之产生的反应

184
00:08:11,530 --> 00:08:13,520
这就是呢，联动

185
00:08:13,520 --> 00:08:14,780
那这是呢

186
00:08:14,780 --> 00:08:17,460
观察者模式的特点

187
00:08:18,420 --> 00:08:21,600
第八种，状态模式

188
00:08:21,600 --> 00:08:25,380
状态模式呢，它是允许一个对象呢

189
00:08:25,380 --> 00:08:27,820
在它内部状态变化的时

190
00:08:27,820 --> 00:08:29,560
改变他的行动

191
00:08:29,560 --> 00:08:31,230
它的特点是什么呢

192
00:08:31,230 --> 00:08:34,030
会把状态封装成类

193
00:08:34,030 --> 00:08:37,240
它可以结合 u ml 的类图，呃

194
00:08:37,240 --> 00:08:39,039
状态图去理解

195
00:08:39,039 --> 00:08:41,000
那我们在状态图当中

196
00:08:41,000 --> 00:08:43,059
一个节点表示一个状态吧

197
00:08:43,059 --> 00:08:46,340
那这个状态名变成了类名的时候

198
00:08:46,340 --> 00:08:47,440
其实就是呢

199
00:08:47,440 --> 00:08:49,840
状态模式的应用

200
00:08:49,840 --> 00:08:52,680
那我们为什么要划分状态呢

201
00:08:52,680 --> 00:08:56,500
不同的状态可以有不同的行为

202
00:08:56,500 --> 00:08:59,050
比较典型的是什么呢

203
00:08:59,050 --> 00:09:02,130
比如说一些会员制度

204
00:09:02,130 --> 00:09:04,040
它的积分制度的话

205
00:09:04,040 --> 00:09:06,520
由不同的状态诶

206
00:09:06,520 --> 00:09:07,900
比如说金塔

207
00:09:07,900 --> 00:09:11,280
银卡到金卡会考虑积分吧

208
00:09:11,280 --> 00:09:13,260
积分发生变化的话

209
00:09:13,260 --> 00:09:17,630
满足条件就会跳转到金卡会员

210
00:09:17,630 --> 00:09:21,050
那这种呢，就是状态模式

211
00:09:21,770 --> 00:09:24,050
其次，策略模式

212
00:09:24,050 --> 00:09:27,710
策略模式啊，跟状态模式的应用很相似

213
00:09:27,710 --> 00:09:29,930
但不是同样的作用

214
00:09:29,930 --> 00:09:31,940
解决的不是同一个问题

215
00:09:31,940 --> 00:09:34,570
对于策略模式而言的话

216
00:09:34,570 --> 00:09:36,150
它是属于呢

217
00:09:36,150 --> 00:09:39,530
将我们的方案封装起来

218
00:09:39,530 --> 00:09:41,010
封装之后呢

219
00:09:41,010 --> 00:09:44,990
这些方案相互之间可以去切换

220
00:09:44,990 --> 00:09:47,810
那这种解决问题的方案呢

221
00:09:47,810 --> 00:09:51,090
可以理解为我们定义了一系列的算法

222
00:09:51,090 --> 00:09:53,650
把算法进行封装

223
00:09:53,650 --> 00:09:54,870
封装之后

224
00:09:54,870 --> 00:09:58,250
这些算法之间可以互相替代

225
00:09:58,250 --> 00:10:03,830
然后呢，让算法独立于它的用户而变化

226
00:10:03,830 --> 00:10:06,260
那这里谁是类啊

227
00:10:06,260 --> 00:10:07,850
算法是类

228
00:10:07,850 --> 00:10:09,350
方案是类

229
00:10:09,350 --> 00:10:11,150
并不是状态了

230
00:10:11,150 --> 00:10:12,550
那我们为什么说

231
00:10:12,550 --> 00:10:15,240
二者的使用有一定的相似性呢

232
00:10:15,240 --> 00:10:17,850
因为我们在平常去举例的时候

233
00:10:17,850 --> 00:10:19,270
经常会发现呢

234
00:10:19,270 --> 00:10:20,540
策略模式啊

235
00:10:20,540 --> 00:10:24,020
它有一种应用就是根据会员来打折

236
00:10:24,020 --> 00:10:26,510
那这个过程当中

237
00:10:26,510 --> 00:10:30,410
我们虽然看到的是金卡、银卡

238
00:10:30,410 --> 00:10:32,430
但并不是作为状态吧

239
00:10:32,430 --> 00:10:36,190
而是金卡折扣、银卡折扣

240
00:10:36,190 --> 00:10:40,920
然后根据相应的折扣去计算一些东西

241
00:10:40,920 --> 00:10:43,950
计算一些结果来进行反馈

242
00:10:43,950 --> 00:10:48,290
所以二者呢，要注意有一定的区分

243
00:10:48,980 --> 00:10:52,050
第十种，模板方法

244
00:10:52,050 --> 00:10:55,820
模板方法注意它也涉及到算法

245
00:10:55,820 --> 00:10:59,150
但它定义的是算法股价

246
00:10:59,150 --> 00:11:01,760
注意它并不是完整的算法

247
00:11:01,760 --> 00:11:03,810
只是一个框架性的内容

248
00:11:03,810 --> 00:11:04,900
那我们呢

249
00:11:04,900 --> 00:11:06,460
具体的框架

250
00:11:06,460 --> 00:11:07,700
它的骨肉啊

251
00:11:07,700 --> 00:11:09,120
它的肉啊、皮啊

252
00:11:09,120 --> 00:11:10,360
什么时候加呢

253
00:11:10,360 --> 00:11:13,420
在子类当中再去添加

254
00:11:13,420 --> 00:11:17,410
所以它其实是相当于将子类当中啊

255
00:11:17,410 --> 00:11:21,080
所有涉及到的共通的框架

256
00:11:21,080 --> 00:11:22,640
把它呢，提出来

257
00:11:22,640 --> 00:11:25,010
放到了我们的接口当中吧

258
00:11:25,010 --> 00:11:28,990
子类实现的时候去填写这些步骤

259
00:11:28,990 --> 00:11:31,550
他的记忆关键字的话呢

260
00:11:31,550 --> 00:11:33,970
是文档模板填空

261
00:11:33,970 --> 00:11:36,000
比如说我们在签合同的时候

262
00:11:36,000 --> 00:11:39,400
大家会发现一个公司的合同只有那么几套

263
00:11:39,400 --> 00:11:42,270
那这个框架会不会变啊

264
00:11:42,270 --> 00:11:44,670
它有一些需要你填写的地方

265
00:11:44,670 --> 00:11:47,230
会留一条横线或者空格吧

266
00:11:47,230 --> 00:11:51,340
那具体的内容一般呢，都是通用的

267
00:11:51,340 --> 00:11:53,430
这个骨架就是模板

268
00:11:53,430 --> 00:11:57,220
我们每一个人在填写的时候再去呢

269
00:11:57,220 --> 00:12:00,820
将具体的步骤给它呢，写进去

270
00:12:00,820 --> 00:12:02,180
内容写进去

271
00:12:02,180 --> 00:12:04,860
这就是呢模板方法啊

272
00:12:04,860 --> 00:12:06,960
那我们的子类可以呢

273
00:12:06,960 --> 00:12:09,490
不改变它具体的算法结构

274
00:12:09,490 --> 00:12:14,040
就可以呢重新去定义其中的一些特殊的步骤

275
00:12:14,040 --> 00:12:17,330
因为我们可以把这些特定步骤给它抽出来

276
00:12:17,330 --> 00:12:22,380
作为诶，我们的延迟实现的部分

277
00:12:23,030 --> 00:12:26,050
最后第11个设计模式

278
00:12:26,050 --> 00:12:27,830
访问者模式

279
00:12:27,830 --> 00:12:32,360
访问者模式它是将数据与操作分离

280
00:12:32,360 --> 00:12:35,020
所以它也有两个维度

281
00:12:35,020 --> 00:12:37,040
一个维度是数据

282
00:12:37,040 --> 00:12:39,670
一个维度呢是操作

283
00:12:39,670 --> 00:12:42,740
而这个维度与维度之间啊

284
00:12:42,740 --> 00:12:45,380
注意与我们的桥接模式

285
00:12:45,380 --> 00:12:47,820
注意区分桥接模式

286
00:12:47,820 --> 00:12:49,760
将二者联系起来了吧

287
00:12:49,760 --> 00:12:52,160
而访问者模式当中

288
00:12:52,160 --> 00:12:55,990
中间会有一个跳用的过程

289
00:12:55,990 --> 00:12:57,500
调用的时候呢

290
00:12:57,500 --> 00:13:00,140
我们会选择一种访问方式

291
00:13:00,140 --> 00:13:03,590
一旦选择另外两种都没有用了

292
00:13:03,590 --> 00:13:06,110
选择访问方式之后

293
00:13:06,110 --> 00:13:09,890
会依次访问所所有的数据

294
00:13:09,890 --> 00:13:10,890
不能遗漏

295
00:13:10,890 --> 00:13:12,930
必须呢全部访问

296
00:13:12,930 --> 00:13:16,260
这种呢，就叫做访问者模式

297
00:13:16,260 --> 00:13:18,740
那我们在这个过程当中

298
00:13:18,740 --> 00:13:21,400
它对象结构当中的元素啊

299
00:13:21,400 --> 00:13:22,780
基本上是不会呢

300
00:13:22,780 --> 00:13:25,040
去进行一些特殊的变化

301
00:13:25,040 --> 00:13:26,900
我们一般呢，定义的时

302
00:13:26,900 --> 00:13:29,950
都是呢，定义一种新的访问方法

303
00:13:29,950 --> 00:13:32,030
那这个过程当中呢

304
00:13:32,030 --> 00:13:34,550
我们不需要改变各个元素类

305
00:13:34,550 --> 00:13:35,980
这样的一个前提

306
00:13:35,980 --> 00:13:38,560
可以呢定义一些新的操作

307
00:13:38,560 --> 00:13:41,760
增加了一些新的访问方式

308
00:13:41,760 --> 00:13:44,580
这就是呢，访问者模式

309
00:13:44,580 --> 00:13:48,790
这11种设计模式相对于前面来说呢

310
00:13:48,790 --> 00:13:51,170
量就稍微大了一些了

311
00:13:51,170 --> 00:13:54,400
大家呢，注意区分一下中英文拼

312
00:13:54,400 --> 00:13:56,800
以及呢，速记关键字

313
00:13:56,800 --> 00:14:01,050
接下来我们展开来看一下这一部分的类图

314
00:14:01,050 --> 00:14:03,380
对于行为型设计模式啊

315
00:14:03,380 --> 00:14:06,370
它所涉及到的一共呢有11种

316
00:14:06,370 --> 00:14:08,200
相对来说还是比较多的

317
00:14:08,200 --> 00:14:10,500
那我们重点呢，来看一下

318
00:14:10,500 --> 00:14:13,660
在考试当中曾经涉及到的一些类图

319
00:14:13,660 --> 00:14:17,300
其他的那图呢，大家简单了解一下就可以了

320
00:14:17,300 --> 00:14:19,640
首先我们看到在考试当中

321
00:14:19,640 --> 00:14:21,930
涉及较多的观察者模式

322
00:14:21,930 --> 00:14:25,120
观察者模式它的特点呀

323
00:14:25,120 --> 00:14:28,520
是一对多的联动

324
00:14:32,340 --> 00:14:36,040
他也呢，可以叫做订阅的方式

325
00:14:36,040 --> 00:14:39,420
那这种联动是什么样的形式呢

326
00:14:39,420 --> 00:14:43,190
它会有一个被观察的主题

327
00:14:43,190 --> 00:14:46,720
然后呢，根据这个主题呀，抽象

328
00:14:46,720 --> 00:14:48,100
然后给他呢

329
00:14:48,100 --> 00:14:50,060
找到具体的，诶

330
00:14:50,060 --> 00:14:53,620
我们被观察的对象找到之后呢

331
00:14:53,620 --> 00:14:57,940
与之对应的也可以有多个观察者

332
00:14:57,940 --> 00:15:00,860
那这是观察者的抽象类或者接口

333
00:15:00,860 --> 00:15:04,350
那我们的观察者接口有了之后

334
00:15:04,350 --> 00:15:07,370
也有呢，具体的观察者对

335
00:15:07,370 --> 00:15:09,790
有了这些内容之后啊

336
00:15:09,790 --> 00:15:12,630
它们之间是如何联系起来的呢

337
00:15:12,630 --> 00:15:13,960
在考试当中

338
00:15:13,960 --> 00:15:17,830
下午题呢，也出现过细节的一些方式考察

339
00:15:17,830 --> 00:15:20,160
我们简单的给大家介绍一下

340
00:15:20,160 --> 00:15:21,460
代码的内容呢

341
00:15:21,460 --> 00:15:24,260
我们在后面的 java 填空部分呢

342
00:15:24,260 --> 00:15:26,490
再来给大家做一些说明

343
00:15:26,490 --> 00:15:32,360
那首先，观察者模式它的特点在于呢，联动

344
00:15:32,360 --> 00:15:34,050
如何来联动呢

345
00:15:34,050 --> 00:15:37,550
我们的主题存在之后

346
00:15:37,550 --> 00:15:41,590
观察者每参与进来一次呢

347
00:15:41,590 --> 00:15:44,350
我们就给它进行一次添加

348
00:15:44,350 --> 00:15:46,000
或者叫做注册

349
00:15:46,000 --> 00:15:52,250
那注册之后在里面添加了这样的一些，诶

350
00:15:52,250 --> 00:15:53,780
我们的观察者对象

351
00:15:53,780 --> 00:15:55,830
每来一个我们就注册一下

352
00:15:55,830 --> 00:15:57,410
来一个注册一下

353
00:15:57,410 --> 00:15:58,940
那类似于呢

354
00:15:58,940 --> 00:16:01,840
我们在微博当中点关注

355
00:16:01,840 --> 00:16:04,120
可以呢，理解为我们呢

356
00:16:04,120 --> 00:16:06,690
关注了某一个博主

357
00:16:06,690 --> 00:16:08,810
那这个过程当中

358
00:16:08,810 --> 00:16:12,610
其实就是注册我们被观察的对象了

359
00:16:12,610 --> 00:16:15,670
那注册上之后，大家关联起来了

360
00:16:15,670 --> 00:16:16,870
可以有注册

361
00:16:16,870 --> 00:16:18,090
也可以有取消

362
00:16:18,090 --> 00:16:22,150
这就是它的注册和删除的过程

363
00:16:22,560 --> 00:16:24,740
有了这样的过程之后

364
00:16:24,740 --> 00:16:27,790
大家会发现自己关注的博主

365
00:16:27,790 --> 00:16:30,290
一旦有了动态会怎么样啊

366
00:16:30,290 --> 00:16:32,910
给大家发布推送一个

367
00:16:32,910 --> 00:16:34,540
诶，更新的通知吧

368
00:16:34,540 --> 00:16:36,960
那这种推送的过程呢

369
00:16:36,960 --> 00:16:38,980
就有一个通知的过程

370
00:16:38,980 --> 00:16:41,880
那他通知的内容做什么呢

371
00:16:41,880 --> 00:16:44,240
通知的内容就是呢

372
00:16:44,240 --> 00:16:47,960
调用我们具体的观察者对象呢

373
00:16:47,960 --> 00:16:49,380
去做更新

374
00:16:49,380 --> 00:16:52,410
那它会有一个呢更新的动作

375
00:16:52,410 --> 00:16:54,230
这个动作呀，会在呢

376
00:16:54,230 --> 00:16:57,070
我们的被观察者对象里面呢

377
00:16:57,070 --> 00:16:58,740
来进行调用

378
00:16:58,740 --> 00:17:02,290
那这就是呢，我们的订阅模式

379
00:17:02,290 --> 00:17:05,410
或者叫做呢观察者模式

380
00:17:05,470 --> 00:17:08,630
那我们在这里呢，需要注意的是

381
00:17:08,630 --> 00:17:11,359
我们在注册的过程当中啊

382
00:17:11,359 --> 00:17:15,160
一般呢会把对象放到一个呢 list 表单

383
00:17:15,160 --> 00:17:18,450
或者呢这种形式的数组当中

384
00:17:18,450 --> 00:17:23,359
然后通知的时候依次去进行通知就可以了

385
00:17:23,359 --> 00:17:26,710
并不需要呢做过多的一些操作

386
00:17:26,710 --> 00:17:28,770
所以说观察者模式啊

387
00:17:28,770 --> 00:17:32,150
它简化了这种沟通的过程

388
00:17:32,150 --> 00:17:34,830
那这是观察者模式

389
00:17:34,830 --> 00:17:39,120
接下来看一个类似的访问者模式

390
00:17:39,120 --> 00:17:44,470
访问者模式和观察者模式容易混淆

391
00:17:45,410 --> 00:17:47,910
那在这个过程当中呢

392
00:17:47,910 --> 00:17:50,350
我们简单做一下区分

393
00:17:50,350 --> 00:17:52,150
访问者模式

394
00:17:52,150 --> 00:17:56,770
它解决的是数据和访问的分离

395
00:17:56,770 --> 00:17:58,710
那在这个过程当中

396
00:17:58,710 --> 00:18:01,290
我们会有具体的数据

397
00:18:01,290 --> 00:18:04,380
还有呢，具体的访问方式

398
00:18:04,380 --> 00:18:06,850
那与我们的观察者

399
00:18:06,850 --> 00:18:09,330
被观察者来区别一下的话

400
00:18:09,330 --> 00:18:11,800
被观察者其实只有一个

401
00:18:11,800 --> 00:18:14,710
而在访问者模式当中呢

402
00:18:14,710 --> 00:18:19,930
这两个部分都可以发生了比较多的变化

403
00:18:19,930 --> 00:18:24,650
其次，访问者模式与桥接模式的图示呢

404
00:18:24,650 --> 00:18:26,450
也有一定的相似性

405
00:18:26,450 --> 00:18:30,150
它也有呢，两颗继承数的变化

406
00:18:30,150 --> 00:18:34,740
但是这两棵树之间不是直接联系起来的

407
00:18:34,740 --> 00:18:40,040
而是呢，通过我们的应用用程序来进行联系

408
00:18:40,040 --> 00:18:44,440
这个呢，也是我们访问者模式与桥接模式

409
00:18:44,440 --> 00:18:46,840
在图示上的一个区分

410
00:18:46,840 --> 00:18:50,210
那接下来再从细节上来看的话

411
00:18:50,210 --> 00:18:52,030
访问者模式

412
00:18:52,030 --> 00:18:56,720
它是选择某一种具体的访问方式

413
00:18:56,720 --> 00:19:01,480
然后对另一侧的所有源民诉

414
00:19:01,480 --> 00:19:04,040
来进行全部访问

415
00:19:04,040 --> 00:19:07,990
注意，当我们在记录元素的时候

416
00:19:07,990 --> 00:19:11,670
同样呢，也会用一种类似数组的结

417
00:19:11,670 --> 00:19:13,090
把它记录下来

418
00:19:13,090 --> 00:19:14,970
那记录下来之后

419
00:19:14,970 --> 00:19:20,430
我们的访问者只需要依次去进行访问

420
00:19:20,430 --> 00:19:21,470
就可以了

421
00:19:21,470 --> 00:19:27,460
注意这里的元素一定会全部被访问到

422
00:19:27,460 --> 00:19:28,440
那这是呢

423
00:19:28,440 --> 00:19:30,300
访问者过程

424
00:19:30,300 --> 00:19:32,770
访问者模式当中啊

425
00:19:32,770 --> 00:19:36,560
它有两个比较典型的方法

426
00:19:36,560 --> 00:19:41,670
一个呢，是访问者当中有 visit 方法

427
00:19:41,670 --> 00:19:45,070
一个呢，是在我们的元素当

428
00:19:45,070 --> 00:19:49,560
有一个呢，接受访问 accept 方法

429
00:19:49,560 --> 00:19:51,910
这两个方法呢，要注意

430
00:19:51,910 --> 00:19:56,760
它也可以体现我们访问者模式的特点

431
00:19:56,760 --> 00:19:59,350
关于访问者各个部分

432
00:19:59,350 --> 00:20:00,900
它的组成含义

433
00:20:00,900 --> 00:20:04,110
visitor 呢，是他的抽象访问者

434
00:20:04,110 --> 00:20:07,670
下面呢，有具体的访问者元素

435
00:20:07,670 --> 00:20:10,750
它可以定义一个接受访问的操作

436
00:20:10,750 --> 00:20:14,210
访问者会声明一个呢，访问的操作

437
00:20:14,210 --> 00:20:17,270
那下面呢，也可以有具体的诶

438
00:20:17,270 --> 00:20:20,390
接受操作的元素内容

439
00:20:20,390 --> 00:20:23,660
还有一个呢，叫做对象结构类

440
00:20:23,660 --> 00:20:24,830
它可以呢

441
00:20:24,830 --> 00:20:28,690
诶，对我们的访问者和元素结构呢

442
00:20:28,690 --> 00:20:30,240
做一些联系

443
00:20:30,240 --> 00:20:32,410
那这是呢，访问者模式

444
00:20:32,410 --> 00:20:35,030
注意区分它与观察者模式

445
00:20:35,030 --> 00:20:36,870
还有桥接模式呢

446
00:20:36,870 --> 00:20:38,530
不要混淆了

447
00:20:39,160 --> 00:20:42,100
接下来再来看一下状态模式

448
00:20:42,100 --> 00:20:45,060
状态模式的类图比较简单

449
00:20:45,060 --> 00:20:46,600
他的理解呀

450
00:20:46,600 --> 00:20:49,840
我们会发现它有一个抽象的 state 

451
00:20:49,840 --> 00:20:52,200
也就是状态的接口

452
00:20:52,200 --> 00:20:53,930
抽象之后

453
00:20:53,930 --> 00:20:59,060
下面的具体子类都会对应一个状态

454
00:20:59,060 --> 00:21:01,220
所以我们说状态模式

455
00:21:01,220 --> 00:21:04,560
它就是将状态封装成了类

456
00:21:04,560 --> 00:21:08,310
这里的每一个子类都是呢，它的状态

457
00:21:08,310 --> 00:21:11,840
那不同的状态处理方式不一样

458
00:21:11,840 --> 00:21:13,980
所以在状态当中啊

459
00:21:13,980 --> 00:21:16,460
它有一定的处理方式

460
00:21:16,460 --> 00:21:17,600
让我们呢

461
00:21:17,600 --> 00:21:20,700
唉，来进行不同的操作

462
00:21:20,700 --> 00:21:22,180
那这个地方呢

463
00:21:22,180 --> 00:21:24,360
多了一个 contact 

464
00:21:24,360 --> 00:21:27,210
那这一个，哎，是干嘛的呢

465
00:21:27,210 --> 00:21:29,170
它是一个情景类

466
00:21:29,170 --> 00:21:32,940
它其实就是我们应用程序的一个接口

467
00:21:32,940 --> 00:21:36,190
客户应用程序感兴趣的

468
00:21:36,190 --> 00:21:37,710
有兴趣的一个接口

469
00:21:37,710 --> 00:21:38,850
它可以呀

470
00:21:38,850 --> 00:21:42,160
我维护我们相应的状态类

471
00:21:42,160 --> 00:21:45,480
这就是呢，状态模式的过程

472
00:21:45,500 --> 00:21:47,560
职责链模式呢

473
00:21:47,560 --> 00:21:49,560
它的特点是一个呢

474
00:21:49,560 --> 00:21:51,660
层层审批的过程

475
00:21:51,660 --> 00:21:53,930
它的类图没有什么特点

476
00:21:53,930 --> 00:21:55,990
但是它在类当中啊

477
00:21:55,990 --> 00:21:58,030
会有具体的处

478
00:21:58,030 --> 00:22:00,660
以及呢，向上提交的过程

479
00:22:00,660 --> 00:22:06,200
每一层审批必须要有向上提交的这个作用

480
00:22:06,200 --> 00:22:08,220
才能够层层审批

481
00:22:08,220 --> 00:22:12,680
达到呢，这个沿着链传递请求的目的

482
00:22:12,680 --> 00:22:14,610
这就是呢，值得练

483
00:22:14,610 --> 00:22:17,180
它有一个呢，传递者的接

484
00:22:17,180 --> 00:22:19,160
以及具体的传递者

485
00:22:19,160 --> 00:22:22,920
还有呢，相应的客户应用程序

486
00:22:23,350 --> 00:22:25,710
对于命令模式呢

487
00:22:25,710 --> 00:22:29,640
它的特点会将请求封装成对象

488
00:22:29,640 --> 00:22:31,930
那这个地方不是封装成类了

489
00:22:31,930 --> 00:22:33,890
是封装成对象

490
00:22:33,890 --> 00:22:35,670
那我们对命令啊

491
00:22:35,670 --> 00:22:38,250
这个单词呢，表示的是命令

492
00:22:38,250 --> 00:22:41,650
一般在命令模式的类图当中可能会出现

493
00:22:41,650 --> 00:22:44,120
那针对命令模式来看的话

494
00:22:44,120 --> 00:22:46,580
它有一个呢，抽象的命令类

495
00:22:46,580 --> 00:22:50,610
与之对应的就会有呢，具体的命令类

496
00:22:50,610 --> 00:22:53,270
那这个具体的命令类啊

497
00:22:53,270 --> 00:22:56,730
它会将我们的接收者对象诶

498
00:22:56,730 --> 00:22:59,710
绑定一个具体的动作

499
00:22:59,710 --> 00:23:01,250
绑定之后呢

500
00:23:01,250 --> 00:23:04,490
我们的命令是可以被执行的

501
00:23:04,490 --> 00:23:07,370
这是呢，执行命令的过程

502
00:23:07,370 --> 00:23:10,420
那实现这个方法就是呢

503
00:23:10,420 --> 00:23:13,140
调用相应的操作

504
00:23:13,140 --> 00:23:15,540
我们的调用者，哎

505
00:23:15,540 --> 00:23:18,460
invoke 在上面呢，有一个调用

506
00:23:18,460 --> 00:23:23,060
可以呢，要求一个命令对象来执行某一个请求

507
00:23:23,060 --> 00:23:26,000
在这里进行我们的要

508
00:23:26,000 --> 00:23:28,490
相应的描述和调用

509
00:23:28,490 --> 00:23:29,790
接收者

510
00:23:29,790 --> 00:23:31,090
他知道呢

511
00:23:31,090 --> 00:23:35,790
哎，我们应该如何来执行相关的这个请求

512
00:23:35,790 --> 00:23:39,230
最后呢，也有一个应用，应用程序

513
00:23:39,640 --> 00:23:43,220
客户应用程序可以具体去定义

514
00:23:43,220 --> 00:23:45,200
哎，我们的命令是什么

515
00:23:45,200 --> 00:23:48,280
然后呢，我们的接收者是谁

516
00:23:48,280 --> 00:23:51,000
这就是呢，命令模式的类图

517
00:23:51,000 --> 00:23:53,860
了解到他有执行的过程

518
00:23:53,860 --> 00:23:56,420
有方法，它的一个 action 呢

519
00:23:56,420 --> 00:23:59,180
动作的匹配就可以了

520
00:23:59,180 --> 00:24:02,280
接下来看到的是解释器模式

521
00:24:02,280 --> 00:24:04,550
解释器模式相对来说啊

522
00:24:04,550 --> 00:24:06,650
如果大家了解到虚拟机

523
00:24:06,650 --> 00:24:08,580
了解到编译原理的话

524
00:24:08,580 --> 00:24:10,100
就比较好理解了

525
00:24:10,100 --> 00:24:11,400
但我们在这里呢

526
00:24:11,400 --> 00:24:12,820
其实还没有讲到

527
00:24:12,820 --> 00:24:15,110
对于编译的过程来说呢

528
00:24:15,110 --> 00:24:18,750
它是将我们确定的输入，诶

529
00:24:18,750 --> 00:24:20,610
把它呢变成输出

530
00:24:20,610 --> 00:24:23,410
比如我们在一些程序开发语言里面

531
00:24:23,410 --> 00:24:26,750
输入一个语句，诶， print f 

532
00:24:26,750 --> 00:24:29,390
然后 S 等于百分号 D 

533
00:24:29,390 --> 00:24:30,970
然后呢，输出五

534
00:24:30,970 --> 00:24:35,340
那最终的结果会在界面当中输出五

535
00:24:35,340 --> 00:24:37,920
那这中间具体怎么来处理的啊

536
00:24:37,920 --> 00:24:40,070
它有一个转换的规则吧

537
00:24:40,070 --> 00:24:41,980
这个转换的规则呢

538
00:24:41,980 --> 00:24:45,510
就是我们解释器来做的转换

539
00:24:45,510 --> 00:24:47,440
那解释器当中呢

540
00:24:47,440 --> 00:24:50,970
它可以根据文法来进行定义

541
00:24:50,970 --> 00:24:55,800
文法呢，包含非终结符和终结符

542
00:24:55,800 --> 00:24:57,860
所以在这里能够看到呢

543
00:24:57,860 --> 00:25:00,740
非终结的表达式和终结表达

544
00:25:00,740 --> 00:25:04,290
中间呢，有一个转换的过程

545
00:25:04,290 --> 00:25:08,650
那有一个呢，抽象表达式的类作为二者的抽象

546
00:25:08,650 --> 00:25:12,710
然后再由呢，应用程序去进行处

547
00:25:12,710 --> 00:25:16,350
我们相应的，诶，所有的信息

548
00:25:16,350 --> 00:25:21,620
那简单的了解解释器它的过程就可以了

549
00:25:21,620 --> 00:25:25,070
那这是呢，关于解释器的部分

550
00:25:25,070 --> 00:25:27,930
下面看到迭代器模式

551
00:25:27,930 --> 00:25:32,370
迭代器模式呢，目前考代码考得很少

552
00:25:32,370 --> 00:25:36,030
因为我们在相应的 java 当中呢

553
00:25:36,030 --> 00:25:39,210
其实是已经有了迭代器接口的

554
00:25:39,210 --> 00:25:41,520
所以说呢，目前还没有考过

555
00:25:41,520 --> 00:25:43,700
大家自己去写一个迭代期

556
00:25:43,700 --> 00:25:45,480
那针对迭代器

557
00:25:45,480 --> 00:25:47,940
它的作用就是提供一种呢

558
00:25:47,940 --> 00:25:50,460
顺序访问聚合对象的方式

559
00:25:50,460 --> 00:25:51,580
首先的话

560
00:25:51,580 --> 00:25:54,080
它会把我们的对对象啊

561
00:25:54,080 --> 00:25:55,860
把它结合起来

562
00:25:55,860 --> 00:25:58,990
形成了一个聚合对象

563
00:25:58,990 --> 00:26:02,890
针对这种聚合之后的对象呢

564
00:26:02,890 --> 00:26:05,110
我们要访问的时候

565
00:26:05,110 --> 00:26:09,350
它保留了相应的找初始位置

566
00:26:09,350 --> 00:26:12,140
访问下一个对象的过程

567
00:26:12,140 --> 00:26:13,950
那这就是一个呢

568
00:26:13,950 --> 00:26:15,550
按顺序访问

569
00:26:15,550 --> 00:26:18,450
也就是迭代访问的过程

570
00:26:18,450 --> 00:26:23,660
最终呢，也是呢，由应用程序来进行调用的

571
00:26:23,660 --> 00:26:28,320
大致呢，了解迭代器它的迭代过程就可以了

572
00:26:28,320 --> 00:26:29,660
迭代器呢

573
00:26:29,660 --> 00:26:32,700
它可以有顺序访问，哎

574
00:26:32,700 --> 00:26:38,210
一般呢，会用 next 方法来找到下一个元素

575
00:26:38,210 --> 00:26:41,360
那我们呢，在 java 当

576
00:26:41,360 --> 00:26:42,780
迭代器也有呢

577
00:26:42,780 --> 00:26:44,410
这个方法的调用

578
00:26:44,410 --> 00:26:47,210
其他的内容呢，简单看一看

579
00:26:47,210 --> 00:26:49,050
知道呢，具体的迭代器

580
00:26:49,050 --> 00:26:50,610
具体的聚合哎

581
00:26:50,610 --> 00:26:53,170
也就是呢数据对应关系就行了
