1
00:00:00,000 --> 00:00:03,170
接下来看到结构型设计模式

2
00:00:03,170 --> 00:00:05,160
结构型设计模式呢

3
00:00:05,160 --> 00:00:07,860
主要是为了将对象或者类

4
00:00:07,860 --> 00:00:10,660
把它呢，组装成更大的一类呢

5
00:00:10,660 --> 00:00:12,550
结构来进行使用

6
00:00:12,550 --> 00:00:14,720
那在这个过程当中

7
00:00:14,720 --> 00:00:16,640
结构型设计模式啊

8
00:00:16,640 --> 00:00:19,380
它一共呢是有七种

9
00:00:19,380 --> 00:00:20,930
分别是呢

10
00:00:20,930 --> 00:00:24,660
适配器模式、桥接模式、组合模式

11
00:00:24,660 --> 00:00:27,820
装饰模式、外观模式、享元模

12
00:00:27,820 --> 00:00:28,520
以及呢

13
00:00:28,520 --> 00:00:29,580
代理模式

14
00:00:29,580 --> 00:00:32,479
那对于这七种设计模式

15
00:00:32,479 --> 00:00:33,480
大家同样呢

16
00:00:33,480 --> 00:00:35,040
首先第一个维度

17
00:00:35,040 --> 00:00:38,770
记住这七种设计模式的中英文名称

18
00:00:38,770 --> 00:00:42,610
然后呢，依据相应的速记关键字

19
00:00:42,610 --> 00:00:46,490
尽量呢，可以还原出它的这样的一些适用场

20
00:00:46,490 --> 00:00:48,170
来加以理解

21
00:00:48,170 --> 00:00:50,800
那我们首先看到呢，适配器

22
00:00:50,800 --> 00:00:54,420
那适配器我们日常生活当中

23
00:00:54,420 --> 00:00:56,860
经常接触到的就是呢

24
00:00:56,860 --> 00:00:59,010
我们的电源适配器

25
00:00:59,010 --> 00:01:01,600
那我们的家用电源220

26
00:01:01,600 --> 00:01:04,450
手机充电器可能只有呢，24伏

27
00:01:04,450 --> 00:01:06,340
这中间不一样吧

28
00:01:06,340 --> 00:01:07,080
那怎么办

29
00:01:07,080 --> 00:01:09,400
通过适配器来转换

30
00:01:09,400 --> 00:01:11,700
所以它有一个很大的作用呢

31
00:01:11,700 --> 00:01:14,000
就是转换接口

32
00:01:14,630 --> 00:01:18,530
它可以将一个原本不能用的接口呢

33
00:01:18,530 --> 00:01:22,780
转换成我们用户希望得到的另一种接口

34
00:01:22,780 --> 00:01:24,020
转换之后啊

35
00:01:24,020 --> 00:01:26,700
可以使呢，原本不相容的，哎

36
00:01:26,700 --> 00:01:27,900
你的手机直接用

37
00:01:27,900 --> 00:01:30,060
直接用220伏就爆了呀

38
00:01:30,060 --> 00:01:31,460
所以原本不相容

39
00:01:31,460 --> 00:01:33,200
现在增加了一个适配器

40
00:01:33,200 --> 00:01:36,480
从而呢，让它们得以协同工作

41
00:01:36,480 --> 00:01:39,790
那这种抽象起来的过程当中啊

42
00:01:39,790 --> 00:01:43,030
还有一些典型的应用呢，就是翻译

43
00:01:43,030 --> 00:01:44,960
比如说中英文的话

44
00:01:44,960 --> 00:01:47,520
中文和英文之间的相互之间

45
00:01:47,520 --> 00:01:48,960
大家可能听不懂

46
00:01:48,960 --> 00:01:52,660
但一旦中间增加了一个翻译器的话

47
00:01:52,660 --> 00:01:54,430
诶，是不是就解决问题了

48
00:01:54,430 --> 00:01:56,740
所以翻译器啊，它也可以呢

49
00:01:56,740 --> 00:01:58,840
作为适配器来理解

50
00:01:58,840 --> 00:02:01,660
第二种，桥接模式

51
00:02:02,370 --> 00:02:04,350
桥接模式呢

52
00:02:04,350 --> 00:02:05,830
它是将啊

53
00:02:05,830 --> 00:02:08,009
我们整个类呢

54
00:02:08,009 --> 00:02:11,820
抽象部分和实现部分分离开了

55
00:02:11,820 --> 00:02:14,400
那这个分离之后

56
00:02:14,400 --> 00:02:17,500
大家呢，可以独立地产生变化

57
00:02:17,500 --> 00:02:20,770
相当于变化的这两棵树啊

58
00:02:20,770 --> 00:02:23,210
继承数呢，是拆分开的

59
00:02:23,210 --> 00:02:27,290
那它的实现部分有不同的表示，诶

60
00:02:27,290 --> 00:02:29,720
它的具体的抽象部分呢

61
00:02:29,720 --> 00:02:30,980
也有这种呢

62
00:02:30,980 --> 00:02:32,780
诶，不同的变化过程

63
00:02:32,780 --> 00:02:35,360
最终呢，再把它们组合起来

64
00:02:35,360 --> 00:02:38,100
这里呢，一般有一个组合

65
00:02:38,100 --> 00:02:42,300
然后呢，有一个 RNP 来表示拼接

66
00:02:42,300 --> 00:02:44,870
那目前在考试当中啊

67
00:02:44,870 --> 00:02:48,090
也有抽象之后把这一部分省略掉了

68
00:02:48,090 --> 00:02:49,240
所以要知道呢

69
00:02:49,240 --> 00:02:50,720
这种结构一般呢

70
00:02:50,720 --> 00:02:53,250
是属于桥接模式的

71
00:02:53,250 --> 00:02:57,720
它的整个实用的试用的过程当中啊

72
00:02:57,720 --> 00:02:59,200
在日常生活当中

73
00:02:59,200 --> 00:03:01,620
其实呢，也经常可以见到

74
00:03:01,620 --> 00:03:06,100
比如说我们现在所使用的 QQ 或者微信

75
00:03:06,100 --> 00:03:08,480
也包括大家用到的西塞 app 

76
00:03:08,480 --> 00:03:10,160
大家其实都会用

77
00:03:10,160 --> 00:03:13,680
那用的过程大家有没有发现安卓

78
00:03:13,680 --> 00:03:16,230
然后呢，还有苹

79
00:03:16,230 --> 00:03:18,730
他们使用的 app 的系统

80
00:03:18,730 --> 00:03:22,530
包括呢，在 PC 机上其实是不一样的吧

81
00:03:22,800 --> 00:03:27,160
那这是呢，它的系统端的不同的变化

82
00:03:27,160 --> 00:03:31,000
我们呢要做相应的适应性的开发吧

83
00:03:31,000 --> 00:03:32,100
其次

84
00:03:32,100 --> 00:03:35,060
我们在使用西塞相关的

85
00:03:35,060 --> 00:03:36,970
这样的一些软件的时候

86
00:03:36,970 --> 00:03:39,870
会有呢西塞诶，西塞网

87
00:03:39,870 --> 00:03:42,360
还有呢一些公众号啊

88
00:03:42,360 --> 00:03:43,680
还有呢小程序

89
00:03:43,680 --> 00:03:46,910
还有呢 PC 端的话一般呢用浏览器

90
00:03:46,910 --> 00:03:49,130
那不同的这种软件

91
00:03:49,130 --> 00:03:51,010
是不是又有了一个

92
00:03:51,010 --> 00:03:52,440
不同的变化维度啊

93
00:03:52,440 --> 00:03:56,190
那我们呢一般使用的时候选择其中一种

94
00:03:56,190 --> 00:03:59,840
那我们拼接起来是不是才是最终的产品啊

95
00:03:59,840 --> 00:04:04,360
比如说 app ，手机版的西赛 app 

96
00:04:04,360 --> 00:04:06,870
那这就是呢最终的结果

97
00:04:06,870 --> 00:04:08,240
这就是呢，唉

98
00:04:08,240 --> 00:04:12,400
将我们抽象部分实现部分分开之后呢

99
00:04:12,400 --> 00:04:15,440
进行变化的桥接模式

100
00:04:16,310 --> 00:04:19,010
第三种组合模式

101
00:04:19,010 --> 00:04:22,320
组合模式呢，它也是树形结构

102
00:04:22,320 --> 00:04:24,320
但不是多棵树了

103
00:04:24,320 --> 00:04:26,510
它只有呢一棵树

104
00:04:26,510 --> 00:04:29,900
这是我们呢在操作系统当中

105
00:04:29,900 --> 00:04:32,950
经常看到的树形目录结构

106
00:04:32,950 --> 00:04:34,010
比如说呢

107
00:04:34,010 --> 00:04:36,810
唉，我们打开某一个文

108
00:04:36,810 --> 00:04:40,070
和打开其中的文件夹

109
00:04:40,070 --> 00:04:43,760
大家是不是都可以用右键来直接打开呀

110
00:04:43,760 --> 00:04:47,910
那我们在进行树形目录的时候啊

111
00:04:47,910 --> 00:04:51,560
它的地址有拼装这样的一个结构

112
00:04:51,560 --> 00:04:55,250
那拼装之后有整体有部分

113
00:04:55,250 --> 00:04:59,140
这里的部分一般呢会用叶子来表示

114
00:04:59,140 --> 00:05:04,000
整体和部分它们的使用方法是一致的

115
00:05:04,000 --> 00:05:05,580
那这个过程呢

116
00:05:05,580 --> 00:05:07,340
使用具有一致性

117
00:05:07,340 --> 00:05:09,950
就是呢组合模式的特点

118
00:05:09,950 --> 00:05:13,500
典型的就是树形目录结构

119
00:05:14,510 --> 00:05:17,270
第四种，装饰模式

120
00:05:17,270 --> 00:05:21,410
装饰模式呢，它的整个目的在于呢

121
00:05:21,410 --> 00:05:24,100
动态的去附加职责

122
00:05:24,100 --> 00:05:28,490
那这些职责都是作为装饰存在的

123
00:05:28,490 --> 00:05:29,970
可有可无

124
00:05:29,970 --> 00:05:34,230
那我们需要的时候就用了子类的形式

125
00:05:34,230 --> 00:05:35,980
把它呢扩展出来

126
00:05:35,980 --> 00:05:37,160
替换上去

127
00:05:37,160 --> 00:05:39,040
或者说呢，添加上去

128
00:05:39,040 --> 00:05:41,750
那这个呢，就是装饰模式

129
00:05:41,750 --> 00:05:43,740
那比较常见的

130
00:05:43,740 --> 00:05:46,640
比如说大家现在奶茶文化很火啊

131
00:05:46,640 --> 00:05:50,220
大家点奶茶的时候会有珍珠奶茶

132
00:05:50,220 --> 00:05:52,060
会有椰果奶茶

133
00:05:52,060 --> 00:05:54,520
那我们现在是不是经常可以

134
00:05:54,520 --> 00:05:56,730
珍珠奶茶加椰果啊

135
00:05:56,730 --> 00:05:58,190
那这个过程当中

136
00:05:58,190 --> 00:06:01,730
我们有没有必要说珍珠奶茶、椰果奶茶

137
00:06:01,730 --> 00:06:03,480
珍珠椰果奶茶

138
00:06:03,480 --> 00:06:07,140
珍珠布丁奶茶、珍珠椰果布丁奶

139
00:06:07,140 --> 00:06:09,000
这样去派生子类呀

140
00:06:09,000 --> 00:06:10,010
没有必要

141
00:06:10,010 --> 00:06:13,270
这种派生就太夸张了

142
00:06:13,280 --> 00:06:15,040
我们直接呢

143
00:06:15,040 --> 00:06:18,840
将奶茶、珍珠、椰果、布丁等

144
00:06:18,840 --> 00:06:21,650
全臀部作为装饰的子类

145
00:06:21,650 --> 00:06:24,310
然后在实例化的过程当中

146
00:06:24,310 --> 00:06:27,870
你点了我们就把它呢添加上去

147
00:06:27,870 --> 00:06:31,070
这种呢，就是动态添加职责

148
00:06:31,070 --> 00:06:33,670
也就是呢，装饰模式

149
00:06:33,670 --> 00:06:35,050
那这是呢

150
00:06:35,050 --> 00:06:36,360
装饰模式

151
00:06:36,360 --> 00:06:39,270
第五种，外观模式

152
00:06:39,310 --> 00:06:43,940
外观模式呢，它也是统一接口

153
00:06:43,940 --> 00:06:46,620
但它是对外来统一

154
00:06:46,620 --> 00:06:49,820
对内是不是一个转换接口呢

155
00:06:49,820 --> 00:06:50,710
不是

156
00:06:50,710 --> 00:06:51,980
它的内部啊

157
00:06:51,980 --> 00:06:54,620
其实更多的针对的是子系统

158
00:06:54,620 --> 00:06:57,480
或者说一组接口的变化

159
00:06:57,480 --> 00:07:00,310
那我们在做一些过渡的时候

160
00:07:00,310 --> 00:07:03,910
也许呢你有七个、八个这样的一些子系统

161
00:07:03,910 --> 00:07:07,620
但我们可能只通过一个菜单来调用

162
00:07:07,620 --> 00:07:12,850
那这种呢，其实也是属于对外提供一致的外观

163
00:07:12,850 --> 00:07:15,900
它是呢，定义了一个高层的接口

164
00:07:15,900 --> 00:07:18,670
将子系统呢封装起来

165
00:07:18,670 --> 00:07:22,040
从而呢，提供了一致对外的外观

166
00:07:22,040 --> 00:07:24,840
那内部到底怎么做转换

167
00:07:24,840 --> 00:07:27,140
就是开发去解决的问题

168
00:07:27,140 --> 00:07:30,040
我们使用的时候需要知道吗

169
00:07:30,040 --> 00:07:30,900
不需要

170
00:07:30,900 --> 00:07:33,720
也许我就是一个按钮的使用

171
00:07:33,720 --> 00:07:37,440
但内部会做呢一些复杂的处理

172
00:07:37,440 --> 00:07:40,240
这就是呢外观模式

173
00:07:40,870 --> 00:07:42,190
第六种

174
00:07:42,190 --> 00:07:43,780
响源模式

175
00:07:43,780 --> 00:07:45,350
想圆模式

176
00:07:45,350 --> 00:07:49,490
它所针对的是大量的细粒度的对象

177
00:07:49,490 --> 00:07:51,640
比如说文字

178
00:07:51,640 --> 00:07:55,430
那我们在写一篇文章的过程当中

179
00:07:55,430 --> 00:07:56,670
不同的文章

180
00:07:56,670 --> 00:07:59,580
我们就要有不同的这样的实践过程吧

181
00:07:59,580 --> 00:08:03,280
那我们的文章肯定是千差万别

182
00:08:03,280 --> 00:08:05,500
我们要生成多少对象啊

183
00:08:05,500 --> 00:08:06,360
很麻烦

184
00:08:06,360 --> 00:08:10,320
但如果说英文我们只生成26个字母雷

185
00:08:10,320 --> 00:08:11,660
那这种情况下

186
00:08:11,660 --> 00:08:14,960
就大大的节约了我们这样的过程

187
00:08:14,960 --> 00:08:16,780
所以它可以啊

188
00:08:16,780 --> 00:08:20,870
支持大量的细粒度的对象来进行共享

189
00:08:20,870 --> 00:08:22,180
共享之后呢

190
00:08:22,180 --> 00:08:24,020
再把它放在一起

191
00:08:24,020 --> 00:08:27,420
组成我们最终需要的结果

192
00:08:27,420 --> 00:08:30,460
这就是呢想源模式

193
00:08:31,550 --> 00:08:34,370
第七种，代理模式

194
00:08:34,370 --> 00:08:35,650
代理模式呢

195
00:08:35,650 --> 00:08:40,750
它提供的是对这个对象的控制访问

196
00:08:40,750 --> 00:08:42,840
那说到代理的话

197
00:08:42,840 --> 00:08:44,039
我们在这里啊

198
00:08:44,039 --> 00:08:47,240
在平常生活当中经常会

199
00:08:47,240 --> 00:08:49,550
诶，看到一些代理商吧

200
00:08:49,550 --> 00:08:53,160
那我们在跟代理商买东西的时候

201
00:08:53,160 --> 00:08:55,620
最终这个东西从哪里发货呢

202
00:08:55,620 --> 00:08:58,100
还是厂家发货

203
00:08:58,100 --> 00:09:00,820
所以啊，在这个过程当中

204
00:09:00,820 --> 00:09:03,380
具体的访问方式没变

205
00:09:03,380 --> 00:09:06,460
只是呢，中间增加了一个结构

206
00:09:06,460 --> 00:09:08,220
这个结构有什么好处啊

207
00:09:08,220 --> 00:09:11,480
我们说在层次与层次之间增加一个层次

208
00:09:11,480 --> 00:09:13,620
可以呢降低它的耦合度

209
00:09:13,620 --> 00:09:17,900
那这里只是呢，提供了一种访问方式

210
00:09:18,220 --> 00:09:21,460
典型的还有呢，快捷方式

211
00:09:21,460 --> 00:09:25,640
那我们在电脑桌面上生成快捷方式

212
00:09:25,640 --> 00:09:28,080
可以直接打开某一个程序吧

213
00:09:28,080 --> 00:09:30,760
但大它打开的方式是什么

214
00:09:30,760 --> 00:09:35,910
是通过我们的代理找到他的目标路径

215
00:09:35,910 --> 00:09:38,820
找到目标程序再去打开吧

216
00:09:38,820 --> 00:09:40,780
在这个过程当中

217
00:09:40,780 --> 00:09:44,540
内部的打开过程是没有变化的

218
00:09:44,540 --> 00:09:45,380
变化的

219
00:09:45,380 --> 00:09:51,580
只是这种访问方式可以控制对内部的访问

220
00:09:51,580 --> 00:09:55,230
那这里呢，就是我们给大家介绍到

221
00:09:55,230 --> 00:09:57,190
结构型设计模式

222
00:09:57,190 --> 00:09:59,550
一共呢，有七种

223
00:09:59,550 --> 00:10:01,830
这七种设计模式呢

224
00:10:01,830 --> 00:10:05,240
我们再展开简单看一看它的类图

225
00:10:05,240 --> 00:10:08,820
类图这一部分不不要求大家呢

226
00:10:08,820 --> 00:10:10,580
能够完全的记住

227
00:10:10,580 --> 00:10:13,900
听一听呢，有个大概的印象就可以了

228
00:10:13,900 --> 00:10:15,750
在考试当中啊

229
00:10:15,750 --> 00:10:17,370
对类图的考察

230
00:10:17,370 --> 00:10:22,540
我们呢，是要求大家能够通过特殊的类名判断

231
00:10:22,540 --> 00:10:24,040
也就呢，可以了

232
00:10:24,040 --> 00:10:26,830
结构的判断呢，并没有做要求

233
00:10:26,830 --> 00:10:29,630
那首先看到桥接模式

234
00:10:29,630 --> 00:10:35,810
桥接模式会将它的抽象部分和实现部分

235
00:10:35,810 --> 00:10:38,970
分离成两棵不同的树

236
00:10:38,970 --> 00:10:41,100
抽象部分可以有呢

237
00:10:41,100 --> 00:10:42,340
具体的，诶

238
00:10:42,340 --> 00:10:45,330
扩充它有不同的抽象部分

239
00:10:45,330 --> 00:10:48,480
然后呢，实现部分也可以呢

240
00:10:48,480 --> 00:10:51,570
唉，抽出来发生了不同的变化

241
00:10:51,570 --> 00:10:53,590
那这个变化呢

242
00:10:53,590 --> 00:10:57,340
唉，可以有具体的 A 变化或者 B 变化

243
00:10:57,340 --> 00:11:01,170
最终呢，还是会以一个 IMP 

244
00:11:01,170 --> 00:11:03,870
这种桥接组合的方式呢

245
00:11:03,870 --> 00:11:06,890
来返回最终的结果

246
00:11:06,890 --> 00:11:07,890
clint 

247
00:11:07,890 --> 00:11:10,850
还是呢，用客户的应用程

248
00:11:10,850 --> 00:11:14,270
来调用我们最终的结果

249
00:11:14,270 --> 00:11:16,740
那这些组成部分当中

250
00:11:16,740 --> 00:11:20,010
包括抽象定义的抽象类接口

251
00:11:20,010 --> 00:11:21,990
实现类的接

252
00:11:21,990 --> 00:11:24,640
以及具体的实现类

253
00:11:24,640 --> 00:11:26,230
那还包括呢

254
00:11:26,230 --> 00:11:30,520
我们使用这一部分的客户应用程序

255
00:11:30,520 --> 00:11:31,980
桥接模式

256
00:11:31,980 --> 00:11:35,900
它是呢将继承数进行了拆分

257
00:11:35,900 --> 00:11:39,350
两棵树分开发生变化

258
00:11:39,350 --> 00:11:40,420
那这是呢

259
00:11:40,420 --> 00:11:41,720
桥接

260
00:11:42,780 --> 00:11:45,610
再来看组合模式

261
00:11:45,610 --> 00:11:48,700
组合模式只有一棵树了

262
00:11:48,700 --> 00:11:51,340
而这一棵树当中呢

263
00:11:51,340 --> 00:11:53,940
我们会有叶子节点

264
00:11:53,940 --> 00:11:56,750
哎，这是呢最底层的叶子节点

265
00:11:56,750 --> 00:11:58,970
叶子节点还可以呢

266
00:11:58,970 --> 00:12:01,000
做一些组合拼装

267
00:12:01,000 --> 00:12:03,010
那叶子部件的话

268
00:12:03,010 --> 00:12:05,190
是属于呢比较细粒度的

269
00:12:05,190 --> 00:12:09,300
拼装起来呢，还可以有组合的这种类型

270
00:12:09,300 --> 00:12:12,260
组合类型和叶子类型啊

271
00:12:12,260 --> 00:12:14,460
都是属于部件型

272
00:12:14,460 --> 00:12:16,660
它的这种接口的实现

273
00:12:16,660 --> 00:12:19,640
那我们在使用过程当中

274
00:12:19,640 --> 00:12:24,810
这三个部分它的使用是具有一致性的

275
00:12:24,810 --> 00:12:30,180
所以呀，我们的组合模式看起来成层次是有的

276
00:12:30,180 --> 00:12:33,060
但是不同层次使用方式呢

277
00:12:33,060 --> 00:12:35,130
仍然是一致的

278
00:12:35,130 --> 00:12:38,260
它也有整体与部分的划分

279
00:12:38,260 --> 00:12:40,610
但大家呢，用起来都一样

280
00:12:40,610 --> 00:12:43,610
典型的就是呢树形目录结构

281
00:12:43,610 --> 00:12:44,890
那在这里

282
00:12:44,890 --> 00:12:48,540
client 同样呢，是我们的客户应用程序

283
00:12:48,540 --> 00:12:54,560
可以通过接口来访问具体的叶子或者组合

284
00:12:54,560 --> 00:12:55,560
不见

285
00:12:56,730 --> 00:12:59,470
第三种，适配器模式

286
00:12:59,470 --> 00:13:04,230
适配器模式的目的就在于呢，做接口转换

287
00:13:04,230 --> 00:13:07,530
典型的就是电源适配器

288
00:13:07,530 --> 00:13:12,030
那我们转换的过程当中会有呢，目标接口，哎

289
00:13:12,030 --> 00:13:15,570
这是我们最终想要得到的24伏，哎

290
00:13:15,570 --> 00:13:17,530
适配器转换之后的结果

291
00:13:17,530 --> 00:13:21,830
然后呢，还有一个待转换的接口

292
00:13:21,830 --> 00:13:25,570
那这个接口的话是我们想要用的

293
00:13:25,570 --> 00:13:27,330
但是呢，用不了的

294
00:13:27,330 --> 00:13:30,440
那比如说呢，这就是220伏的，诶

295
00:13:30,440 --> 00:13:33,000
家用的电压谁来做转换

296
00:13:33,000 --> 00:13:35,790
由适配器来做转换

297
00:13:35,790 --> 00:13:37,000
它可以呢

298
00:13:37,000 --> 00:13:39,140
通过转换的方式

299
00:13:39,140 --> 00:13:44,130
将最终的结果与目的接口呢，统一起来

300
00:13:44,130 --> 00:13:48,100
那这就是呢，我们转换的目的

301
00:13:48,100 --> 00:13:51,230
那这里面涉及到的目的类

302
00:13:51,230 --> 00:13:53,790
唉，我们目标抽象类

303
00:13:53,790 --> 00:13:57,770
它定义的是我们需要的这种领域的接口

304
00:13:57,770 --> 00:14:00,120
适配器的工接口

305
00:14:00,120 --> 00:14:03,620
那这里呢，是作为调用的过程

306
00:14:03,620 --> 00:14:05,910
作为一个转换器存在的

307
00:14:05,910 --> 00:14:07,830
还有呢，母接口

308
00:14:07,830 --> 00:14:10,730
这是我们需要接入的地方

309
00:14:10,730 --> 00:14:12,270
客户调

310
00:14:12,270 --> 00:14:17,190
同样呢，是客户的应用程序来协调使用

311
00:14:17,190 --> 00:14:19,670
它主要呢，是做转换

312
00:14:19,670 --> 00:14:24,920
将我们220伏电压转换成24伏的，诶

313
00:14:24,920 --> 00:14:27,170
充电器来使用

314
00:14:27,170 --> 00:14:28,720
那这是呢，我们

315
00:14:28,720 --> 00:14:30,920
哎，具体的转换过程

316
00:14:30,920 --> 00:14:31,760
这就是呢

317
00:14:31,760 --> 00:14:33,630
适配器模式

318
00:14:33,630 --> 00:14:36,050
第四种，装饰模式

319
00:14:36,050 --> 00:14:37,490
装饰模式呢

320
00:14:37,490 --> 00:14:39,910
它将所有需要的东西啊

321
00:14:39,910 --> 00:14:43,110
都作为呢，装饰的子类

322
00:14:43,110 --> 00:14:45,670
然后呢，将子类啊

323
00:14:45,670 --> 00:14:49,690
需要的内容在实例化到我们的目标当中

324
00:14:49,690 --> 00:14:52,670
从而呢，得到最终的结果

325
00:14:52,670 --> 00:14:55,010
那在这个过程当中呢

326
00:14:55,010 --> 00:15:00,640
我们会有部件来定义对象的接口

327
00:15:00,640 --> 00:15:01,830
那这里呢

328
00:15:01,830 --> 00:15:04,010
诶，我们在部件里面可以呢

329
00:15:04,010 --> 00:15:06,880
通过部件把这些东西呢，拼起来

330
00:15:06,880 --> 00:15:10,050
那部件的话就会有具体的有接

331
00:15:10,050 --> 00:15:11,650
就有具体的类了

332
00:15:11,650 --> 00:15:14,040
具体的布线内呢，可以啊

333
00:15:14,040 --> 00:15:17,190
给他呢，额外来增加一些职责

334
00:15:17,190 --> 00:15:19,660
这里的具体装饰

335
00:15:19,660 --> 00:15:22,950
这一般呢，装饰是一个抽象类

336
00:15:22,950 --> 00:15:25,250
那这个抽象类可以呢

337
00:15:25,250 --> 00:15:29,600
维护我们内部的内有的这些部件

338
00:15:29,600 --> 00:15:35,190
也可以呢生成一系列相关的装饰子类

339
00:15:35,190 --> 00:15:37,900
那我们具体的装饰子类呢

340
00:15:37,900 --> 00:15:40,260
在需要的时候就可以呢

341
00:15:40,260 --> 00:15:43,860
给我们的这个部件对象来增加

342
00:15:43,860 --> 00:15:44,800
职责

343
00:15:44,800 --> 00:15:50,040
动态的添加职责是装饰模式的特点

344
00:15:50,540 --> 00:15:53,520
它的具体添加过程啊

345
00:15:53,520 --> 00:15:58,000
一般呢，是可以通过实例化作为参数

346
00:15:58,000 --> 00:15:59,970
把它添加进去的

347
00:15:59,970 --> 00:16:02,150
那就是装饰模式

348
00:16:02,150 --> 00:16:05,210
接下来看到外观模式

349
00:16:05,210 --> 00:16:10,050
外观模式它会定义一个高层的接口

350
00:16:10,050 --> 00:16:13,320
将内部的一组接口呢

351
00:16:13,320 --> 00:16:14,720
封装起来

352
00:16:14,720 --> 00:16:17,290
那我们具体对外呢

353
00:16:17,290 --> 00:16:19,080
是统一了一个外观

354
00:16:19,080 --> 00:16:23,840
这个统一的外观是如何来协调内部操作的

355
00:16:23,840 --> 00:16:26,040
是开发过程来决定的

356
00:16:26,040 --> 00:16:27,340
它可以呢

357
00:16:27,340 --> 00:16:30,660
方便我们从外部来调用它

358
00:16:30,660 --> 00:16:34,430
简化这个调用的过程并没有呢

359
00:16:34,430 --> 00:16:37,950
哎，具体的去修改内部的子系统

360
00:16:37,950 --> 00:16:39,190
那这就是呢

361
00:16:39,190 --> 00:16:40,590
外观模式

362
00:16:40,590 --> 00:16:42,560
它有一个呢，外形类

363
00:16:42,560 --> 00:16:47,060
还有呢，相应的子系统类在它的内部

364
00:16:47,060 --> 00:16:50,800
那这是呢，关于外观模式的使用

365
00:16:50,800 --> 00:16:53,860
第六种，向圆模式

366
00:16:53,860 --> 00:16:55,440
享元模式呢

367
00:16:55,440 --> 00:16:58,700
它主要是为了提供我们大量的一些呢

368
00:16:58,700 --> 00:17:02,130
唉，尤其是细粒度对象的共享

369
00:17:02,130 --> 00:17:03,590
它相对来说呢

370
00:17:03,590 --> 00:17:05,750
这种对象啊，是非常

371
00:17:05,750 --> 00:17:07,530
力度是非常细的

372
00:17:07,530 --> 00:17:10,099
我们只有呢，一点点的一些东西

373
00:17:10,099 --> 00:17:12,200
那这样一点点的东西呢

374
00:17:12,200 --> 00:17:13,440
再把它作为

375
00:17:13,440 --> 00:17:16,020
诶，我们所需要的内容

376
00:17:16,020 --> 00:17:18,319
作为一个整体来出现

377
00:17:18,319 --> 00:17:19,829
那我们在这里呢

378
00:17:19,829 --> 00:17:22,890
会抽象轻量级的一个类

379
00:17:22,890 --> 00:17:24,630
唉，这是一个类接口

380
00:17:24,630 --> 00:17:26,530
它是抽象轻量级

381
00:17:26,530 --> 00:17:32,620
下面呢，有具体的可以共享的和不可以共享的

382
00:17:32,620 --> 00:17:34,070
这样的轻量类

383
00:17:34,070 --> 00:17:36,700
那有了这些类之后

384
00:17:36,700 --> 00:17:38,360
唉，有的是可共享

385
00:17:38,360 --> 00:17:41,500
有的是不可共享的这些啊

386
00:17:41,500 --> 00:17:44,280
具体的内容再通过呢

387
00:17:44,280 --> 00:17:48,040
客户应用程序来进行调用

388
00:17:48,040 --> 00:17:53,650
从而呢，去使用相应的这些呢，细粒度的对象

389
00:17:53,650 --> 00:17:56,720
那这里涉及到的就是呢

390
00:17:56,720 --> 00:17:59,610
我们的想源模式

391
00:17:59,610 --> 00:18:01,010
代理模式呢

392
00:18:01,010 --> 00:18:05,080
它会有一个我们真正想要访问的对象

393
00:18:05,080 --> 00:18:07,770
那对于这个对象而言的话

394
00:18:07,770 --> 00:18:10,250
我们可以提供代理的方式

395
00:18:10,250 --> 00:18:13,280
也可以进行直接访问的方式

396
00:18:13,280 --> 00:18:18,360
他们继承同一个抽象的这个对象接口

397
00:18:18,360 --> 00:18:22,450
哎，抽象我们实体想要访问对象的接口

398
00:18:22,450 --> 00:18:25,610
它们的访问方式其实是一样的

399
00:18:25,610 --> 00:18:27,420
所以我们可以呢

400
00:18:27,420 --> 00:18:30,760
通过这个代理来进行访问，诶

401
00:18:30,760 --> 00:18:35,260
从而呢，避免直接访问我们的实体对象呢

402
00:18:35,260 --> 00:18:37,950
那我们在代理的过程当中呢

403
00:18:37,950 --> 00:18:40,670
唉，同样是由用户程序

404
00:18:40,670 --> 00:18:44,520
最终呢，通过我们的高层接口来决定

405
00:18:44,520 --> 00:18:47,430
最终是哪一种方式来访问的

406
00:18:47,430 --> 00:18:52,690
远程代理、虚拟代理、保护代理都是呢，代理模

407
00:18:52,690 --> 00:18:55,890
它的应用大家呢，可以看一看

408
00:18:55,890 --> 00:18:57,430
远程代理的话

409
00:18:57,430 --> 00:19:00,630
它是呢，向不同的地址空间中的实体啊

410
00:19:00,630 --> 00:19:02,030
发送一些请求

411
00:19:02,030 --> 00:19:03,390
虚拟代理的话

412
00:19:03,390 --> 00:19:06,200
它是呢，缓存实体的地址信息

413
00:19:06,200 --> 00:19:07,570
保护在你呢

414
00:19:07,570 --> 00:19:11,890
它是啊，在检查我们的请求是否呢

415
00:19:11,890 --> 00:19:14,210
是不是有所需要的权限

416
00:19:14,210 --> 00:19:16,870
这里呢，大致知道就可以了

417
00:19:16,870 --> 00:19:19,520
这是呢，代理的几种方式

418
00:19:19,520 --> 00:19:22,250
那针对代理模式的类

419
00:19:22,250 --> 00:19:25,900
知道呢，它的大致结构就可以了

420
00:19:25,900 --> 00:19:29,120
下面呢，我们来看一下结构型设计模式

421
00:19:29,120 --> 00:19:32,520
在软件设计师考试真题当中的体现

422
00:19:32,520 --> 00:19:35,200
那下面这道题

423
00:19:36,040 --> 00:19:41,440
首先假设现在我们要创建一个 web 的应用框架

424
00:19:41,440 --> 00:19:44,480
然后呢，基于此框架的话

425
00:19:44,480 --> 00:19:48,360
可以创建不同的具体 web 应用

426
00:19:48,360 --> 00:19:49,860
比如说呢唉

427
00:19:49,860 --> 00:19:53,640
具体的应用有博客、新闻网站、网上商店

428
00:19:53,640 --> 00:19:57,530
并可以为美各 web 应用的话

429
00:19:57,530 --> 00:20:00,180
创建不同的主题样式

430
00:20:00,180 --> 00:20:02,720
那比如说深色和浅色

431
00:20:02,720 --> 00:20:03,060
诶

432
00:20:03,060 --> 00:20:07,160
我们发现有一种变化是博客

433
00:20:07,160 --> 00:20:10,460
新闻网站以及网上商店

434
00:20:10,460 --> 00:20:15,640
有一种变化是主题深色或者浅色

435
00:20:15,640 --> 00:20:18,180
那这里有什么样的特点啊

436
00:20:18,180 --> 00:20:22,410
我们发现它其实是两个维度的变化吧

437
00:20:22,410 --> 00:20:26,920
并且他们拆分成了独立的两个呢继承数

438
00:20:26,920 --> 00:20:29,690
最终在使用的过程当中

439
00:20:29,690 --> 00:20:32,130
比如说我们有一个唉

440
00:20:32,130 --> 00:20:33,570
net 的 story 

441
00:20:33,570 --> 00:20:37,820
有一个深色或者就是呢浅色的商店

442
00:20:37,820 --> 00:20:40,880
那这种拼接过程是不是很熟悉呢

443
00:20:40,880 --> 00:20:44,860
诶，这一业务需要的类图采用如下所示

444
00:20:44,860 --> 00:20:46,400
诶，什么样的模式啊

445
00:20:46,400 --> 00:20:49,870
这个是属于桥接模式

446
00:20:51,120 --> 00:20:56,350
这里还没有讲到访问者模式啊

447
00:20:56,350 --> 00:21:01,570
访问者模式与桥接模式有一定的相似性

448
00:21:01,570 --> 00:21:03,990
那有什么样的区别呢

449
00:21:03,990 --> 00:21:06,760
如果是访问者模式

450
00:21:06,760 --> 00:21:12,630
他会选择其中一种方式来顺序访问

451
00:21:12,630 --> 00:21:16,380
另一侧的所有清单条目

452
00:21:16,380 --> 00:21:20,200
一般呢，另一侧是 item 条目

453
00:21:20,200 --> 00:21:23,050
然后呢，依次去进行访问

454
00:21:23,050 --> 00:21:24,890
那我们这里很显然

455
00:21:24,890 --> 00:21:28,250
我们的目标是进行拼接吧

456
00:21:28,250 --> 00:21:31,190
并不是说去进行访问的

457
00:21:31,190 --> 00:21:34,180
那访问者模式选择这种模式之后

458
00:21:34,180 --> 00:21:37,070
另外一种访问方式呢，就不需要了

459
00:21:37,070 --> 00:21:39,100
这里的话，我们是可以呢

460
00:21:39,100 --> 00:21:41,340
产生不同的组合的

461
00:21:41,340 --> 00:21:46,450
所以访问者模式和桥接模式呢，是不一样的

462
00:21:46,450 --> 00:21:50,160
那在这个类图当中有没有看到桥

463
00:21:50,160 --> 00:21:52,180
唉，有没有看到 IMPR 

464
00:21:52,180 --> 00:21:53,040
没有看到

465
00:21:53,040 --> 00:21:54,200
有没有看到组

466
00:21:54,200 --> 00:21:55,490
也没有看到

467
00:21:55,490 --> 00:22:00,320
所以这道题呢，其实是考试当中较难的题型

468
00:22:00,320 --> 00:22:06,170
根据没有特殊描述的这种类图来判断

469
00:22:06,170 --> 00:22:11,390
那我们可以根据这里的情景描述

470
00:22:11,390 --> 00:22:14,820
告诉我们两个维度的变化了

471
00:22:14,820 --> 00:22:18,780
那这种呢，一般就是桥接模式

472
00:22:18,850 --> 00:22:23,030
接下来判断出它的设计模式之后

473
00:22:23,030 --> 00:22:29,550
其中哪一个是客户程序使用的主要接口

474
00:22:29,550 --> 00:22:34,610
那我们看到这是应用程序的框架吧

475
00:22:34,610 --> 00:22:36,830
唉，这是具体的应用

476
00:22:38,280 --> 00:22:40,560
这是主题

477
00:22:41,400 --> 00:22:43,100
那大家想一想

478
00:22:43,100 --> 00:22:44,220
作为一个客户

479
00:22:44,220 --> 00:22:46,620
你用的是应用还是主题呀

480
00:22:46,620 --> 00:22:50,070
很明显我们用到的是应用吧

481
00:22:50,070 --> 00:22:54,120
所以我们用到的主要接口，哎

482
00:22:54,120 --> 00:22:55,400
这里有两个接口

483
00:22:55,400 --> 00:22:56,560
一个是应用接口

484
00:22:56,560 --> 00:22:57,760
一个是主题接口

485
00:22:57,760 --> 00:23:01,060
应该呢是应用接口

486
00:23:01,400 --> 00:23:04,180
其次呢，我们会看到啊

487
00:23:04,180 --> 00:23:07,460
B 选项和 D 选项是底一层的

488
00:23:07,460 --> 00:23:10,020
具体实现类并不是接口

489
00:23:10,020 --> 00:23:13,390
所以主要区分的就是呢，上面两个接口

490
00:23:13,390 --> 00:23:16,440
它对于客户程序来看的话

491
00:23:16,440 --> 00:23:18,990
是什么样的一个作用

492
00:23:18,990 --> 00:23:23,050
那我们在这里如果不了解怎么办呢

493
00:23:23,050 --> 00:23:26,320
我们会发现后面还有一句描述

494
00:23:26,320 --> 00:23:30,840
它可以维护对主题类型的应用

495
00:23:30,840 --> 00:23:32,840
主题类型在哪里啊

496
00:23:32,840 --> 00:23:34,120
在这里

497
00:23:34,120 --> 00:23:39,090
所以维持对它的应用是谁来维持的

498
00:23:39,090 --> 00:23:42,280
由这一部分来维持的

499
00:23:42,280 --> 00:23:45,380
从这里呀，我们也能够知道呢

500
00:23:45,380 --> 00:23:51,290
哎，根据我们的题干已有信息排除掉主题了

501
00:23:51,290 --> 00:23:53,450
所以他选择的呢

502
00:23:53,450 --> 00:23:56,550
是应用程序的接口

503
00:23:56,550 --> 00:23:59,820
那这个模式是什么类型的呢

504
00:23:59,820 --> 00:24:04,760
哎，它的分类应该是结构型对象模式

505
00:24:04,760 --> 00:24:08,450
这个模式的主要意图是什么呢

506
00:24:08,450 --> 00:24:13,290
A 选项将抽象部分与实线部分分离

507
00:24:13,290 --> 00:24:14,770
独立发生变

508
00:24:14,770 --> 00:24:17,670
是桥接模式的特点

509
00:24:18,270 --> 00:24:19,650
D 选项

510
00:24:19,650 --> 00:24:23,390
动态的给一个对象添加一些额外的职责

511
00:24:23,390 --> 00:24:24,650
是谁的特点啊

512
00:24:24,650 --> 00:24:27,670
是装饰模式的特点

513
00:24:28,420 --> 00:24:29,780
C 选项

514
00:24:29,780 --> 00:24:33,360
为其他对象提供一种代理

515
00:24:33,360 --> 00:24:35,580
以控制对对象的访问

516
00:24:35,580 --> 00:24:38,020
它是呢代理模式

517
00:24:38,340 --> 00:24:39,640
D 选项

518
00:24:39,640 --> 00:24:40,920
当一个类的

519
00:24:40,920 --> 00:24:45,160
将一个类的接口转换成希望的另一个接口

520
00:24:45,160 --> 00:24:47,360
接口转换适配

521
00:24:47,360 --> 00:24:49,060
它的一个使用

522
00:24:52,180 --> 00:24:55,260
那这是呢适配器它的意图

523
00:24:55,260 --> 00:24:57,470
那这里四个选项当中

524
00:24:57,470 --> 00:25:01,900
A 选项才是桥接模式的使用意图

525
00:25:01,900 --> 00:25:05,670
都可以呢根据我们的关键字来进行

526
00:25:05,670 --> 00:25:08,380
进行一些呢还原的工作

527
00:25:08,380 --> 00:25:11,940
那这些呢就是结构型设计模式
