1
00:00:00,000 --> 00:00:02,580
下面再看到中介者模式

2
00:00:02,580 --> 00:00:06,410
中介者模式呢，它是我们客户啊

3
00:00:06,410 --> 00:00:10,750
相应的沟通过程当中增加了中介者

4
00:00:10,750 --> 00:00:12,530
那在这里的话

5
00:00:12,530 --> 00:00:18,050
我们呢，定义了相应的中介者接口

6
00:00:18,050 --> 00:00:21,610
以及具体的中介者角色

7
00:00:21,870 --> 00:00:23,390
定义之后

8
00:00:23,390 --> 00:00:25,870
我们还有呢，相应的同事类

9
00:00:25,870 --> 00:00:29,150
或者可以把它理解为啊，我们的客户

10
00:00:29,150 --> 00:00:33,090
那这些客户具体的客户也会有相应的接口吧

11
00:00:33,090 --> 00:00:36,520
我们一般会抽象更高的层次来进行交互

12
00:00:36,520 --> 00:00:40,070
那我们在这些客户过程当中呢

13
00:00:40,070 --> 00:00:43,630
每一个客户都应该知道谁是中介

14
00:00:43,630 --> 00:00:47,470
大家都只需要与中介来进行沟通

15
00:00:47,470 --> 00:00:50,240
客户与客户之间有没有路径啊

16
00:00:50,240 --> 00:00:51,860
是没有路径的

17
00:00:51,860 --> 00:00:53,900
大家的交互交互方式啊

18
00:00:53,900 --> 00:00:56,720
都是与中介来进行绑定的

19
00:00:56,720 --> 00:00:59,560
这就是呢，中介者模式的特点

20
00:00:59,560 --> 00:01:01,390
它使得我们对象啊

21
00:01:01,390 --> 00:01:03,510
不需要直接来交互了

22
00:01:03,510 --> 00:01:07,000
相对来说呢，耦合度会比较低

23
00:01:07,000 --> 00:01:10,840
那原本对象与对象之间是，诶

24
00:01:10,840 --> 00:01:15,310
大家一对多的来相互的形成沟通路径

25
00:01:15,310 --> 00:01:18,060
但是有了中介者之后

26
00:01:18,060 --> 00:01:22,210
所有的沟通路径都是与中介者来沟通

27
00:01:22,210 --> 00:01:25,980
比如说有一个人原本的对象一

28
00:01:25,980 --> 00:01:28,790
他电话号码发生了变化

29
00:01:28,790 --> 00:01:30,570
如果没有中介者

30
00:01:30,570 --> 00:01:34,280
他要给其他五个对象全都发消息吧

31
00:01:34,280 --> 00:01:39,060
但是现在我们只需要告诉中介者就可以了

32
00:01:39,060 --> 00:01:43,690
这就能降低了与其他对象之间的耦合度

33
00:01:43,690 --> 00:01:47,160
那这就是呢，中介者模式的过程

34
00:01:47,160 --> 00:01:50,000
下面再来看备忘录模式

35
00:01:50,000 --> 00:01:51,610
备忘录模式啊

36
00:01:51,610 --> 00:01:55,630
是在呢，我们原有的基础上去给它呢

37
00:01:55,630 --> 00:01:58,950
做一个相应的内部状态的备份

38
00:01:58,950 --> 00:02:00,430
所以它的核心呢

39
00:02:00,430 --> 00:02:02,420
其实就是做备份

40
00:02:02,420 --> 00:02:04,930
那我们在做备份的时候

41
00:02:04,930 --> 00:02:09,150
诶，知道呢，他会通过某一个唉方式

42
00:02:09,150 --> 00:02:12,290
把我们的备份记录下来就可以了

43
00:02:12,290 --> 00:02:14,130
那在这个过程当中

44
00:02:14,130 --> 00:02:17,400
如果我们要进行一些还原的话

45
00:02:17,400 --> 00:02:18,320
就可以呢

46
00:02:18,320 --> 00:02:22,120
直接通过管理者来进行还原

47
00:02:22,120 --> 00:02:24,480
那在这里我们会有呢

48
00:02:24,480 --> 00:02:27,740
诶，相应的原始数据

49
00:02:27,740 --> 00:02:30,540
对原始数据保留下来

50
00:02:30,540 --> 00:02:32,230
形成备忘录

51
00:02:32,230 --> 00:02:33,960
里面会有一些呢

52
00:02:33,960 --> 00:02:37,620
相应的内部状态来进行记录

53
00:02:37,620 --> 00:02:40,860
那这就是脑备忘录模式

54
00:02:41,850 --> 00:02:46,600
策略模式呢，它与状态模式比较相似

55
00:02:46,600 --> 00:02:50,910
但是我们会发现它在封装的过程当中

56
00:02:50,910 --> 00:02:54,930
针对的是一种具体的策略方案

57
00:02:54,930 --> 00:02:56,990
而不是状态了

58
00:02:56,990 --> 00:02:59,130
所以它们的区分其实在于

59
00:02:59,130 --> 00:03:01,550
一个将状态封装成类

60
00:03:01,550 --> 00:03:05,310
一个呢，将一个完整的算法封装成类

61
00:03:05,310 --> 00:03:08,250
那这个过程呢，就是策略模式

62
00:03:08,250 --> 00:03:11,380
策略模式呢，也会有情景类

63
00:03:11,380 --> 00:03:16,620
来确定最终自己所选择的策略到底是谁

64
00:03:16,620 --> 00:03:18,680
那策略者模式呢

65
00:03:18,680 --> 00:03:19,910
策略模式啊

66
00:03:19,910 --> 00:03:23,230
大家呢，知道这种定义算法的过

67
00:03:23,230 --> 00:03:25,340
来封装就可以了

68
00:03:25,340 --> 00:03:28,480
模板方法也会说到算法

69
00:03:28,480 --> 00:03:32,560
但它定义的类并不是算法类

70
00:03:32,560 --> 00:03:36,770
他会呀，将我们在特定过程当中

71
00:03:36,770 --> 00:03:41,140
比如说呢，大家都有一些固定的框架

72
00:03:41,140 --> 00:03:46,460
那我们每一次只需要修改某一个特定步骤的

73
00:03:46,460 --> 00:03:47,260
实际内

74
00:03:47,260 --> 00:03:48,260
就可以了

75
00:03:48,260 --> 00:03:51,710
我们就可以呢，将框架抽象出来

76
00:03:51,710 --> 00:03:53,180
形成一个类

77
00:03:53,180 --> 00:03:55,520
这种框架抽象出来之后

78
00:03:55,520 --> 00:03:58,940
在子类当中实现具体的步骤

79
00:03:58,940 --> 00:04:01,500
就是呢，模板方法的作用

80
00:04:01,500 --> 00:04:03,790
它就是将实现步骤呢

81
00:04:03,790 --> 00:04:07,570
某一些步骤延迟到子类当中来实现

82
00:04:07,570 --> 00:04:10,760
那这就是你的模板方法啊

83
00:04:11,270 --> 00:04:13,090
这些类图啊

84
00:04:13,090 --> 00:04:14,130
相对来说呢

85
00:04:14,130 --> 00:04:18,050
在考试当中一般是可以看到类名

86
00:04:18,050 --> 00:04:19,899
从而进行辨别的

87
00:04:19,899 --> 00:04:21,430
如果没有

88
00:04:21,430 --> 00:04:24,940
也可以根据应用场景来分析

89
00:04:24,940 --> 00:04:29,330
如果还是找不到对应的 A 设计模式

90
00:04:29,330 --> 00:04:30,410
还可以呢

91
00:04:30,410 --> 00:04:34,970
从其他关联问题或者选项当中呢

92
00:04:34,970 --> 00:04:36,730
去进行排除

93
00:04:36,730 --> 00:04:40,030
从而呢，找到正确的答案

94
00:04:40,030 --> 00:04:43,540
下面我们再来看一下关于呢

95
00:04:43,540 --> 00:04:44,360
设计模

96
00:04:44,360 --> 00:04:46,300
在真题当中的一些呢

97
00:04:46,300 --> 00:04:47,720
其他的考察

98
00:04:47,720 --> 00:04:50,350
唉，我们的行为型设计模式

99
00:04:50,350 --> 00:04:53,040
接下来我们来看一下

100
00:04:53,040 --> 00:04:55,390
我们相应的设计模式啊

101
00:04:55,390 --> 00:04:58,650
在软件设计师考试真题当中的体现

102
00:04:58,650 --> 00:05:00,610
那后面这些试题呢

103
00:05:00,610 --> 00:05:04,040
就是以行为型设计模式为主了

104
00:05:04,040 --> 00:05:07,540
那下面是一道综合考察的题型

105
00:05:07,540 --> 00:05:09,870
它的考察形式就是呢

106
00:05:09,870 --> 00:05:12,470
将相应的设计模式名称

107
00:05:12,470 --> 00:05:16,000
与它适合应用的场景匹配起来

108
00:05:16,000 --> 00:05:20,140
那首先呢，第一空以下哪个设计模式

109
00:05:20,140 --> 00:05:23,660
能够动态的给一些对象来添加一些呢

110
00:05:23,660 --> 00:05:25,420
额外的职责

111
00:05:25,420 --> 00:05:29,870
而不需要呢，去修改我们的对象结构

112
00:05:29,870 --> 00:05:32,230
动态添加额外职责

113
00:05:32,230 --> 00:05:36,020
这是呢，很明确的装饰器的模式

114
00:05:36,020 --> 00:05:38,110
它是呢，通过装饰

115
00:05:38,110 --> 00:05:42,600
最终呢，可以通过实例化将职责添加上去

116
00:05:42,600 --> 00:05:44,530
其他选项当中

117
00:05:44,530 --> 00:05:47,840
组合模式，它体现的是整体与部分

118
00:05:47,840 --> 00:05:49,810
并且整体与部分啊

119
00:05:49,810 --> 00:05:53,960
能够呢用统一一致性的方式去使用

120
00:05:53,960 --> 00:05:56,640
典型的就是树形目录结构

121
00:05:56,640 --> 00:05:58,110
第二个选项

122
00:05:58,110 --> 00:05:59,330
外观模式

123
00:05:59,330 --> 00:06:02,830
它主要呢，应用于对子系统进行屏蔽

124
00:06:02,830 --> 00:06:05,220
把子系统封装起来之后

125
00:06:05,220 --> 00:06:07,760
用统一的外观对外

126
00:06:07,760 --> 00:06:11,150
那我们呢，操作起来就简单了很多

127
00:06:11,150 --> 00:06:13,490
C 选项的响人模式呢

128
00:06:13,490 --> 00:06:16,540
它是细粒度的这种呢形式

129
00:06:16,540 --> 00:06:21,140
它主要啊，针对的就是细粒度对象的共享

130
00:06:21,140 --> 00:06:24,960
典型的就是文字对象共享的形式

131
00:06:24,960 --> 00:06:28,680
那第二空以下哪一个设计模式

132
00:06:28,680 --> 00:06:32,720
定义了一个用于创建对象的接口

133
00:06:32,720 --> 00:06:33,240
诶

134
00:06:33,240 --> 00:06:34,740
创建对象的接口

135
00:06:34,740 --> 00:06:38,410
让子类来决定实例化哪一个类

136
00:06:38,410 --> 00:06:42,140
那这是很典型的创建型设计模式吧

137
00:06:42,140 --> 00:06:44,400
下面的四个选项当中

138
00:06:44,400 --> 00:06:46,460
其实只有 A 选项

139
00:06:46,460 --> 00:06:50,940
工厂方法是我们的创建型的设计模式

140
00:06:50,940 --> 00:06:53,040
工厂方法可以呢

141
00:06:53,040 --> 00:06:56,420
将实例化过程延迟到子类当中

142
00:06:56,420 --> 00:07:00,320
与它相似的有呢，抽象工厂

143
00:07:00,320 --> 00:07:03,850
它是呢，将一系列的这样的对象

144
00:07:03,850 --> 00:07:07,610
可以呢，成系列的用工厂来生

145
00:07:07,710 --> 00:07:09,830
其他的选项

146
00:07:09,830 --> 00:07:13,700
显然，模式是结构型行为模式

147
00:07:13,700 --> 00:07:15,860
而结构型的设计模式

148
00:07:15,860 --> 00:07:18,520
而观察者和中介者呢

149
00:07:18,520 --> 00:07:21,610
是典型的行为型设计模式

150
00:07:21,610 --> 00:07:25,650
想人模式我们刚刚呢，已经介绍过了

151
00:07:25,650 --> 00:07:30,490
观察者模式呢，它体现的是一对多的联动

152
00:07:30,490 --> 00:07:32,230
中介者模式

153
00:07:32,230 --> 00:07:37,000
它主要呢，是解决了我们的沟通的方式

154
00:07:37,000 --> 00:07:38,540
原本大家呢

155
00:07:38,540 --> 00:07:41,660
是一个对象与五个对象相互之间啊

156
00:07:41,660 --> 00:07:42,790
做一些交互

157
00:07:42,790 --> 00:07:46,340
现在呢，为了解决这种交互问题

158
00:07:46,340 --> 00:07:48,680
我们在中间引入中介者

159
00:07:48,680 --> 00:07:51,590
大家呢，都与中介者来交互

160
00:07:51,590 --> 00:07:57,270
它可以啊，降低对象与对象之间交互的耦合度

161
00:07:57,270 --> 00:08:01,050
所以呢，中介者是可以呢解耦的

162
00:08:01,170 --> 00:08:02,770
第三题

163
00:08:02,770 --> 00:08:06,690
想要使一个后端的数据模

164
00:08:06,690 --> 00:08:11,550
能够呢，被多个前端的用户界面联系起来

165
00:08:11,550 --> 00:08:13,550
那这个过程当

166
00:08:13,550 --> 00:08:16,410
是由一个后端数据模型

167
00:08:16,410 --> 00:08:19,940
与多个，诶，用户界面进行连接吧

168
00:08:19,940 --> 00:08:25,880
它们之间的连接其实就是一个交互的过程

169
00:08:25,880 --> 00:08:29,460
那这种有多个交互过程的

170
00:08:29,460 --> 00:08:32,520
用哪一种设计模式会比较好呢

171
00:08:32,520 --> 00:08:35,760
应该是用中介者模式

172
00:08:35,760 --> 00:08:38,659
下面的四个选项当中

173
00:08:38,659 --> 00:08:42,080
装饰者模式和响人模式呢

174
00:08:42,080 --> 00:08:44,380
是结构型的设计模式

175
00:08:44,380 --> 00:08:47,550
装饰模式是动态添加职责

176
00:08:47,550 --> 00:08:50,510
而享源是细粒度的共享

177
00:08:50,510 --> 00:08:55,980
观察者模式更多的是体现一对多的联动

178
00:08:55,980 --> 00:09:01,260
那这种联动的过程需要主动地去做连接嘛

179
00:09:01,260 --> 00:09:02,500
不需要它

180
00:09:02,500 --> 00:09:07,180
更多的是当被观察者发生一些变化的时候

181
00:09:07,180 --> 00:09:10,580
观察者随之发生变化

182
00:09:10,580 --> 00:09:13,730
它体现的是这种联动变化的过程

183
00:09:13,730 --> 00:09:16,450
那我们这里更加强调的是

184
00:09:16,450 --> 00:09:18,930
连接或者说交互的过程

185
00:09:18,930 --> 00:09:20,740
这种交互过程呢

186
00:09:20,740 --> 00:09:24,680
用中介者方式可以简化交互过程

187
00:09:24,680 --> 00:09:28,540
所以第三空选择的是 D 选项

188
00:09:28,540 --> 00:09:32,360
那这种考察形式就是文字性的叙述

189
00:09:32,360 --> 00:09:33,880
它的应用场景

190
00:09:33,880 --> 00:09:38,240
从而呢找到匹配的设计模式名称

191
00:09:39,040 --> 00:09:41,100
下面再来看呢

192
00:09:41,100 --> 00:09:44,400
接下来的这道题是结合设计模式

193
00:09:44,400 --> 00:09:45,910
类图的考察

194
00:09:45,910 --> 00:09:48,240
自动售货机可以呢

195
00:09:48,240 --> 00:09:54,310
根据库存、存放、货币量、找币能力、所选项目等不同

196
00:09:54,310 --> 00:09:57,940
在货币存入并进行选择

197
00:09:57,940 --> 00:10:00,300
进行如下的行为

198
00:10:00,300 --> 00:10:02,320
唉，交付产品不找零

199
00:10:02,320 --> 00:10:04,170
交付产品并找零

200
00:10:04,170 --> 00:10:07,420
存入，货币不足而不提供产品

201
00:10:07,420 --> 00:10:10,440
库存不足而不提供任何产品

202
00:10:10,440 --> 00:10:11,680
那这是什么

203
00:10:11,680 --> 00:10:15,320
这是应用场景的描述

204
00:10:15,320 --> 00:10:18,780
那应用场景它告诉我们呢

205
00:10:18,780 --> 00:10:23,450
在存入的时候选择相应的行为

206
00:10:23,450 --> 00:10:27,940
那这种根据一定策略来选行为的话

207
00:10:27,940 --> 00:10:32,070
其实很相似的就是状态模式和策略模式了

208
00:10:32,070 --> 00:10:33,690
这道题当中啊

209
00:10:33,690 --> 00:10:36,760
它是结合类图来考察

210
00:10:36,760 --> 00:10:38,600
这一个业务需求

211
00:10:38,600 --> 00:10:41,180
我们适合采用哪一个设计模式

212
00:10:41,180 --> 00:10:43,320
类图如下所示

213
00:10:43,320 --> 00:10:45,630
那我们说判断类图

214
00:10:45,630 --> 00:10:48,910
根据类图来识别设计模式的时候

215
00:10:48,910 --> 00:10:51,680
第一个层次的识别是什么

216
00:10:51,680 --> 00:10:55,190
找具有代表性的类名

217
00:10:55,190 --> 00:11:00,050
这个 status 呢，是很明显的状态模式的，诶

218
00:11:00,050 --> 00:11:01,400
它的一个代称吧

219
00:11:01,400 --> 00:11:05,420
所以这道题他选择的就是状态模式

220
00:11:05,420 --> 00:11:09,780
将相应的一些呢，状态封装成类

221
00:11:09,780 --> 00:11:12,210
在不同的状态当中呢

222
00:11:12,210 --> 00:11:14,890
有对应的一些行为

223
00:11:14,890 --> 00:11:16,310
所以这道题啊

224
00:11:16,310 --> 00:11:19,510
如果说看我们的应用场景

225
00:11:19,510 --> 00:11:21,130
你没有看明白的话

226
00:11:21,130 --> 00:11:23,850
从类图你也应该呢

227
00:11:23,850 --> 00:11:27,520
来找到相应的这个，诶，类名

228
00:11:27,520 --> 00:11:30,410
从而呢，找到它的设计模式名称

229
00:11:30,410 --> 00:11:32,070
这种考察题型

230
00:11:32,070 --> 00:11:36,550
在我们考试当中出现的还是比较多的

231
00:11:36,550 --> 00:11:38,750
那这道题其实呢

232
00:11:38,750 --> 00:11:40,250
也有类似的一道

233
00:11:40,250 --> 00:11:43,470
下午加下午的面向对象程序设计题

234
00:11:43,470 --> 00:11:46,770
考的是一个纸巾的售货系统

235
00:11:46,770 --> 00:11:51,720
那我们现在呢，再来看后面对类图的具体考察

236
00:11:51,720 --> 00:11:54,850
其中哪一部分是使用

237
00:11:54,850 --> 00:11:58,740
是我们客户应用程序使用的主要接口

238
00:11:58,740 --> 00:12:01,160
那我们在这个当中呢

239
00:12:01,160 --> 00:12:05,500
还可以用状态来来对它进行配置

240
00:12:05,500 --> 00:12:09,550
客户程序使用的主要应用程接口

241
00:12:09,550 --> 00:12:10,870
那我们想一想

242
00:12:10,870 --> 00:12:12,950
客户程序是不是一般

243
00:12:12,950 --> 00:12:15,850
跟我们右侧的部分是分离的

244
00:12:15,850 --> 00:12:19,720
这个 by 其实就是我们购买的客户应用程序

245
00:12:19,720 --> 00:12:22,440
应用程序使用的是什么呢

246
00:12:22,440 --> 00:12:25,310
应该是另一端的接口

247
00:12:25,310 --> 00:12:29,630
所以第二空问的选项呢

248
00:12:29,630 --> 00:12:33,870
应该是我们的 A 选项

249
00:12:35,150 --> 00:12:38,430
根据它的调用过程来看

250
00:12:38,430 --> 00:12:41,550
这个接口才是我们所需要的

251
00:12:41,550 --> 00:12:44,970
那我们这个模式是什么类型呢

252
00:12:44,970 --> 00:12:48,900
状态模式，它是典型的行为型模式

253
00:12:48,900 --> 00:12:51,300
我们说过在考试当中啊

254
00:12:51,300 --> 00:12:54,850
目前没有涉及到类模式的考察

255
00:12:54,850 --> 00:12:59,650
它也是呢，行为型对象模式啊

256
00:12:59,650 --> 00:13:01,130
行为型模式

257
00:13:01,130 --> 00:13:02,710
涉及到类模式的

258
00:13:02,710 --> 00:13:05,940
应该呢，只会看到解释器模式

259
00:13:05,940 --> 00:13:10,230
目前解释器在软式考试当中考的并不多

260
00:13:10,230 --> 00:13:12,470
那我们的状态模式

261
00:13:12,470 --> 00:13:14,730
它主要的意图是什么呢

262
00:13:14,730 --> 00:13:16,830
ABCD 4个选项

263
00:13:16,830 --> 00:13:17,700
A 选项

264
00:13:17,700 --> 00:13:21,820
状态发一个对象的状态发生改变的时候

265
00:13:21,820 --> 00:13:24,680
所有依赖它的对象都得到通知

266
00:13:24,680 --> 00:13:25,620
随之更新

267
00:13:25,620 --> 00:13:28,360
那这个其实是观察者模式

268
00:13:28,360 --> 00:13:29,800
他的意图吧

269
00:13:29,980 --> 00:13:34,760
B 选项，在不破坏封装的前提下

270
00:13:34,760 --> 00:13:37,340
捕获对象的内部状态

271
00:13:37,340 --> 00:13:41,150
并且呢，在对象之外来进行保存

272
00:13:41,150 --> 00:13:43,120
我们保存的是什么

273
00:13:43,120 --> 00:13:45,420
保存的其实就是备份

274
00:13:45,420 --> 00:13:48,840
那就是呢，备忘录模式的作用

275
00:13:50,980 --> 00:13:54,560
C 选项在一个对象啊

276
00:13:54,560 --> 00:13:57,380
在它内部状态改变的时候

277
00:13:57,380 --> 00:13:59,290
改变他的行为

278
00:13:59,290 --> 00:14:02,430
那这里其实就是内部状态改变

279
00:14:02,430 --> 00:14:05,240
有随之对应的行为改变吧

280
00:14:05,240 --> 00:14:07,700
所以这是呢状态模式

281
00:14:07,700 --> 00:14:10,380
也就是本题的意图

282
00:14:10,380 --> 00:14:14,130
D 选项将请求封装为对象

283
00:14:14,130 --> 00:14:15,950
从而呢可以根据啊

284
00:14:15,950 --> 00:14:17,530
我们使用不同的请

285
00:14:17,530 --> 00:14:20,100
对客户来进行参数化

286
00:14:20,100 --> 00:14:21,980
这是呢命令模式

287
00:14:21,980 --> 00:14:23,540
它的意图

288
00:14:24,320 --> 00:14:26,500
那这道题主要呢

289
00:14:26,500 --> 00:14:31,760
是对状态、模式以及它的类图的一个简单考察

290
00:14:32,490 --> 00:14:36,310
下面再来看一道复杂一些的题型

291
00:14:36,310 --> 00:14:41,650
假设现在要创建一个简单的超市销售系统

292
00:14:41,650 --> 00:14:47,400
客户将毛巾、饼干、酸奶等物品加入购物车

293
00:14:47,400 --> 00:14:52,600
在收银台人工或者自动的来进行收银

294
00:14:52,600 --> 00:14:53,000
唉

295
00:14:53,000 --> 00:14:58,380
将购物车当中的每一个物品的价格进行汇总

296
00:14:58,380 --> 00:15:00,380
汇总到总价格当中呢

297
00:15:00,380 --> 00:15:01,580
来进行结账

298
00:15:01,580 --> 00:15:05,080
这个业务需要的类图如下所示

299
00:15:05,080 --> 00:15:08,760
前面给的同样是应用场景

300
00:15:08,760 --> 00:15:12,190
这道题也是呢结合类图的考察

301
00:15:12,190 --> 00:15:16,330
但是我们会发现这道题的类土

302
00:15:16,330 --> 00:15:20,890
对于我们的类名是没有实际的诶

303
00:15:20,890 --> 00:15:23,920
它对我们的设计模式是没有对应关系的

304
00:15:23,920 --> 00:15:27,260
这是呢，对现实世界抽象出来的

305
00:15:27,260 --> 00:15:30,310
一定具有一定含义的类名了

306
00:15:30,310 --> 00:15:33,200
那我们现在需要什么样的设计模式

307
00:15:33,200 --> 00:15:36,050
采用了如下的类图

308
00:15:36,050 --> 00:15:40,320
那我们发现这个 item 条目清单

309
00:15:40,320 --> 00:15:45,320
其实是访问者模式经常出现的一类形式吧

310
00:15:45,320 --> 00:15:48,400
那它有一些细碎的条目

311
00:15:48,400 --> 00:15:50,910
并且定义了一些方式

312
00:15:50,910 --> 00:15:53,550
每一种方式选定之后

313
00:15:53,550 --> 00:15:57,100
会对所有的条目来进行汇总

314
00:15:57,100 --> 00:16:00,670
虽然看起来有两棵不同的树

315
00:16:00,670 --> 00:16:04,730
但是它们之间并不是直接连接的吧

316
00:16:04,730 --> 00:16:07,670
而是通过一些其他的结构来连接

317
00:16:07,670 --> 00:16:10,480
所以它不会呢，是桥接

318
00:16:10,480 --> 00:16:15,660
那我们在这里会不会是状观察者模式呢

319
00:16:15,860 --> 00:16:17,660
观察者模式

320
00:16:17,660 --> 00:16:22,150
它有一侧是只有一个被观察者对象的

321
00:16:22,150 --> 00:16:24,720
然后有多个观察者

322
00:16:24,720 --> 00:16:29,360
那这里显然呢，也不满足一对多的联动

323
00:16:29,360 --> 00:16:33,220
策略模式是将策略进行封装

324
00:16:33,220 --> 00:16:37,950
然后选择策略之后呢，去进行计算

325
00:16:37,950 --> 00:16:40,620
但我们这个方式当中

326
00:16:40,620 --> 00:16:44,890
策略需不需要考虑另一端的东西啊

327
00:16:44,890 --> 00:16:46,500
是不需要的

328
00:16:46,500 --> 00:16:48,480
所以在这里看起来

329
00:16:48,480 --> 00:16:52,060
好像与策略也有一定的相似关系

330
00:16:52,060 --> 00:16:57,400
但是策略会将这些内容写在策略本身里面

331
00:16:57,400 --> 00:16:59,580
封装成算法策略

332
00:16:59,580 --> 00:17:01,900
而不是呢像本题一

333
00:17:01,900 --> 00:17:04,990
把我们的数据放在了一侧

334
00:17:04,990 --> 00:17:08,410
访问方式放在了另一侧

335
00:17:08,410 --> 00:17:13,530
所以这是将数据和数据的使用拆分开了

336
00:17:13,530 --> 00:17:17,240
这是典型的访问者模式

337
00:17:17,240 --> 00:17:18,700
除此以外

338
00:17:18,700 --> 00:17:22,010
我们在后面的选项当中会看到

339
00:17:22,010 --> 00:17:24,119
以下有一个部

340
00:17:24,119 --> 00:17:25,300
定义了一个呢

341
00:17:25,300 --> 00:17:31,100
以 check out 对象为参数的 ACACCEPT 操作

342
00:17:31,100 --> 00:17:33,610
那这个 up accept 操作

343
00:17:33,610 --> 00:17:36,600
其实我们在讲类图的时候提到过

344
00:17:36,600 --> 00:17:40,440
它是一个接受访问的操作吧

345
00:17:41,330 --> 00:17:43,750
谁来接受访问呢

346
00:17:43,750 --> 00:17:47,880
应该是条目来接受访问

347
00:17:47,880 --> 00:17:50,480
由子类来具体实现

348
00:17:50,480 --> 00:17:52,300
那下面是子妹类

349
00:17:52,300 --> 00:17:53,910
我们在这里呢

350
00:17:53,910 --> 00:17:57,550
定义相应操作的是谁呢

351
00:17:57,550 --> 00:17:59,730
应该是条目

352
00:17:59,730 --> 00:18:02,210
所以选择 A 选项

353
00:18:02,210 --> 00:18:06,860
这里呢，可以理解为条目或者元素数据

354
00:18:06,860 --> 00:18:09,620
那这个模式是什么样的模式呢

355
00:18:09,620 --> 00:18:12,170
它是一个行为型设计模式

356
00:18:12,170 --> 00:18:13,250
那我们说呢

357
00:18:13,250 --> 00:18:16,190
在这里基本上涉及到的都是

358
00:18:16,190 --> 00:18:19,130
行为型对象模式

359
00:18:19,130 --> 00:18:23,230
适合于什么样的诶场景呢

360
00:18:23,230 --> 00:18:26,330
A 选项必须保存一个对象

361
00:18:26,330 --> 00:18:29,950
在某一时刻的部分状态

362
00:18:29,950 --> 00:18:32,430
那这种保存的过程

363
00:18:32,430 --> 00:18:35,220
其实就是拿来做备份恢复的吧

364
00:18:35,220 --> 00:18:37,430
所以 A 选项它是呢

365
00:18:37,430 --> 00:18:40,320
备忘录设计模式的意图

366
00:18:40,320 --> 00:18:44,440
B 选项想要在不明确指定接收者的情况下呢

367
00:18:44,440 --> 00:18:47,860
向多个对象当中的一个来提交请求

368
00:18:47,860 --> 00:18:50,810
那这一个不能处理的话怎么办

369
00:18:50,810 --> 00:18:52,380
向上去提交

370
00:18:52,380 --> 00:18:55,190
它是一个层层审批的过程

371
00:18:55,190 --> 00:18:57,530
也就是呢职责链

372
00:18:57,530 --> 00:19:00,070
它的呢，唉，使用过程

373
00:19:02,440 --> 00:19:06,860
C 选项需要一个对象结构当中的对象了

374
00:19:06,860 --> 00:19:11,440
然后呢，进行需要对一个对象结构当中的对象

375
00:19:11,440 --> 00:19:16,190
进行很多不同的并且不相关的操作

376
00:19:16,190 --> 00:19:18,650
那这种不相关的操作

377
00:19:18,650 --> 00:19:21,670
其实与我们刚刚看到的这种

378
00:19:21,670 --> 00:19:24,160
人工结账和自助结账

379
00:19:24,160 --> 00:19:25,200
很相似吧

380
00:19:25,200 --> 00:19:28,980
它其实就是将我们数据和它的操作

381
00:19:28,980 --> 00:19:30,280
来进行分离

382
00:19:30,280 --> 00:19:35,120
这就是我们本题当中访问者模式它的意图

383
00:19:35,120 --> 00:19:35,840
最后

384
00:19:35,840 --> 00:19:41,320
D 选项在不同的时刻指定排列和执行请求

385
00:19:41,320 --> 00:19:44,370
涉及到排排列这个过程的话

386
00:19:44,370 --> 00:19:47,530
一般呢是我们的命令模式

387
00:19:47,530 --> 00:19:50,440
它可以呀去排排列记录

388
00:19:50,440 --> 00:19:53,130
甚至呢撤销我们的请求

389
00:19:53,130 --> 00:19:58,070
所以这一个 D 选项描述的是命令模式

390
00:19:58,070 --> 00:20:01,640
那这道题相对于前面的题型来说呢

391
00:20:01,640 --> 00:20:03,520
更加的复杂了一些

392
00:20:03,520 --> 00:20:07,240
因为涉及到的类图更加抽象

393
00:20:07,240 --> 00:20:10,850
但是呢，我们提到它的特殊操作之后啊

394
00:20:10,850 --> 00:20:13,050
大家呢，也应该能够呢

395
00:20:13,050 --> 00:20:15,920
辨别出相应的设计模式

396
00:20:15,920 --> 00:20:17,220
那我们会发现

397
00:20:17,220 --> 00:20:19,940
设计模式的判断涉及到几个维度呢

398
00:20:19,940 --> 00:20:22,080
首先第一个层次，诶

399
00:20:22,080 --> 00:20:23,920
应用场景的匹配

400
00:20:23,920 --> 00:20:25,580
其次，第二个层次

401
00:20:25,580 --> 00:20:26,640
类图当中

402
00:20:26,640 --> 00:20:30,180
它的类名中英文拼写与之呢

403
00:20:30,180 --> 00:20:32,100
匹配起来进行判断

404
00:20:32,100 --> 00:20:35,560
第三个呢，就涉及到类图的细节部分

405
00:20:35,560 --> 00:20:39,060
那有一些设计模式会有一些特殊的操作

406
00:20:39,060 --> 00:20:41,740
我们呢，也要加以识别

407
00:20:41,740 --> 00:20:43,510
那这些啊，是关于呢

408
00:20:43,510 --> 00:20:45,440
设计模式的考察

409
00:20:45,440 --> 00:20:48,370
我们前面给大家讲到的设计模式

410
00:20:48,370 --> 00:20:52,750
大家第一个维度要掌握的就是设计模式

411
00:20:52,750 --> 00:20:55,160
它的中英文拼写和分类

412
00:20:55,160 --> 00:20:58,410
我们前面呢，是分散开给大家讲的

413
00:20:58,410 --> 00:21:02,320
那么下面这个页面给大家做了一个汇总

414
00:21:02,320 --> 00:21:05,240
将相应的设计模

415
00:21:05,240 --> 00:21:08,440
以及呢，它所对应的类

416
00:21:08,440 --> 00:21:10,660
都给大家呢，列举了一下

417
00:21:10,660 --> 00:21:13,480
在这些表格当中啊

418
00:21:13,480 --> 00:21:18,290
我们要知道类这里列举的设计模式啊

419
00:21:18,290 --> 00:21:21,080
它是既可以作为类模式

420
00:21:21,080 --> 00:21:24,180
也可以作为对象模式来存在的

421
00:21:24,180 --> 00:21:28,220
但是目前在我们的软考系列当中

422
00:21:28,220 --> 00:21:31,540
还没有考到过类模式的说法

423
00:21:31,540 --> 00:21:35,120
知道呢，有这样的一个概念存在就可以了

424
00:21:35,120 --> 00:21:37,320
我们重要的是掌握呢

425
00:21:37,320 --> 00:21:40,580
诶，创建型设计模式有五种

426
00:21:40,580 --> 00:21:44,880
哪些它的中英文拼写要能够呢识别

427
00:21:44,880 --> 00:21:48,270
结构型设计模式有七种

428
00:21:48,270 --> 00:21:51,170
那这七种设计模式当中诶

429
00:21:51,170 --> 00:21:53,990
它的中英文拼写如何来识别

430
00:21:53,990 --> 00:21:57,100
行为型设计模式有11种

431
00:21:57,100 --> 00:22:00,720
它的中英文拼写也要呢，有所识别

432
00:22:00,720 --> 00:22:05,580
那具体这些设计模式所匹配的关键字

433
00:22:05,580 --> 00:22:07,500
意图以及类图的话

434
00:22:07,500 --> 00:22:09,700
我们在前面已经介绍过了

435
00:22:09,700 --> 00:22:13,200
这里呢，就不再重复去加以说明了

436
00:22:13,200 --> 00:22:14,480
大家可以自己呢

437
00:22:14,480 --> 00:22:16,730
再去回忆巩固一下

438
00:22:16,730 --> 00:22:17,700
那这些啊

439
00:22:17,700 --> 00:22:21,260
就是关于设计模式需要大家掌握的内容
