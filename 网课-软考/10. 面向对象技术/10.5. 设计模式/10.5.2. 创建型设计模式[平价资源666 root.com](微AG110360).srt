1
00:00:00,000 --> 00:00:00,520
接下来

2
00:00:00,520 --> 00:00:04,490
我们先来展开看一下创建型的设计模式

3
00:00:04,490 --> 00:00:06,380
设计模式的考察呢

4
00:00:06,380 --> 00:00:09,120
要求大家掌握的第一个维度啊

5
00:00:09,120 --> 00:00:10,850
是关于设计模

6
00:00:10,850 --> 00:00:13,090
它的中英文拼写和分类

7
00:00:13,090 --> 00:00:15,010
那我们首先呢，可以看到

8
00:00:15,010 --> 00:00:18,480
创建型设计模式一共呢，有五种

9
00:00:18,480 --> 00:00:21,470
这五种设计模式分别是呢

10
00:00:21,470 --> 00:00:24,340
抽象工厂、工厂以及呢

11
00:00:24,340 --> 00:00:27,140
构建器原型和单例模式

12
00:00:27,140 --> 00:00:30,000
那在判断的过程当中呢

13
00:00:30,000 --> 00:00:33,380
有时候虽然会出现复杂的类土

14
00:00:33,380 --> 00:00:35,060
让人呢，难以区分

15
00:00:35,060 --> 00:00:37,140
但是其中的类名啊

16
00:00:37,140 --> 00:00:41,020
一般呢，可能会出现涉及设计模式的关键字

17
00:00:41,020 --> 00:00:43,790
所以啊，这个中英文拼写呢

18
00:00:43,790 --> 00:00:47,120
是大家必须要掌握的一个内容

19
00:00:47,120 --> 00:00:50,900
那针对这五种创建型设计模式

20
00:00:50,900 --> 00:00:54,140
它们可以用来解决哪些问题呢

21
00:00:54,140 --> 00:00:55,120
我们可以呀

22
00:00:55,120 --> 00:00:58,720
简单的看一看它的说明和速记关键字

23
00:00:58,720 --> 00:01:01,980
我们呀，根据后面的速记关键字

24
00:01:01,980 --> 00:01:06,150
尽量呢，可以根据关键字还原出它的简要说明

25
00:01:06,150 --> 00:01:09,190
也就是呢，它的适用场景和意图了

26
00:01:09,190 --> 00:01:13,690
那我们在这里首先看到的是抽象工厂模式

27
00:01:13,690 --> 00:01:18,070
它的特点啊，是可以生产成系列的产品

28
00:01:18,070 --> 00:01:21,590
那这种成系列一般就是多个吧

29
00:01:21,590 --> 00:01:25,000
它的一个工厂可以生产多个产品

30
00:01:25,000 --> 00:01:25,960
多个对象

31
00:01:25,960 --> 00:01:29,300
而这种对象呢，是具有一定的相关性的

32
00:01:29,300 --> 00:01:30,580
常用在呢

33
00:01:30,580 --> 00:01:32,910
比如说我们在做一些，呃

34
00:01:32,910 --> 00:01:34,830
数据库接口开发的时候

35
00:01:34,830 --> 00:01:35,990
这种数据库啊

36
00:01:35,990 --> 00:01:37,370
不同的数据库呢

37
00:01:37,370 --> 00:01:40,250
它的一些创建，诶，产生

38
00:01:40,250 --> 00:01:44,210
以及呢，我们使用调用和关闭链接

39
00:01:44,210 --> 00:01:45,510
这样的一些对象啊

40
00:01:45,510 --> 00:01:47,180
可能呢，大家都有

41
00:01:47,180 --> 00:01:48,530
那我们可以呢

42
00:01:48,530 --> 00:01:50,470
生产一个 oracle 系列的

43
00:01:50,470 --> 00:01:52,830
生产一个呢 MYSQL 系列的等等

44
00:01:52,830 --> 00:01:56,340
按自己的需要去生产成系列的产品

45
00:01:56,340 --> 00:01:59,090
那这就是呢，抽象工厂

46
00:01:59,090 --> 00:02:01,060
它提供一个接口

47
00:02:01,060 --> 00:02:05,700
可以呢，创建一系列相关或者相互依赖的对象

48
00:02:05,700 --> 00:02:08,940
不需要呢指定他们具体的分类

49
00:02:08,940 --> 00:02:11,390
具体的类是不需要指明的

50
00:02:11,390 --> 00:02:16,690
第二种，构建器模式也可以叫做生成器模式

51
00:02:16,690 --> 00:02:20,390
那它的翻译可能会存在一些区别

52
00:02:20,390 --> 00:02:22,970
所谓的构建器模式

53
00:02:22,970 --> 00:02:26,330
它针对的构建的是复杂对象

54
00:02:26,330 --> 00:02:27,560
它的构造过程

55
00:02:27,560 --> 00:02:29,950
那一个对象很复杂的时候

56
00:02:29,950 --> 00:02:34,110
我们可以呢，将它的表示和构造过程呢分离开

57
00:02:34,110 --> 00:02:37,430
然后呢，虽然是相同的构造过程

58
00:02:37,430 --> 00:02:41,260
但是我们呢，可以生产出不同的表示

59
00:02:41,260 --> 00:02:43,230
那这里的构造过

60
00:02:43,230 --> 00:02:44,870
其实就是我们啊

61
00:02:44,870 --> 00:02:46,810
在创建的过程当中呢

62
00:02:46,810 --> 00:02:50,470
以 part 这样的一些部分来进行了创建

63
00:02:50,470 --> 00:02:51,480
它的表示

64
00:02:51,480 --> 00:02:54,220
然后呢，再调用这种构造方法

65
00:02:54,220 --> 00:02:56,680
把这一部分呢，给它创建出来

66
00:02:56,680 --> 00:03:00,070
从而呢，让表示和构造分离开

67
00:03:00,070 --> 00:03:02,890
那有的复杂对象少一块

68
00:03:02,890 --> 00:03:05,070
那它可以呢少构造一部分

69
00:03:05,070 --> 00:03:06,820
这就是呢，构建器

70
00:03:06,820 --> 00:03:10,220
它主要针对的就是复杂对象的构造

71
00:03:10,220 --> 00:03:14,480
工厂方法呢，是定义了一个创建对象的接口

72
00:03:14,480 --> 00:03:16,820
那这个创建对象的接口啊

73
00:03:16,820 --> 00:03:19,440
最终会被使进行实现

74
00:03:19,440 --> 00:03:22,140
有一些子类来实现这个接口

75
00:03:22,140 --> 00:03:25,530
那到底是哪些子类来实现

76
00:03:25,530 --> 00:03:30,070
由子类来决定我们实例化的是哪一个类

77
00:03:30,070 --> 00:03:32,020
这就是呢，工厂方法

78
00:03:32,020 --> 00:03:34,120
因为是子类来实现的

79
00:03:34,120 --> 00:03:37,690
所以它是一个动态生产对象的过程

80
00:03:37,690 --> 00:03:41,730
它可以推迟我们子类实例化的过程

81
00:03:41,730 --> 00:03:44,190
这是呢，工厂方法

82
00:03:44,190 --> 00:03:46,050
圆形方法呢

83
00:03:46,050 --> 00:03:48,850
它也可以叫做克隆方法

84
00:03:48,850 --> 00:03:51,320
它里面呢，会有克隆

85
00:03:51,320 --> 00:03:54,250
唉，这样的一些函数来调用

86
00:03:54,250 --> 00:03:58,400
从而呢，复制我们原有的实例化对象

87
00:03:58,400 --> 00:04:02,690
通过复制呢，来减少实例化的开销过程

88
00:04:02,690 --> 00:04:05,190
那它的克隆过程的话

89
00:04:05,190 --> 00:04:07,650
是通过圆形的实例

90
00:04:07,650 --> 00:04:10,310
然后呢来创建实例的对象

91
00:04:10,310 --> 00:04:12,240
那这个过程有拷贝

92
00:04:12,240 --> 00:04:15,180
一定呢，要注意有不一样的地

93
00:04:15,180 --> 00:04:16,980
还需要呢做修改

94
00:04:16,980 --> 00:04:18,779
这是呢，圆形模式

95
00:04:18,779 --> 00:04:20,560
也叫呢克隆模式

96
00:04:20,560 --> 00:04:23,590
单例模式，它的特点比较典型

97
00:04:23,590 --> 00:04:25,720
唉，只有单一的一个实例

98
00:04:25,720 --> 00:04:28,110
所以叫做呢，单例模式

99
00:04:28,110 --> 00:04:30,010
那它的保证的话

100
00:04:30,010 --> 00:04:31,770
这种单个实例啊

101
00:04:31,770 --> 00:04:36,690
就能够呢，只提供一个访问它的全局访问接口

102
00:04:36,690 --> 00:04:38,720
哎，全局访问点

103
00:04:38,720 --> 00:04:41,340
那这里涉及到单例的话

104
00:04:41,340 --> 00:04:43,130
比如说呢，我们啊

105
00:04:43,130 --> 00:04:45,470
在做一些浏览器开发的话

106
00:04:45,470 --> 00:04:48,570
是保证只有一个主页的

107
00:04:48,570 --> 00:04:51,680
那这就是呢，单例模式它的特点

108
00:04:51,680 --> 00:04:53,440
那这些啊，就是呢

109
00:04:53,440 --> 00:04:56,290
属于创建型设计模式

110
00:04:56,290 --> 00:04:58,200
接下来我们来看一下呢

111
00:04:58,200 --> 00:05:00,410
创建型设计模式的类图

112
00:05:00,410 --> 00:05:02,390
对于类图的考察呀

113
00:05:02,390 --> 00:05:05,840
我们呢，不要求大家细致地去掌握它的应用

114
00:05:05,840 --> 00:05:07,460
因为类图本身的话

115
00:05:07,460 --> 00:05:09,900
可能会存在一些结构相似的地方

116
00:05:09,900 --> 00:05:12,350
无法呢，通过结构来判断

117
00:05:12,350 --> 00:05:16,540
那如何从内图找到它相应的设计模式呢

118
00:05:16,540 --> 00:05:17,900
我们目前啊

119
00:05:17,900 --> 00:05:22,040
基本上呢，还是根据设计模式的类名来判断的

120
00:05:22,040 --> 00:05:24,440
如果找不到这样的一些类名

121
00:05:24,440 --> 00:05:30,160
就尽量呢，从题干给出的场民警来进行判断了

122
00:05:30,160 --> 00:05:31,700
因为啊，结构的话

123
00:05:31,700 --> 00:05:34,370
其实是无法确定它的设计模式的

124
00:05:34,370 --> 00:05:36,600
那我们首先看到第一类

125
00:05:36,600 --> 00:05:38,620
抽象工厂模式

126
00:05:38,620 --> 00:05:40,720
抽象工厂模式呢

127
00:05:40,720 --> 00:05:44,340
它有一个工厂的抽象类或者呢接口

128
00:05:44,340 --> 00:05:46,760
那这个抽象工厂下面呢

129
00:05:46,760 --> 00:05:49,800
有具体的做生产的工厂

130
00:05:49,800 --> 00:05:53,230
我们呢，会称生产系列产品

131
00:05:53,230 --> 00:05:55,190
那生产一个系列

132
00:05:55,190 --> 00:05:58,340
就增加这个系列的工厂就可以了

133
00:05:58,340 --> 00:06:00,790
那我们在生产的过程当中

134
00:06:00,790 --> 00:06:03,190
这一系列同系列的产品啊

135
00:06:03,190 --> 00:06:06,980
一般呢，都会具有相似或者相同的功能吧

136
00:06:06,980 --> 00:06:09,580
那我们现在要生产产品 A 的话

137
00:06:09,580 --> 00:06:12,260
里面呢有一系列的 B 呢

138
00:06:12,260 --> 00:06:14,020
也有一号系列的

139
00:06:14,020 --> 00:06:15,680
那我们在生产，哎

140
00:06:15,680 --> 00:06:18,240
工厂二、生产系列二的时候呢

141
00:06:18,240 --> 00:06:20,220
它会有 A 2和 B 2

142
00:06:20,220 --> 00:06:22,120
这样呢，来进行构

143
00:06:22,120 --> 00:06:24,750
我们最终的这个产品

144
00:06:24,750 --> 00:06:29,190
这里的 CLINTON 呢，一般是作为客户应用程序来的

145
00:06:29,190 --> 00:06:30,680
应用程序的话

146
00:06:30,680 --> 00:06:31,720
可以呢

147
00:06:31,720 --> 00:06:36,720
使用我们抽象产品和抽象工厂生产对象

148
00:06:36,720 --> 00:06:38,730
我们的产品啊

149
00:06:38,730 --> 00:06:41,140
也有一定的抽象接口

150
00:06:41,140 --> 00:06:44,270
以及呢，它们具体的产品

151
00:06:44,270 --> 00:06:48,790
那我们在这里整个类图当中有抽象工厂

152
00:06:48,790 --> 00:06:49,950
有具体工厂

153
00:06:49,950 --> 00:06:51,430
有抽象产品

154
00:06:51,430 --> 00:06:52,810
有具体产品

155
00:06:52,810 --> 00:06:54,820
产品是成系列

156
00:06:54,820 --> 00:06:58,080
然后呢，在不同的工厂当中呢

157
00:06:58,080 --> 00:06:59,890
来生产产品

158
00:06:59,890 --> 00:07:01,150
那这是呢

159
00:07:01,150 --> 00:07:04,290
我们抽象工厂它的一个过程

160
00:07:04,290 --> 00:07:07,350
主要针对的就是多个系列，诶

161
00:07:07,350 --> 00:07:10,370
创建一系列相关的这种产品

162
00:07:10,370 --> 00:07:12,380
那这是呢，抽象工厂

163
00:07:12,380 --> 00:07:15,060
下面呢，再来看工厂模式

164
00:07:15,060 --> 00:07:18,510
工厂模式呢，相对会简单一些

165
00:07:18,510 --> 00:07:22,050
它也有工厂和产品的区分

166
00:07:22,050 --> 00:07:23,330
那这里呢

167
00:07:23,330 --> 00:07:26,210
产品会有呢，一定的接口

168
00:07:26,210 --> 00:07:28,480
以及呢，它的实现类

169
00:07:28,480 --> 00:07:29,540
那这是呢

170
00:07:29,540 --> 00:07:31,800
产品以及真实

171
00:07:31,800 --> 00:07:36,160
或者说具体的实现接口的产品类

172
00:07:36,160 --> 00:07:39,240
而我们的工厂是以呢

173
00:07:39,240 --> 00:07:41,770
创造者的这个接口

174
00:07:41,770 --> 00:07:46,120
和工厂方法来进行表示的

175
00:07:46,120 --> 00:07:49,450
那我们这里的工厂角色可以呢

176
00:07:49,450 --> 00:07:51,780
声明他的工厂方法

177
00:07:51,780 --> 00:07:53,580
通过工厂方

178
00:07:53,580 --> 00:07:56,640
注意跟抽象工厂不一样

179
00:07:56,640 --> 00:07:59,260
它只返回一个产品

180
00:07:59,260 --> 00:08:02,230
不会呢返回系列产品

181
00:08:02,230 --> 00:08:06,370
那这个过程当中是不是由接口来返回啊

182
00:08:06,370 --> 00:08:07,290
不是啊

183
00:08:07,290 --> 00:08:12,240
它是由我们具体的工厂角色来进行创建的

184
00:08:12,240 --> 00:08:14,240
也就是说上面是接口

185
00:08:14,240 --> 00:08:16,880
下面才是具体的实现类

186
00:08:16,880 --> 00:08:19,950
由我们真实的工厂来实现

187
00:08:19,950 --> 00:08:22,270
从而进行返回

188
00:08:22,270 --> 00:08:25,370
那这里呢，是工厂模式

189
00:08:25,370 --> 00:08:26,930
它是为了啊

190
00:08:26,930 --> 00:08:29,150
让我们实例化的过程呢

191
00:08:29,150 --> 00:08:31,770
延迟到子类当中去

192
00:08:31,770 --> 00:08:35,960
从而呢，唉，由子类决定实例化过程

193
00:08:35,960 --> 00:08:37,720
延迟实例化

194
00:08:37,720 --> 00:08:41,610
这是呢，工厂模式它的作用啊

195
00:08:41,610 --> 00:08:44,340
第三种，圆形模式

196
00:08:44,340 --> 00:08:46,080
圆形模式呢

197
00:08:46,080 --> 00:08:48,060
它主要的特点啊

198
00:08:48,060 --> 00:08:52,620
就是呢，以克隆方法来生成实例

199
00:08:52,620 --> 00:08:55,610
那这个过程不需要呢 new 了

200
00:08:55,610 --> 00:08:57,620
不需要用 new 来实例化

201
00:08:57,620 --> 00:08:59,900
所以呢，实例化的过程比较快

202
00:08:59,900 --> 00:09:01,960
产生对象的过程比较快

203
00:09:01,960 --> 00:09:05,140
可以呢，节约一定的资源

204
00:09:05,140 --> 00:09:08,200
那在这个类图当中呢

205
00:09:08,200 --> 00:09:11,400
圆形是一个抽象类，哎

206
00:09:11,400 --> 00:09:13,230
或者呢是一个接口

207
00:09:13,230 --> 00:09:14,910
那我们现在呢

208
00:09:14,910 --> 00:09:19,790
唉，会有具体的这样的圆形类来进行拷贝

209
00:09:19,790 --> 00:09:23,120
从而呢，进行实现过程

210
00:09:23,120 --> 00:09:26,720
CLINT 是我们的应用程序

211
00:09:26,720 --> 00:09:31,750
客户应用程序调用圆形接口访问原型接口

212
00:09:31,750 --> 00:09:34,580
从而呢，来进行拷贝的过程

213
00:09:34,580 --> 00:09:35,620
这就是呢

214
00:09:35,620 --> 00:09:37,920
圆形设计模式

215
00:09:37,920 --> 00:09:41,130
第四种，单例设计模式

216
00:09:41,130 --> 00:09:44,820
单例模式的特点就是保证一个类

217
00:09:44,820 --> 00:09:48,310
它只有唯一的一个实例进行访问

218
00:09:48,310 --> 00:09:50,450
从而呢，唉进行返回

219
00:09:50,450 --> 00:09:54,640
从而呢确保全局只有一个访问点

220
00:09:54,640 --> 00:09:56,580
那单例当中呢

221
00:09:56,580 --> 00:10:00,080
它会有一些地静态的属性和方法

222
00:10:00,080 --> 00:10:02,360
确保呢不被改变

223
00:10:02,360 --> 00:10:03,380
那这是呢

224
00:10:03,380 --> 00:10:05,220
单例模式

225
00:10:06,160 --> 00:10:09,040
第五种，生成器模式

226
00:10:09,040 --> 00:10:10,940
生成器模式呢

227
00:10:10,940 --> 00:10:13,790
它也叫做构建器模式

228
00:10:13,790 --> 00:10:15,340
翻译不一样

229
00:10:15,340 --> 00:10:17,860
我们会有一个呢构建器

230
00:10:17,860 --> 00:10:21,680
以及呢一个使用构建器的指挥者

231
00:10:21,680 --> 00:10:24,720
可以呢理解为应用程序

232
00:10:24,720 --> 00:10:28,780
那我们呢，通过这种抽象的构建器

233
00:10:28,780 --> 00:10:32,060
再生成呢实际的构建器

234
00:10:32,060 --> 00:10:33,160
那这是一个呢

235
00:10:33,160 --> 00:10:35,080
我们会发现类图当中啊

236
00:10:35,080 --> 00:10:36,740
都会有这样的层次

237
00:10:36,740 --> 00:10:39,330
我们具体的这些调用的类

238
00:10:39,330 --> 00:10:42,150
或者呢，哎，具体调用的这些类啊

239
00:10:42,150 --> 00:10:45,010
它的上层要么是抽象的类

240
00:10:45,010 --> 00:10:47,610
要么呢是抽象的接口

241
00:10:48,550 --> 00:10:51,370
对于抽象创建者的话

242
00:10:51,370 --> 00:10:56,090
哎，建造者它呢，会给对相应的这些部件啊

243
00:10:56,090 --> 00:10:58,150
来创建它的部分，诶

244
00:10:58,150 --> 00:11:01,620
build part 来创建各个组成部分

245
00:11:01,620 --> 00:11:04,300
然后呢，去获取结果

246
00:11:04,300 --> 00:11:09,400
获取结果其实就是拼装出产品的这个过程

247
00:11:09,720 --> 00:11:11,560
指挥

248
00:11:11,560 --> 00:11:12,720
他是呢

249
00:11:12,720 --> 00:11:17,720
使用我们构建器的这样的一个接口的对象

250
00:11:17,720 --> 00:11:21,820
最后呢，产品就是我们构造的

251
00:11:21,820 --> 00:11:25,480
或者说构建的具体的复杂的对象

252
00:11:25,480 --> 00:11:29,280
从而呢，来进行定义的一个过程

253
00:11:29,280 --> 00:11:32,200
那这就是呢，生成器模式

254
00:11:32,200 --> 00:11:36,780
它主要针对的是将复杂的表

255
00:11:36,780 --> 00:11:39,790
以及呢构造的过程分离开

256
00:11:39,790 --> 00:11:42,600
针对复杂对象的构造

257
00:11:42,600 --> 00:11:47,070
这些啊，就是我们创建型设计模式的类图

258
00:11:47,070 --> 00:11:50,500
接下来我们看一下创建型设计模式

259
00:11:50,500 --> 00:11:53,870
在软件设计师考试真题当中的考察

260
00:11:53,870 --> 00:11:56,520
那么它的考察当中啊

261
00:11:56,520 --> 00:11:58,080
第一种考法呢

262
00:11:58,080 --> 00:12:01,910
就是以文字的形式给出了它的适用场景

263
00:12:01,910 --> 00:12:05,810
与我们的设计模式名称来进行匹配

264
00:12:05,810 --> 00:12:08,290
那这种考察形式当中

265
00:12:08,290 --> 00:12:09,670
题目告诉我们

266
00:12:09,670 --> 00:12:11,350
以下哪一种模式

267
00:12:11,350 --> 00:12:15,650
会将一个复杂对象的构建与表示分离

268
00:12:15,650 --> 00:12:17,800
使得同样的构建过程

269
00:12:17,800 --> 00:12:20,150
可以创建不同的表示呢

270
00:12:20,150 --> 00:12:23,560
诶，将构建和表示分离的

271
00:12:23,560 --> 00:12:25,670
它是呢构建器

272
00:12:25,670 --> 00:12:29,120
也可以呢叫做生成器

273
00:12:29,120 --> 00:12:31,920
所以这里呢，应该选择 A 选项

274
00:12:31,920 --> 00:12:36,360
那以下哪些情况适合选用该模式呢

275
00:12:36,360 --> 00:12:40,080
我们看到下面有四个条目

276
00:12:40,080 --> 00:12:44,470
首先，抽象复杂对象的构建过程

277
00:12:44,470 --> 00:12:48,240
那我们构建过程有没有把它抽象出来啊

278
00:12:48,240 --> 00:12:49,200
我们前面说了

279
00:12:49,200 --> 00:12:52,150
会分成一部分一部分的来进行构建法

280
00:12:52,150 --> 00:12:53,590
所以它是呢

281
00:12:53,590 --> 00:12:55,710
生成器或者说构建

282
00:12:55,710 --> 00:12:57,820
它的一个呢适用情况

283
00:12:57,820 --> 00:13:01,790
其次呢，基于构建过程的具体实现

284
00:13:01,790 --> 00:13:04,510
唉，构建复杂对象的不同表示

285
00:13:04,510 --> 00:13:08,910
那这也是呢构建器它的诶，具体的体现

286
00:13:08,910 --> 00:13:10,560
剩下的第三条

287
00:13:10,560 --> 00:13:13,360
一个类仅有一个实例

288
00:13:13,360 --> 00:13:15,880
这是单例模式

289
00:13:17,540 --> 00:13:18,860
第四条

290
00:13:18,860 --> 00:13:20,360
一个类的实例啊

291
00:13:20,360 --> 00:13:24,790
只能有几个不同状态组合中的一种

292
00:13:24,790 --> 00:13:26,640
那这种诶

293
00:13:26,640 --> 00:13:30,090
十实力已经确定组合形式了

294
00:13:30,090 --> 00:13:31,090
那我们呢

295
00:13:31,090 --> 00:13:33,390
在下一次要使用的时候

296
00:13:33,390 --> 00:13:37,770
通过已有的组合来进行复制就可以了

297
00:13:37,770 --> 00:13:40,500
所以它适合的是克隆

298
00:13:40,500 --> 00:13:44,480
或者说呢，原型模式的这个表述

299
00:13:46,520 --> 00:13:49,800
那我们排除三和四之后啊

300
00:13:49,800 --> 00:13:51,200
也能找到呢

301
00:13:51,200 --> 00:13:52,900
正确的答案应该呢

302
00:13:52,900 --> 00:13:54,820
是第一条、第二条

303
00:13:54,820 --> 00:13:56,650
那这一类问题

304
00:13:56,650 --> 00:14:00,000
首先呢，我们要根据他的描

305
00:14:00,000 --> 00:14:02,740
以及呢它的一些关键字

306
00:14:02,740 --> 00:14:05,690
来找到它对应的这种呢

307
00:14:05,690 --> 00:14:07,800
哎，设计模式名称

308
00:14:07,800 --> 00:14:10,520
然后根据呢设计模式名称

309
00:14:10,520 --> 00:14:14,380
来匹配它的一些意图和应用场景

310
00:14:14,380 --> 00:14:16,570
在匹配的过程当中

311
00:14:16,570 --> 00:14:19,880
可以根据选项来排除

312
00:14:19,880 --> 00:14:26,060
那这里是关于构建器它的适用情况的考察

313
00:14:26,310 --> 00:14:28,630
下面呢，再来看哎

314
00:14:28,630 --> 00:14:30,490
这道题是对呢

315
00:14:30,490 --> 00:14:34,270
设计模式当中类图的应用考察

316
00:14:34,870 --> 00:14:37,290
首先，题目告诉我们

317
00:14:37,290 --> 00:14:38,650
某快餐厅啊

318
00:14:38,650 --> 00:14:40,050
现在呢，主要制

319
00:14:40,050 --> 00:14:42,620
并且呢，出售儿童套餐

320
00:14:42,620 --> 00:14:43,660
然后一般呢

321
00:14:43,660 --> 00:14:48,840
可以包括主餐、饮料、玩具、餐品种类可能不一样

322
00:14:48,840 --> 00:14:50,710
制作过程相同

323
00:14:50,710 --> 00:14:55,690
前台的服务员、调度厨师来制作套餐

324
00:14:55,690 --> 00:14:59,430
那其实这里啊，就是它的应用场景描述

325
00:14:59,430 --> 00:15:03,290
如果下面的题干，哎，当中啊

326
00:15:03,290 --> 00:15:05,650
如果图示我们看不出来

327
00:15:05,650 --> 00:15:08,340
就可以通过描述来看一看

328
00:15:08,340 --> 00:15:10,420
那想要开发一个软

329
00:15:10,420 --> 00:15:12,500
实现这个制作的过程

330
00:15:12,500 --> 00:15:14,890
这个制作的过程我们会发现

331
00:15:14,890 --> 00:15:16,610
它会制作套餐吧

332
00:15:16,610 --> 00:15:19,130
所以它最终呢，应该是用到了一

333
00:15:19,130 --> 00:15:21,020
创建型的设计模式

334
00:15:21,020 --> 00:15:23,610
那制作的过程相同

335
00:15:23,610 --> 00:15:26,390
其实就是一个呢，相同的构建器

336
00:15:26,390 --> 00:15:29,510
只是呢，组成它的表示不一样

337
00:15:29,510 --> 00:15:30,530
这道题呀

338
00:15:30,530 --> 00:15:33,920
它所描述的设计模式呢，其实是构建器

339
00:15:33,920 --> 00:15:36,530
那如果这里你没有看出来的话

340
00:15:36,530 --> 00:15:38,720
我们看到下面这个类图

341
00:15:38,720 --> 00:15:40,510
在类图当

342
00:15:40,510 --> 00:15:43,590
大家呢，仔细看一看有没有熟悉的

343
00:15:43,590 --> 00:15:44,820
诶，名字啊

344
00:15:44,820 --> 00:15:47,780
这里有典型的 builder 吧

345
00:15:47,780 --> 00:15:52,260
跟我们的生成器是不是一模一样

346
00:15:52,260 --> 00:15:55,160
所以根据类图来看的话

347
00:15:55,160 --> 00:16:00,560
这个设计采用的是生成器的设计模式

348
00:16:00,560 --> 00:16:01,740
然后呢

349
00:16:01,740 --> 00:16:05,470
唉，这个设计模式后面也明确告诉大家了

350
00:16:05,470 --> 00:16:09,160
这个设计模式可以将一个复杂对象的构建

351
00:16:09,160 --> 00:16:11,720
和它的表示分离开吧

352
00:16:11,720 --> 00:16:15,810
这也是呢，生成器它的适用场景

353
00:16:15,810 --> 00:16:19,530
所以在这里其实从三个不同的方面

354
00:16:19,530 --> 00:16:21,280
向你叙述了一下

355
00:16:21,280 --> 00:16:24,200
这道题考的就是呢，生成器

356
00:16:24,200 --> 00:16:26,750
那我们在这个过程当中

357
00:16:26,750 --> 00:16:29,580
其中以下哪一个选项

358
00:16:29,580 --> 00:16:33,950
构造一个使用 builder 接口的对象

359
00:16:33,950 --> 00:16:36,280
那看到这里之后

360
00:16:36,280 --> 00:16:39,100
下面这一个选项干嘛了

361
00:16:39,100 --> 00:16:41,560
构造了一个对象吧

362
00:16:41,880 --> 00:16:44,240
这个对象有什么特点

363
00:16:44,240 --> 00:16:47,850
这个对象使用 build 接口

364
00:16:47,850 --> 00:16:50,600
那我们看到 builder 的接口在哪

365
00:16:50,600 --> 00:16:53,960
生成器在这一系列东西方面

366
00:16:53,960 --> 00:16:55,200
谁是接口

367
00:16:55,200 --> 00:16:58,180
最上层的是生成器的接口

368
00:16:58,180 --> 00:17:01,710
那与之相关的谁来使用它呢

369
00:17:01,710 --> 00:17:04,200
诶，应该是指挥者

370
00:17:04,200 --> 00:17:06,099
那在这道题当中

371
00:17:06,099 --> 00:17:09,160
指挥者的内容是 waiter 

372
00:17:09,160 --> 00:17:11,390
也就是呢，服务员

373
00:17:11,390 --> 00:17:13,829
所以在第二题当中

374
00:17:13,829 --> 00:17:18,890
应该呢，是由服务员使用了这个构造了

375
00:17:18,890 --> 00:17:22,300
这样的一个使用生成器的接口

376
00:17:22,300 --> 00:17:24,660
那这个过程当中

377
00:17:24,660 --> 00:17:28,020
我们有没有详细去看谁是谁啊

378
00:17:28,020 --> 00:17:29,070
没有吧

379
00:17:29,070 --> 00:17:33,200
只需要搞清楚要找的是什么样的对象

380
00:17:33,200 --> 00:17:34,100
然后呢

381
00:17:34,100 --> 00:17:39,390
区分与它相关的这一系列的类就可以了

382
00:17:39,390 --> 00:17:42,900
那这个模式属于什么类型呢

383
00:17:42,900 --> 00:17:46,070
诶，应该是创建型设计模式吧

384
00:17:46,070 --> 00:17:49,570
那这里是创建型对象模式

385
00:17:49,570 --> 00:17:52,350
目前没有选择到过呢

386
00:17:52,350 --> 00:17:54,170
诶，什么类模式啊

387
00:17:54,170 --> 00:17:55,970
都是对象模式

388
00:17:55,970 --> 00:18:00,430
那该模式适合于什么样的场景呢

389
00:18:00,430 --> 00:18:02,690
下面四个选项当中

390
00:18:02,690 --> 00:18:08,870
当一个系统应该独立于它的产品创建

391
00:18:09,080 --> 00:18:11,230
构成表示

392
00:18:11,230 --> 00:18:13,890
那从创建开始就是呢

393
00:18:13,890 --> 00:18:15,770
哎，单一的列出来了

394
00:18:15,770 --> 00:18:19,810
那我们看到产品的创建与它独立的

395
00:18:19,810 --> 00:18:21,430
大家会发现是什么呢

396
00:18:21,430 --> 00:18:23,650
一般是工厂方法系列的

397
00:18:23,650 --> 00:18:27,240
那它创建之后还有构成和表示

398
00:18:27,240 --> 00:18:31,490
那这里呢，其实是成系列的进行的拼装

399
00:18:31,490 --> 00:18:37,390
那这里所针对的是抽象工厂模式啊

400
00:18:39,400 --> 00:18:42,790
这是抽象工厂模式的一个应用

401
00:18:42,790 --> 00:18:43,940
B 选项

402
00:18:43,940 --> 00:18:45,960
当一个类希望呢

403
00:18:45,960 --> 00:18:48,700
由它的子类来指

404
00:18:48,700 --> 00:18:50,710
它所创建的对象

405
00:18:50,710 --> 00:18:53,310
由子类延迟实例化

406
00:18:53,310 --> 00:18:57,120
就是呢，单纯的工厂方法

407
00:18:57,120 --> 00:19:02,640
C 选项，当要强调一系列相关产品，诶

408
00:19:02,640 --> 00:19:04,120
一系列产品的

409
00:19:04,120 --> 00:19:05,380
它也是呢

410
00:19:05,380 --> 00:19:07,290
抽象工厂方法

411
00:19:07,290 --> 00:19:09,830
抽象工厂的设计模式

412
00:19:09,830 --> 00:19:12,850
那在 D 选项当中，唉

413
00:19:12,850 --> 00:19:14,010
C 选项当中啊

414
00:19:14,010 --> 00:19:15,090
拼接之后呢

415
00:19:15,090 --> 00:19:17,900
这一系列的产品对象设计之后

416
00:19:17,900 --> 00:19:19,720
是需要联合使用的

417
00:19:19,720 --> 00:19:21,180
这个联合使用呢

418
00:19:21,180 --> 00:19:22,840
其实就是类似于呢

419
00:19:22,840 --> 00:19:24,340
唉，成系列拼接

420
00:19:24,340 --> 00:19:26,740
大家一起来用的这样的一个意思

421
00:19:26,740 --> 00:19:28,210
我们啊，在设计

422
00:19:28,210 --> 00:19:30,970
比如说像数据库接口的时候

423
00:19:30,970 --> 00:19:33,280
一般呢，你会有多个这种产品

424
00:19:33,280 --> 00:19:34,860
这些产品啊，你都会呢

425
00:19:34,860 --> 00:19:36,620
一系列一系列的来用

426
00:19:36,620 --> 00:19:39,230
并且呢，诶，抽象工厂的话

427
00:19:39,230 --> 00:19:41,430
它所生产的一系列产品

428
00:19:41,430 --> 00:19:44,600
我们可以呢，成系列的来进行配置

429
00:19:44,600 --> 00:19:45,790
所以这个地方呢

430
00:19:45,790 --> 00:19:48,350
都是属于抽象工厂的特点

431
00:19:48,350 --> 00:19:49,910
最后， D 选项

432
00:19:49,910 --> 00:19:52,180
当构造过程必须呢

433
00:19:52,180 --> 00:19:54,160
允许被构造的对

434
00:19:54,160 --> 00:19:56,850
有不同的表示的时候

435
00:19:56,850 --> 00:19:59,600
那我们在构造的过程当中啊

436
00:19:59,600 --> 00:20:01,440
所谓的生成器

437
00:20:01,440 --> 00:20:05,270
它构造过程可以有所不同

438
00:20:05,270 --> 00:20:08,560
它的过程看起来抽象的是一样的

439
00:20:08,560 --> 00:20:11,240
但是我们可以选择其中的一部分

440
00:20:11,240 --> 00:20:14,790
然后呢，去从而改变它的表示

441
00:20:14,790 --> 00:20:15,800
那这里呢

442
00:20:15,800 --> 00:20:17,040
就可以啊

443
00:20:17,040 --> 00:20:20,940
允许被构造的对象有不同的表示

444
00:20:20,940 --> 00:20:22,680
这是呢，生成器

445
00:20:22,680 --> 00:20:26,960
也就是呢，构建器适用于的场景

446
00:20:26,960 --> 00:20:28,720
那这道题是对呢

447
00:20:28,720 --> 00:20:31,120
生成器的结合。考察

448
00:20:31,600 --> 00:20:34,560
这些呢，就是需要大家掌握的

449
00:20:34,560 --> 00:20:38,920
关于我们的创建型设计模式当中

450
00:20:38,920 --> 00:20:41,290
两类考察题型

451
00:20:41,290 --> 00:20:43,260
大家呢，回去之后啊

452
00:20:43,260 --> 00:20:46,280
也需要自己做一做题呢，去进行巩固

453
00:20:46,280 --> 00:20:52,220
当前这道题是我们某一年下午真题的改编

454
00:20:52,220 --> 00:20:53,810
下午题当中呢

455
00:20:53,810 --> 00:20:56,670
曾经考过这个制作披萨的

456
00:20:56,670 --> 00:20:58,290
这个夏威夷披萨呀

457
00:20:58,290 --> 00:20:59,190
这一道呢

458
00:20:59,190 --> 00:21:00,540
代码填空题

459
00:21:00,540 --> 00:21:03,450
然后呢，在近几次考试当中呢

460
00:21:03,450 --> 00:21:05,090
又把它改编了一下

461
00:21:05,090 --> 00:21:06,850
作为呢，选择题

462
00:21:06,850 --> 00:21:09,930
出现在我们的软件设计师考试当中呢

463
00:21:09,930 --> 00:21:11,580
所以这两个部分啊

464
00:21:11,580 --> 00:21:14,510
大家可以放在一起呢，来进行复习

465
00:21:14,510 --> 00:21:14,920
唉

466
00:21:14,920 --> 00:21:19,460
将我们的面向对象技术与面向对象程序

467
00:21:19,460 --> 00:21:20,260
设计题呢

468
00:21:20,260 --> 00:21:24,080
放在一块来进行呃，整理梳理

469
00:21:24,080 --> 00:21:26,940
那这些呢，就是创建型设计模式
