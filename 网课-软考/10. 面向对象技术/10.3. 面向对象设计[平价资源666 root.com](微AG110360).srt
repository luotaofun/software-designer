1
00:00:00,000 --> 00:00:02,360
接下来看到面向对象设计

2
00:00:02,360 --> 00:00:03,960
面向对象设计啊

3
00:00:03,960 --> 00:00:07,290
它也是面向对象开发的其中一个过程

4
00:00:07,290 --> 00:00:10,720
那我们在软件设计师考试当中啊

5
00:00:10,720 --> 00:00:13,960
经常把面向对象设计这一部分呢

6
00:00:13,960 --> 00:00:18,280
诶，把它集中到设计原则来进行讲解

7
00:00:18,280 --> 00:00:20,600
因为目前在考试当中啊

8
00:00:20,600 --> 00:00:24,550
我们对于面向对象设计这一部分的考察

9
00:00:24,550 --> 00:00:28,540
只呢，体现在了设计原则的考察

10
00:00:28,540 --> 00:00:33,450
并且我们对于设计原则这种呢，理论性的描述

11
00:00:33,450 --> 00:00:35,780
也也会呢，把它归到啊

12
00:00:35,780 --> 00:00:38,400
面向对象基本概念里面去理解

13
00:00:38,400 --> 00:00:40,230
也是呢，可以的

14
00:00:40,230 --> 00:00:44,610
那这一部分在我们的软设考试上午题当中呢

15
00:00:44,610 --> 00:00:46,340
出现的并不多

16
00:00:46,340 --> 00:00:49,710
它主要呢，集中在面向对

17
00:00:49,710 --> 00:00:51,670
它的七大基本原则

18
00:00:51,670 --> 00:00:54,610
以及呢，一些其他原则上

19
00:00:54,610 --> 00:00:56,810
我们在前面给大家呢

20
00:00:56,810 --> 00:00:59,440
会介绍到结构化的一些内容

21
00:00:59,440 --> 00:01:01,990
结构化分析与设计的时候

22
00:01:01,990 --> 00:01:06,460
它的设计啊，主要涉及的是模块设计的原则

23
00:01:06,460 --> 00:01:08,590
唉，一句话大家回忆一下

24
00:01:08,590 --> 00:01:10,890
最核心的是什么原则啊

25
00:01:10,890 --> 00:01:15,140
高类聚、低耦合啊

26
00:01:15,140 --> 00:01:18,560
噗噗噗噗噗噗噗

27
00:01:27,730 --> 00:01:31,570
那我们在面向对象设计过程的时候呢

28
00:01:31,570 --> 00:01:35,120
也会遵循相似的一些原则

29
00:01:35,120 --> 00:01:38,440
也会有一些呢不一样的原则

30
00:01:38,440 --> 00:01:40,480
那我们首先看到呢

31
00:01:40,480 --> 00:01:42,580
对于面向对象设计原则

32
00:01:42,580 --> 00:01:44,080
它分了两大块

33
00:01:44,080 --> 00:01:47,750
第一大块是面向对象设计的七大原则

34
00:01:47,750 --> 00:01:49,470
稍微呢，基本一些

35
00:01:49,470 --> 00:01:52,670
那我们的教程上给出的是五大原则

36
00:01:52,670 --> 00:01:55,140
这里呢，我们稍微做了一些扩展

37
00:01:55,140 --> 00:01:58,140
后面还有其他的一些设计原

38
00:01:58,140 --> 00:02:00,020
会给大家呢进行介绍

39
00:02:00,020 --> 00:02:04,070
首先看到这七大原则考的呢，稍微多一些

40
00:02:04,070 --> 00:02:07,720
第一个原则呢，叫做单一职责原则

41
00:02:07,720 --> 00:02:09,789
所谓的单一职责

42
00:02:09,789 --> 00:02:12,970
它是呢，设计目的单一的类

43
00:02:12,970 --> 00:02:14,920
这种目的单一

44
00:02:14,920 --> 00:02:19,960
其实跟我们提到的功能类聚呢，是非常相似的

45
00:02:19,960 --> 00:02:21,580
大家要注意呢

46
00:02:21,580 --> 00:02:25,780
我们所谓的目的单一并不是单纯啊

47
00:02:25,780 --> 00:02:29,490
并不是说呢，功能或者目的越简单越好

48
00:02:29,490 --> 00:02:32,660
而是呢，为了同一个目标而前进

49
00:02:32,660 --> 00:02:33,960
所以在这里

50
00:02:33,960 --> 00:02:37,520
目的单一是功能类聚的一种呢

51
00:02:37,520 --> 00:02:39,750
变换的说法啊

52
00:02:39,750 --> 00:02:44,160
那它的这种单一性就叫单一职责原则

53
00:02:44,160 --> 00:02:45,900
第二个叫做呢

54
00:02:45,900 --> 00:02:47,880
开放封闭原则

55
00:02:47,880 --> 00:02:52,480
我们也可以简称为开闭原则

56
00:02:54,150 --> 00:02:56,910
所谓的开放和封闭

57
00:02:56,910 --> 00:03:00,270
分别应对的是哪一部分呢

58
00:03:00,270 --> 00:03:02,250
我们啊，在这里

59
00:03:02,250 --> 00:03:04,410
对于面向对象来说

60
00:03:04,410 --> 00:03:07,310
它的一些类与类之间

61
00:03:07,310 --> 00:03:09,260
唉，因为会生成对象

62
00:03:09,260 --> 00:03:12,400
对象会通过什么来进行交互呢

63
00:03:12,400 --> 00:03:14,060
唉，大家回忆一下

64
00:03:14,060 --> 00:03:19,230
对象与对象之间会通过消息来传递

65
00:03:19,230 --> 00:03:21,190
然后进行通信

66
00:03:21,190 --> 00:03:23,950
那如果说有消息传递

67
00:03:23,950 --> 00:03:26,580
它们之间会存在一些依赖关系吧

68
00:03:26,580 --> 00:03:27,910
那我们啊

69
00:03:27,910 --> 00:03:33,000
如果说对某一个类加以修改的话

70
00:03:33,000 --> 00:03:37,160
与它相关联的这些类都需要呢

71
00:03:37,160 --> 00:03:39,370
随之加以修改吧

72
00:03:39,370 --> 00:03:41,310
即使不用修改

73
00:03:41,310 --> 00:03:42,710
我们也要做什么呢

74
00:03:42,710 --> 00:03:45,870
要做一次回归测试

75
00:03:45,870 --> 00:03:49,570
这个也是在测试阶段给大家讲到过的

76
00:03:49,570 --> 00:03:51,150
测试的分类当中

77
00:03:51,150 --> 00:03:53,560
回归测试比较特殊

78
00:03:53,560 --> 00:03:55,200
它是属于什么呢

79
00:03:55,200 --> 00:03:58,580
一旦对我们的程序进行了修改

80
00:03:58,580 --> 00:04:01,470
就很有可能会引入新的 bug 

81
00:04:01,470 --> 00:04:05,150
所以修改之后一定要进行回归测试

82
00:04:05,150 --> 00:04:09,190
那既然修改会引入新的 bug 

83
00:04:09,190 --> 00:04:11,830
所以我们要对修改封闭

84
00:04:11,830 --> 00:04:14,640
不要呢轻易的去做修改

85
00:04:14,640 --> 00:04:17,350
那我的功能发生变化了

86
00:04:17,350 --> 00:04:19,990
或者说诶，我给它做了升级

87
00:04:19,990 --> 00:04:21,940
新增的功能怎么办呢

88
00:04:21,940 --> 00:04:26,270
注意这里我们以扩展来解决问题

89
00:04:26,270 --> 00:04:29,370
原有的功能并不会发生变化

90
00:04:29,370 --> 00:04:32,650
我们在原有的代码基础

91
00:04:32,650 --> 00:04:34,610
新增呢新的

92
00:04:34,610 --> 00:04:36,110
这样的变化功能

93
00:04:36,110 --> 00:04:39,270
这个呢就是对扩展开放

94
00:04:39,270 --> 00:04:42,350
这个原则呢叫做开放

95
00:04:42,350 --> 00:04:47,750
封闭原则也会简称为开闭原则

96
00:04:48,330 --> 00:04:52,770
第三个原则叫做呢李氏替换原则

97
00:04:52,770 --> 00:04:56,380
注意这里啊是一个音译词

98
00:04:56,380 --> 00:05:01,550
所以它一般呢也可以写作公理的这个礼

99
00:05:01,550 --> 00:05:04,990
那所谓的礼序替换原则

100
00:05:04,990 --> 00:05:07,250
替换的是什么呢

101
00:05:07,250 --> 00:05:10,620
替换的是子类和父类

102
00:05:10,620 --> 00:05:16,230
子类可以替换任意父类出现的位置

103
00:05:16,230 --> 00:05:19,300
那这里所谓的能替换

104
00:05:19,300 --> 00:05:21,620
就说明我们抽象

105
00:05:21,620 --> 00:05:23,100
抽象的非常好

106
00:05:23,100 --> 00:05:24,950
哎，比如说呃

107
00:05:24,950 --> 00:05:29,350
假设我们有一个动物类

108
00:05:32,830 --> 00:05:35,230
以及猫类

109
00:05:39,860 --> 00:05:43,040
我们说，所有的动物都会叫

110
00:05:43,040 --> 00:05:45,340
那动物会叫

111
00:05:47,520 --> 00:05:51,540
这个动物能不能替换成猫会叫呢

112
00:05:51,540 --> 00:05:53,740
哎，如果可以替换

113
00:05:53,740 --> 00:05:58,240
就说明我们这里满足了里氏替换的原则

114
00:05:58,240 --> 00:05:59,790
这种行为呢

115
00:05:59,790 --> 00:06:01,000
哎，可以啊

116
00:06:01,000 --> 00:06:05,580
很好的证明我们抽象的规律呢，是非常好的

117
00:06:05,580 --> 00:06:07,690
如果不能替换

118
00:06:07,690 --> 00:06:11,660
说明我们子类对父类继承之后呢

119
00:06:11,660 --> 00:06:13,730
修改的这一部分啊

120
00:06:13,730 --> 00:06:16,430
是不能作为通用部分的

121
00:06:16,430 --> 00:06:19,080
所以这里啊，所谓的李氏替换

122
00:06:19,080 --> 00:06:22,020
它有一个潜意浅含的意思呢

123
00:06:22,020 --> 00:06:25,240
就是说子类继承父类之后

124
00:06:25,240 --> 00:06:26,760
只对父类做扩展

125
00:06:26,760 --> 00:06:28,850
不要呢对父类做修改

126
00:06:28,850 --> 00:06:30,350
一旦做修改的话

127
00:06:30,350 --> 00:06:33,270
他就有可能呢，会失去这种理

128
00:06:33,270 --> 00:06:35,120
是替换的规律

129
00:06:35,120 --> 00:06:36,040
那这是呢

130
00:06:36,040 --> 00:06:38,730
关于李氏替换原则

131
00:06:38,730 --> 00:06:42,350
替换什么子类可以替换父类

132
00:06:42,350 --> 00:06:47,140
这里呢，其实就是可以用特殊来替

133
00:06:47,140 --> 00:06:48,940
一般的描述

134
00:06:48,940 --> 00:06:51,870
那这是第三条原则

135
00:06:51,870 --> 00:06:56,570
第四条原则叫做呢，依赖倒置原则

136
00:06:56,570 --> 00:06:58,620
所谓的倒置

137
00:06:58,620 --> 00:07:00,610
什么是政治呢

138
00:07:00,610 --> 00:07:04,110
唉，我们在讲结构化开发的时候

139
00:07:04,110 --> 00:07:05,710
其实也有提到

140
00:07:05,710 --> 00:07:09,350
模块与模块之间是有调用关系的吧

141
00:07:09,350 --> 00:07:15,200
那这种模块与模块之间调用下面的模块

142
00:07:15,200 --> 00:07:16,680
我们一般说什么呢

143
00:07:16,680 --> 00:07:19,250
说下面是子程序

144
00:07:19,250 --> 00:07:22,100
上面呢，是我们的主程序吧

145
00:07:22,100 --> 00:07:26,830
一般说高层模块调用低层模块

146
00:07:26,830 --> 00:07:29,150
那我们在主函数当中

147
00:07:29,150 --> 00:07:31,930
要调用某一个子函数的话

148
00:07:31,930 --> 00:07:34,150
说明我们在开发之前

149
00:07:34,150 --> 00:07:36,330
一定要写好子函

150
00:07:36,330 --> 00:07:37,850
才能进行调用吧

151
00:07:37,850 --> 00:07:41,150
那开发的过程就依赖于底层

152
00:07:41,150 --> 00:07:44,230
开发之后高层才能使用

153
00:07:44,230 --> 00:07:47,360
那我们这种依赖的过程就是呢

154
00:07:47,360 --> 00:07:49,820
依赖于底层

155
00:07:50,250 --> 00:07:52,910
除了这里的倒置啊

156
00:07:52,910 --> 00:07:55,190
这里的这种依赖关系以外

157
00:07:55,190 --> 00:07:57,750
我们在面向对象当中啊

158
00:07:57,750 --> 00:08:02,850
整个分析的过程是从现实世界抽象出对象

159
00:08:02,850 --> 00:08:05,250
从对象抽象出类

160
00:08:05,250 --> 00:08:08,120
再从类抽象出父类吧

161
00:08:08,120 --> 00:08:10,310
那这是我们分析的过程

162
00:08:10,310 --> 00:08:12,630
实际的实现过程

163
00:08:12,630 --> 00:08:15,620
我们会先开发负累

164
00:08:15,620 --> 00:08:20,640
再通过父类继承它的 A 产生它的子类

165
00:08:20,640 --> 00:08:26,100
再通过子类来实现产生某一个对象吧

166
00:08:26,100 --> 00:08:27,560
实例化一个对象

167
00:08:27,560 --> 00:08:29,750
那在这个过程当中，诶

168
00:08:29,750 --> 00:08:32,210
哪一个抽象级别最高呢

169
00:08:32,210 --> 00:08:35,600
应该是父类的级别最高

170
00:08:35,600 --> 00:08:37,980
所以它是高层

171
00:08:37,980 --> 00:08:43,110
子类是低层或者说底层

172
00:08:43,110 --> 00:08:45,340
那我们在开发的时候

173
00:08:45,340 --> 00:08:51,380
一般呢要针对高层的父类或者接口来开发

174
00:08:51,380 --> 00:08:54,930
而不是针对子类来开发

175
00:08:54,930 --> 00:08:59,890
那由原本的底层依赖变成了高层依赖

176
00:08:59,890 --> 00:09:03,380
这种就叫做呢，依赖倒置原则

177
00:09:03,380 --> 00:09:05,400
它是要求我们呢

178
00:09:05,400 --> 00:09:08,300
依赖于高层的抽象

179
00:09:08,300 --> 00:09:11,010
而不是具体的实现

180
00:09:11,010 --> 00:09:14,620
我们要针对高层的这种接口

181
00:09:14,620 --> 00:09:16,690
或者抽象类来编程

182
00:09:16,690 --> 00:09:20,830
而不是呢，针对具体的实现来编程

183
00:09:20,830 --> 00:09:23,460
这样呢，我们在实现啊

184
00:09:23,460 --> 00:09:25,360
面向对象的过程当中

185
00:09:25,360 --> 00:09:27,080
它的多肽以及呢

186
00:09:27,080 --> 00:09:30,290
实现过程都会呢，更丰富一些

187
00:09:30,290 --> 00:09:31,760
也可以啊

188
00:09:31,760 --> 00:09:34,940
解决我们对子类的这种呢，依赖关系

189
00:09:34,940 --> 00:09:37,520
一个父类它也许有，诶

190
00:09:37,520 --> 00:09:41,710
所有的，比如说有个三个、五个、十个这样的子类

191
00:09:41,710 --> 00:09:43,700
针对子类开发的话

192
00:09:43,700 --> 00:09:46,980
我们要有十种不同的开发规则吧

193
00:09:46,980 --> 00:09:51,420
但是我们只需要针对父类这样的一个接口

194
00:09:51,420 --> 00:09:54,040
或者高层的抽象类来开发的话

195
00:09:54,040 --> 00:09:55,750
对于底层来说

196
00:09:55,750 --> 00:09:58,660
大家适用的规则是一样的

197
00:09:58,660 --> 00:10:00,760
所以这样开发起来呢

198
00:10:00,760 --> 00:10:03,650
它的复用性也会呢，更好一些

199
00:10:03,650 --> 00:10:04,680
这就是呢

200
00:10:04,680 --> 00:10:08,200
依赖倒置原则啊

201
00:10:08,200 --> 00:10:09,940
还有哪些原则呢

202
00:10:09,940 --> 00:10:11,440
我们接着往下看

203
00:10:11,440 --> 00:10:13,140
下一个叫做呢

204
00:10:13,140 --> 00:10:15,360
接口隔离原则

205
00:10:15,360 --> 00:10:18,020
接口隔离原则

206
00:10:18,020 --> 00:10:21,480
它是呢，在开发过程当中

207
00:10:21,480 --> 00:10:23,870
针对接口开发的时候

208
00:10:23,870 --> 00:10:29,070
唉，比如说我们要对某一个类预留对外的接口

209
00:10:29,070 --> 00:10:32,700
那这种接口可能有多个

210
00:10:32,700 --> 00:10:35,840
我们要实现很多的功能

211
00:10:35,840 --> 00:10:38,590
可以呢，用一个接口

212
00:10:38,590 --> 00:10:43,050
大家呢，每一次新的功能都往这个接口上面加

213
00:10:43,050 --> 00:10:44,450
也可以呢

214
00:10:44,450 --> 00:10:48,620
将接口啊与功能对应起来

215
00:10:48,620 --> 00:10:50,820
每增加一个新的功能

216
00:10:50,820 --> 00:10:53,960
我就能增加一个新的接口

217
00:10:53,960 --> 00:10:58,470
那这两两种方式有什么样的区别呢

218
00:10:58,470 --> 00:11:00,140
对于接口来说啊

219
00:11:00,140 --> 00:11:02,100
我们一般以硬件来理解

220
00:11:02,100 --> 00:11:04,540
大家会觉得更加具体一些啊

221
00:11:04,540 --> 00:11:07,250
比如说大家的笔记本电脑，呃

222
00:11:07,250 --> 00:11:09,910
不知道大家有没有买过这样的笔记本啊

223
00:11:09,910 --> 00:11:12,290
现在有很多型号的笔记本

224
00:11:12,290 --> 00:11:13,970
它的这种

225
00:11:13,970 --> 00:11:15,970
呃，网线接口啊

226
00:11:15,970 --> 00:11:19,280
现在呢，跟 USB 接口长得一样了

227
00:11:19,280 --> 00:11:23,500
那这样子，诶，会出现什么样的情况呢

228
00:11:23,500 --> 00:11:25,880
我们会发现只有一个接口

229
00:11:25,880 --> 00:11:27,940
既能呢做网线功能

230
00:11:27,940 --> 00:11:30,840
也能呢，做一个 USB 数据传输

231
00:11:30,840 --> 00:11:32,390
那是不是很好呢

232
00:11:32,390 --> 00:11:34,830
哎，我不需要再开发其他接口啦

233
00:11:34,830 --> 00:11:36,560
但是我们会发现

234
00:11:36,560 --> 00:11:40,540
原本只是 USB 接口功能出问题

235
00:11:40,540 --> 00:11:42,940
现在你的电脑却连不上网了

236
00:11:42,940 --> 00:11:44,020
那为什么呢

237
00:11:44,020 --> 00:11:45,780
因为我们把功能啊

238
00:11:45,780 --> 00:11:47,440
揉到一块去了

239
00:11:47,440 --> 00:11:49,020
还有比较典型的

240
00:11:49,020 --> 00:11:52,010
我们现在有一些手机充电口

241
00:11:52,010 --> 00:11:55,260
和我们的耳机口是在一块儿的

242
00:11:55,260 --> 00:11:58,100
那原本呢，可能是你耳机出了问题

243
00:11:58,100 --> 00:11:59,280
耳机口的问题

244
00:11:59,280 --> 00:12:01,180
现在呢，手机充不进去电

245
00:12:01,180 --> 00:12:02,240
充不进去电了

246
00:12:02,240 --> 00:12:03,420
直接不能用了

247
00:12:03,420 --> 00:12:07,000
那是不是诶，相对来说损失更大了

248
00:12:07,000 --> 00:12:10,210
那所谓的接口隔离呀

249
00:12:10,210 --> 00:12:15,250
就是说新的功能我们呢，就用新的接口

250
00:12:15,250 --> 00:12:18,760
每一个功能的接口呢，都是专门的

251
00:12:18,760 --> 00:12:22,990
不要呢，用一个总接口来解决问题

252
00:12:22,990 --> 00:12:25,570
因为用一个总接口的话

253
00:12:25,570 --> 00:12:27,270
它们这个接口啊

254
00:12:27,270 --> 00:12:29,570
会与很多功能调用呢

255
00:12:29,570 --> 00:12:31,080
产生耦合

256
00:12:31,080 --> 00:12:35,680
那这种耦合性大家相互依赖关系太紧密了

257
00:12:35,680 --> 00:12:37,860
一旦出现问题的话

258
00:12:37,860 --> 00:12:42,360
大家呢，都需要重新的去进行检查匹配

259
00:12:42,360 --> 00:12:45,380
那这个功能相对来说呢

260
00:12:45,380 --> 00:12:46,780
造成的诶

261
00:12:46,780 --> 00:12:48,260
范围的影响呢

262
00:12:48,260 --> 00:12:50,750
影响的范围啊，就会呢比较大

263
00:12:50,750 --> 00:12:53,710
那这就是呢，接口隔离原则

264
00:12:53,710 --> 00:12:56,980
接口呢，要用多个专门的接口

265
00:12:56,980 --> 00:12:58,440
不要呢混到一起

266
00:12:58,440 --> 00:13:00,740
用单一的总接口

267
00:13:00,740 --> 00:13:03,100
这是接口隔离

268
00:13:03,100 --> 00:13:07,380
其实它与我们第一条单一职责原则

269
00:13:07,380 --> 00:13:08,890
是不是很相似啊

270
00:13:08,890 --> 00:13:12,910
它是涉及目的单一的接口

271
00:13:14,030 --> 00:13:15,390
啊

272
00:13:23,660 --> 00:13:25,840
接口它还有一个概念

273
00:13:25,840 --> 00:13:26,980
大家还记得吗

274
00:13:26,980 --> 00:13:29,380
接口类也叫边界类

275
00:13:29,380 --> 00:13:31,020
它是类的一种

276
00:13:31,020 --> 00:13:33,090
那类目的单一

277
00:13:33,090 --> 00:13:33,990
也就是呢

278
00:13:33,990 --> 00:13:35,370
接口目的单一

279
00:13:35,370 --> 00:13:38,720
二者呢，是有一定的关联性和相似性的

280
00:13:38,720 --> 00:13:41,360
那我们这里啊，所提出的原

281
00:13:41,360 --> 00:13:43,440
并不是一个人提出来的

282
00:13:43,440 --> 00:13:47,910
而是呢，根据啊，我们历年的这样的一些经验

283
00:13:47,910 --> 00:13:50,250
有人呢，进行了一个汇总

284
00:13:50,250 --> 00:13:53,790
所以这些原则并不是完全隔离开的

285
00:13:53,790 --> 00:13:57,330
相互之间可能会存在交叉

286
00:13:57,330 --> 00:14:00,540
那接口隔离原则看完之后

287
00:14:00,540 --> 00:14:02,930
我们再来看第六条原则

288
00:14:02,930 --> 00:14:06,080
叫做组合重用原则

289
00:14:06,080 --> 00:14:09,400
它强调的是重用的方

290
00:14:09,400 --> 00:14:12,380
用组合来达成

291
00:14:12,380 --> 00:14:16,030
那我们在面向对象过程当中

292
00:14:16,030 --> 00:14:18,650
包括后面讲 UML 图的时候

293
00:14:18,650 --> 00:14:22,600
大家会发现面向对象里面有很多的关系

294
00:14:22,600 --> 00:14:25,200
那在这些关系当中

295
00:14:25,200 --> 00:14:29,890
继承它是非常紧密的耦合关系

296
00:14:29,890 --> 00:14:32,610
而组合相对来说呢

297
00:14:32,610 --> 00:14:34,720
紧密性就弱了一些

298
00:14:34,720 --> 00:14:38,090
所以我们尽量呢，用弱耦合的，诶

299
00:14:38,090 --> 00:14:40,890
用组合来实现重用

300
00:14:40,890 --> 00:14:44,880
而不是继承关系来达到重用目的

301
00:14:44,880 --> 00:14:47,690
那包括我们在讲设计模式的时候

302
00:14:47,690 --> 00:14:48,750
也会发现呢

303
00:14:48,750 --> 00:14:50,910
有一些重用就是呢

304
00:14:50,910 --> 00:14:53,500
利用组合方式来实现的

305
00:14:53,500 --> 00:14:56,130
那为什么要用这种方式

306
00:14:56,130 --> 00:14:58,990
就是为了降低耦合性

307
00:14:58,990 --> 00:15:01,410
或者我们叫做呢解偶

308
00:15:04,680 --> 00:15:06,220
耦合度高了

309
00:15:06,220 --> 00:15:09,350
因为呢，产生的影响关联性会比较大

310
00:15:09,350 --> 00:15:11,540
耦合度一旦呢，降低

311
00:15:11,540 --> 00:15:14,200
那我们在做一些修改的时候呢

312
00:15:14,200 --> 00:15:15,900
哎，做一些变动的时候

313
00:15:15,900 --> 00:15:18,320
影响范围呢就会少一些

314
00:15:18,320 --> 00:15:19,240
那就是呢

315
00:15:19,240 --> 00:15:21,000
组合重用原则

316
00:15:21,000 --> 00:15:23,200
重用的方式选择组合

317
00:15:23,200 --> 00:15:25,080
而不是继承

318
00:15:25,080 --> 00:15:29,060
那第七条原则叫做呢，迪米特原则

319
00:15:29,060 --> 00:15:32,440
也叫做呢，最少知识法则

320
00:15:32,440 --> 00:15:35,820
它所要求的是什么样的一个状态呢

321
00:15:35,820 --> 00:15:37,100
一个对象啊

322
00:15:37,100 --> 00:15:40,860
他应当呢，尽可能的不要去知道其他的对象

323
00:15:40,860 --> 00:15:43,180
为什么你一旦了解了

324
00:15:43,180 --> 00:15:45,050
你就要呢产生关联性

325
00:15:45,050 --> 00:15:47,410
一旦产生了关联性

326
00:15:47,410 --> 00:15:51,610
那我们就会呢，牵一发而动全身吧

327
00:15:51,610 --> 00:15:53,310
所以我们在这里呢

328
00:15:53,310 --> 00:15:57,220
尽量只负责自己必须知道的东西

329
00:15:57,220 --> 00:15:58,590
不需要你知道

330
00:15:58,590 --> 00:16:00,310
就不要呢去看它

331
00:16:00,310 --> 00:16:00,650
唉

332
00:16:00,650 --> 00:16:01,560
否则的话

333
00:16:01,560 --> 00:16:04,990
原本跟你没关系的一个类发生变化

334
00:16:04,990 --> 00:16:06,230
因为你知道它

335
00:16:06,230 --> 00:16:07,510
你需要知道它呀

336
00:16:07,510 --> 00:16:09,770
所以它变化你也要呢

337
00:16:09,770 --> 00:16:12,220
随之去进行一些调整

338
00:16:12,220 --> 00:16:14,280
反而呢，增加了麻烦

339
00:16:14,280 --> 00:16:15,940
所以我们在这里呢

340
00:16:15,940 --> 00:16:18,090
诶，知道的多并不好

341
00:16:18,090 --> 00:16:19,120
每个人呢

342
00:16:19,120 --> 00:16:20,440
每个对象啊

343
00:16:20,440 --> 00:16:25,060
尽可能的只了解我们必须知道的内容

344
00:16:25,060 --> 00:16:30,410
对其他的对象要尽可能少的去了解

345
00:16:30,410 --> 00:16:34,440
那这个少就是呢，最少知识法则

346
00:16:34,440 --> 00:16:36,690
了解这七大原则

347
00:16:36,690 --> 00:16:38,910
它的描述以及呢

348
00:16:38,910 --> 00:16:43,010
与它相应原则名称的对应关系

349
00:16:43,010 --> 00:16:45,190
我们在考试当中的考察

350
00:16:45,190 --> 00:16:47,110
一般呢，是给大家描述

351
00:16:47,110 --> 00:16:49,820
让大家判断对应的原则

352
00:16:49,820 --> 00:16:52,180
或者给大家原则的名称

353
00:16:52,180 --> 00:16:57,370
让大家呢，来判断哪些描述是与之对应的

354
00:16:57,370 --> 00:17:00,710
这是考得较多的七大原则

355
00:17:01,080 --> 00:17:03,860
还有考得较少的一些呢

356
00:17:03,860 --> 00:17:07,550
其他原则也给大家呢，简单介绍一下

357
00:17:07,550 --> 00:17:09,470
那这一类的原则呀

358
00:17:09,470 --> 00:17:12,130
其实主要针对的是包

359
00:17:12,130 --> 00:17:13,420
这一部分

360
00:17:13,420 --> 00:17:17,910
包呢，它是我们面向对象当中的一个结构

361
00:17:17,910 --> 00:17:21,760
在 UML 图当中有专门的一个包结构

362
00:17:21,760 --> 00:17:26,180
一个包里面可以包含很多的一些类或者组件

363
00:17:26,180 --> 00:17:29,090
而在面向对象开发当中的话

364
00:17:29,090 --> 00:17:32,930
唉，我们经常会用到包这个关键字

365
00:17:32,930 --> 00:17:34,540
所谓的打包

366
00:17:34,540 --> 00:17:36,800
包里面可以有多个类

367
00:17:36,800 --> 00:17:39,120
实现了不同的功能

368
00:17:39,120 --> 00:17:41,300
面向对象设计当中呢

369
00:17:41,300 --> 00:17:43,080
哎，我们的七大原则

370
00:17:43,080 --> 00:17:44,580
大家呢了解之后

371
00:17:44,580 --> 00:17:47,180
其他原则简单看一看就行了

372
00:17:47,180 --> 00:17:50,780
首先第一条，关于重用发布

373
00:17:50,780 --> 00:17:52,370
那这个地方啊

374
00:17:52,370 --> 00:17:55,030
我们虽然也提到了重用

375
00:17:55,030 --> 00:17:57,660
但它强调的是发布

376
00:17:57,660 --> 00:18:02,740
重用和发布它的力度是一样的

377
00:18:02,740 --> 00:18:05,210
也就是说呢，你重用了什么

378
00:18:05,210 --> 00:18:08,810
你就要呢对重用的这一部分来发布

379
00:18:08,810 --> 00:18:12,050
那我们一般在面向对象当中写的代码啊

380
00:18:12,050 --> 00:18:15,830
要发布之后才能去调用这样的功能啊

381
00:18:15,830 --> 00:18:18,070
也就是说你重用了

382
00:18:18,070 --> 00:18:19,990
我们呢就要重新发布

383
00:18:19,990 --> 00:18:21,260
它们之间呢

384
00:18:21,260 --> 00:18:23,260
它的粗细的力度呢

385
00:18:23,260 --> 00:18:25,220
是相等的、等价的

386
00:18:25,220 --> 00:18:26,980
就叫做重用发布

387
00:18:26,980 --> 00:18:28,540
等价原则

388
00:18:29,040 --> 00:18:32,300
第二个，共同封闭原则

389
00:18:32,300 --> 00:18:34,600
那这里指的是封闭

390
00:18:34,600 --> 00:18:38,000
我们还记得前面讲到的开闭原则吧

391
00:18:38,000 --> 00:18:40,140
对什么样的地方开放

392
00:18:40,140 --> 00:18:41,630
对什么封闭啊

393
00:18:41,630 --> 00:18:44,240
对我们的修改封闭

394
00:18:44,240 --> 00:18:46,550
然后呢，对扩展开放

395
00:18:46,550 --> 00:18:49,860
那我们这里的共同分封闭呢

396
00:18:49,860 --> 00:18:52,900
指的是包里面所有的类

397
00:18:52,900 --> 00:18:55,280
那对同一个性质的变化呢

398
00:18:55,280 --> 00:18:57,810
唉，应该是共同封闭的

399
00:18:57,810 --> 00:19:01,360
所以说仍然是对变化封闭

400
00:19:01,360 --> 00:19:03,880
那针对同一类的变化

401
00:19:03,880 --> 00:19:08,670
一个包当中所有的类都应该对它来封闭

402
00:19:08,670 --> 00:19:10,990
这就是共同封闭

403
00:19:10,990 --> 00:19:12,270
与它类似的

404
00:19:12,270 --> 00:19:15,330
还有一个呢，共同重用原则

405
00:19:15,330 --> 00:19:18,510
那所谓的共同重用

406
00:19:18,510 --> 00:19:21,970
针对的也是一个包里面所有的类

407
00:19:21,970 --> 00:19:23,060
那我们呢

408
00:19:23,060 --> 00:19:27,240
唉，如果说有一个类里面重用呢

409
00:19:27,240 --> 00:19:29,590
唉，包里面有一个类重用了

410
00:19:29,590 --> 00:19:33,200
那么我们整个包里面所有的类都会呢

411
00:19:33,200 --> 00:19:34,500
拿来重用

412
00:19:34,500 --> 00:19:35,360
这就是呢

413
00:19:35,360 --> 00:19:37,890
共同重用原则

414
00:19:37,890 --> 00:19:41,010
第四个，无环依赖原则

415
00:19:41,010 --> 00:19:42,830
什么是还能

416
00:19:42,830 --> 00:19:45,490
我们在讲操作系统的时候

417
00:19:45,490 --> 00:19:48,530
死锁有一个条件叫做环路等待

418
00:19:48,530 --> 00:19:49,950
唉， A 等于 B 

419
00:19:49,950 --> 00:19:51,120
B 等于 A 

420
00:19:51,120 --> 00:19:53,770
那这个过程就叫做环路

421
00:19:53,770 --> 00:19:57,520
所谓的无环依赖就是包之间啊

422
00:19:57,520 --> 00:20:00,550
它们的结构呢，不要形成环

423
00:20:00,550 --> 00:20:01,830
那这就是呢

424
00:20:01,830 --> 00:20:04,150
无环依赖原则

425
00:20:04,150 --> 00:20:07,800
指的是包它的依赖关系

426
00:20:07,800 --> 00:20:10,650
最后还有一个稳定依赖

427
00:20:10,650 --> 00:20:14,120
以及呢，稳定抽象原则

428
00:20:14,120 --> 00:20:16,580
所谓的稳定依赖，唉

429
00:20:16,580 --> 00:20:20,560
简单来说就是朝稳定的方向产生依赖关系

430
00:20:20,560 --> 00:20:22,040
稳定抽象呢

431
00:20:22,040 --> 00:20:26,870
就是朝我们稳定的这种程度来发展

432
00:20:26,870 --> 00:20:28,880
包它的抽象程度啊

433
00:20:28,880 --> 00:20:32,830
应该呢跟它的稳定程度是一致的

434
00:20:32,830 --> 00:20:35,150
那这里呢，大家只需要诶

435
00:20:35,150 --> 00:20:38,390
了解到相应的这种说法和原则

436
00:20:38,390 --> 00:20:40,840
能够呢对应起来就可以了

437
00:20:40,840 --> 00:20:42,620
目前这一部分啊

438
00:20:42,620 --> 00:20:44,700
在我们的考试当中呢

439
00:20:44,700 --> 00:20:46,320
重复度并不高

440
00:20:46,320 --> 00:20:49,260
所以大家了解即可

441
00:20:49,770 --> 00:20:52,730
下面我们来看面向对象设计

442
00:20:52,730 --> 00:20:56,650
在我们软件设计师考试真题当中的体现

443
00:20:56,650 --> 00:20:59,750
首先是七大基本原则的考察

444
00:20:59,750 --> 00:21:02,910
那进行面向对象设计的时候

445
00:21:02,910 --> 00:21:05,700
若对于一个类而言

446
00:21:05,700 --> 00:21:10,550
应该呢仅有一个引起它变化的原因

447
00:21:10,550 --> 00:21:13,810
这属于什么设计原则呢

448
00:21:13,810 --> 00:21:17,560
首先我们要看到这里有几个类啊

449
00:21:17,560 --> 00:21:20,150
针对一个类而言的吧

450
00:21:20,150 --> 00:21:24,030
所以在这里跟子类、父类有没有关系啊

451
00:21:24,030 --> 00:21:25,160
没有关系

452
00:21:25,160 --> 00:21:27,600
所以不会是里氏替换

453
00:21:27,600 --> 00:21:31,380
并且我们会发现这里有没有提到接口呢

454
00:21:31,380 --> 00:21:35,210
哎，没有接口指的是接口

455
00:21:35,210 --> 00:21:37,030
它的责任单一吧

456
00:21:37,030 --> 00:21:39,910
所以这里呢也不是接口

457
00:21:39,910 --> 00:21:43,970
那我们剩下的单一职责和开放封闭

458
00:21:43,970 --> 00:21:45,250
唉，大家想一想

459
00:21:45,250 --> 00:21:47,370
这道题题干的描述

460
00:21:47,370 --> 00:21:50,570
跟我们的定义并不是完全一致

461
00:21:50,570 --> 00:21:53,470
但有一定的相似性

462
00:21:53,470 --> 00:21:55,850
所谓的开放封闭

463
00:21:55,850 --> 00:21:59,150
它是针对扩展开放

464
00:21:59,770 --> 00:22:06,030
对修改封闭这里有没有提到扩展

465
00:22:06,030 --> 00:22:07,080
没有

466
00:22:07,080 --> 00:22:08,700
所以在这里的话

467
00:22:08,700 --> 00:22:12,470
它是没有体现 K 和 B 的对比的

468
00:22:12,470 --> 00:22:15,200
所以 B 选项啊，也不是

469
00:22:15,200 --> 00:22:18,560
他指的是单一责任的原则

470
00:22:18,560 --> 00:22:21,520
所谓的单一职责原则

471
00:22:21,520 --> 00:22:26,260
是为了设计目的单一的类

472
00:22:29,520 --> 00:22:31,820
那这个单一

473
00:22:31,820 --> 00:22:33,400
唉，目的单一

474
00:22:33,400 --> 00:22:38,010
其实就是呢，仅有一个引起它变化的原因

475
00:22:38,010 --> 00:22:43,040
这种引起它变化其实就是它的目的

476
00:22:43,040 --> 00:22:44,870
仅有一个目的

477
00:22:44,870 --> 00:22:46,010
就是呢，唉

478
00:22:46,010 --> 00:22:47,310
目的单一

479
00:22:47,310 --> 00:22:49,180
单一职责原则

480
00:22:49,180 --> 00:22:51,860
这里呢，在考试当中啊

481
00:22:51,860 --> 00:22:54,440
如果发现一些描

482
00:22:54,440 --> 00:22:56,790
跟你呢，所记忆的内

483
00:22:56,790 --> 00:22:58,510
并不是完全一致

484
00:22:58,510 --> 00:22:59,570
怎么办呢

485
00:22:59,570 --> 00:23:02,230
针对其他选项对比

486
00:23:02,230 --> 00:23:04,510
看一看有没有呢

487
00:23:04,510 --> 00:23:05,870
解题的思路

488
00:23:05,870 --> 00:23:08,170
那我们在这里会发现呢

489
00:23:08,170 --> 00:23:10,750
对于接口隔离原则

490
00:23:10,750 --> 00:23:14,530
它的接口啊，是明确会提到的

491
00:23:14,530 --> 00:23:16,660
其次呢，李氏替换

492
00:23:16,660 --> 00:23:19,410
它会有父类、子类，唉

493
00:23:19,410 --> 00:23:21,850
有明确的替换过程

494
00:23:21,850 --> 00:23:24,890
至少有两个类可以替换吧

495
00:23:24,890 --> 00:23:29,220
而开闭原则，它体现的是一个对比

496
00:23:29,220 --> 00:23:33,930
对扩展和修改处理方式不一样的对比

497
00:23:33,930 --> 00:23:38,870
这是呢，我们说到的面向对象设计的七大原则

498
00:23:38,890 --> 00:23:43,860
下面呢，再来看一下对我们其他原则的考察

499
00:23:43,860 --> 00:23:47,610
那在进行面向对象系统设计的时候

500
00:23:47,610 --> 00:23:51,910
针对包来看它的所有类啊

501
00:23:51,910 --> 00:23:55,050
对于同一性质的变化，诶

502
00:23:55,050 --> 00:23:57,630
一个变化一旦呢

503
00:23:57,630 --> 00:23:59,770
对一个包产生影响

504
00:23:59,770 --> 00:24:03,660
那对包里面所有的类都会产生影响

505
00:24:03,660 --> 00:24:07,590
那在这里我们会发现它属于什么原则呢

506
00:24:07,590 --> 00:24:11,160
针对包来看肯定是共同的

507
00:24:11,160 --> 00:24:13,640
那共同的这种原则

508
00:24:13,640 --> 00:24:17,800
我们会看到呢，有共同封闭和共同重用

509
00:24:17,800 --> 00:24:20,210
共同封闭针对的是什么

510
00:24:20,210 --> 00:24:22,250
针对变化而言吧

511
00:24:22,250 --> 00:24:25,670
所以这里呢，其实是封闭原则

512
00:24:25,670 --> 00:24:27,570
对修改封闭

513
00:24:27,570 --> 00:24:29,130
对变化封闭

514
00:24:29,130 --> 00:24:31,320
所以是共同封闭

515
00:24:31,320 --> 00:24:33,440
那共同重用呢

516
00:24:33,440 --> 00:24:35,240
就是在包里面

517
00:24:35,240 --> 00:24:36,690
你对一个类，唉

518
00:24:36,690 --> 00:24:38,150
包里面一个类重用呢

519
00:24:38,150 --> 00:24:40,800
这个包里所有类呢，都会拿来重用

520
00:24:40,800 --> 00:24:43,890
开闭原则它不是针对包的

521
00:24:43,890 --> 00:24:45,670
它是针对类的

522
00:24:45,670 --> 00:24:47,930
对开、对扩展、开放

523
00:24:47,930 --> 00:24:49,580
对修改封闭

524
00:24:49,580 --> 00:24:51,410
接口隔离原则

525
00:24:51,410 --> 00:24:53,050
它是针对接口的

526
00:24:53,050 --> 00:24:55,850
接口的目的应该呢，单一

527
00:24:55,850 --> 00:24:57,510
不要呢用目的啊

528
00:24:57,510 --> 00:25:00,380
综合的这种总接口来处理

529
00:25:00,380 --> 00:25:04,340
那这是呢，对其他原则的考察

530
00:25:04,340 --> 00:25:08,880
主要呢，还是概念与名词的匹配关系

531
00:25:08,880 --> 00:25:10,530
大家呢，需要掌握

532
00:25:10,530 --> 00:25:13,390
以上呢，就是关于面向对象设计

533
00:25:13,390 --> 00:25:15,040
需要大家掌握的内容

534
00:25:15,040 --> 00:25:15,530
呃

535
00:25:15,530 --> 00:25:17,890
相对来说还是呢，基本概念

536
00:25:17,890 --> 00:25:22,070
需要呢，大家花更多的时间精力去啊，做一做题

537
00:25:22,070 --> 00:25:23,010
巩固一下

538
00:25:23,010 --> 00:25:23,630
设计

539
00:25:23,630 --> 00:25:26,850
这一部分呢，在考试当中占的比重呢

540
00:25:26,850 --> 00:25:28,110
并不是特别多
