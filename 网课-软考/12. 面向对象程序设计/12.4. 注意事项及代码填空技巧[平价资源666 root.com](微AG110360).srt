1
00:00:00,000 --> 00:00:02,500
下面我们简单的汇总一下

2
00:00:02,500 --> 00:00:05,980
对于这一类面向对象程序设计题

3
00:00:05,980 --> 00:00:08,080
也就是代码填空题当中呢

4
00:00:08,080 --> 00:00:09,880
需要注意的一些事项

5
00:00:09,880 --> 00:00:12,870
以及呢，代码填空的技巧部分

6
00:00:12,870 --> 00:00:15,280
首先的话我们要注意啊

7
00:00:15,280 --> 00:00:17,120
在代码填空的时

8
00:00:17,120 --> 00:00:19,910
一定要注意大小写问题

9
00:00:19,910 --> 00:00:23,930
我们的 java 和 C 加加都是大小写敏感的

10
00:00:23,930 --> 00:00:25,030
什么意思呢

11
00:00:25,030 --> 00:00:27,990
就是你将小写字母写成大写的话

12
00:00:27,990 --> 00:00:28,750
它会报错

13
00:00:28,750 --> 00:00:29,880
无法识别

14
00:00:29,880 --> 00:00:33,160
所以一定呢，要注意它的拼写

15
00:00:33,160 --> 00:00:35,700
尤其大小写呢，容易出错

16
00:00:35,700 --> 00:00:37,160
不要呢写错了

17
00:00:37,160 --> 00:00:41,630
那我们呢，在考试的时候经常会碰到啊

18
00:00:41,630 --> 00:00:45,480
要添加 this 或者使用 super 这种情况

19
00:00:45,480 --> 00:00:47,130
什么是 this 呢

20
00:00:47,130 --> 00:00:50,880
this 它是代指本类的对象

21
00:00:50,880 --> 00:00:53,360
那为什么要带纸呢

22
00:00:53,360 --> 00:00:56,140
我们在开发的过程当中啊

23
00:00:56,140 --> 00:00:59,100
对于属性成员数据

24
00:00:59,100 --> 00:01:01,940
一般呢会定义为私有的

25
00:01:01,940 --> 00:01:04,940
那这种私有的属性

26
00:01:04,940 --> 00:01:09,040
我们要如如何来查看或者修改呢

27
00:01:09,040 --> 00:01:12,720
我们也可以给他们保留公有的接口

28
00:01:12,720 --> 00:01:15,180
那这种接口一般呢

29
00:01:15,180 --> 00:01:18,360
叫做 get 和 set 函数

30
00:01:19,020 --> 00:01:23,670
get 函数呢，它是获取属性的函数

31
00:01:23,670 --> 00:01:29,800
那获取的时候我们的前面有返回值类型 get a 

32
00:01:29,800 --> 00:01:32,390
然后具体的内容呢

33
00:01:32,390 --> 00:01:35,710
就是返回 A 这个对象

34
00:01:35,710 --> 00:01:38,170
set 函数是做什么呢

35
00:01:38,170 --> 00:01:41,270
它会传递具体的数值

36
00:01:41,270 --> 00:01:45,590
那传递数值的话，用来做配置的

37
00:01:45,590 --> 00:01:47,800
它在配置的过程当中

38
00:01:47,800 --> 00:01:52,220
因为大家的名字一般呢，是同名来传输

39
00:01:52,220 --> 00:01:55,690
所以为了区分就有了 this 点

40
00:01:55,690 --> 00:01:58,120
A 等于 A 这种写法

41
00:01:58,120 --> 00:02:02,370
那这里呢，就会经常看到 this 它的用法了

42
00:02:02,370 --> 00:02:04,530
那这两个框架呀

43
00:02:04,530 --> 00:02:06,670
其实在我们代码开发的时候

44
00:02:06,670 --> 00:02:10,590
经常可以跟着属性随之自动生成

45
00:02:10,590 --> 00:02:13,080
可以一键生成的一些函数啊

46
00:02:13,080 --> 00:02:16,830
那我们在这里来看一下什么时候加 this 呢

47
00:02:16,830 --> 00:02:22,150
第一种就是呢，在 set 方法当中引用对象的变量

48
00:02:22,590 --> 00:02:25,570
假如我们现在有一个类

49
00:02:25,570 --> 00:02:27,310
它实现了一个接口

50
00:02:27,310 --> 00:02:28,580
这个类呢

51
00:02:28,580 --> 00:02:31,350
定义了很多的私有属性

52
00:02:31,350 --> 00:02:33,980
针对这些私有属性

53
00:02:33,980 --> 00:02:37,660
我们呢要去设定它相应的数值

54
00:02:37,660 --> 00:02:41,390
那设参数的时候就要传递参数

55
00:02:41,390 --> 00:02:46,360
传递参数会将相应的传参列表

56
00:02:46,360 --> 00:02:49,140
放到我们的参数列表当中去

57
00:02:49,140 --> 00:02:52,800
那这种传递过来的参数呢

58
00:02:52,800 --> 00:02:55,020
是我们传递的实参

59
00:02:55,020 --> 00:02:58,280
那这是我们传递具体数

60
00:02:58,280 --> 00:02:59,540
传过来的时候

61
00:02:59,540 --> 00:03:00,540
它的名字

62
00:03:00,540 --> 00:03:02,710
那我们要把它给谁呢

63
00:03:02,710 --> 00:03:07,320
要给到我们本类当中的属性名

64
00:03:07,320 --> 00:03:09,610
这个过程当中的话

65
00:03:09,610 --> 00:03:11,690
如果不用 this 

66
00:03:11,690 --> 00:03:15,040
就是本类当中属性名

67
00:03:15,040 --> 00:03:19,250
负值为参数列表传参的数值

68
00:03:19,250 --> 00:03:21,870
那大家长得一样呢

69
00:03:21,870 --> 00:03:24,620
到底谁传给谁呢

70
00:03:24,620 --> 00:03:26,380
计算机不知道

71
00:03:26,380 --> 00:03:28,520
所以要加以区别

72
00:03:28,520 --> 00:03:29,620
怎么来区别

73
00:03:29,620 --> 00:03:34,430
我们现在是把参数列表传给本类对象

74
00:03:34,430 --> 00:03:38,620
所以用本类对象加以引用

75
00:03:38,620 --> 00:03:40,310
this 点表示

76
00:03:40,310 --> 00:03:43,630
这是本类对象的组成部分

77
00:03:43,630 --> 00:03:47,750
我们经常看到 set 开头的这样的函数

78
00:03:47,750 --> 00:03:50,610
做的呢就是一个传参的过程

79
00:03:50,610 --> 00:03:54,590
经常呢会看到这种 this 的用法

80
00:03:54,970 --> 00:04:00,130
这是呢 set 方法当中引用对象的变量

81
00:04:00,130 --> 00:04:05,070
其次还有呢，我们在每一个类当中啊

82
00:04:05,070 --> 00:04:08,420
是可以呢有构造函数的

83
00:04:08,420 --> 00:04:11,150
那没有看到构造函数

84
00:04:11,150 --> 00:04:15,230
意味着我们构造函数是缺省状态

85
00:04:15,230 --> 00:04:18,690
也就是不带参数的构造函数

86
00:04:18,690 --> 00:04:21,519
那如果有参数的话

87
00:04:21,519 --> 00:04:24,120
这种构造函数如何来写呢

88
00:04:24,120 --> 00:04:27,510
构造函数在本类当中

89
00:04:27,510 --> 00:04:33,530
是一个与类名同名的成员函数

90
00:04:42,700 --> 00:04:47,930
比如说下面有一个类名是 cash discount 

91
00:04:47,930 --> 00:04:50,470
那我们在类当中啊

92
00:04:50,470 --> 00:04:52,810
有一个成员函数

93
00:04:52,810 --> 00:04:56,620
它的名字也叫 cash discount 

94
00:04:56,620 --> 00:05:00,760
那我们对于这种成员函数，诶

95
00:05:00,760 --> 00:05:02,320
它是同名的

96
00:05:02,320 --> 00:05:05,370
与类同名就叫做构造函数

97
00:05:05,370 --> 00:05:09,550
构造函数在构造对象的时候需要传参

98
00:05:09,550 --> 00:05:10,990
传什么参呢

99
00:05:10,990 --> 00:05:14,090
诶，没有属性的时候就不需要传参

100
00:05:14,090 --> 00:05:16,390
如果带属性的话

101
00:05:16,390 --> 00:05:21,650
我们一般呢，会写传递属性值的参数列表

102
00:05:21,650 --> 00:05:25,300
所以船参的过程当中

103
00:05:25,300 --> 00:05:28,280
这个构造函数的参数列表呀

104
00:05:28,280 --> 00:05:29,260
就是呢

105
00:05:29,260 --> 00:05:34,150
唉，与我们的属性名称相应的匹配起来的

106
00:05:34,150 --> 00:05:37,530
那这个过程又存在一个问题了吧

107
00:05:37,530 --> 00:05:40,890
我们这里是属性名称

108
00:05:40,890 --> 00:05:43,400
这里是传参的对象

109
00:05:43,400 --> 00:05:46,030
如果不带 this 的话

110
00:05:46,030 --> 00:05:48,450
大家又长得一样了呀

111
00:05:48,450 --> 00:05:50,720
不知道谁给谁怎么办

112
00:05:50,720 --> 00:05:52,550
加上 this 点

113
00:05:52,550 --> 00:05:54,110
注意这里的点啊

114
00:05:54,110 --> 00:05:55,900
也要呢标注出来

115
00:05:55,900 --> 00:05:58,280
那 this 点表示呢

116
00:05:58,280 --> 00:06:02,230
这是对当前对象来进行赋值的

117
00:06:02,230 --> 00:06:07,150
当前对象的属性赋值为等号右侧的部分

118
00:06:07,150 --> 00:06:09,780
那这就是呢，构造函

119
00:06:09,780 --> 00:06:11,000
构造的过程

120
00:06:11,000 --> 00:06:14,340
也会呢出现同名属性名唉

121
00:06:14,340 --> 00:06:15,340
取值相等啊

122
00:06:15,340 --> 00:06:17,520
这种传值赋值的过

123
00:06:17,520 --> 00:06:20,600
要用 this 来加以区分

124
00:06:21,730 --> 00:06:25,970
其次，我们在做父类与子类的时候

125
00:06:25,970 --> 00:06:28,760
或者接口与实现类的时候

126
00:06:28,760 --> 00:06:30,220
一定要注意呢

127
00:06:30,220 --> 00:06:33,300
它们之间的方法要统一

128
00:06:33,300 --> 00:06:35,340
我们在父类、子类啊

129
00:06:35,340 --> 00:06:37,140
尤其是抽象类

130
00:06:37,140 --> 00:06:38,450
还有接口

131
00:06:38,450 --> 00:06:40,840
那在这个过程当中呢

132
00:06:40,840 --> 00:06:42,860
如果有方法缺失

133
00:06:42,860 --> 00:06:47,100
可以呢，依据它相应的父类或者相应的子类

134
00:06:47,100 --> 00:06:49,350
来判断缺失的内容

135
00:06:49,350 --> 00:06:52,430
对于接口和抽象方法

136
00:06:52,430 --> 00:06:53,830
一定要注意

137
00:06:53,830 --> 00:06:55,690
它是没有方法体

138
00:06:55,690 --> 00:06:57,870
也就是呢，没有后括号的

139
00:06:57,870 --> 00:07:00,320
那在 C 加加当中呢

140
00:07:00,320 --> 00:07:03,140
它就是一个纯虚函数

141
00:07:03,140 --> 00:07:06,100
要用虚虚拟来修饰

142
00:07:06,100 --> 00:07:10,910
并且还有等于零的这种写法要注意

143
00:07:10,910 --> 00:07:13,540
最后，我们再来看一下呢

144
00:07:13,540 --> 00:07:15,200
代码填空当中啊

145
00:07:15,200 --> 00:07:18,330
比较麻烦的是函数调用的过程

146
00:07:18,330 --> 00:07:19,730
函数调用

147
00:07:19,730 --> 00:07:21,630
如果说代码当中啊

148
00:07:21,630 --> 00:07:23,750
方法体出现缺失的话

149
00:07:23,750 --> 00:07:24,530
我们呢

150
00:07:24,530 --> 00:07:29,840
可以根据传参来判断这个参数是什么类型

151
00:07:29,840 --> 00:07:32,180
而对应类型的对象

152
00:07:32,180 --> 00:07:34,880
能够调用的方法又有哪些

153
00:07:34,880 --> 00:07:37,120
从而来进行填空

154
00:07:37,120 --> 00:07:38,480
代码当中呢

155
00:07:38,480 --> 00:07:43,930
还可能出现我们的参数列表或者形参缺失

156
00:07:43,930 --> 00:07:47,600
那这个时候我们需要根据方法体判断

157
00:07:47,600 --> 00:07:51,410
我们在这个方法当中用到了哪些参数

158
00:07:51,410 --> 00:07:53,960
而用到的这些参数诶

159
00:07:53,960 --> 00:07:56,560
是不是目前没有给出来

160
00:07:56,560 --> 00:07:58,600
需要呢，来进行补充

161
00:07:58,600 --> 00:08:02,350
并且呢，判断了这个参数的类型

162
00:08:02,350 --> 00:08:05,090
这是我们在代码填空题当中

163
00:08:05,090 --> 00:08:07,280
难度较大的一类填空

164
00:08:07,280 --> 00:08:10,470
下面呢，简单给大家列举了一个例子

165
00:08:10,470 --> 00:08:14,060
那现在呢，有一个，唉， class book 

166
00:08:14,060 --> 00:08:16,030
它实现了一个接口

167
00:08:16,030 --> 00:08:18,350
针对这个实现过程呢

168
00:08:18,350 --> 00:08:20,530
我们有一个 accept 方法

169
00:08:20,530 --> 00:08:22,190
其实这是设计模式

170
00:08:22,190 --> 00:08:24,970
访问者模式里面的一个典型应用

171
00:08:24,970 --> 00:08:27,610
那在访问者方法后面

172
00:08:27,610 --> 00:08:31,500
跟随的是一个访问者类型的对象参数

173
00:08:31,500 --> 00:08:35,250
现在我们要补充一个方法体的话

174
00:08:35,250 --> 00:08:39,179
那这里一般会涉及到参数的使用吧

175
00:08:39,179 --> 00:08:41,419
既然传参肯定会用嘛

176
00:08:41,419 --> 00:08:42,799
所以我们可以呢

177
00:08:42,799 --> 00:08:46,580
跟随它的参数列表类型

178
00:08:46,580 --> 00:08:49,370
找到对应的这个类

179
00:08:49,370 --> 00:08:53,730
而这个类能够调用的方法有哪些呢

180
00:08:53,730 --> 00:08:57,370
哎，它有两个 visit 方法

181
00:08:57,700 --> 00:09:02,700
而这两个 visit 方法区别的就在于

182
00:09:02,700 --> 00:09:04,670
这个对象不一样

183
00:09:04,670 --> 00:09:06,970
唉，它所使用的参数不一样

184
00:09:06,970 --> 00:09:10,620
我们会发现这里没有给出其他参数啊

185
00:09:10,620 --> 00:09:12,860
这个时候我们就要考虑呢

186
00:09:12,860 --> 00:09:18,130
this ，唉，或者呢 super 在函数当中的用法了

187
00:09:18,130 --> 00:09:20,470
当参数不够用的时候

188
00:09:20,470 --> 00:09:25,000
考虑一下会不会是本类对象作为参数

189
00:09:25,000 --> 00:09:27,660
或者父类对象作为参数

190
00:09:27,660 --> 00:09:32,390
或者呢，调用了父类对象的某些函数方法

191
00:09:32,390 --> 00:09:33,800
而这里的话

192
00:09:33,800 --> 00:09:37,370
我们的上层是一个抽象接口

193
00:09:37,370 --> 00:09:41,330
现在不可作为本类对象的话

194
00:09:41,330 --> 00:09:45,860
刚好可以呢用来作为 visit 的参数

195
00:09:45,860 --> 00:09:51,160
所以这里缺失的内容是由 visito

196
00:09:51,160 --> 00:09:56,300
这个呢，唉，对象调用了自己 visit 的参数

197
00:09:56,300 --> 00:09:56,680
诶

198
00:09:56,680 --> 00:09:58,700
visit 的成员函数

199
00:09:58,700 --> 00:10:03,720
这个成员函数使用的参数是 book 类型的

200
00:10:03,720 --> 00:10:06,550
也就是本类对象类型

201
00:10:06,550 --> 00:10:10,180
直接用 this 来表示就可以了

202
00:10:10,180 --> 00:10:15,280
那这个其实是我们访问者模式的典型应用

203
00:10:15,280 --> 00:10:19,720
但我们只根据它的参数类型调用关系

204
00:10:19,720 --> 00:10:22,040
也能够找到答案

205
00:10:22,040 --> 00:10:25,850
这是呢，比较特殊的一种呢，查找过程

206
00:10:25,850 --> 00:10:28,280
所以啊，我们针对这

207
00:10:28,280 --> 00:10:30,000
给大家汇总了一些呢

208
00:10:30,000 --> 00:10:31,920
代码填空的技巧

209
00:10:31,920 --> 00:10:33,870
那第一类，填空

210
00:10:33,870 --> 00:10:37,650
关键字填空一定要注意大小写和拼写

211
00:10:37,650 --> 00:10:40,400
不要呢出现拼写错误

212
00:10:40,400 --> 00:10:43,190
第二类方法，缺失的填空

213
00:10:43,190 --> 00:10:46,130
那这里缺失方法可以呢

214
00:10:46,130 --> 00:10:47,030
根据父类

215
00:10:47,030 --> 00:10:51,740
子类或者接口类与实现类之间的对应关系

216
00:10:51,740 --> 00:10:53,020
来进行补充

217
00:10:53,020 --> 00:10:54,930
那这个补充的过程

218
00:10:54,930 --> 00:10:58,350
一定要注意接口以及抽象方法

219
00:10:58,350 --> 00:11:01,350
它们是没有方法体的

220
00:11:01,350 --> 00:11:03,810
但是返回值类型

221
00:11:03,810 --> 00:11:08,120
参数列表一定要跟上面保持一致

222
00:11:08,120 --> 00:11:11,170
参数列表不要漏掉了

223
00:11:11,360 --> 00:11:14,520
注意构造函数的写法

224
00:11:14,520 --> 00:11:18,880
还有呢， get 和 set 方法它的使用

225
00:11:18,910 --> 00:11:22,850
其次呢，哎，我们在使用 java 的时候

226
00:11:22,850 --> 00:11:26,090
有可能会出现一些自带类型

227
00:11:26,090 --> 00:11:29,810
比如说一些 list 或者迭代器这样的一些用法

228
00:11:29,810 --> 00:11:31,250
那这就没办法了

229
00:11:31,250 --> 00:11:34,230
这种考察只能呢靠平时的积累

230
00:11:34,230 --> 00:11:38,940
老师呢没办法把所有的类型都给大家呢讲到

231
00:11:38,940 --> 00:11:41,920
那我们呢在实例化的过程当中

232
00:11:41,920 --> 00:11:44,100
这种填写就要注意呢

233
00:11:44,100 --> 00:11:46,380
实例化它的参数选择

234
00:11:46,380 --> 00:11:49,750
实例化它的实例化过程啊

235
00:11:49,750 --> 00:11:51,910
一般是 L 

236
00:11:52,790 --> 00:11:53,990
名

237
00:11:55,230 --> 00:11:57,070
对象名

238
00:11:58,960 --> 00:12:02,720
等于 new 一个类名

239
00:12:03,280 --> 00:12:06,350
后面跟随参数列表

240
00:12:06,350 --> 00:12:11,070
那这里其实就是调用了它的同名构造函数

241
00:12:11,070 --> 00:12:12,940
来进行实例化

242
00:12:12,940 --> 00:12:14,130
还有一类呢

243
00:12:14,130 --> 00:12:17,590
是可以利用子类、父类来进行实例化

244
00:12:17,590 --> 00:12:18,930
那会有呢

245
00:12:18,930 --> 00:12:21,940
父类名称对象名

246
00:12:22,980 --> 00:12:27,180
以此呢， new 一个它的子类

247
00:12:32,830 --> 00:12:34,490
这个过程呢

248
00:12:34,490 --> 00:12:37,670
也是可以做实例化过程的

249
00:12:37,670 --> 00:12:41,120
那这是常见实例化的一个结构

250
00:12:41,120 --> 00:12:42,360
那我们呢

251
00:12:42,360 --> 00:12:45,080
第四类考察就是函数调用

252
00:12:45,080 --> 00:12:48,130
函数调用呢，要注意参数列表

253
00:12:48,130 --> 00:12:49,640
它的参数类型

254
00:12:49,640 --> 00:12:53,060
以及呢，对应参数能够调用的方法

255
00:12:53,060 --> 00:12:57,840
从而筛选出当前需要补充的函数

256
00:12:57,840 --> 00:13:01,060
那这就是呢，做函数调用的时候

257
00:13:01,060 --> 00:13:04,160
需要注意的一些代码填空的技巧了

258
00:13:04,160 --> 00:13:08,310
最后呢，唉，我们在软件设计师考试当中啊

259
00:13:08,310 --> 00:13:09,330
程序设计

260
00:13:09,330 --> 00:13:14,460
设计题最难的其实是在于与设计模式的结合

261
00:13:14,460 --> 00:13:18,740
那我们这些呢，可以结合历年真题的积累

262
00:13:18,740 --> 00:13:21,250
从而呢，进行提升

263
00:13:21,250 --> 00:13:23,850
那这就是呢，给大家介绍到的

264
00:13:23,850 --> 00:13:24,830
代码填空

265
00:13:24,830 --> 00:13:28,720
需要注意的一些事项和技巧的总结

266
00:13:28,720 --> 00:13:30,550
那像关键字填空

267
00:13:30,550 --> 00:13:33,930
还有上下文代码缺失这类补充

268
00:13:33,930 --> 00:13:36,960
完全可以把它当作呢送分题了

269
00:13:36,960 --> 00:13:41,270
给大家讲到了 set 方法和构造函数的用法

270
00:13:41,270 --> 00:13:45,210
这种呢， this 的用途也是呢送分性质的

271
00:13:45,210 --> 00:13:47,430
其他的内容相对来说呢

272
00:13:47,430 --> 00:13:49,410
有一些难度可以啊

273
00:13:49,410 --> 00:13:51,630
试着在做题的过程当中呢

274
00:13:51,630 --> 00:13:55,950
去理顺我们代码当中的逻辑顺序

275
00:13:55,950 --> 00:13:58,370
那这些呢，看完之后

276
00:13:58,370 --> 00:13:59,410
学完之后

277
00:13:59,410 --> 00:14:01,870
后面呢我们再以真题的形

278
00:14:01,870 --> 00:14:03,550
带大家来进行巩固
