1
00:00:00,000 --> 00:00:01,520
我们再来看一下

2
00:00:01,520 --> 00:00:05,250
关于构建器这样的设计模式的例题

3
00:00:05,250 --> 00:00:07,180
那下面告诉我们呢

4
00:00:07,180 --> 00:00:09,500
某个快餐厅主要呢

5
00:00:09,500 --> 00:00:11,990
制作并且出售儿童套餐

6
00:00:11,990 --> 00:00:16,900
一般呢，包括主餐、各类披萨、饮料和玩具

7
00:00:16,900 --> 00:00:20,940
其餐种啊、企业用餐的品种

8
00:00:20,940 --> 00:00:22,800
哎，这样的种类可能不一样

9
00:00:22,800 --> 00:00:25,130
但是呢，制作过程相同

10
00:00:25,130 --> 00:00:29,740
前台服务员调度厨师来制作套餐

11
00:00:29,740 --> 00:00:35,460
那现采用生成器相应的模式来实现制作过程

12
00:00:35,460 --> 00:00:38,590
得到如图所示的类图

13
00:00:38,590 --> 00:00:40,440
那我们在这里的话

14
00:00:40,440 --> 00:00:42,700
首先呢，这一类问题啊

15
00:00:42,700 --> 00:00:46,920
其实在我们后面的近几次的考察当中

16
00:00:46,920 --> 00:00:49,700
还曾经呢，出现改编

17
00:00:49,700 --> 00:00:52,900
将这类题型改成了上午题来考

18
00:00:52,900 --> 00:00:56,630
大家给了相应的这种类图和题干描述

19
00:00:56,630 --> 00:00:58,470
问大家是什么设计模式

20
00:00:58,470 --> 00:01:03,170
那这里呢，显然是我们生成器的是设计模式

21
00:01:03,170 --> 00:01:06,430
那针对代码填空题来看的话

22
00:01:06,430 --> 00:01:09,180
我们可以忽略掉它的这种呢

23
00:01:09,180 --> 00:01:10,640
设计模式的调用

24
00:01:10,640 --> 00:01:13,390
从语法先来进行填空

25
00:01:13,390 --> 00:01:16,300
那我们首先根据语法部分来看的话

26
00:01:16,300 --> 00:01:19,050
我们这里有一个披萨的类

27
00:01:19,050 --> 00:01:23,190
然后呢，有一个抽象的披萨 builder ，诶

28
00:01:23,190 --> 00:01:25,800
披萨构电器的抽象类

29
00:01:25,800 --> 00:01:28,320
那针对这个抽象类而言

30
00:01:28,320 --> 00:01:30,140
它有一个具体的实现吧

31
00:01:30,140 --> 00:01:31,260
下面有一个

32
00:01:31,260 --> 00:01:33,440
诶，夏威夷披萨构建器

33
00:01:33,440 --> 00:01:35,220
它继承了，诶

34
00:01:35,220 --> 00:01:39,670
或者说呢，它继承了我们的这个披萨生成器吧

35
00:01:39,670 --> 00:01:41,130
继承之后

36
00:01:41,130 --> 00:01:43,850
那它所包含的方法只有一个

37
00:01:43,850 --> 00:01:46,230
这个方法从哪里继承来的

38
00:01:46,230 --> 00:01:49,340
从它的抽象父类继承来的

39
00:01:49,340 --> 00:01:50,560
也就是说

40
00:01:50,560 --> 00:01:54,790
对比抽象父类和实现的子类来看的话

41
00:01:54,790 --> 00:01:56,130
我们会发现呢

42
00:01:56,130 --> 00:01:59,500
第 A 个填空它缺失了一个方法

43
00:01:59,500 --> 00:02:00,470
什么方法

44
00:02:00,470 --> 00:02:02,580
就是呢， builder pass 

45
00:02:02,580 --> 00:02:05,430
那这个 builder parts 的方法呢

46
00:02:05,430 --> 00:02:09,110
其实是我们生成器典型的应用

47
00:02:09,110 --> 00:02:13,440
那这里有一些细节需要大家注意

48
00:02:13,440 --> 00:02:15,980
那这个填空对不对

49
00:02:15,980 --> 00:02:17,690
大家可以自己看一看

50
00:02:17,690 --> 00:02:19,460
其实不对

51
00:02:19,460 --> 00:02:20,980
为什么不对呢

52
00:02:20,980 --> 00:02:22,020
我们说啊

53
00:02:22,020 --> 00:02:24,480
在抽抽象函数当中

54
00:02:24,480 --> 00:02:26,820
哎，在我们抽象类当中

55
00:02:26,820 --> 00:02:29,880
至少要包含一个抽象方法吧

56
00:02:29,880 --> 00:02:33,150
而在这里没有抽象方法

57
00:02:33,150 --> 00:02:37,380
所以我们补充的方法一定是抽象的

58
00:02:37,380 --> 00:02:40,970
并且子类在继承抽象类的时候

59
00:02:40,970 --> 00:02:44,570
一定会对抽象方法加以继承

60
00:02:44,840 --> 00:02:48,500
所以我们在这里补充的方法

61
00:02:48,500 --> 00:02:50,520
除了类型

62
00:02:50,590 --> 00:02:55,990
返回值、类型以及函数名、参数列表以外

63
00:02:55,990 --> 00:02:58,990
它还缺失了一个修饰

64
00:02:58,990 --> 00:03:00,320
什么修饰呢

65
00:03:00,320 --> 00:03:03,200
抽象修饰注意拼写

66
00:03:03,200 --> 00:03:04,700
不要写错了

67
00:03:04,700 --> 00:03:07,220
那这个抽象的修饰

68
00:03:07,220 --> 00:03:13,500
你放在 public 后面或者前面其实都是可以的

69
00:03:13,500 --> 00:03:17,220
那我们在这里 public 已经给出来了

70
00:03:17,220 --> 00:03:22,140
所以在填空的时候是不需要写出来 public 的

71
00:03:22,140 --> 00:03:26,470
只写抽象返回值为空

72
00:03:26,470 --> 00:03:30,520
builder pass 函数参数列表为空

73
00:03:30,520 --> 00:03:34,570
所以在填空的时候一定要注意细节

74
00:03:34,570 --> 00:03:37,180
很多同学会觉得自己会做

75
00:03:37,180 --> 00:03:41,130
然而呢，在具体代码填空的时候经常丢分

76
00:03:41,130 --> 00:03:42,330
丢在哪里呢

77
00:03:42,330 --> 00:03:45,010
就是丢在这一类细节问题

78
00:03:45,010 --> 00:03:47,770
所以碰到抽象关键

79
00:03:47,770 --> 00:03:50,630
一定呢，要有所警惕

80
00:03:50,630 --> 00:03:52,940
不要呢把它漏掉了

81
00:03:52,940 --> 00:03:55,790
那我们再来看后面的填空

82
00:03:56,220 --> 00:03:59,240
下面有一个 class water 类

83
00:03:59,240 --> 00:04:01,060
唉，有一个服务员的类

84
00:04:01,060 --> 00:04:05,860
那这个服务员的类它有一个呢，自己的属性诶

85
00:04:05,860 --> 00:04:06,840
叫做什么呢

86
00:04:06,840 --> 00:04:09,220
叫做披萨生成器吧

87
00:04:09,220 --> 00:04:11,870
那这个披萨生成器下面呢

88
00:04:11,870 --> 00:04:15,060
又给了一个典型的 set 方法的应用

89
00:04:15,060 --> 00:04:16,980
set 方法是干嘛的

90
00:04:16,980 --> 00:04:19,589
是用来设置属性值的

91
00:04:19,589 --> 00:04:23,350
那我们设置的属性值名称是谁呢

92
00:04:23,350 --> 00:04:25,350
是披萨 builder 

93
00:04:25,350 --> 00:04:28,520
那我们设置的时候有一个值给它

94
00:04:28,520 --> 00:04:30,630
这是一个传参的过程

95
00:04:30,630 --> 00:04:32,690
传递的参数是谁呢

96
00:04:32,690 --> 00:04:35,530
在我们的参数列表里面

97
00:04:35,530 --> 00:04:39,120
传递的参数也叫披萨 builder 

98
00:04:39,120 --> 00:04:43,480
那两个名称一样的时候怎么办

99
00:04:43,480 --> 00:04:46,560
添加 this 点加以区分

100
00:04:46,560 --> 00:04:50,150
这就是呢， set 函数的典型应用

101
00:04:50,150 --> 00:04:51,360
同名属性

102
00:04:51,360 --> 00:04:53,340
用 this 点表示呢

103
00:04:53,340 --> 00:04:55,990
本类对象的调用

104
00:04:55,990 --> 00:05:00,590
所以这里呢，是对我们披萨生成器的一个呢

105
00:05:00,590 --> 00:05:01,590
设置过程

106
00:05:01,590 --> 00:05:03,050
设置构建器

107
00:05:03,050 --> 00:05:07,000
或者叫做呢，生成器相同的一个意思啊

108
00:05:07,000 --> 00:05:09,660
那再来看下面这一部分

109
00:05:09,660 --> 00:05:11,760
对于披萨这里呢

110
00:05:11,760 --> 00:05:14,420
我们还有一个 get 披萨

111
00:05:14,420 --> 00:05:16,020
那 get 披萨的话

112
00:05:16,020 --> 00:05:19,200
我们返回的是一个披萨比的

113
00:05:19,200 --> 00:05:23,310
然后呢，从而获取到我们的披萨

114
00:05:23,310 --> 00:05:28,040
那这个披萨 builder 是我们刚刚传递过来的参数吧

115
00:05:28,040 --> 00:05:31,960
那这个披萨 builder 我们返回来来看一下

116
00:05:31,960 --> 00:05:34,810
披萨 builder 有几个函数啊

117
00:05:34,810 --> 00:05:38,720
在这里它有自己的披萨参数

118
00:05:38,720 --> 00:05:40,450
有 get 披萨

119
00:05:40,450 --> 00:05:42,990
哎，我们刚刚调用的 get pizza 吧

120
00:05:42,990 --> 00:05:45,380
那还有什么样的用法呢

121
00:05:45,380 --> 00:05:47,840
还可以 create new 披萨

122
00:05:47,840 --> 00:05:49,420
创建一个新披萨

123
00:05:49,420 --> 00:05:53,020
然后还有它的创建部分

124
00:05:53,020 --> 00:05:55,620
这样的两个函数没有用到

125
00:05:55,620 --> 00:05:58,680
那我们下面会看到对于 waiter 

126
00:05:58,680 --> 00:06:01,110
它的构建函数当中

127
00:06:01,110 --> 00:06:04,930
它调用了披萨比的 A 点什么呢

128
00:06:04,930 --> 00:06:08,910
引用了它创建新披萨的函数

129
00:06:08,910 --> 00:06:13,090
那缺失了一个填空函数体的缺失

130
00:06:13,090 --> 00:06:14,350
我们曾经提到

131
00:06:14,350 --> 00:06:16,960
我们可以纵观这一个类

132
00:06:16,960 --> 00:06:19,840
看一看有哪些参数可用

133
00:06:19,840 --> 00:06:22,910
那这样的参数能够调用

134
00:06:22,910 --> 00:06:26,070
或者被哪些函数调用

135
00:06:26,070 --> 00:06:27,670
那我们会发现

136
00:06:27,670 --> 00:06:31,340
引用调用的对象都是披萨 B 的

137
00:06:31,340 --> 00:06:34,670
披萨 builder 。自身自带了三个函数

138
00:06:34,670 --> 00:06:36,530
一个是 get pizza 

139
00:06:36,530 --> 00:06:39,010
一个是 create new pia 

140
00:06:39,010 --> 00:06:40,360
还有一个什么

141
00:06:40,360 --> 00:06:43,300
还有一个 builder pass 

142
00:06:43,710 --> 00:06:47,730
所以这里仍然是披萨 builder 诶

143
00:06:47,730 --> 00:06:52,440
然后呢，来调用自己创建部分的函数

144
00:06:52,440 --> 00:06:58,270
那这个函数其实也是构建器典型的应用

145
00:06:58,270 --> 00:07:00,710
那我们呢，调用 white 之后呢

146
00:07:00,710 --> 00:07:04,350
要一步步的去创建出完整的

147
00:07:04,350 --> 00:07:06,240
这样的披萨过程

148
00:07:06,240 --> 00:07:09,830
那这些呢，是我们前面对于披萨

149
00:07:09,830 --> 00:07:13,000
builder 以及 waiter 的这样的一些设置

150
00:07:13,000 --> 00:07:16,840
那下面就到了我们的主函数部分呢

151
00:07:16,840 --> 00:07:20,230
主函数它会呢去点餐

152
00:07:20,230 --> 00:07:22,290
那点餐的时候

153
00:07:22,290 --> 00:07:25,630
我们实例化了一个对象， waiter ，唉

154
00:07:25,630 --> 00:07:27,170
实例化一个服务员

155
00:07:27,170 --> 00:07:32,670
然后呢，实例化了一个夏威夷披萨构建器

156
00:07:32,670 --> 00:07:34,750
那有了 weight 

157
00:07:34,750 --> 00:07:37,590
有了夏威夷构建器之后

158
00:07:37,590 --> 00:07:40,110
我们要求输出

159
00:07:40,110 --> 00:07:41,530
唉，这个披萨

160
00:07:41,530 --> 00:07:45,210
并且由 white 来 get pizza 了吧

161
00:07:45,210 --> 00:07:48,230
那由 weer 来进行输出

162
00:07:48,230 --> 00:07:49,800
那在这里啊

163
00:07:49,800 --> 00:07:51,100
我们要注意

164
00:07:51,100 --> 00:07:52,580
这两个填

165
00:07:52,580 --> 00:07:56,920
其实就是呢，需要有关于我们设计模

166
00:07:56,920 --> 00:07:58,760
应用的基础了

167
00:07:58,920 --> 00:08:02,360
下面在应用的过程当中

168
00:08:02,360 --> 00:08:05,320
我们会发现应用的过程呀

169
00:08:05,320 --> 00:08:10,400
是将构建器和 white 把它拼装起来

170
00:08:10,400 --> 00:08:11,950
我们首先呢

171
00:08:11,950 --> 00:08:15,010
对于夏威夷构建器而言的话

172
00:08:15,010 --> 00:08:19,560
它其实是指只有构建部分，诶

173
00:08:19,560 --> 00:08:21,500
这样一个函数可用的吧

174
00:08:21,500 --> 00:08:24,190
那在这里有没有用到呢

175
00:08:24,190 --> 00:08:29,620
我们会发现这个函数是被 white 来调用的

176
00:08:29,620 --> 00:08:33,429
所以最终会用 white 来进行调用

177
00:08:33,429 --> 00:08:38,270
那 white 怎么调用夏威夷生成器构造的披萨呢

178
00:08:38,270 --> 00:08:42,350
只需要把生成器放到 white 就可以了

179
00:08:42,350 --> 00:08:46,970
所以我们利用 waiter 来设置它自己的生成器

180
00:08:46,970 --> 00:08:48,450
设置的是谁呢

181
00:08:48,450 --> 00:08:51,510
是我们刚刚实例化的夏威夷

182
00:08:51,510 --> 00:08:53,340
诶，披萨构建器

183
00:08:53,340 --> 00:08:56,550
那构建完成之后结束了吗

184
00:08:56,550 --> 00:08:59,660
没有，我们只是设置了构建器

185
00:08:59,660 --> 00:09:03,360
下一步还要呢，真正的去进行构建

186
00:09:03,360 --> 00:09:07,300
所以是 waiter 它的构造方法，诶

187
00:09:07,300 --> 00:09:10,940
它的构建披萨的方法不是同名构造函数啊

188
00:09:10,940 --> 00:09:12,090
不要理解错了

189
00:09:12,090 --> 00:09:13,720
那除此以外

190
00:09:13,720 --> 00:09:15,340
我们还有一个，诶

191
00:09:15,340 --> 00:09:17,020
获取披萨的方法吧

192
00:09:17,020 --> 00:09:22,470
在这里其实刚好是维特三种方法的调用

193
00:09:22,470 --> 00:09:24,890
那这里如果说不确定

194
00:09:24,890 --> 00:09:26,350
通过 waiter 呢

195
00:09:26,350 --> 00:09:30,890
也能够查看相应方法的调用过程

196
00:09:31,230 --> 00:09:36,180
那这里呢，是我们生成器模式的典型应用

197
00:09:36,180 --> 00:09:37,920
具体的代

198
00:09:37,920 --> 00:09:40,340
大家呢，可以自己再来看一看

199
00:09:40,340 --> 00:09:41,520
这样的写法

200
00:09:41,520 --> 00:09:44,610
细节上注意呢，不要有遗漏

201
00:09:44,610 --> 00:09:48,290
那这些啊，就是我们生成器程序设计题
