1
00:00:00,000 --> 00:00:01,660
接下来我们看到呢

2
00:00:01,660 --> 00:00:03,360
适配器它的应用

3
00:00:03,360 --> 00:00:05,100
适配器的作用呢

4
00:00:05,100 --> 00:00:07,670
在于一对一的接口转换

5
00:00:07,670 --> 00:00:09,150
那我们可以呢

6
00:00:09,150 --> 00:00:11,230
将不可用的这样的接口

7
00:00:11,230 --> 00:00:13,430
转换成了可用的接口

8
00:00:13,430 --> 00:00:14,820
下面告诉我们呢

9
00:00:14,820 --> 00:00:17,420
有一个软件系统已经设计

10
00:00:17,420 --> 00:00:21,480
并且实现了用于显示地址信息的这样的类

11
00:00:21,480 --> 00:00:25,810
那现在要求提供了基于荷兰语的这样的

12
00:00:25,810 --> 00:00:26,450
地址信息

13
00:00:26,450 --> 00:00:27,350
显示接口

14
00:00:27,350 --> 00:00:28,800
为了实现

15
00:00:28,800 --> 00:00:29,780
并且呢

16
00:00:29,780 --> 00:00:30,200
诶

17
00:00:30,200 --> 00:00:33,800
考虑到以后可能还会出现新的这种语言

18
00:00:33,800 --> 00:00:34,650
接口的话

19
00:00:34,650 --> 00:00:35,680
我们决定呢

20
00:00:35,680 --> 00:00:39,560
采用适配器的模式来实现这种方式

21
00:00:39,560 --> 00:00:40,970
那我们会发现

22
00:00:40,970 --> 00:00:44,450
地址信息是我们现在已经做好的

23
00:00:44,450 --> 00:00:46,470
而荷兰语地址呢

24
00:00:46,470 --> 00:00:48,940
是我们现在带适配的

25
00:00:48,940 --> 00:00:52,700
或者说带转换的一个呢，语言转

26
00:00:52,700 --> 00:00:56,720
至过程呢，会通过适配器来进行转换

27
00:00:56,720 --> 00:00:58,910
我们先呢，忽略设计模式

28
00:00:58,910 --> 00:01:00,010
只看代码

29
00:01:00,010 --> 00:01:01,570
相应的语法问题的话

30
00:01:01,570 --> 00:01:02,950
我们来看一下

31
00:01:03,210 --> 00:01:06,490
首先给了我们一个地址类型

32
00:01:06,490 --> 00:01:08,330
那这个地址类啊

33
00:01:08,330 --> 00:01:10,190
下面呢有三种方法

34
00:01:10,190 --> 00:01:13,560
分别呢，是获取它的街道邮

35
00:01:13,560 --> 00:01:15,830
以及呢所属的城市

36
00:01:15,830 --> 00:01:18,750
那下面呢，是荷兰语的地址

37
00:01:18,750 --> 00:01:22,530
诶，那这种的话，如果不太了解对应关系

38
00:01:22,530 --> 00:01:24,540
做起题来就比较麻烦了

39
00:01:24,540 --> 00:01:26,090
那我们看到呢

40
00:01:26,090 --> 00:01:27,970
s t r a a at 

41
00:01:27,970 --> 00:01:31,360
与 STREET 是不是很相似啊

42
00:01:31,360 --> 00:01:34,850
所以它们之间是具有对应关系的

43
00:01:34,850 --> 00:01:37,590
然后 zip 是邮编

44
00:01:37,590 --> 00:01:40,130
它与我们的 postcode 

45
00:01:40,130 --> 00:01:44,440
唉，这种 code 编码也有一定的诶，对应关系

46
00:01:44,440 --> 00:01:48,190
所以这两者呢，是有一定匹配关系的

47
00:01:48,190 --> 00:01:52,620
第三个 city 与我们的 PLAATS 呢

48
00:01:52,620 --> 00:01:54,180
也有匹配关系

49
00:01:54,180 --> 00:01:57,320
把这个对应关系啊，先搞清楚

50
00:02:27,360 --> 00:02:29,640
那我们把对应关系呢

51
00:02:29,640 --> 00:02:31,640
做了一个简单的标注

52
00:02:31,640 --> 00:02:33,300
下面呢，我们发现呢

53
00:02:33,300 --> 00:02:34,950
我们给了一个适配器

54
00:02:34,950 --> 00:02:37,330
那这是一个荷兰地址的适配器

55
00:02:37,330 --> 00:02:38,550
适配之后啊

56
00:02:38,550 --> 00:02:42,020
它继承了父类荷兰语的地址

57
00:02:42,020 --> 00:02:46,110
下面呢，第一个填空的缺失是一个呢

58
00:02:46,110 --> 00:02:47,880
成员缺失

59
00:02:47,880 --> 00:02:49,820
那这个成员缺失

60
00:02:49,820 --> 00:02:51,980
我们先看下文当中啊

61
00:02:51,980 --> 00:02:55,560
我们会发现它有一个同名的构造函数

62
00:02:55,560 --> 00:02:57,720
并且是带参数的

63
00:02:57,720 --> 00:03:01,430
那代参构造函数是为了配置

64
00:03:01,430 --> 00:03:03,240
设置一定的数值吧

65
00:03:03,240 --> 00:03:05,020
一定的属性取值

66
00:03:05,020 --> 00:03:06,640
那配置给谁

67
00:03:06,640 --> 00:03:12,580
唉，将 ADDR 我们传参传给 ADD r 1 SS 

68
00:03:12,580 --> 00:03:15,310
那谁是我们的成员属性啊

69
00:03:15,310 --> 00:03:17,220
见我们的等号

70
00:03:17,220 --> 00:03:19,560
左侧被赋值的对象呢

71
00:03:19,560 --> 00:03:23,250
是当前类所包含的成员属性

72
00:03:23,250 --> 00:03:26,450
而右侧是我们赋值的内容

73
00:03:26,450 --> 00:03:29,230
也就是呢，传参的内容

74
00:03:29,490 --> 00:03:33,470
所以根据这里我们会发现，唉

75
00:03:33,470 --> 00:03:38,950
我们缺失的属性名称叫做 ADD r e s 

76
00:03:38,950 --> 00:03:43,120
它的类型根据参数列表来看

77
00:03:43,120 --> 00:03:46,410
也是呢， ADDRESS 

78
00:03:46,410 --> 00:03:50,190
那这就是呢，我们缺失的成员属性

79
00:03:50,190 --> 00:03:53,440
我们在代餐构造函数当中啊

80
00:03:53,440 --> 00:03:57,220
还经常会用到 this 点这种形式

81
00:03:57,220 --> 00:04:00,490
this 点表示的是同类属性，诶

82
00:04:00,490 --> 00:04:02,640
我们当前类的对象

83
00:04:02,640 --> 00:04:04,480
那放在这个位置

84
00:04:04,480 --> 00:04:05,820
一般是因为啊

85
00:04:05,820 --> 00:04:10,570
两个属性箭头在我们的等号左侧和右侧啊

86
00:04:10,570 --> 00:04:12,730
它们的名称一致了

87
00:04:12,730 --> 00:04:16,110
那为了区别会用 this 点加以区分

88
00:04:16,110 --> 00:04:17,610
那这里不一样

89
00:04:17,610 --> 00:04:20,370
所以呢，可以忽略不写 this 点

90
00:04:20,370 --> 00:04:23,120
你在左侧写了 this 点呢

91
00:04:23,120 --> 00:04:24,500
问题也不大

92
00:04:24,500 --> 00:04:29,760
也能够啊识别出它是我们当前类的成员属性

93
00:04:30,120 --> 00:04:31,660
再往下看

94
00:04:31,660 --> 00:04:32,580
下面呢

95
00:04:32,580 --> 00:04:37,300
是我们适配器当中的 STRAAT 方法

96
00:04:37,300 --> 00:04:40,300
那这个方法是干嘛的呢

97
00:04:40,300 --> 00:04:44,040
唉，这个方法是为了做转换的

98
00:04:44,040 --> 00:04:45,410
那类似于啊

99
00:04:45,410 --> 00:04:48,810
我们在做中英文转换的时候

100
00:04:48,810 --> 00:04:52,750
我们想要的是一个中文的词汇

101
00:04:52,750 --> 00:04:57,060
而当前看到的文献是英文的

102
00:04:57,060 --> 00:04:58,160
那怎么办

103
00:04:58,160 --> 00:05:02,580
我们会通过翻译器来进行翻译

104
00:05:02,580 --> 00:05:05,730
翻译器它所做的是什么呢

105
00:05:05,730 --> 00:05:09,390
输入英文之后输出中文

106
00:05:09,390 --> 00:05:14,220
所以具体的实现最终体现的是中文吧

107
00:05:14,220 --> 00:05:18,290
也就是说，我们在荷兰语地址和 address 

108
00:05:18,290 --> 00:05:20,270
地址转换的过程当中

109
00:05:20,270 --> 00:05:23,910
最终我们想要看到的具体实现

110
00:05:23,910 --> 00:05:26,510
是左侧这一部分

111
00:05:26,510 --> 00:05:27,410
所以啊

112
00:05:27,410 --> 00:05:32,890
在它的函数名称中间的实现过程来看的话

113
00:05:32,890 --> 00:05:37,660
最终实现的是与之对应的这种呢

114
00:05:37,660 --> 00:05:40,670
诶，地址信息的类型

115
00:05:40,670 --> 00:05:43,140
那地址信息的类

116
00:05:43,140 --> 00:05:48,600
我们在这里呢，要考虑到面向对象过程当中啊

117
00:05:48,600 --> 00:05:52,160
方法一般都是被对象来调用的

118
00:05:52,160 --> 00:05:54,500
那我们方法体的缺失

119
00:05:54,500 --> 00:05:58,470
就要考虑这个类里面有什么对象可用呢

120
00:05:58,470 --> 00:06:01,710
我们会发现它有一个地址对象吧

121
00:06:01,710 --> 00:06:06,650
所以用地址对象调用他自己的 street 

122
00:06:06,650 --> 00:06:08,840
这种方法就可以了

123
00:06:08,840 --> 00:06:14,180
那我们最终实现的还是呢， address 这种形式

124
00:06:14,180 --> 00:06:17,560
那就起到了接口转换的作用

125
00:06:17,560 --> 00:06:20,030
也就是适配器它的应用

126
00:06:20,030 --> 00:06:22,380
如果不了解适配器

127
00:06:22,380 --> 00:06:27,410
那我们在这里只需要考虑相应的对应关系

128
00:06:27,410 --> 00:06:28,940
以及呢，唉

129
00:06:28,940 --> 00:06:33,860
调用对应函数的对象是 address 就可以了

130
00:06:33,860 --> 00:06:36,610
这里呢，也能够找到相应的答案

131
00:06:36,610 --> 00:06:39,820
但是本题呀，其实还存在第二个坑点

132
00:06:39,820 --> 00:06:43,780
就是呢，这个对应关系你能不能找得到

133
00:06:44,100 --> 00:06:46,980
那对于第二个填空，看完之后

134
00:06:46,980 --> 00:06:50,510
三四填空跟第二个填空是一模一样的

135
00:06:50,510 --> 00:06:53,790
同样呢，填的是对应关系

136
00:06:53,790 --> 00:06:56,310
与它对应的是 zip 方法

137
00:06:56,310 --> 00:06:59,080
与它对应的是 city 方法

138
00:06:59,080 --> 00:07:04,330
调用该函数的对对象都是呢 address 成员

139
00:07:04,330 --> 00:07:07,570
也就是我们当前定义的私有成员

140
00:07:07,570 --> 00:07:08,910
那这道题啊

141
00:07:08,910 --> 00:07:11,090
第一空和第二、三、四空呢

142
00:07:11,090 --> 00:07:13,080
也有一定的关联性

143
00:07:13,080 --> 00:07:16,100
所以本题呢，它的逻辑理起来

144
00:07:16,100 --> 00:07:17,540
理解起来不难

145
00:07:17,540 --> 00:07:21,280
但是填空的时候很容易呢，出现错误

146
00:07:21,280 --> 00:07:24,060
这里呢，要注意细心一些

147
00:07:24,060 --> 00:07:27,140
那下面是我们的测试类

148
00:07:27,480 --> 00:07:32,410
测试类呢，也是我们本代码当中的主函数

149
00:07:32,410 --> 00:07:36,400
首先呢，它实例化了一个 address 的对象

150
00:07:36,400 --> 00:07:38,050
叫做 ADDR 

151
00:07:38,050 --> 00:07:40,410
然后缺失了一个填空

152
00:07:40,410 --> 00:07:43,230
接下来可以输出一句话

153
00:07:43,230 --> 00:07:47,030
然后呢，调用了 test 的方法

154
00:07:47,340 --> 00:07:49,820
test 的方法当中啊

155
00:07:49,820 --> 00:07:51,980
它调用了一个参数

156
00:07:51,980 --> 00:07:54,910
那很明显参数没有出现

157
00:07:54,910 --> 00:07:59,730
所以这里第五空缺失的填空是参数

158
00:07:59,730 --> 00:08:02,250
它的缺失进行实例化

159
00:08:02,250 --> 00:08:05,380
那我们这个参数应该是对象吧

160
00:08:05,380 --> 00:08:07,800
实例化的过程当中

161
00:08:07,800 --> 00:08:10,690
它会有一定的类名

162
00:08:10,690 --> 00:08:13,510
对象名等于 new 

163
00:08:13,510 --> 00:08:15,450
然后类名

164
00:08:16,170 --> 00:08:19,170
以及相应的参数列表

165
00:08:19,170 --> 00:08:23,220
那这是呢，比较常规的实例化的过程

166
00:08:23,220 --> 00:08:27,170
那我们在这里对象名是不是已经明确了

167
00:08:27,170 --> 00:08:33,380
是 a ADD r 、 AD 、 APTER 

168
00:08:33,380 --> 00:08:35,210
这是一个适配器

169
00:08:35,210 --> 00:08:39,100
那这个适配器它的类型是什么呢

170
00:08:39,100 --> 00:08:42,240
我们根据具体的这个测试方法

171
00:08:42,240 --> 00:08:43,480
我们会发现呢

172
00:08:43,480 --> 00:08:46,300
测试方法已经明确

173
00:08:46,300 --> 00:08:47,940
我们传参的类型吧

174
00:08:47,940 --> 00:08:52,680
所以这个参数类型最终一定是

175
00:08:52,680 --> 00:08:55,340
哎，我们的荷兰地址

176
00:08:55,980 --> 00:08:58,240
那我们会发现，哎

177
00:08:58,240 --> 00:09:00,540
这是一个适配器的名字

178
00:09:00,540 --> 00:09:02,540
这是一个地址的名字

179
00:09:02,540 --> 00:09:05,260
它们怎么会搅合到一块儿去了呢

180
00:09:05,260 --> 00:09:08,920
其实这就是典型的父类拿来实例化

181
00:09:08,920 --> 00:09:12,960
我们如果是父类与子类来进行实例化的话

182
00:09:12,960 --> 00:09:15,570
一般前面是父类名

183
00:09:15,570 --> 00:09:17,820
后面是子类名

184
00:09:17,820 --> 00:09:19,920
那在本题当中啊

185
00:09:19,920 --> 00:09:23,420
适配器他继承了荷兰语地址

186
00:09:23,420 --> 00:09:26,160
所以啊，前面是它的父类

187
00:09:26,160 --> 00:09:30,220
也就是当前的荷兰语地址作为类名

188
00:09:34,680 --> 00:09:36,980
那 new 的是谁呢

189
00:09:36,980 --> 00:09:40,420
new 的它应该是一个适配器

190
00:09:40,420 --> 00:09:42,890
那这个适配器

191
00:09:42,890 --> 00:09:47,630
它的构造函数是我们诶用到的一个参数吧

192
00:09:47,630 --> 00:09:51,840
那这个构造函数是代参的构造函数

193
00:09:51,840 --> 00:09:55,250
所以我们在实例过程当中

194
00:09:55,250 --> 00:09:57,030
实例化过程当中

195
00:09:57,030 --> 00:09:59,760
它的类名是哎

196
00:09:59,760 --> 00:10:02,740
它的这个荷兰语适配器

197
00:10:07,300 --> 00:10:12,270
后面还要跟随一个参数做实例化

198
00:10:12,270 --> 00:10:14,240
诶，那这个参数是谁啊

199
00:10:14,240 --> 00:10:16,420
是一个地址类型的参数

200
00:10:16,420 --> 00:10:19,350
地址类型的参数已经有了吧

201
00:10:19,350 --> 00:10:22,750
所以在这里用到的参数就是呢

202
00:10:22,750 --> 00:10:23,800
A d d 

203
00:10:23,800 --> 00:10:26,340
前面实例化的地址

204
00:10:26,340 --> 00:10:27,800
所以这道题啊

205
00:10:27,800 --> 00:10:31,180
第五个填空呢，考的是实例化的过程

206
00:10:31,180 --> 00:10:34,410
并且这个实例化的过程比较复杂

207
00:10:34,410 --> 00:10:38,580
用到了父类和子类来进行实例化

208
00:10:38,580 --> 00:10:42,420
并且最终实例化还是一个代餐的

209
00:10:42,420 --> 00:10:43,760
实例化的过程

210
00:10:43,760 --> 00:10:46,660
嗯，那这五个填空的代码

211
00:10:46,660 --> 00:10:47,860
大家可以自己呢

212
00:10:47,860 --> 00:10:50,460
再来看一看它的具体写法

213
00:10:50,460 --> 00:10:53,300
这道题。首先第一空呢

214
00:10:53,300 --> 00:10:55,250
肯定是送分性质的

215
00:10:55,250 --> 00:10:57,870
告诉我们的是缺失了一个属性

216
00:10:57,870 --> 00:11:01,980
根据呢，构造函数可以判断缺失属性的名称

217
00:11:01,980 --> 00:11:03,280
以及呢，它的

218
00:11:03,280 --> 00:11:05,290
诶，相应的数据类型

219
00:11:05,290 --> 00:11:09,410
那中间的三个代码都是呢

220
00:11:09,410 --> 00:11:11,410
适配器的应用本身

221
00:11:11,410 --> 00:11:13,410
它的逻辑比较好理解

222
00:11:13,410 --> 00:11:16,050
只要知道是找对应关系的

223
00:11:16,050 --> 00:11:19,810
一般呢，第 A 个填空还是第二个填空啊

224
00:11:19,810 --> 00:11:24,940
关于呢，这个同类型相似方法的一个转换

225
00:11:24,940 --> 00:11:26,860
还是能够判断出来的

226
00:11:26,860 --> 00:11:29,720
如果有一定英文基础了，诶

227
00:11:29,720 --> 00:11:32,320
我们的 zip 和我们的呃

228
00:11:32,320 --> 00:11:34,880
post code 能够呢联系起来

229
00:11:34,880 --> 00:11:38,090
第三个填空呢，其实也是能够找到的

230
00:11:38,090 --> 00:11:41,540
那如果前面两个填空判断出来之后

231
00:11:41,540 --> 00:11:45,620
剩余的对应关系也会呢，随之找出来

232
00:11:45,620 --> 00:11:48,650
最难的其实就是我们最后一个

233
00:11:48,650 --> 00:11:50,770
实例化的过程

234
00:11:51,140 --> 00:11:53,580
实例化结果当中啊

235
00:11:53,580 --> 00:11:56,300
它的对象名称根据函数调用

236
00:11:56,300 --> 00:11:57,100
知道了

237
00:11:57,100 --> 00:12:01,300
然后呢，前面的类型根据你呢下面方法调用

238
00:12:01,300 --> 00:12:04,810
传参的类型也能够随之确定

239
00:12:04,810 --> 00:12:09,640
那比较困难的是找到它是适配器的类型

240
00:12:09,640 --> 00:12:11,880
那这里呢，就要理解

241
00:12:11,880 --> 00:12:14,500
我们在一些代码填空啊

242
00:12:14,500 --> 00:12:16,320
包括程序设计的时候

243
00:12:16,320 --> 00:12:19,960
有一些名称它是具有一定隐含含义的

244
00:12:19,960 --> 00:12:21,580
像我们前面所做的

245
00:12:21,580 --> 00:12:25,360
其实就命名已经明确了是一个适配器

246
00:12:25,360 --> 00:12:26,740
所以在这里啊

247
00:12:26,740 --> 00:12:29,570
他一定做的是适配器的实例化

248
00:12:29,570 --> 00:12:33,610
那找到适配器实例化与之对应的参数

249
00:12:33,610 --> 00:12:36,220
就完成了实例化的过程

250
00:12:36,220 --> 00:12:38,660
这道题啊，有一定的难度

251
00:12:38,660 --> 00:12:42,400
但是呢，还是可以保证有一定得分的
