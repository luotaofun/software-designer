1
00:00:00,000 --> 00:00:02,120
我们接下来看到的呢

2
00:00:02,120 --> 00:00:07,780
是以回溯法来解决背包问题的真题实例

3
00:00:07,780 --> 00:00:10,000
在这道题当中啊

4
00:00:10,000 --> 00:00:11,500
我们可以看到呢

5
00:00:11,500 --> 00:00:13,440
首先，题干告诉我们

6
00:00:13,440 --> 00:00:16,320
对于零一背包问题的描述

7
00:00:16,320 --> 00:00:17,560
跟我们呢

8
00:00:17,560 --> 00:00:20,020
之前的背包问题概述

9
00:00:20,020 --> 00:00:22,650
讲解的基本上是一致的

10
00:00:22,650 --> 00:00:27,220
有 N 个物品对 I 等于1234到 N 

11
00:00:27,220 --> 00:00:30,940
那这第 I 个物品的价值呢，记作 V ， I 

12
00:00:30,940 --> 00:00:33,040
重量呢，记作 WI 

13
00:00:33,040 --> 00:00:35,280
那 vi 和 WI 肯定呢

14
00:00:35,280 --> 00:00:37,060
是大于等于零的

15
00:00:37,060 --> 00:00:39,990
非负数背包的总容量呢

16
00:00:39,990 --> 00:00:41,870
即作大写的 W 

17
00:00:41,870 --> 00:00:45,250
大写的 W 呢，同样是非负的

18
00:00:45,250 --> 00:00:49,890
选择其中的一些物品装入这个背包

19
00:00:49,890 --> 00:00:53,020
使装入背包的物品啊

20
00:00:53,020 --> 00:00:56,300
它的总价值尽可能的大

21
00:00:56,300 --> 00:00:57,530
也就是呢

22
00:00:57,530 --> 00:00:59,450
描述我们之前给大家的

23
00:00:59,450 --> 00:01:00,790
这样的一个公式

24
00:01:00,790 --> 00:01:05,570
满足呢，所有的物品当中要么在背包

25
00:01:05,570 --> 00:01:07,270
要么不在背包

26
00:01:07,270 --> 00:01:10,190
并且满足限制条件

27
00:01:10,190 --> 00:01:14,710
物品的总重量不能超过背包的总容量

28
00:01:14,710 --> 00:01:18,290
其次呢，唉，我们要求一个最优解

29
00:01:18,290 --> 00:01:20,410
使得呢，装入物品啊

30
00:01:20,410 --> 00:01:23,270
它的总价值尽可能的大

31
00:01:23,270 --> 00:01:25,070
这个物品要么都放

32
00:01:25,070 --> 00:01:26,570
要么都不放呢

33
00:01:26,570 --> 00:01:28,370
就叫做零一背包

34
00:01:28,370 --> 00:01:29,280
问题

35
00:01:29,280 --> 00:01:32,880
类似于呢，我们在过海关，呃

36
00:01:32,880 --> 00:01:37,160
有时候呢，会让大家选择一些物品来进行带回

37
00:01:37,160 --> 00:01:40,470
不能呢，超过限定的一个重量

38
00:01:40,470 --> 00:01:42,820
那我们在带回物品的时候

39
00:01:42,820 --> 00:01:45,780
有时候呢，会考虑到它的价值问题

40
00:01:45,780 --> 00:01:49,320
一方面呢，不能超过限定的重量

41
00:01:49,320 --> 00:01:52,570
其次呢，想要带回的物品价值还要呢

42
00:01:52,570 --> 00:01:53,650
尽可能的高

43
00:01:53,650 --> 00:01:56,060
这就是呢，零一背包

44
00:01:56,060 --> 00:01:58,760
那我们本题当中啊

45
00:01:58,760 --> 00:02:01,670
是要求以回溯法来解决

46
00:02:01,670 --> 00:02:02,980
回溯法呢

47
00:02:02,980 --> 00:02:06,540
它就是以一种系统的搜索方法

48
00:02:06,540 --> 00:02:09,680
对整个解空间来进行探索

49
00:02:09,680 --> 00:02:12,130
确定解空间之后啊

50
00:02:12,130 --> 00:02:14,570
从根节点开始呢

51
00:02:14,570 --> 00:02:20,050
按照深度优先的策略来进行便利解的

52
00:02:20,050 --> 00:02:22,790
这棵空间树探索呢

53
00:02:22,790 --> 00:02:25,020
满足约束条件的解

54
00:02:25,020 --> 00:02:26,090
也就是呢

55
00:02:26,090 --> 00:02:29,430
我们的重量不能超过背包总容量

56
00:02:29,430 --> 00:02:31,790
然后尽可能得到最优解

57
00:02:31,790 --> 00:02:34,780
那我们在回溯法解决的时候呢

58
00:02:34,780 --> 00:02:36,880
没有要求最优解

59
00:02:36,880 --> 00:02:40,980
一般它是对所有的解都会呢，做一个便利

60
00:02:40,980 --> 00:02:43,080
可以得到很多的可行解

61
00:02:43,080 --> 00:02:45,120
再从可行解当中啊

62
00:02:45,120 --> 00:02:48,090
去找到一个最优解

63
00:02:48,090 --> 00:02:51,510
那对每一个当前节点而言啊

64
00:02:51,510 --> 00:02:55,450
若扩展该节点已经不满足约束的条件

65
00:02:55,450 --> 00:02:56,860
这样的节点的话

66
00:02:56,860 --> 00:02:59,920
则不需要再继续扩展了

67
00:02:59,920 --> 00:03:02,180
也就是说呢，在这里啊

68
00:03:02,180 --> 00:03:05,060
为了提高算法的搜索效率

69
00:03:05,060 --> 00:03:08,060
我们呢，会设定一个呢，限界函数

70
00:03:08,060 --> 00:03:09,990
拿来呢，减脂呀

71
00:03:09,990 --> 00:03:12,130
如果说当前这个节点

72
00:03:12,130 --> 00:03:14,180
如果扩展这个节点的话

73
00:03:14,180 --> 00:03:16,240
已经不满足约束条件了

74
00:03:16,240 --> 00:03:18,840
我们呢，就不需要往后去探索

75
00:03:18,840 --> 00:03:22,050
把这一个分支呢，直接减掉

76
00:03:22,050 --> 00:03:26,130
那这里呢，就可以提高我们搜索的效率

77
00:03:26,130 --> 00:03:30,890
现在假设已经涉及了这样的一个限界函数

78
00:03:30,890 --> 00:03:34,600
那这个函数呢，里面传递了一些参数

79
00:03:34,600 --> 00:03:37,470
V 、 wk 和大写的 W 

80
00:03:37,470 --> 00:03:41,060
分别表示当前已经获得的价值

81
00:03:41,060 --> 00:03:46,220
当前背包的重量、已经确定是否选择的物品数量

82
00:03:46,220 --> 00:03:48,920
和背包的总容量

83
00:03:48,920 --> 00:03:53,370
那对于搜索数当中的某个节点而言啊

84
00:03:53,370 --> 00:03:56,440
这个函数的值可以表示呢

85
00:03:56,440 --> 00:04:00,740
确定了部分物品是否选择之后

86
00:04:00,740 --> 00:04:04,790
剩下物品满足约束条件的前提下

87
00:04:04,790 --> 00:04:07,740
能够获得的最大价值

88
00:04:07,740 --> 00:04:09,130
提炼一下呢

89
00:04:09,130 --> 00:04:11,550
就是说我们这个 B 的函数啊

90
00:04:11,550 --> 00:04:14,250
最终返回的是一个呢价值

91
00:04:14,250 --> 00:04:17,709
这个价值呢，是对当前的这个物品

92
00:04:17,709 --> 00:04:20,250
假设放进去之后能够呢

93
00:04:20,250 --> 00:04:21,790
获得的最大价值

94
00:04:21,790 --> 00:04:25,140
并且呢，是满足了约束条件的

95
00:04:25,140 --> 00:04:28,710
那我们当前这个物品放进去的最大价值

96
00:04:28,710 --> 00:04:33,710
如果说小于等于已经得到的最优解

97
00:04:33,710 --> 00:04:35,070
说明有没有用啊

98
00:04:35,070 --> 00:04:35,790
没有用

99
00:04:35,790 --> 00:04:39,390
那这个节点呢，就不需要往下去扩展了

100
00:04:39,390 --> 00:04:42,660
这就是一个剪枝丫的过程

101
00:04:43,360 --> 00:04:46,500
下面给了零一背包问题

102
00:04:46,500 --> 00:04:50,350
它的回溯算法相关的伪代

103
00:04:50,350 --> 00:04:51,400
里面呢

104
00:04:51,400 --> 00:04:53,780
涉及到的参数有，呃

105
00:04:53,780 --> 00:04:56,480
大写的 W 表示背包容量

106
00:04:56,480 --> 00:04:58,320
N 表示物品个数

107
00:04:58,320 --> 00:05:01,360
小写的 W 呢，是一个重量数组

108
00:05:01,360 --> 00:05:03,230
V 是价值数组

109
00:05:03,230 --> 00:05:06,570
FW 是获得最大价值的时

110
00:05:06,570 --> 00:05:08,400
对应的背包重量

111
00:05:08,400 --> 00:05:08,960
f 

112
00:05:08,960 --> 00:05:11,120
P 呢，表示我们啊

113
00:05:11,120 --> 00:05:13,660
背包能够获得的最大价值

114
00:05:13,660 --> 00:05:16,790
X 呢，是问题的最优解

115
00:05:16,790 --> 00:05:20,040
cw 呢是当前背包重量

116
00:05:20,040 --> 00:05:23,200
CP 呢是当前获得的价值

117
00:05:23,200 --> 00:05:27,200
K 表示当前考虑的物品编号

118
00:05:27,200 --> 00:05:30,860
Y 是当前已获得的部分

119
00:05:30,860 --> 00:05:31,740
解

120
00:05:31,980 --> 00:05:36,240
在这里给我们展示到的是一个呢

121
00:05:36,240 --> 00:05:37,690
伪代码

122
00:05:37,690 --> 00:05:42,340
伪代码也是算法描述的一种形式

123
00:05:42,340 --> 00:05:46,920
这里面没有明确的算法的格式要求

124
00:05:46,920 --> 00:05:47,960
没有标准

125
00:05:47,960 --> 00:05:48,450
嗯

126
00:05:48,450 --> 00:05:51,360
那我们碰到伪代码填写的时候呢

127
00:05:51,360 --> 00:05:53,300
一般啊，根据上下文

128
00:05:53,300 --> 00:05:56,660
比如说呢，这是将零赋值给 CP 

129
00:05:56,660 --> 00:05:57,820
赋值给 cw 

130
00:05:57,820 --> 00:06:01,300
以箭头指向来表示赋值

131
00:06:01,300 --> 00:06:03,240
那在这里的话

132
00:06:03,240 --> 00:06:07,260
近几年的考试已经很少看到伪代码了

133
00:06:07,260 --> 00:06:08,800
伪代码的考察呢

134
00:06:08,800 --> 00:06:12,370
一般是在2013年以前的真题啊

135
00:06:12,370 --> 00:06:14,100
才能够呢，看得到了

136
00:06:14,100 --> 00:06:16,620
那我们在这个函数当中呢

137
00:06:16,620 --> 00:06:19,480
诶，相应的伪代码告诉我们呢

138
00:06:19,480 --> 00:06:22,440
首先给 cw cp 赋值为零

139
00:06:22,440 --> 00:06:23,520
缺少一个填空

140
00:06:23,520 --> 00:06:28,680
一将一呢，赋值给 F 、 P 、 cw 和 CP 啊

141
00:06:28,680 --> 00:06:32,350
都是我们呢，在执行过程当中碰到的

142
00:06:32,350 --> 00:06:36,880
中间的重量变量和中间的价值变量

143
00:06:36,880 --> 00:06:38,840
当前所获得的价值

144
00:06:38,840 --> 00:06:40,840
当前的背包重量

145
00:06:40,840 --> 00:06:43,640
那接下来 while 循环

146
00:06:43,640 --> 00:06:46,240
while 循环的条件是 true 

147
00:06:46,240 --> 00:06:48,630
也就是说呢，肯定会满足条件

148
00:06:48,630 --> 00:06:50,760
那会不会死循环呢

149
00:06:50,760 --> 00:06:54,060
碰到 return 的话就会呢跳出循环

150
00:06:54,060 --> 00:06:56,780
接下来嵌套了一个 while 循环

151
00:06:56,780 --> 00:06:58,590
K 小于等于 N 

152
00:06:58,590 --> 00:07:01,410
哎，此时 K 有没有值呢

153
00:07:01,410 --> 00:07:02,270
没有

154
00:07:02,270 --> 00:07:06,130
所以我们需要对 K 来进行赋值

155
00:07:06,150 --> 00:07:10,470
K 的取值能够取到 N 的话

156
00:07:10,470 --> 00:07:14,970
那这里是对 K 进行一些变化

157
00:07:14,970 --> 00:07:17,610
那 K 的初始取值啊

158
00:07:17,610 --> 00:07:18,850
要么是零

159
00:07:18,850 --> 00:07:20,260
要么是一

160
00:07:20,260 --> 00:07:23,320
在这里根据题干当

161
00:07:23,320 --> 00:07:26,120
物品编号告诉我们呢

162
00:07:26,120 --> 00:07:28,920
从一开始以及呢

163
00:07:28,920 --> 00:07:30,600
循环的界

164
00:07:30,600 --> 00:07:33,250
当等于 N 的时候结束

165
00:07:33,250 --> 00:07:35,870
那这个地方能够取到 N 

166
00:07:35,870 --> 00:07:38,730
应该是取值一到 N 

167
00:07:38,730 --> 00:07:40,430
一般作为啊

168
00:07:40,430 --> 00:07:42,970
正常的 C 代码来看的话

169
00:07:42,970 --> 00:07:45,680
一些 for 循环涉及到数组

170
00:07:45,680 --> 00:07:49,960
它的变量取值范围是零到 N 减一

171
00:07:49,960 --> 00:07:51,640
那这是伪代码

172
00:07:51,640 --> 00:07:55,370
它的说明当中给我们的应该是一到 N 

173
00:07:55,370 --> 00:07:59,330
所以第一空是对 K 进行赋值

174
00:07:59,330 --> 00:08:01,760
将一赋值给 K 

175
00:08:01,760 --> 00:08:03,360
那接下来呢

176
00:08:03,360 --> 00:08:08,360
唉， CW 加上 wk 小于等于 W 大写的 W 

177
00:08:08,360 --> 00:08:12,400
那这里表示的是当前的背包重量

178
00:08:12,400 --> 00:08:15,340
加上我们要放的 DEK 个物

179
00:08:15,340 --> 00:08:17,010
放进去之后呢

180
00:08:17,010 --> 00:08:18,850
没有超过背包容量

181
00:08:18,850 --> 00:08:20,960
就执行下面的步骤

182
00:08:20,960 --> 00:08:25,020
否则的话呢，唉并不能去执行

183
00:08:25,020 --> 00:08:27,290
那如果说不满足条件

184
00:08:27,290 --> 00:08:30,170
我们直接呢，尝试下一个物品

185
00:08:30,170 --> 00:08:36,390
所以啊，最后这里缺少的是跳出中间 while 循环

186
00:08:36,390 --> 00:08:38,150
它所执行的步骤

187
00:08:38,150 --> 00:08:40,260
尝试下一个物品

188
00:08:40,260 --> 00:08:41,330
也就是呢

189
00:08:41,330 --> 00:08:44,820
物品编号加一再进行尝试

190
00:08:44,820 --> 00:08:48,420
那么是将 K 加一复制给 K 

191
00:08:48,420 --> 00:08:51,870
那满足条件我们需要做什么呢

192
00:08:51,870 --> 00:08:53,970
接下来呢，我们能够看到

193
00:08:53,970 --> 00:08:58,750
执行的是将 CP 加上 VK 赋值给 CP 

194
00:08:58,750 --> 00:09:00,120
也就是说呢

195
00:09:00,120 --> 00:09:03,900
对当前背包的总价值进行更新

196
00:09:03,900 --> 00:09:09,720
更新的内容呢，是将当前背包的价值加上呢

197
00:09:09,720 --> 00:09:13,220
对应的 K 编号的物品价值

198
00:09:13,220 --> 00:09:16,650
假设我们把物品放进去了

199
00:09:16,650 --> 00:09:19,890
那当前的总价值就应该是 CP 

200
00:09:19,890 --> 00:09:24,030
那接下来缺少的是什么样的一个语句呢

201
00:09:24,030 --> 00:09:28,630
我们可以看到 CP 是当前的背包价值

202
00:09:28,630 --> 00:09:33,270
还有一个呢， cw 当前背包重量也要呢

203
00:09:33,270 --> 00:09:35,100
同样的做更新

204
00:09:35,100 --> 00:09:36,930
如何来更新呢

205
00:09:36,930 --> 00:09:40,250
用原有的背包重量加上呢

206
00:09:40,250 --> 00:09:44,170
我们当前要放的编号为 K 的物品重量

207
00:09:44,170 --> 00:09:46,370
然后呢，把这个数值啊

208
00:09:46,370 --> 00:09:47,450
累加起来

209
00:09:47,450 --> 00:09:49,800
放到呢 cw 当中去

210
00:09:49,800 --> 00:09:54,320
这两个步骤呢，所做的操作有一定的对应关系

211
00:09:54,320 --> 00:09:56,940
我们呢，既要看背包的重量

212
00:09:56,940 --> 00:09:59,310
也要呢，看背包的价值

213
00:09:59,310 --> 00:10:00,970
既然能放进去

214
00:10:00,970 --> 00:10:04,090
我们可以当前局部解记录为一

215
00:10:04,090 --> 00:10:06,130
表示物品放置进去了

216
00:10:06,130 --> 00:10:08,550
如果没放就记录为零

217
00:10:08,550 --> 00:10:11,920
并且呢，放完之后需要呢，进一步扩展

218
00:10:11,920 --> 00:10:14,230
K 等于 K 加一

219
00:10:14,230 --> 00:10:16,560
那 K 等于 K 加一之后

220
00:10:16,560 --> 00:10:18,660
如果这个 K 大于 N 

221
00:10:18,660 --> 00:10:21,800
说明我们已经访问完了

222
00:10:21,800 --> 00:10:22,700
这样的节点

223
00:10:22,700 --> 00:10:24,440
N 访问完了

224
00:10:24,440 --> 00:10:28,340
说明呢，我们要从局部解变成全局解了

225
00:10:28,340 --> 00:10:30,020
这个过程当中呢

226
00:10:30,020 --> 00:10:33,750
哎，看一看我们在中间过程当中

227
00:10:33,750 --> 00:10:40,820
涉及到的最优解和当前的价值谁比较大

228
00:10:40,820 --> 00:10:44,640
那如果说最优解比当前解要小的话

229
00:10:44,640 --> 00:10:45,460
说明什么呢

230
00:10:45,460 --> 00:10:47,020
这个解不在最优

231
00:10:47,020 --> 00:10:48,780
所以我们要交换一下

232
00:10:48,780 --> 00:10:52,470
把最大的 CP 呢，赋值给最优 F 

233
00:10:52,470 --> 00:10:56,500
同样呢， FW 的话也要进行调整

234
00:10:56,500 --> 00:11:01,140
把当前的 cw 呢，同步的更新给 FW 

235
00:11:01,140 --> 00:11:02,870
那此时的话呢

236
00:11:02,870 --> 00:11:04,700
K 记作 N 

237
00:11:04,700 --> 00:11:05,930
哎，更新为 N 

238
00:11:05,930 --> 00:11:07,670
表示呢我们要结束了

239
00:11:07,670 --> 00:11:09,650
把这个局部解 Y 呢

240
00:11:09,650 --> 00:11:12,070
给我们的最终解 X 

241
00:11:12,070 --> 00:11:15,070
那这个过程当中呢，就是比较呢

242
00:11:15,070 --> 00:11:19,050
哎，我们当前这个解有没有到最后

243
00:11:20,080 --> 00:11:23,400
如果不满足这样的条件的话

244
00:11:23,400 --> 00:11:25,740
说明这个物品不会放进去

245
00:11:25,740 --> 00:11:29,220
对应的 YK 呢，应该是记作零的

246
00:11:29,220 --> 00:11:32,240
然后看到的是一个呢，帮的函数

247
00:11:32,240 --> 00:11:33,450
限界函数

248
00:11:33,450 --> 00:11:37,410
那题干中告诉我们现阶函数传的参数

249
00:11:37,410 --> 00:11:41,390
以及呢，它表示的这样的最终结果

250
00:11:41,390 --> 00:11:46,250
那我们呢，看到返回值小于等于 FP 的话

251
00:11:46,250 --> 00:11:48,130
则表示什么呢

252
00:11:48,130 --> 00:11:50,550
小于等于当前最优解

253
00:11:50,550 --> 00:11:53,670
说明这个节点无需再扩展

254
00:11:53,670 --> 00:11:55,900
既然无需扩展的话

255
00:11:55,900 --> 00:11:57,260
我们可以看到呢

256
00:11:57,260 --> 00:12:01,560
唉，判断一下这个 K 有没有等于零

257
00:12:01,560 --> 00:12:03,200
如果等于零的话

258
00:12:03,200 --> 00:12:06,890
说明我们当前并不需要去往下，哎

259
00:12:06,890 --> 00:12:07,990
做一些操作了

260
00:12:07,990 --> 00:12:09,710
如果不等于零

261
00:12:09,710 --> 00:12:11,730
既然这个物品不能放

262
00:12:11,730 --> 00:12:14,820
我们所做的呢，就是在数当中啊

263
00:12:14,820 --> 00:12:16,710
既然这个节点不能放

264
00:12:16,710 --> 00:12:19,060
下一步所做的是回溯

265
00:12:19,060 --> 00:12:20,130
也就是呢

266
00:12:20,130 --> 00:12:23,080
回溯法的一个核心语句回推

267
00:12:23,080 --> 00:12:26,250
我们是以 K 来做计数的

268
00:12:26,250 --> 00:12:28,090
那现在回退的话

269
00:12:28,090 --> 00:12:30,780
说明 K 需要的减一

270
00:12:30,780 --> 00:12:33,290
将 K 减一赋值给 K 

271
00:12:33,290 --> 00:12:37,200
如果啊，我们回溯之后 K 等于零

272
00:12:37,200 --> 00:12:40,160
那此时的话说明回溯结束了

273
00:12:40,160 --> 00:12:43,220
我们呢就返回这个结果

274
00:12:43,450 --> 00:12:46,230
如果回溯的过程当中

275
00:12:46,230 --> 00:12:49,010
发现这个并不是根节点的话

276
00:12:49,010 --> 00:12:51,290
那我们下一步所做的就需要呢

277
00:12:51,290 --> 00:12:54,920
把我们尝试的这个物品啊退出来

278
00:12:54,920 --> 00:12:56,030
既然不好

279
00:12:56,030 --> 00:12:57,210
我们呢就退

280
00:12:57,210 --> 00:12:58,290
怎么退呢

281
00:12:58,290 --> 00:13:01,250
首先对应的解还原成零

282
00:13:01,250 --> 00:13:04,840
然后呢，当前的总重量减去呢

283
00:13:04,840 --> 00:13:06,770
我们刚刚放的物品 K 

284
00:13:06,770 --> 00:13:08,370
当前的总价值

285
00:13:08,370 --> 00:13:12,470
减去了当前的物品 K 的价值就可以了

286
00:13:12,470 --> 00:13:14,420
这是伪代码当中啊

287
00:13:14,420 --> 00:13:17,800
涉及到的一些呢，填空的内容

288
00:13:17,800 --> 00:13:21,140
直接呢，带大家先分析了一遍

289
00:13:21,140 --> 00:13:24,310
那涉及到具体的帮的函数

290
00:13:24,310 --> 00:13:27,930
在题目当中没有明确的给出来

291
00:13:27,930 --> 00:13:30,860
后面呢，我们会给大家一段呢

292
00:13:30,860 --> 00:13:34,040
代码里面做了一些简单的

293
00:13:34,040 --> 00:13:37,430
BD 函数的设置和回溯函数

294
00:13:37,430 --> 00:13:41,270
它的伪代码转换之后的代码过程

295
00:13:42,450 --> 00:13:44,910
接下来看一下问题部分

296
00:13:44,910 --> 00:13:46,370
问题一

297
00:13:46,370 --> 00:13:50,150
根据以上说明和 C 代码来填写

298
00:13:50,150 --> 00:13:51,630
伪代码当中的填空

299
00:13:51,630 --> 00:13:53,510
1~4刚刚填完了

300
00:13:53,510 --> 00:13:57,630
问题二，考虑表四杠一的实

301
00:13:57,630 --> 00:13:59,680
假设有三个物品

302
00:13:59,680 --> 00:14:02,740
那四杠一的实例假设有三个物品

303
00:14:02,740 --> 00:14:05,060
背包容量是22

304
00:14:05,060 --> 00:14:08,200
根据上述算法构造搜索数

305
00:14:08,200 --> 00:14:12,870
其中节点的编号表示搜索数生成的顺序

306
00:14:12,870 --> 00:14:17,240
边上的一和零分别表示是否选择对应物品

307
00:14:17,240 --> 00:14:19,080
根。节点以外呢

308
00:14:19,080 --> 00:14:20,540
每个孩子啊

309
00:14:20,540 --> 00:14:23,010
左孩子节点上下数值

310
00:14:23,010 --> 00:14:26,940
表示当前背包的重量和已获得的价值

311
00:14:26,940 --> 00:14:29,450
右孩子旁边的数值呢

312
00:14:29,450 --> 00:14:31,950
表示如果扩展的这个节点

313
00:14:31,950 --> 00:14:34,890
最多能够获得的可能价值

314
00:14:34,890 --> 00:14:38,720
那未获得最优解应该如何来选择

315
00:14:38,720 --> 00:14:39,790
我们说呢

316
00:14:39,790 --> 00:14:42,450
最优解应该是物品放进去之后

317
00:14:42,450 --> 00:14:44,130
不超过背包容量

318
00:14:44,130 --> 00:14:46,930
并且价值尽可能的大

319
00:14:46,930 --> 00:14:48,620
那只有三个物品

320
00:14:48,620 --> 00:14:50,240
不用呢去看代码

321
00:14:50,240 --> 00:14:52,160
也不用呢去看搜索数

322
00:14:52,160 --> 00:14:55,050
直接呢，自己去验证一下就行了

323
00:14:55,050 --> 00:14:57,520
我们如果放物品一的话

324
00:14:57,520 --> 00:15:01,220
接下来物品二放进去会超过重量

325
00:15:01,220 --> 00:15:02,720
不能放物品三

326
00:15:02,720 --> 00:15:04,500
放进去也会超容量

327
00:15:04,500 --> 00:15:08,180
那这个方案的结果呢，价值是30

328
00:15:08,180 --> 00:15:10,280
物品一不放的话

329
00:15:10,280 --> 00:15:11,720
可以放物品二

330
00:15:11,720 --> 00:15:14,580
接下来物品三也能够放进去

331
00:15:14,580 --> 00:15:18,160
此时啊，它的背包总重量是20

332
00:15:18,160 --> 00:15:21,180
总价值呢，是35

333
00:15:21,180 --> 00:15:23,700
有没有其他放置方案呢

334
00:15:23,700 --> 00:15:25,060
哎，其他的方案

335
00:15:25,060 --> 00:15:26,010
比如说呢

336
00:15:26,010 --> 00:15:28,070
呃，我们呢，只放物品三

337
00:15:28,070 --> 00:15:29,930
那这个价值肯定要小一些

338
00:15:29,930 --> 00:15:32,720
还需要呢，放上对应的物品二

339
00:15:32,720 --> 00:15:35,030
跟方案二就一样了

340
00:15:35,030 --> 00:15:38,790
所以这个时候我们选择的是物品二和三

341
00:15:38,790 --> 00:15:41,650
获得的价值呢，是35

342
00:15:41,650 --> 00:15:44,760
这两个空呢，还是比较简单的

343
00:15:44,760 --> 00:15:46,660
有实力的问题啊

344
00:15:46,660 --> 00:15:50,820
可以呢，先根据他的表述去找答案

345
00:15:50,820 --> 00:15:53,110
不一定呢，要去看代码

346
00:15:53,110 --> 00:15:56,140
那对于这个四杠一的实例

347
00:15:56,140 --> 00:15:59,450
若采用穷举法搜索整个空间

348
00:15:59,450 --> 00:16:02,810
它的搜索数的节点应该是多少呢

349
00:16:02,810 --> 00:16:04,810
用了上述的回溯法

350
00:16:04,810 --> 00:16:07,070
搜索数的节点是多少呢

351
00:16:07,070 --> 00:16:10,560
题目给了我们实例的搜索数

352
00:16:10,560 --> 00:16:12,570
那这棵搜索树的话

353
00:16:12,570 --> 00:16:15,850
我们可以看到它的节点总

354
00:16:15,850 --> 00:16:19,140
应该呢，是只有八个节点

355
00:16:19,140 --> 00:16:21,260
这是呢，根据题干

356
00:16:21,260 --> 00:16:24,100
有限界函数之后啊

357
00:16:24,100 --> 00:16:28,860
它所需要搜索的搜索树节点八个

358
00:16:29,280 --> 00:16:32,760
如果说没有这种呢

359
00:16:32,760 --> 00:16:35,950
现阶函数用穷举法来解决的话

360
00:16:35,950 --> 00:16:38,440
首先呢，从根节点出发

361
00:16:38,440 --> 00:16:40,960
看物品一是否放置

362
00:16:40,960 --> 00:16:44,760
物品一基础上再看物品二是否放置

363
00:16:44,760 --> 00:16:47,150
物品三是否放置

364
00:16:47,150 --> 00:16:50,170
这样形成的搜索数啊

365
00:16:50,170 --> 00:16:53,170
应该是一个四层的数

366
00:16:53,170 --> 00:16:55,070
它的节点总数啊

367
00:16:55,070 --> 00:16:57,870
应该是二的四次方减一

368
00:16:57,870 --> 00:17:01,080
也就是等于15个节点

369
00:17:01,080 --> 00:17:03,060
那这个四是怎么来的呢

370
00:17:03,060 --> 00:17:05,420
我们是 N 个物品等于三

371
00:17:05,420 --> 00:17:08,310
所以呢，是 N 加一得出来的

372
00:17:08,310 --> 00:17:10,460
这里呢，就是搜索

373
00:17:10,460 --> 00:17:13,500
穷举法解空间的节点数

374
00:17:13,500 --> 00:17:19,500
所以呢，这个地方搜索的节点总数应该是15

375
00:17:19,500 --> 00:17:20,710
这道题呢

376
00:17:20,710 --> 00:17:21,859
参考答

377
00:17:21,859 --> 00:17:26,440
大家呢，可以看一下涉及到的代码填空

378
00:17:26,440 --> 00:17:28,880
以及呢，涉及到的啊

379
00:17:28,880 --> 00:17:31,820
关于实例题的填空

380
00:17:31,820 --> 00:17:34,800
具体的代码执行过程呢

381
00:17:34,800 --> 00:17:37,760
我们简单的看一下

382
00:17:38,910 --> 00:17:41,010
下面我们来看一下呢

383
00:17:41,010 --> 00:17:42,850
在编译器当中啊

384
00:17:42,850 --> 00:17:45,400
这个代码它的执行过程

385
00:17:45,400 --> 00:17:49,740
呃，由于呢，本题给出来的是伪代码的形式

386
00:17:49,740 --> 00:17:53,320
那我们下面呢，是结合软件设计师教

387
00:17:53,320 --> 00:17:54,580
第五版当中啊

388
00:17:54,580 --> 00:17:56,860
回溯法解决零一背包问题

389
00:17:56,860 --> 00:18:00,910
给出的代码做了一定的调整来加以说明的

390
00:18:00,910 --> 00:18:03,180
这里呢，是限界函数

391
00:18:03,180 --> 00:18:05,480
里面呢，传递了一些参数

392
00:18:05,480 --> 00:18:09,330
比题干当中呢，给的更详细了一些

393
00:18:09,330 --> 00:18:10,770
有一些内容的话

394
00:18:10,770 --> 00:18:12,360
如果没有传参

395
00:18:12,360 --> 00:18:14,100
可能会更麻烦一些啊

396
00:18:14,100 --> 00:18:16,990
所以我们传递的参数呢，比较全

397
00:18:16,990 --> 00:18:20,310
在里面呢，判断这个物品是否合适

398
00:18:20,310 --> 00:18:22,310
如果说合适的话

399
00:18:22,310 --> 00:18:25,180
我们呢就可以把物品放置进去

400
00:18:25,180 --> 00:18:26,660
如果不合适的话

401
00:18:26,660 --> 00:18:31,320
直接呢，放置我们当前所获得的这样的价值

402
00:18:31,320 --> 00:18:35,060
下面是背包它的呢，代码部分

403
00:18:35,060 --> 00:18:37,120
背包函数部分呢

404
00:18:37,120 --> 00:18:39,640
我们声明了一些变量

405
00:18:39,640 --> 00:18:43,570
那 cw 也就是呢，中间的重量值

406
00:18:43,570 --> 00:18:48,150
CP 呢，中间的当前价值值

407
00:18:48,150 --> 00:18:51,170
然后给了一个 waiter 和 profit 呢

408
00:18:51,170 --> 00:18:55,040
记作我们背包的总重量和总容量

409
00:18:55,040 --> 00:18:59,110
用 X 数组来表示最终结果

410
00:18:59,110 --> 00:19:01,740
Y 数组呢，表示中间结果

411
00:19:01,740 --> 00:19:04,730
给他们呢分配了一些空间

412
00:19:04,730 --> 00:19:08,750
分配之后初始赋值都记作一

413
00:19:08,750 --> 00:19:11,080
下面呢，外循环

414
00:19:11,080 --> 00:19:14,120
当 index 小于 N 的时候呢

415
00:19:14,120 --> 00:19:17,480
哎，我们此时看一看物品放进去

416
00:19:17,480 --> 00:19:20,470
有没有超过背包总容量要求

417
00:19:20,470 --> 00:19:22,830
没有超过总容量的情况下

418
00:19:22,830 --> 00:19:25,170
才会呢把物品放进去

419
00:19:25,170 --> 00:19:28,760
并且修改局部截的值等于一

420
00:19:28,760 --> 00:19:32,380
那么此时如果说我们的计数值

421
00:19:32,380 --> 00:19:34,360
index 大于等于 N 的话

422
00:19:34,360 --> 00:19:36,990
说明我们搜索完了 N 个节点

423
00:19:36,990 --> 00:19:41,590
那此时的话，把这个中间解传给呢 X 数组

424
00:19:41,590 --> 00:19:45,730
如果说，诶，我们利用界限函数来判断一下

425
00:19:45,730 --> 00:19:49,380
这个值有没有超过最优解

426
00:19:49,380 --> 00:19:51,240
如果说超过了

427
00:19:51,240 --> 00:19:54,700
我们呢判断一下能不能呢用

428
00:19:54,700 --> 00:19:56,670
如果说没有超过的话

429
00:19:56,670 --> 00:19:59,530
我们呢，所做的操作就是回溯

430
00:19:59,530 --> 00:20:01,070
回溯到什么时候呢

431
00:20:01,070 --> 00:20:02,670
index 等于零的话

432
00:20:02,670 --> 00:20:05,220
就输出最终的结果

433
00:20:05,220 --> 00:20:06,810
否则的话呢

434
00:20:06,810 --> 00:20:10,180
唉，对 Y 进行重新的赋值

435
00:20:10,180 --> 00:20:12,890
这一段代码所做的操作啊

436
00:20:12,890 --> 00:20:15,270
是对柚子树的一个搜索

437
00:20:15,270 --> 00:20:17,230
我们前面所做的操作呢

438
00:20:17,230 --> 00:20:19,660
只能搜索到左子树

439
00:20:19,660 --> 00:20:22,050
接下来呢，所做的操作啊

440
00:20:22,050 --> 00:20:24,270
如果这个物品不能放的话

441
00:20:24,270 --> 00:20:27,090
就唉，把我们的物品退回来

442
00:20:27,090 --> 00:20:29,290
解的值重新写作零

443
00:20:29,290 --> 00:20:33,940
并且呢，中间的重量要减去当前物品重量

444
00:20:33,940 --> 00:20:38,010
中间的价值呢，减去当前的物品价值

445
00:20:38,010 --> 00:20:41,320
那如果说呢，中间这些探索都不需要的话

446
00:20:41,320 --> 00:20:43,940
就是呢，直接扩展下一个节点

447
00:20:43,940 --> 00:20:45,950
让计数值加加

448
00:20:45,950 --> 00:20:47,940
后面给了一个主函数

449
00:20:47,940 --> 00:20:49,880
这当中呢，设定呢

450
00:20:49,880 --> 00:20:51,970
重量数组、价值数组

451
00:20:51,970 --> 00:20:55,170
还有一个呢，单位重量价值的数

452
00:20:55,170 --> 00:20:57,910
调用我们的背包函数

453
00:20:57,910 --> 00:20:59,990
在题干当中啊

454
00:20:59,990 --> 00:21:01,310
缺失的填空

455
00:21:01,310 --> 00:21:06,290
首先第一空呢，是计数值 K 缺少初始值

456
00:21:06,290 --> 00:21:07,490
那我们呢

457
00:21:07,490 --> 00:21:10,730
现在的数组编号是从零开始

458
00:21:10,730 --> 00:21:12,740
所以赋值是等于零的

459
00:21:12,740 --> 00:21:15,670
题干当中物品编号从一开始

460
00:21:15,670 --> 00:21:17,870
所以呢是等于一的

461
00:21:17,870 --> 00:21:21,430
那这个地方赋值 K 等于 K 加一

462
00:21:21,430 --> 00:21:24,120
就是啊，伪代码和 C 代码当中呢

463
00:21:24,120 --> 00:21:26,090
会有的一些区别

464
00:21:26,090 --> 00:21:29,220
伪代码只需要逻辑上符合要求

465
00:21:29,220 --> 00:21:32,590
对于一些细节上的没有这么细致

466
00:21:32,590 --> 00:21:34,690
接下来缺少的第二空呢

467
00:21:34,690 --> 00:21:37,710
是对中间重量求取

468
00:21:37,710 --> 00:21:40,760
需要呢，累加上当前的物品

469
00:21:40,760 --> 00:21:43,480
也就是 cw 等于呢

470
00:21:43,480 --> 00:21:47,000
cw 加上 W 数组当中的 DK 的值

471
00:21:47,000 --> 00:21:48,900
缺少的第三空呢

472
00:21:48,900 --> 00:21:50,920
是节点往下的探索

473
00:21:50,920 --> 00:21:52,980
K 加加 index 加加

474
00:21:52,980 --> 00:21:55,810
也就是 K 等于 K 加一

475
00:21:55,810 --> 00:21:59,070
那缺少的第四空是回溯

476
00:21:59,070 --> 00:22:01,590
回溯的过程是 index 减减

477
00:22:01,590 --> 00:22:05,620
也就是我们呢，缺失的 K 等于 K 减一

478
00:22:05,620 --> 00:22:08,670
这是呢，代码它的执行过程

479
00:22:08,670 --> 00:22:11,330
最终的执行结果呢

480
00:22:11,330 --> 00:22:14,090
我们可以看到它能够探索

481
00:22:14,090 --> 00:22:15,090
左分支呢

482
00:22:15,090 --> 00:22:16,670
方案是100

483
00:22:16,670 --> 00:22:19,260
右分支方案是011

484
00:22:19,260 --> 00:22:21,740
一个呢，最大价值是30

485
00:22:21,740 --> 00:22:23,160
重量是15

486
00:22:23,160 --> 00:22:25,360
一个最大价值是35

487
00:22:25,360 --> 00:22:27,200
重量是20

488
00:22:27,200 --> 00:22:29,500
那这最后的最优解呢

489
00:22:29,500 --> 00:22:32,160
应该是价值35

490
00:22:32,160 --> 00:22:37,490
这就是啊，代码在编译器当中的执行过程

491
00:22:37,490 --> 00:22:42,320
前面呢，给大家讲到了关于临沂背包回溯过程

492
00:22:42,320 --> 00:22:43,550
也给大家呢

493
00:22:43,550 --> 00:22:45,220
看到了题目当中啊

494
00:22:45,220 --> 00:22:47,390
一段呢，伪代码的描述

495
00:22:47,390 --> 00:22:51,210
后面呢，在编译器当中给大家介绍了一下呢

496
00:22:51,210 --> 00:22:53,730
修正之后的一些代码

497
00:22:53,730 --> 00:22:55,970
它的执行结果

498
00:22:55,970 --> 00:22:56,620
呃

499
00:22:56,620 --> 00:22:58,940
包括呢，实例问题当中啊

500
00:22:58,940 --> 00:22:59,860
看到的呢

501
00:22:59,860 --> 00:23:02,720
没有现阶函数进行穷举的时候

502
00:23:02,720 --> 00:23:06,270
它的搜索范围加上限界函数之后

503
00:23:06,270 --> 00:23:07,710
减过质押之后呢

504
00:23:07,710 --> 00:23:09,660
它的搜索范围

505
00:23:09,660 --> 00:23:10,930
那我们呢

506
00:23:10,930 --> 00:23:13,190
主要给大家介绍的就是呢

507
00:23:13,190 --> 00:23:15,150
这样的一些注意呢

508
00:23:15,150 --> 00:23:18,430
伪代码没有明确的语法标准

509
00:23:18,430 --> 00:23:23,410
可以呢根据上下文来进行对应的填写

510
00:23:23,410 --> 00:23:24,850
代码填空啊

511
00:23:24,850 --> 00:23:27,720
一定是跟题干紧密结合的

512
00:23:27,720 --> 00:23:31,290
希望呢，本视频能够给大家提供一些帮助

513
00:23:31,290 --> 00:23:33,110
感谢大家的聆听
