1
00:00:00,160 --> 00:00:02,620
接下来的视频当中呢

2
00:00:02,620 --> 00:00:06,320
我们将以真题的形式给大家介绍

3
00:00:06,320 --> 00:00:11,210
以动态规划法的策略来解决背包问题

4
00:00:12,300 --> 00:00:15,110
首先呢，是题干部分

5
00:00:15,110 --> 00:00:17,600
在题干说明当中啊

6
00:00:17,600 --> 00:00:18,560
告诉我们呢

7
00:00:18,560 --> 00:00:21,590
零一背包它的问题一定义呢

8
00:00:21,590 --> 00:00:23,410
是给定 I 个物品

9
00:00:23,410 --> 00:00:26,730
依次呢，价值记录在 V 1到 I 

10
00:00:26,730 --> 00:00:29,000
给定呢， I 个物

11
00:00:29,000 --> 00:00:32,870
它的重量呢，依次记录在 W 1到 I 

12
00:00:32,870 --> 00:00:36,390
以及呢，背包的容量为 T 

13
00:00:36,390 --> 00:00:39,450
每个物品装到背包里面

14
00:00:39,450 --> 00:00:41,870
或者呢，不装到背包里面

15
00:00:41,870 --> 00:00:43,150
不能做分割

16
00:00:43,150 --> 00:00:45,380
就是呢，零一背包问题

17
00:00:45,380 --> 00:00:49,530
现在呢，我们要求最优的装包方案

18
00:00:49,530 --> 00:00:52,830
使得所得到的价值最大

19
00:00:52,830 --> 00:00:55,400
那么在零一背包问题当中啊

20
00:00:55,400 --> 00:00:57,530
它是具有最优子结构的

21
00:00:57,530 --> 00:00:58,350
定义呢

22
00:00:58,350 --> 00:01:01,070
C 、 I 、 T 这样的二维数组

23
00:01:01,070 --> 00:01:05,060
是最优装包方案所获得的最大价值

24
00:01:05,060 --> 00:01:07,780
那下面呢，给了我们一个递归式

25
00:01:07,780 --> 00:01:09,660
这是呢，第 I 个物

26
00:01:09,660 --> 00:01:12,240
装在呢，容量为 T 的背包当中啊

27
00:01:12,240 --> 00:01:14,950
它的最大价值了

28
00:01:14,950 --> 00:01:17,150
那当没有物品的时候

29
00:01:17,150 --> 00:01:20,050
或者呢，背包容量为零的时候

30
00:01:20,050 --> 00:01:23,000
此时呢，它的价值肯定是为零的

31
00:01:23,000 --> 00:01:26,080
其次呢，当我们这个背包啊

32
00:01:26,080 --> 00:01:29,470
它呢是小于 WI 

33
00:01:29,470 --> 00:01:30,890
也就是表示呢

34
00:01:30,890 --> 00:01:34,170
目前这个物体比背包还要大

35
00:01:34,170 --> 00:01:36,320
那此时呢，肯定放不进去

36
00:01:36,320 --> 00:01:37,770
那我们能够放的呢

37
00:01:37,770 --> 00:01:41,420
其实就是第 I 个物品之前的 I 减一

38
00:01:41,420 --> 00:01:43,690
所以呢，它的最优解啊

39
00:01:43,690 --> 00:01:44,550
就是呢

40
00:01:44,550 --> 00:01:46,800
当 I 减一个物

41
00:01:46,800 --> 00:01:49,380
放在了容量为 T 的

42
00:01:49,380 --> 00:01:51,130
这样的背包当中

43
00:01:51,130 --> 00:01:55,140
第三种情况呢，就是当 I 大于零

44
00:01:55,140 --> 00:01:56,220
并且呢

45
00:01:56,220 --> 00:01:58,280
背包容量是大于

46
00:01:58,280 --> 00:02:01,280
我们当前准备装进去的物品

47
00:02:01,280 --> 00:02:02,900
I 的重量的

48
00:02:02,900 --> 00:02:04,250
那此时的话

49
00:02:04,250 --> 00:02:07,610
我们呢，需要尝试一下这个物品啊

50
00:02:07,610 --> 00:02:10,500
放进去还是呢，不放进去

51
00:02:10,500 --> 00:02:15,180
那如果说这当中哪一个价值更大

52
00:02:15,180 --> 00:02:19,470
这个最大值呢，就是我们当前的最优解

53
00:02:19,470 --> 00:02:25,290
这是呢，对呀，我们的 cit 所定义的递归式

54
00:02:25,290 --> 00:02:29,000
那我们在专题一当中给大家提到过

55
00:02:29,000 --> 00:02:31,780
如果涉及到这一类递归式

56
00:02:31,780 --> 00:02:34,750
并且呢，求的是最优方案的话

57
00:02:34,750 --> 00:02:39,170
它考察的呀，就应该是呢，动态规划法了

58
00:02:39,170 --> 00:02:40,620
那在这当中呢

59
00:02:40,620 --> 00:02:42,500
下面是代码部分

60
00:02:42,500 --> 00:02:47,540
给了我们一定的变量以及呢，常量的说明

61
00:02:47,540 --> 00:02:50,530
下面呢，是代码填空部分

62
00:02:50,530 --> 00:02:53,030
那这是一个呢，不完整的代码

63
00:02:53,030 --> 00:02:55,820
我们呢，在专题一也提到过

64
00:02:55,820 --> 00:02:57,060
动态规划法

65
00:02:57,060 --> 00:02:58,000
它的填空啊

66
00:02:58,000 --> 00:03:01,160
基本上呢，与递归式是离不开的

67
00:03:01,160 --> 00:03:03,500
我们在后面呢，会给大家讲

68
00:03:03,500 --> 00:03:06,280
如何来进行代码填空

69
00:03:06,280 --> 00:03:08,570
下面呢，是问题部分

70
00:03:08,570 --> 00:03:13,250
首先，问题一，代码填空填1~4空

71
00:03:13,250 --> 00:03:14,170
总分八分

72
00:03:14,170 --> 00:03:15,650
每空两分

73
00:03:15,650 --> 00:03:16,970
问题二

74
00:03:16,970 --> 00:03:19,800
根据说明和 C 代码算法

75
00:03:19,800 --> 00:03:22,620
采用了什么样的算法设计策略呢

76
00:03:22,620 --> 00:03:24,100
我们刚刚提到了

77
00:03:24,100 --> 00:03:26,970
应该呢，是动态规划法

78
00:03:26,970 --> 00:03:30,690
求解过程当中是自底向上还是呢

79
00:03:30,690 --> 00:03:32,570
自顶向下的方式呢

80
00:03:32,570 --> 00:03:35,670
那在代码当中我们可以看到

81
00:03:35,670 --> 00:03:37,600
对于这一段代码

82
00:03:37,600 --> 00:03:40,180
我们在调用的过程当中啊

83
00:03:40,180 --> 00:03:44,950
是通过规模减一来进行求解的

84
00:03:44,950 --> 00:03:47,600
那既然是以减法的形式

85
00:03:47,600 --> 00:03:51,320
将规模从大到小进行压缩的话

86
00:03:51,320 --> 00:03:52,920
它的求求解呀

87
00:03:52,920 --> 00:03:57,460
就是呢，采用了自顶向下的方式

88
00:03:57,460 --> 00:04:00,290
问题三是实例

89
00:04:00,290 --> 00:04:02,890
给了我们五项物品的价值

90
00:04:02,890 --> 00:04:04,250
数组和重量

91
00:04:04,250 --> 00:04:05,310
数组

92
00:04:05,310 --> 00:04:07,470
针对这样的物品

93
00:04:07,470 --> 00:04:10,310
它的价值以及重量

94
00:04:10,310 --> 00:04:13,440
背包的总容量呢，是11

95
00:04:13,440 --> 00:04:16,620
我们呢，要求它的最大价值

96
00:04:16,649 --> 00:04:19,269
这一类问题啊

97
00:04:19,269 --> 00:04:22,850
如果带入递归式去验证

98
00:04:22,850 --> 00:04:24,900
很多同学呢，都会头疼

99
00:04:24,900 --> 00:04:27,360
这个递归式我都不太看得懂

100
00:04:27,360 --> 00:04:31,920
并且呢，如果要求二维数组双向去扫描的话

101
00:04:31,920 --> 00:04:34,750
它应该呢，会有25个数值

102
00:04:34,750 --> 00:04:38,450
那这是不是一定要按照这样的方式呢

103
00:04:38,450 --> 00:04:41,090
其实啊，并没有这样的必要

104
00:04:41,090 --> 00:04:43,690
那对于这样的问题三呢

105
00:04:43,690 --> 00:04:46,510
一方面我们知道呢，这个背包啊

106
00:04:46,510 --> 00:04:48,510
它是具有最优子结构的

107
00:04:48,510 --> 00:04:49,690
那其次呢

108
00:04:49,690 --> 00:04:53,810
唉，我们可以呢，将它相应的方案给它呢

109
00:04:53,810 --> 00:04:54,970
列举出来

110
00:04:54,970 --> 00:04:58,020
从方案当中呢，去判定

111
00:04:58,020 --> 00:05:01,520
之前呢，在背包问题的概述当中啊

112
00:05:01,520 --> 00:05:03,360
我们曾经提到过

113
00:05:03,360 --> 00:05:05,250
具有最优子结

114
00:05:05,250 --> 00:05:06,990
这样的背包问题呢

115
00:05:06,990 --> 00:05:10,850
我们可以利用贪心的思想去求最优解

116
00:05:10,850 --> 00:05:13,100
那在这里同样如此

117
00:05:13,100 --> 00:05:14,980
什么样的贪心思想呢

118
00:05:14,980 --> 00:05:15,760
我们啊

119
00:05:15,760 --> 00:05:21,400
将当前最大的价值物品优先呢，放入背包

120
00:05:21,400 --> 00:05:22,750
放完之后呢

121
00:05:22,750 --> 00:05:25,070
再来看看其他的方案

122
00:05:25,070 --> 00:05:27,780
按照这种思路来找方案

123
00:05:27,780 --> 00:05:31,740
再根据呢，方案的结果来找最优解

124
00:05:31,740 --> 00:05:35,810
首先，价值最大的是物品五

125
00:05:35,810 --> 00:05:37,880
对于物品五

126
00:05:37,880 --> 00:05:40,470
如果放入背包之后

127
00:05:40,470 --> 00:05:43,990
接下来物品六是放不进去的

128
00:05:43,990 --> 00:05:47,400
因为啊，总的重量超过了11

129
00:05:47,400 --> 00:05:51,320
物品三，它所占据的重量五

130
00:05:51,320 --> 00:05:53,160
同样呢，放不进去

131
00:05:53,160 --> 00:05:55,340
会挤爆我们的背包

132
00:05:55,340 --> 00:05:57,730
那物品二能不能放呢

133
00:05:57,730 --> 00:05:59,410
能够放进去

134
00:05:59,410 --> 00:06:01,170
并且啊，放入之后

135
00:06:01,170 --> 00:06:04,250
物品一还能够接着往里面放

136
00:06:04,250 --> 00:06:07,170
那此时它的总价值是多少呢

137
00:06:07,170 --> 00:06:09,610
应该是35

138
00:06:09,610 --> 00:06:10,840
结束了吗

139
00:06:10,840 --> 00:06:13,970
没有，我们再来找找其他方案

140
00:06:13,970 --> 00:06:17,980
那物品五，它的重量七

141
00:06:17,980 --> 00:06:19,220
价值28

142
00:06:19,220 --> 00:06:20,570
我们已经看过了

143
00:06:20,570 --> 00:06:24,630
接下来从物品四开始看起

144
00:06:24,630 --> 00:06:26,080
物品四啊

145
00:06:26,080 --> 00:06:27,520
它的重量是六

146
00:06:27,520 --> 00:06:29,610
价值呢，是22

147
00:06:29,610 --> 00:06:33,440
此时物品三能不能放进去呢

148
00:06:33,440 --> 00:06:34,740
可以放进去

149
00:06:34,740 --> 00:06:38,600
并且啊，刚好占满11的容量

150
00:06:38,600 --> 00:06:41,390
那此时它的价值是多少呢

151
00:06:41,390 --> 00:06:43,300
是40

152
00:06:43,300 --> 00:06:48,070
那我们之前呢，说贪心法从当前最优去考虑

153
00:06:48,070 --> 00:06:50,130
为什么方案一不行呢

154
00:06:50,130 --> 00:06:51,410
因为方案一啊

155
00:06:51,410 --> 00:06:55,420
并没有完整的占据满11的容量

156
00:06:55,420 --> 00:06:59,170
只有呢，方案二占据满了这样的容量

157
00:06:59,170 --> 00:07:02,290
接下来我们呢，可以再去考虑

158
00:07:02,290 --> 00:07:04,870
如果物品四

159
00:07:04,870 --> 00:07:06,730
它的容量六啊

160
00:07:06,730 --> 00:07:09,240
除此以外呢，不与五结合了

161
00:07:09,240 --> 00:07:10,310
我们可以呢

162
00:07:10,310 --> 00:07:12,830
与二与一结合起来

163
00:07:12,830 --> 00:07:15,590
放三个物品到背包当中

164
00:07:15,590 --> 00:07:19,900
此时呢，它的价值应该呢，是29

165
00:07:20,190 --> 00:07:22,690
物品四看完了之后呢

166
00:07:22,690 --> 00:07:24,750
从物品三开始考虑

167
00:07:24,750 --> 00:07:26,760
它能够放置的只能呢

168
00:07:26,760 --> 00:07:29,540
与物品二、物品一进行结合了

169
00:07:29,540 --> 00:07:31,870
那它的价值呢，是25

170
00:07:31,870 --> 00:07:36,630
很明显它的最优解应该呢，是40

171
00:07:36,630 --> 00:07:40,170
所以我们能够获取到的最大价

172
00:07:40,170 --> 00:07:42,300
应该呢，是40

173
00:07:42,300 --> 00:07:43,710
这个实例题

174
00:07:43,710 --> 00:07:47,190
我们完全可以利用穷举的方式

175
00:07:47,190 --> 00:07:51,010
将所有可行的方案列举出来

176
00:07:51,010 --> 00:07:53,500
那在考虑可行方案的时候

177
00:07:53,500 --> 00:07:56,060
有一些呢，比如说单个物品的话

178
00:07:56,060 --> 00:07:59,140
它的容量并不是呢，占据满的

179
00:07:59,140 --> 00:08:00,520
所以啊，这种方案呢

180
00:08:00,520 --> 00:08:01,780
就不用去考虑了

181
00:08:01,780 --> 00:08:05,180
我们同时结合贪心的策略

182
00:08:05,180 --> 00:08:07,660
从最大价值开始考虑

183
00:08:07,660 --> 00:08:11,240
然后呢，去穷举相应的方案

184
00:08:11,240 --> 00:08:13,510
从而呢，找到最优解

185
00:08:13,510 --> 00:08:14,770
那这是呢

186
00:08:14,770 --> 00:08:16,750
实力问题

187
00:08:16,750 --> 00:08:21,260
接下来我们再来看一下代码填空部分

188
00:08:21,260 --> 00:08:24,420
首先呢，回到代码当中

189
00:08:28,180 --> 00:08:30,160
在代码当中啊

190
00:08:30,160 --> 00:08:31,740
我们能够看到呢

191
00:08:31,740 --> 00:08:32,200
哎

192
00:08:32,200 --> 00:08:35,419
首先有一个背包的算法里面

193
00:08:35,419 --> 00:08:37,350
声明了变量 I 和 J 

194
00:08:37,350 --> 00:08:40,740
然后呢，有一个双层嵌套的 for 循环

195
00:08:40,740 --> 00:08:42,880
将 CIJ 依次呢

196
00:08:42,880 --> 00:08:44,840
初始赋值为一

197
00:08:44,840 --> 00:08:48,120
接下来 return 一个函数调用

198
00:08:48,120 --> 00:08:50,800
那这是呢，函数调用的方式

199
00:08:50,800 --> 00:08:53,330
调用的是 max value 

200
00:08:53,330 --> 00:08:56,460
这样的一个最大价值的一个函数

201
00:08:56,460 --> 00:08:58,870
在最大价值函数当中啊

202
00:08:58,870 --> 00:09:01,990
它是呢，传递了一个价值数组

203
00:09:01,990 --> 00:09:03,590
一个重量数组

204
00:09:03,590 --> 00:09:08,380
以及呢，对应的物品个数和背包容量

205
00:09:08,380 --> 00:09:10,810
接着在这个函数当中呢

206
00:09:10,810 --> 00:09:12,690
声明了变量 temp 

207
00:09:12,690 --> 00:09:15,880
temp 呢，一般是作为中间变量值的

208
00:09:15,880 --> 00:09:19,660
然后呢，给了一个 if 判断语句

209
00:09:19,660 --> 00:09:23,220
如果 CI 接不等于一

210
00:09:23,220 --> 00:09:24,380
说明什么呢

211
00:09:24,380 --> 00:09:27,870
说明里面是有数值的

212
00:09:27,870 --> 00:09:31,120
那既然有数值说明啊

213
00:09:31,120 --> 00:09:34,080
我们当前是计算了一个数值

214
00:09:34,080 --> 00:09:36,000
这个数值用来干嘛呢

215
00:09:36,000 --> 00:09:38,020
是用来返回的

216
00:09:38,020 --> 00:09:38,770
所以啊

217
00:09:38,770 --> 00:09:44,630
第一空我们要填写的是返回某一个数值

218
00:09:44,670 --> 00:09:46,950
返回的是什么呢

219
00:09:46,950 --> 00:09:49,170
既然 CIJ 不是一

220
00:09:49,170 --> 00:09:51,770
说明它是有效值返回

221
00:09:51,770 --> 00:09:53,210
就是呢， CIJ 

222
00:09:53,210 --> 00:09:56,460
所以呀，第一空是 return c i j 

223
00:09:56,460 --> 00:09:58,120
接下来 if 呢

224
00:09:58,120 --> 00:09:59,360
I 等于零

225
00:09:59,360 --> 00:10:00,940
J 等于零

226
00:10:00,940 --> 00:10:03,470
当 I 等于零的时候

227
00:10:03,470 --> 00:10:05,970
我们所做的这个 J 是什么呢

228
00:10:05,970 --> 00:10:07,910
J 传递的其实呢

229
00:10:07,910 --> 00:10:11,670
就是递归式当中 T 1这个数值

230
00:10:11,670 --> 00:10:13,810
那我们呢，每一次考虑啊

231
00:10:13,810 --> 00:10:16,260
当这个物品容量并不是背包

232
00:10:16,260 --> 00:10:18,120
比背包还要小一点的时候

233
00:10:18,120 --> 00:10:19,380
依次的去考虑

234
00:10:19,380 --> 00:10:21,320
直到呢 J 等于 T 为止

235
00:10:21,320 --> 00:10:23,410
那现在在这里呢

236
00:10:23,410 --> 00:10:26,070
是 I 等于零或者 J 等于零

237
00:10:26,070 --> 00:10:28,070
它等价的就是呢

238
00:10:28,070 --> 00:10:30,910
递归式当中的第一种情况

239
00:10:30,910 --> 00:10:33,190
I 等于零或者 T 等于零

240
00:10:33,190 --> 00:10:35,010
然后所做的操作呢

241
00:10:35,010 --> 00:10:38,170
就是给 CII 接传递一个数值零

242
00:10:38,170 --> 00:10:39,730
否则的话呢

243
00:10:39,730 --> 00:10:42,030
哎，当 I 不等于零

244
00:10:42,030 --> 00:10:45,010
并且呢， J 不等于零的时候

245
00:10:45,010 --> 00:10:49,460
接下来我们要执行其他的代码了

246
00:10:49,460 --> 00:10:55,790
那 CIIJ 等于 VWI 减一阶的时候

247
00:10:55,790 --> 00:10:58,880
那这里它所调用的是什么呢

248
00:10:58,880 --> 00:11:00,540
还是 V 数组

249
00:11:00,540 --> 00:11:05,220
W 数组以及呢 I 减一和 T 

250
00:11:05,220 --> 00:11:09,070
那这样的一个表达式表示的是什么含义呀

251
00:11:09,070 --> 00:11:10,030
表示呢

252
00:11:10,030 --> 00:11:15,890
诶，我们在价值数组 V 和重量数组 W 的条件下

253
00:11:15,890 --> 00:11:18,030
考虑 I 减一个物

254
00:11:18,030 --> 00:11:20,750
在容量 T 的条件下

255
00:11:20,750 --> 00:11:23,340
它的最大价值

256
00:11:23,340 --> 00:11:25,600
那这个最大价值啊

257
00:11:25,600 --> 00:11:28,500
它所对应的其实呢

258
00:11:28,500 --> 00:11:32,310
就是我们在递归式当中

259
00:11:32,310 --> 00:11:34,810
第二种情况

260
00:11:35,050 --> 00:11:38,270
那第二种情况考虑完了之后

261
00:11:38,270 --> 00:11:41,550
接下来其实呢，就是在递归式当中

262
00:11:41,550 --> 00:11:43,020
第三种情况呢

263
00:11:43,020 --> 00:11:45,970
那第三种情况它的条件是什么呢

264
00:11:45,970 --> 00:11:49,890
就是我们所缺失的第二个代码填空

265
00:11:49,890 --> 00:11:53,300
那应该呢，是满足 I 大于零

266
00:11:53,300 --> 00:11:57,480
并且 J 大于等于 WI 

267
00:11:57,480 --> 00:11:59,700
注意这里不再是 T 了

268
00:11:59,700 --> 00:12:01,400
我们在代码当中啊

269
00:12:01,400 --> 00:12:03,950
都是以 J 来代替的

270
00:12:03,950 --> 00:12:07,060
所以呀，第二空呢，是 I 大于零

271
00:12:07,060 --> 00:12:10,290
且皆大于等于 WI 

272
00:12:10,290 --> 00:12:14,140
接下来 temp 等于某一个表达式

273
00:12:14,140 --> 00:12:19,570
然后呢，判断 CIIJ 和 temp 谁比较大

274
00:12:19,570 --> 00:12:21,990
那么这个时候它所对应的

275
00:12:21,990 --> 00:12:25,410
其实就是第三种情况下的表达式

276
00:12:25,410 --> 00:12:28,220
返回一个最大值

277
00:12:28,220 --> 00:12:30,350
什么样的最大值呢

278
00:12:30,350 --> 00:12:35,110
唉， CIIJ 和 temp 它们之间的最大值

279
00:12:35,110 --> 00:12:38,610
那此时的话谁比较大

280
00:12:38,610 --> 00:12:41,650
最终呢，会返回给 CIJ 

281
00:12:41,650 --> 00:12:44,910
那如果说 temp 比较大的话

282
00:12:44,910 --> 00:12:49,770
很明显 CIJ 它应该更新为 temp 值

283
00:12:53,900 --> 00:12:57,720
那它具体比较的是谁呢

284
00:12:57,720 --> 00:13:00,810
一个呢，是 CI 减一和 T 

285
00:13:00,810 --> 00:13:05,970
一个呢是 CI 减1 T 减 WI 加上 VI 

286
00:13:05,970 --> 00:13:09,460
那这个 I 减一和 T 我们在哪里看到呢

287
00:13:09,460 --> 00:13:12,400
其实就是在 if 条件上面啊

288
00:13:12,400 --> 00:13:14,880
所给出来的 CIJ 

289
00:13:14,880 --> 00:13:21,770
那这里呢，是先将 CII 接负值为 CI 减1 T 

290
00:13:21,770 --> 00:13:24,400
这一部分赋值之后

291
00:13:24,400 --> 00:13:26,440
再来呢，与 temp 比较

292
00:13:26,440 --> 00:13:29,070
temp 呢，就是前面这一部

293
00:13:29,070 --> 00:13:32,140
CI 减1 T 1减 WI 

294
00:13:32,140 --> 00:13:33,730
这是呢， CIJ 的值

295
00:13:33,730 --> 00:13:35,700
这个 CIJ 是什么呢

296
00:13:35,700 --> 00:13:40,570
这个 CIJ 其实就是对当前函数的递归调用

297
00:13:40,570 --> 00:13:43,430
那函数名填写下来

298
00:13:43,430 --> 00:13:46,340
其中的参数 V 不变

299
00:13:46,340 --> 00:13:47,820
W 不变

300
00:13:47,820 --> 00:13:51,250
对应的是 I 减一这个物

301
00:13:51,250 --> 00:13:56,640
以及呢，背包容量是接减去 WI 的

302
00:13:56,640 --> 00:13:59,020
那此时呢，这是我们啊

303
00:13:59,020 --> 00:14:02,320
所传递的参数够不够呢

304
00:14:02,320 --> 00:14:04,600
并没有完全结束

305
00:14:04,600 --> 00:14:06,500
调用函数之后啊

306
00:14:06,500 --> 00:14:10,950
还要加上呢，当前物品的价值 VI 

307
00:14:10,950 --> 00:14:15,560
这才是完整的第三个部分填空

308
00:14:15,560 --> 00:14:18,250
填完之后赋值给 temp 

309
00:14:18,250 --> 00:14:23,000
用 temp 与之前所赋值的 CIIJ 来比较

310
00:14:23,000 --> 00:14:24,960
比较之后谁是最大值

311
00:14:24,960 --> 00:14:28,000
就将它呢传递给 CIJ 就行了

312
00:14:28,000 --> 00:14:31,530
那这个时候呢，就是更新 CIIJ 的值

313
00:14:31,530 --> 00:14:34,630
让最大值呢保留在 CII 界当中

314
00:14:34,630 --> 00:14:38,020
最后呢，是返回这个呢，二维数

315
00:14:38,020 --> 00:14:40,660
作为呢，最终的结果

316
00:14:40,660 --> 00:14:46,080
那这是呢，利用动态规划法来求取背包问题

317
00:14:46,080 --> 00:14:49,180
它中间啊，会将所有的结果呢

318
00:14:49,180 --> 00:14:51,880
记录在二维 C 数组当中

319
00:14:51,880 --> 00:14:54,720
以方便我们去查询

320
00:14:54,720 --> 00:14:57,100
规模更小的这样的一个值

321
00:14:57,100 --> 00:15:01,080
但是呢，它采用了递归的方式来实现

322
00:15:01,080 --> 00:15:04,900
并且啊，是自顶向下的递归

323
00:15:04,900 --> 00:15:07,390
所以呢，需要一步一步地代入

324
00:15:07,390 --> 00:15:10,250
才能够计算出最终结果

325
00:15:10,250 --> 00:15:11,670
这个时间复杂度

326
00:15:11,670 --> 00:15:14,290
其实相对来说还是比较大的

327
00:15:14,290 --> 00:15:17,140
具体的代码执行情况

328
00:15:17,140 --> 00:15:19,700
我们呢，会在后面给大家呢

329
00:15:19,700 --> 00:15:22,380
展示一下修正之后的代码

330
00:15:22,380 --> 00:15:24,380
在运行环境当中啊

331
00:15:24,380 --> 00:15:26,040
它的结果

332
00:15:26,820 --> 00:15:30,040
下面呢，给大家展示一下参考答案

333
00:15:30,040 --> 00:15:31,100
问题一

334
00:15:31,100 --> 00:15:32,380
代码填空

335
00:15:32,380 --> 00:15:36,630
第一空返回值应该呢是 CIJ 

336
00:15:36,630 --> 00:15:39,520
那这里给大家展示的代码框

337
00:15:39,520 --> 00:15:41,720
应该呢，缺失了一个 return 

338
00:15:41,720 --> 00:15:43,930
这里啊是 return c i j 

339
00:15:43,930 --> 00:15:48,420
其次呢，第二个空是条件的一个判断

340
00:15:48,420 --> 00:15:51,440
那在这当中呢，要满足 I 大于零

341
00:15:51,440 --> 00:15:55,260
并且呢， J 小于等于 WI 这个 J 啊

342
00:15:55,260 --> 00:15:58,730
对应着递归式当中的 T 1这个参数

343
00:15:58,730 --> 00:16:02,900
第三空是递归调用本函数

344
00:16:02,900 --> 00:16:06,600
并且呢，调用的时候规模是 I 减一

345
00:16:06,600 --> 00:16:09,880
背包容量呢，是 J 减去 WI 

346
00:16:09,880 --> 00:16:12,160
在此基础上还要呢

347
00:16:12,160 --> 00:16:15,500
加上当前价值 vi 

348
00:16:15,500 --> 00:16:18,870
让它呢与我们原本的 CIIJ 啊

349
00:16:18,870 --> 00:16:21,130
这样的取值来进行比较

350
00:16:21,130 --> 00:16:23,090
谁比较大，把它呢

351
00:16:23,090 --> 00:16:25,030
保留到 CIJ 当中

352
00:16:25,030 --> 00:16:26,330
这是呢，第四空

353
00:16:26,330 --> 00:16:28,130
如果 temp 比较大的话

354
00:16:28,130 --> 00:16:30,800
让 temp 赋值给 CIJ 

355
00:16:30,800 --> 00:16:34,690
问题二是算法设计策略的判断

356
00:16:34,690 --> 00:16:38,410
以及呢动态规划法的方向判断

357
00:16:38,410 --> 00:16:42,130
问题三是实例去求最优解

358
00:16:42,130 --> 00:16:46,460
我们前面分析了最优解呢，应该是40

359
00:16:46,460 --> 00:16:48,620
下面呢，我们啊

360
00:16:48,620 --> 00:16:51,420
在运行环境当中看一下呢

361
00:16:51,420 --> 00:16:54,720
这段代码它的运行情况

362
00:16:55,070 --> 00:16:57,790
这是呢，以真题为例

363
00:16:57,790 --> 00:17:01,020
做过修正之后的呢，代码啊

364
00:17:01,020 --> 00:17:03,900
那首先呢，是题干给我们呢

365
00:17:03,900 --> 00:17:06,109
描述了一下问题情况

366
00:17:06,109 --> 00:17:08,260
下面呢，是代码说明

367
00:17:08,260 --> 00:17:11,109
给了一些常量和变量的说明

368
00:17:11,109 --> 00:17:13,560
其次呢，是实例部分

369
00:17:13,560 --> 00:17:16,720
给了我们一个 V 数组和 W 数组

370
00:17:16,720 --> 00:17:19,359
接下来看到代码部分

371
00:17:19,359 --> 00:17:21,700
我们啊，额外声明了一些呢

372
00:17:21,700 --> 00:17:22,760
全局变量

373
00:17:22,760 --> 00:17:24,240
在变量当中啊

374
00:17:24,240 --> 00:17:28,450
记录了价值数组 V 和重量数组 W 

375
00:17:28,450 --> 00:17:30,600
在主函数前面啊

376
00:17:30,600 --> 00:17:34,480
先声明了这两个功能函数

377
00:17:34,480 --> 00:17:37,180
这是呢，题干给我们的两个函数

378
00:17:37,180 --> 00:17:41,150
下面呢，新增了一个主函数来进行调用

379
00:17:41,150 --> 00:17:43,610
我们呢，将结果最终呢

380
00:17:43,610 --> 00:17:48,900
从结果变量 result 这里呢，来进行返回

381
00:17:48,900 --> 00:17:50,780
那通过 result 呢

382
00:17:50,780 --> 00:17:55,810
来调用我们的这个背包问题的函数

383
00:17:55,810 --> 00:17:57,060
调用之后呢

384
00:17:57,060 --> 00:17:59,740
将结果输出就可以了

385
00:17:59,740 --> 00:18:02,960
对于背包问题的求解函数

386
00:18:02,960 --> 00:18:04,560
声明了一些变量

387
00:18:04,560 --> 00:18:07,620
并且呢，用双层嵌套 for 循环

388
00:18:07,620 --> 00:18:10,680
对 CIJ 进行了初始赋值

389
00:18:10,680 --> 00:18:12,010
等于一

390
00:18:12,010 --> 00:18:12,930
接下来

391
00:18:12,930 --> 00:18:18,030
返回值调用了我们的最大价值求解函数

392
00:18:18,030 --> 00:18:21,320
对于最大价值求解函数当中啊

393
00:18:21,320 --> 00:18:24,220
声明呢， temp 变量等于零

394
00:18:24,220 --> 00:18:27,130
如果 CIJ 不等于一

395
00:18:27,130 --> 00:18:30,410
说明有取值已经呢，求过解了

396
00:18:30,410 --> 00:18:33,380
那此时呢，会返回 CIJ 

397
00:18:33,380 --> 00:18:37,380
那这里呢，就是我们第一个填空缺失的地方

398
00:18:37,380 --> 00:18:40,650
接下来就是呢，递归式它的分析了

399
00:18:40,650 --> 00:18:44,470
如果 I 等于零或者 J 等于零

400
00:18:44,470 --> 00:18:46,410
就满足第一种情况

401
00:18:46,410 --> 00:18:48,750
CIIJ 是等于零的

402
00:18:48,750 --> 00:18:50,190
否则的话呢

403
00:18:50,190 --> 00:18:53,570
哎， CIJ 需要判断 CIJ 的话

404
00:18:53,570 --> 00:18:55,870
等于第二种情况

405
00:18:55,870 --> 00:18:59,510
函数调用它所对应的就是呢

406
00:18:59,510 --> 00:19:03,850
CI 减1 T 这样的第二种递归式情况

407
00:19:03,850 --> 00:19:07,710
那这个函数呢，写在我们的代码当中

408
00:19:07,710 --> 00:19:10,200
就是递归调用本函

409
00:19:10,200 --> 00:19:12,600
V 数组和 W 数组不变

410
00:19:12,600 --> 00:19:15,040
对应的规模是 I 减一

411
00:19:15,040 --> 00:19:18,220
用 J 来代替 T 变量

412
00:19:18,220 --> 00:19:20,950
接下来第三种情况

413
00:19:20,950 --> 00:19:24,760
那此时要满足的条件是 I 大于零

414
00:19:24,760 --> 00:19:29,140
并且呢， T 大于等于 WI 没有 T 

415
00:19:29,140 --> 00:19:33,840
所以这里呢，填写的应该是 J 大于等于 WI 

416
00:19:33,840 --> 00:19:37,300
这是呢，所缺失的第二空填空

417
00:19:37,300 --> 00:19:40,530
接下来呢，对于 temp 进行赋值

418
00:19:40,530 --> 00:19:41,950
赋值之后呢

419
00:19:41,950 --> 00:19:43,970
与 CIJ 进行比较

420
00:19:43,970 --> 00:19:45,370
那这个 CIJ 啊

421
00:19:45,370 --> 00:19:47,150
其实对应的就是呢

422
00:19:47,150 --> 00:19:50,650
CI 减1 T 这样的一个变量

423
00:19:50,650 --> 00:19:54,830
这是我们递归式当中的第三种情况

424
00:19:54,830 --> 00:19:56,950
那它所比较的对象呢

425
00:19:56,950 --> 00:19:58,590
是找一个最大值

426
00:19:58,590 --> 00:20:00,690
什么样的最大值呢

427
00:20:00,690 --> 00:20:06,420
唉，应该是 CI 减1 T 减 WI 加 VI 

428
00:20:06,420 --> 00:20:07,980
那这个情况下呢

429
00:20:07,980 --> 00:20:10,060
把 T 替换成 J 

430
00:20:10,060 --> 00:20:14,170
并且呢，以递归调用的形式来写

431
00:20:14,170 --> 00:20:17,030
递归调用本函数 V 数组

432
00:20:17,030 --> 00:20:18,610
W 数组不变

433
00:20:18,610 --> 00:20:22,630
规模变成 I 减一和阶减 WI 

434
00:20:22,630 --> 00:20:24,890
在此基础上加上呢

435
00:20:24,890 --> 00:20:27,680
当前的物品价值为 I 

436
00:20:27,680 --> 00:20:30,310
赋值给 temp 之后啊

437
00:20:30,310 --> 00:20:34,450
那与我们之前记录的 CIIJ 进行比较

438
00:20:34,450 --> 00:20:35,850
谁比较大呢

439
00:20:35,850 --> 00:20:38,130
就保留在 CIJ 当中

440
00:20:38,130 --> 00:20:40,790
那如果 CIJ 比较小怎么办呢

441
00:20:40,790 --> 00:20:42,130
tap 比较大的话

442
00:20:42,130 --> 00:20:44,830
那将 temp 呢，复制给 CIJ 就行了

443
00:20:44,830 --> 00:20:48,190
那这就是呢，所缺失的第四个填空

444
00:20:48,190 --> 00:20:49,320
那这里呢

445
00:20:49,320 --> 00:20:51,680
注意第一空返回值

446
00:20:51,680 --> 00:20:55,750
第二空是呢，我们的一个条件判断语句

447
00:20:55,750 --> 00:20:58,700
第三空呢，是 temp 的赋值语句

448
00:20:58,700 --> 00:21:02,720
第四空呢，是最后的 CII 接返回值

449
00:21:02,720 --> 00:21:07,250
接下来呢，我们额外添加了一些呢输出语句

450
00:21:07,250 --> 00:21:10,150
看一下呢，中间的执行结果

451
00:21:10,150 --> 00:21:12,010
以 count 计数值啊

452
00:21:12,010 --> 00:21:14,170
来调整输出的格式

453
00:21:14,170 --> 00:21:16,410
每三个元素值呢

454
00:21:16,410 --> 00:21:18,870
会进行一次换行

455
00:21:19,840 --> 00:21:22,360
执行之后的结果呢

456
00:21:22,360 --> 00:21:24,100
给大家展示了一下

457
00:21:24,100 --> 00:21:28,160
那这之中啊，最大值应该呢是40

458
00:21:28,160 --> 00:21:32,900
40呢最后会返回给主函数

459
00:21:32,900 --> 00:21:36,330
并且呢，输出这个主函数啊

460
00:21:36,330 --> 00:21:39,030
结果呢，应该是等于40的

461
00:21:39,030 --> 00:21:42,490
也就是这道题当中的最优解

462
00:21:43,130 --> 00:21:46,510
上面的视频呢，是以真题的形

463
00:21:46,510 --> 00:21:48,370
向大家呢介绍了一下

464
00:21:48,370 --> 00:21:52,040
如何以动态规划法来求解背包问题

465
00:21:52,040 --> 00:21:55,090
并且呢，带大家再次回顾了一

466
00:21:55,090 --> 00:21:56,710
动态规划法当中啊

467
00:21:56,710 --> 00:22:00,160
递归式对于代码填空来说呢，是很重要的

468
00:22:00,160 --> 00:22:03,710
如何结合递归式来进行代码填空

469
00:22:03,710 --> 00:22:07,290
最后呢，又以啊，运行环境的形

470
00:22:07,290 --> 00:22:09,710
带大家呢看了一下这一段代码

471
00:22:09,710 --> 00:22:13,690
分析了一下呢，它最终的一个运行结果

472
00:22:13,690 --> 00:22:16,770
并且呢，加了一些输出语句

473
00:22:16,770 --> 00:22:20,730
帮助大家呢去理解中间这样的一个过程

474
00:22:20,730 --> 00:22:23,380
嗯，感谢大家的聆听

475
00:22:23,380 --> 00:22:25,520
希望呢，本视频能够呢

476
00:22:25,520 --> 00:22:27,720
给大家提供一些帮助
