1
00:00:00,000 --> 00:00:01,840
接下来我们看到呢

2
00:00:01,840 --> 00:00:02,820
案例部分

3
00:00:02,820 --> 00:00:04,860
数据结构与算法应用

4
00:00:04,860 --> 00:00:06,920
那这是我们软件设计师考试

5
00:00:06,920 --> 00:00:09,470
下午固定的试题四的部分啊

6
00:00:09,470 --> 00:00:11,750
那它的考察题型呢

7
00:00:11,750 --> 00:00:15,110
一般是给大家一大段的题干说明

8
00:00:15,110 --> 00:00:18,190
表示呢，唉，这是自然语言的描述

9
00:00:18,190 --> 00:00:21,030
然后给大家一些呢，代码说明

10
00:00:21,030 --> 00:00:24,290
就是呢，对下面代码的一些变量的介绍

11
00:00:24,290 --> 00:00:27,200
然后给大家一个 C 语言程序

12
00:00:27,200 --> 00:00:30,160
目前在我们的软件设计师考试当中

13
00:00:30,160 --> 00:00:33,580
主要考察的还是 C 语言的算法设计

14
00:00:33,580 --> 00:00:37,300
伪代码的部分已经有很多年没有出现了

15
00:00:37,300 --> 00:00:38,620
所以我们以呢

16
00:00:38,620 --> 00:00:41,040
C 语言的语法基础为主

17
00:00:41,040 --> 00:00:43,000
需要大家呢，去掌握

18
00:00:43,000 --> 00:00:45,490
后面给大家一些问题

19
00:00:45,490 --> 00:00:47,470
那这里问题的考察

20
00:00:47,470 --> 00:00:51,460
一般会针对代码部分有缺失

21
00:00:51,460 --> 00:00:53,600
需要大家呢，进行代码填空

22
00:00:53,600 --> 00:00:57,830
一般缺失的分值在8~10分的样子

23
00:00:57,830 --> 00:01:02,160
然后要求大家判断它的算法策略，诶

24
00:01:02,160 --> 00:01:03,080
大概两分

25
00:01:03,080 --> 00:01:05,300
时间复杂度大概两分

26
00:01:05,300 --> 00:01:09,520
还有一个实例最终的运行结果大概呢，三分

27
00:01:09,520 --> 00:01:12,670
这就是它的基本考察情况

28
00:01:12,670 --> 00:01:15,570
那这里的考察内容啊

29
00:01:15,570 --> 00:01:17,350
我们会给大家呢

30
00:01:17,350 --> 00:01:18,970
综合介绍一些呢

31
00:01:18,970 --> 00:01:20,570
相应的解题技巧

32
00:01:20,570 --> 00:01:22,500
那首先我们要知道

33
00:01:22,500 --> 00:01:24,490
在备考阶段的时候

34
00:01:24,490 --> 00:01:25,890
我们就要知道啊

35
00:01:25,890 --> 00:01:27,630
对于算法应用题

36
00:01:27,630 --> 00:01:30,120
它的总分值是15分

37
00:01:30,120 --> 00:01:33,520
我们要求大家能够拿到的分值

38
00:01:33,520 --> 00:01:35,740
是6~8分左右

39
00:01:35,740 --> 00:01:39,110
因为它本身是我们整个软件设计师当中

40
00:01:39,110 --> 00:01:40,670
最难的一个部分

41
00:01:40,670 --> 00:01:43,600
也是很多同学呢，不熟悉的部分

42
00:01:43,600 --> 00:01:46,590
那大家在学习这个章节之后啊

43
00:01:46,590 --> 00:01:48,870
需要呢，自己再去自学一

44
00:01:48,870 --> 00:01:51,280
C 语言相关的基础语法

45
00:01:51,280 --> 00:01:55,410
我们要求的6~8分来自于什么呢

46
00:01:55,410 --> 00:01:58,950
哎，首先算法策略的判断

47
00:01:59,550 --> 00:02:04,780
这个两分的分值要求大家尽可能的拿到

48
00:02:04,780 --> 00:02:07,720
然后呢，时间复杂度，诶

49
00:02:07,720 --> 00:02:12,130
这个判断也要求大家尽可能拿到分值

50
00:02:12,130 --> 00:02:15,050
一般呢，也是在两分左右

51
00:02:15,050 --> 00:02:18,170
那剩下的就是呢，代码填空

52
00:02:18,170 --> 00:02:23,120
能够呢，在此基础上填一些基础的语法填空

53
00:02:23,120 --> 00:02:24,960
唉，拿个一到两题

54
00:02:24,960 --> 00:02:26,060
也就是呢

55
00:02:26,060 --> 00:02:31,250
唉，2~4分就已经达到我们的备考要求了

56
00:02:31,250 --> 00:02:33,180
那我们会发现，诶

57
00:02:33,180 --> 00:02:35,820
原本这是一个15分的分值题吧

58
00:02:35,820 --> 00:02:37,060
对于大家来讲

59
00:02:37,060 --> 00:02:39,860
我们只要掌握核心的几个考点

60
00:02:39,860 --> 00:02:44,730
其他的内容有能力、有精力的再去呢，进行拓展

61
00:02:44,730 --> 00:02:47,380
尤其很多的分值来源啊

62
00:02:47,380 --> 00:02:49,640
还是与 C 语言已算

63
00:02:49,640 --> 00:02:53,270
以我们的算法描述有一定相关性的

64
00:02:53,270 --> 00:02:54,840
那我们后面呢

65
00:02:54,840 --> 00:02:56,370
展开来看一下

66
00:02:56,370 --> 00:02:58,140
我们会给大家介绍呢

67
00:02:58,140 --> 00:02:59,620
算法策略的区分

68
00:02:59,620 --> 00:03:02,780
这里其实我们在算法基础的章节

69
00:03:02,780 --> 00:03:04,500
已经给大家介绍到了

70
00:03:04,500 --> 00:03:07,770
时间复杂度与空间复杂度的识别

71
00:03:07,770 --> 00:03:11,660
在我们的算法基础题当中也已经提到了

72
00:03:11,660 --> 00:03:13,020
那这里主要呢

73
00:03:13,020 --> 00:03:16,710
再给大家补充一些代码填空的技巧

74
00:03:16,710 --> 00:03:18,530
那大家在做题的时候呢

75
00:03:18,530 --> 00:03:20,430
有一些分析的思路

76
00:03:20,430 --> 00:03:24,550
再加上自己去积累的 CC 语言的语法

77
00:03:24,550 --> 00:03:26,880
就可以呢去做这类问题了

78
00:03:26,880 --> 00:03:31,200
后面呢，我们会以代码的形式给大家呢，讲例题

79
00:03:31,200 --> 00:03:33,450
每一种算法策略都会呢

80
00:03:33,450 --> 00:03:35,310
给大家举一个例子

81
00:03:35,310 --> 00:03:36,560
那大家可以呢

82
00:03:36,560 --> 00:03:39,320
先看一看我们的解题技巧的内容

83
00:03:39,320 --> 00:03:41,730
再去呢，听实例的部分

84
00:03:41,730 --> 00:03:45,040
那我们首先看到算法策略的区分

85
00:03:45,040 --> 00:03:47,520
主要涉及四种算法策略吧

86
00:03:47,520 --> 00:03:49,690
分治法，对问题进行拆分

87
00:03:49,690 --> 00:03:51,440
一般可以用递归解决

88
00:03:51,440 --> 00:03:54,200
我们考试当中涉及到的主要有

89
00:03:54,200 --> 00:03:57,210
归并、快速排序以及二分搜索

90
00:03:57,210 --> 00:04:00,050
贪心法呢，一般用于求满意解

91
00:04:00,050 --> 00:04:01,550
常见的形式啊

92
00:04:01,550 --> 00:04:04,250
考察就是背包问题和多机调度

93
00:04:04,250 --> 00:04:07,010
那它主要呢，是局部最优

94
00:04:07,010 --> 00:04:09,390
整体不见得有最优啊

95
00:04:09,390 --> 00:04:12,680
每一步都会有明确的既定策略

96
00:04:12,680 --> 00:04:15,590
动态规划法一般用来求最优解

97
00:04:15,590 --> 00:04:19,930
描述当中会有最优子结构和递归式的体现

98
00:04:19,930 --> 00:04:22,900
实现过程当中呢，会有数组存储

99
00:04:22,900 --> 00:04:24,620
注意数组啊

100
00:04:24,620 --> 00:04:26,520
在很多算法策略

101
00:04:26,520 --> 00:04:28,770
很多代码中都会看到

102
00:04:28,770 --> 00:04:31,550
只有存储的是中间。解的时候

103
00:04:31,550 --> 00:04:35,370
我们才说呢，是用于动态规划法的

104
00:04:35,410 --> 00:04:38,690
它的时间复杂度特殊的地方

105
00:04:38,690 --> 00:04:40,880
自顶向下有二的 N 次方

106
00:04:40,880 --> 00:04:42,520
而自底向上的话

107
00:04:42,520 --> 00:04:43,340
只需要呢

108
00:04:43,340 --> 00:04:46,780
N 的 K 次方或者 N 的 A 次方就可以了

109
00:04:46,780 --> 00:04:49,110
常见的矩阵乘法

110
00:04:49,110 --> 00:04:52,800
背包问题和最长公共子序列的问题

111
00:04:52,800 --> 00:04:56,240
回溯法呢，它有探索和回退的过程

112
00:04:56,240 --> 00:04:59,040
可以求任意解或者所有解

113
00:04:59,040 --> 00:05:00,360
主要用来解呢

114
00:05:00,360 --> 00:05:04,440
哎， N 皇后问题在我们考试当中呢，考了两次啊

115
00:05:04,440 --> 00:05:08,080
背包问题呢，在早年曾经出现过

116
00:05:08,080 --> 00:05:09,340
综合来看

117
00:05:09,340 --> 00:05:12,570
它们的区分分治法有递归

118
00:05:12,570 --> 00:05:15,660
并且一般出现的就是归并排序

119
00:05:15,660 --> 00:05:18,920
快速排序、二分搜索这样的二分问题

120
00:05:18,920 --> 00:05:20,340
贪心法呢

121
00:05:20,340 --> 00:05:23,680
唉，它一般来讲可以求满意解，呃

122
00:05:23,680 --> 00:05:26,920
涉及到的没有全局考虑啊

123
00:05:26,920 --> 00:05:29,170
只有呢，当前的判断

124
00:05:29,170 --> 00:05:33,010
一般用来解决背包问题和多机调度

125
00:05:33,010 --> 00:05:34,690
动态规划法

126
00:05:34,690 --> 00:05:36,490
它有最优子结构

127
00:05:36,490 --> 00:05:38,080
还有呢，递归式

128
00:05:38,080 --> 00:05:42,580
那它其实说递归式是与贪心法最大的区别

129
00:05:42,580 --> 00:05:44,520
最优子结构是与呢

130
00:05:44,520 --> 00:05:46,240
分制法最大的区别

131
00:05:46,240 --> 00:05:48,140
并且它本身还有呢

132
00:05:48,140 --> 00:05:50,770
中间数组来求记录

133
00:05:50,770 --> 00:05:52,270
中间结果

134
00:05:52,680 --> 00:05:56,340
中间结果呀，会用数组来进行记录

135
00:05:56,340 --> 00:05:58,260
也是它的最大特点

136
00:05:58,260 --> 00:06:00,210
那常见的典型问题

137
00:06:00,210 --> 00:06:03,620
矩阵乘法、背包和最长公共子序

138
00:06:03,620 --> 00:06:04,560
回溯法

139
00:06:04,560 --> 00:06:07,600
典型的特点就是探索和回退

140
00:06:07,600 --> 00:06:10,810
它会用一个变量来表示它的规模

141
00:06:10,810 --> 00:06:12,050
如果有回退

142
00:06:12,050 --> 00:06:14,340
一般会有呢减一的过程

143
00:06:14,340 --> 00:06:17,620
那常见的就是 N 皇后和迷宫问题

144
00:06:17,620 --> 00:06:20,360
这个我们在前面其实都给大家讲到了吧

145
00:06:20,360 --> 00:06:23,300
并且对于这四种算法策略的判断

146
00:06:23,300 --> 00:06:26,600
唉，最先判断的就是回溯有没有探索回退

147
00:06:26,600 --> 00:06:27,880
有的话是回溯

148
00:06:27,880 --> 00:06:29,360
没有往下面看

149
00:06:29,360 --> 00:06:32,510
那这里有没有出现二分的思想

150
00:06:32,510 --> 00:06:34,350
有的话就是分制吧

151
00:06:34,350 --> 00:06:37,750
那我们如果说出现了划分子问题

152
00:06:37,750 --> 00:06:41,580
然后呢，哎，它没有记录中间数组

153
00:06:41,580 --> 00:06:43,740
我们也可以认为是分制

154
00:06:43,740 --> 00:06:46,400
但一般在我们软设考试当中

155
00:06:46,400 --> 00:06:48,570
还是呢，非二分的问题

156
00:06:48,570 --> 00:06:50,940
还是动态规划法居多

157
00:06:50,940 --> 00:06:54,790
那当如果说有划分子问题，诶

158
00:06:54,790 --> 00:06:56,050
还有呢，递归式

159
00:06:56,050 --> 00:06:57,530
还有中间数组

160
00:06:57,530 --> 00:06:59,560
有最优子结构的描述

161
00:06:59,560 --> 00:07:02,720
这种一般呢，是动态规划法了

162
00:07:02,720 --> 00:07:04,750
如果说没有递归式

163
00:07:04,750 --> 00:07:06,550
没有子问题划分

164
00:07:06,550 --> 00:07:07,990
没有探索回退

165
00:07:07,990 --> 00:07:11,870
一般用到的就是呢，谈心法的策略

166
00:07:12,060 --> 00:07:14,700
那这是呢，对算法策略啊

167
00:07:14,700 --> 00:07:15,880
它的区分

168
00:07:15,880 --> 00:07:19,070
对时间复杂度和空间复杂度呢

169
00:07:19,070 --> 00:07:21,830
我们要求大家掌握常见的这个

170
00:07:21,830 --> 00:07:23,820
时间规模的排序

171
00:07:23,820 --> 00:07:27,310
那其中常量级要能够识别吧

172
00:07:27,310 --> 00:07:28,610
单层循环

173
00:07:28,610 --> 00:07:31,970
双层嵌套循环和三层嵌套循环

174
00:07:31,970 --> 00:07:36,080
要能够识别二分或者树形结构

175
00:07:36,080 --> 00:07:37,900
归并和快速排序

176
00:07:37,900 --> 00:07:41,440
以及呢，树形结构外外层有嵌套

177
00:07:41,440 --> 00:07:44,070
那这里呢， log 2 N 和 N 倍

178
00:07:44,070 --> 00:07:46,990
log 2 N 也要呢，能够识

179
00:07:46,990 --> 00:07:48,960
最后呢，二的 N 次方

180
00:07:48,960 --> 00:07:52,540
它的特殊应用我们在前面呢也有提到啊

181
00:07:52,540 --> 00:07:55,260
包括呢，公共子序列的个数啊

182
00:07:55,260 --> 00:07:57,920
以及呢，我们涉及到的递归啊

183
00:07:57,920 --> 00:08:00,060
它我们的动态规划法

184
00:08:00,060 --> 00:08:01,980
自顶向下进行递归的时候

185
00:08:01,980 --> 00:08:04,620
也可能涉及到这个时间复杂度

186
00:08:04,620 --> 00:08:07,680
空间复杂度呢，就考虑局部变量

187
00:08:07,680 --> 00:08:12,290
或者呢，唉，是我们辅助空间的一个使用

188
00:08:12,290 --> 00:08:14,300
作为空间复杂度

189
00:08:14,300 --> 00:08:18,560
那这是呢，涉及到的时间复杂度和空间复杂度

190
00:08:18,560 --> 00:08:20,950
关于代码填空的技巧呢

191
00:08:20,950 --> 00:08:22,930
我们在这里一定要注意啊

192
00:08:22,930 --> 00:08:25,280
考老师并不是你觉得

193
00:08:25,280 --> 00:08:27,460
而是需要阅卷老师觉得

194
00:08:27,460 --> 00:08:28,960
出卷老师觉得

195
00:08:28,960 --> 00:08:31,680
那这里所有的答案来源呢

196
00:08:31,680 --> 00:08:34,480
还是需要仔细的去审题

197
00:08:34,480 --> 00:08:38,669
那代码填空的时候要检查代码上下文啊

198
00:08:38,669 --> 00:08:41,049
有一些基础语法的问题

199
00:08:41,049 --> 00:08:42,780
变量有没有声明

200
00:08:42,780 --> 00:08:44,460
有没有付出值

201
00:08:44,460 --> 00:08:49,230
那如果诶，有返回值与题干要求的这个变量啊

202
00:08:49,230 --> 00:08:51,650
上下文有没有保持一致

203
00:08:51,800 --> 00:08:54,660
还要检查 for 循环当中啊

204
00:08:54,660 --> 00:08:57,880
我们的这个计数 I 、 J 、 K 这样的一些变量

205
00:08:57,880 --> 00:09:00,810
它有没有赋值、赋初值

206
00:09:00,810 --> 00:09:03,670
以及呢，终止条件的设定

207
00:09:03,670 --> 00:09:07,820
注意呢，外循环它的开始和结束的边界

208
00:09:07,820 --> 00:09:09,570
有一些变量名啊

209
00:09:09,570 --> 00:09:10,870
有特殊的含义

210
00:09:10,870 --> 00:09:15,190
比如说 max 和 mini 用来保存最大值和最小值的

211
00:09:15,190 --> 00:09:15,890
想一想

212
00:09:15,890 --> 00:09:18,730
如果有一个数值比最大值还要大

213
00:09:18,730 --> 00:09:20,010
这个最大值对不对

214
00:09:20,010 --> 00:09:20,590
不对

215
00:09:20,590 --> 00:09:24,080
叫修正。给最大值重新进行赋值

216
00:09:24,080 --> 00:09:26,210
最小值同样如此

217
00:09:26,210 --> 00:09:29,090
如果有一个数比最小值还要小

218
00:09:29,090 --> 00:09:31,570
那说明这个最小值也要呢

219
00:09:31,570 --> 00:09:33,230
就进行修正吧

220
00:09:33,230 --> 00:09:37,490
那还有一些呢，中间变量用来呢暂存数据的

221
00:09:37,490 --> 00:09:39,590
经常拿来做交换

222
00:09:39,590 --> 00:09:43,620
那这是我们提到的一些基础语法的应用

223
00:09:43,620 --> 00:09:47,270
那还有一些特殊的算法策略当中啊

224
00:09:47,270 --> 00:09:50,970
回溯法可能会出现回退分治法

225
00:09:50,970 --> 00:09:53,490
它的递归调用呢，注意它的写

226
00:09:53,490 --> 00:09:55,630
自己调用，自己动态

227
00:09:55,630 --> 00:09:58,880
规划法呢，可能会有查表的操作

228
00:09:58,880 --> 00:10:00,120
那我们呢

229
00:10:00,120 --> 00:10:02,100
在整个考试当中

230
00:10:02,100 --> 00:10:05,140
它的题干说明都是很重要的

231
00:10:05,140 --> 00:10:08,630
考试当中题干说明、代码说明

232
00:10:08,630 --> 00:10:10,140
还有递归

233
00:10:10,140 --> 00:10:12,280
代码的注释和上下文

234
00:10:12,280 --> 00:10:16,060
都会给大家填空带来一定的提示

235
00:10:16,060 --> 00:10:19,250
所以一定要仔细审题

236
00:10:19,250 --> 00:10:23,710
一般如果出现公式或者递归式的话

237
00:10:23,710 --> 00:10:27,730
都可能会要求大家去补充相关填空

238
00:10:27,730 --> 00:10:32,210
比如说边界问题和表达式都有可能出现

239
00:10:32,210 --> 00:10:35,390
还有循环和判断条件等等

240
00:10:35,390 --> 00:10:37,690
代码说明呢，很重要

241
00:10:37,690 --> 00:10:40,670
它会指出一些变量的含义啊

242
00:10:40,670 --> 00:10:43,420
也会呢，哎，在一些数组当中

243
00:10:43,420 --> 00:10:46,960
还会指定它的初始值和边界值

244
00:10:46,960 --> 00:10:49,820
所以也要呢，去看代码

245
00:10:49,820 --> 00:10:51,460
上下文当中呢

246
00:10:51,460 --> 00:10:53,900
诶，有没有相应的缺失

247
00:10:53,900 --> 00:10:55,640
需要大家呢去注意

248
00:10:55,640 --> 00:10:57,970
并且在分制法当中的话

249
00:10:57,970 --> 00:11:01,320
我们一般啊，会出现对称的代码填空

250
00:11:01,320 --> 00:11:02,500
呃，所以说呢

251
00:11:02,500 --> 00:11:04,580
有上下文依据的时候

252
00:11:04,580 --> 00:11:08,370
对于大家填空也是一个呢，很重要的提示

253
00:11:08,370 --> 00:11:10,690
题干说明当中呢

254
00:11:10,690 --> 00:11:13,650
会给出相应的算法过程吧

255
00:11:13,650 --> 00:11:15,560
到底是怎么来实现的

256
00:11:15,560 --> 00:11:18,690
我们其实就是把自然语言转换成了代码

257
00:11:18,690 --> 00:11:24,490
所以要根据题干说明来进行代码的描述

258
00:11:24,490 --> 00:11:26,490
那这个过程当中呢

259
00:11:26,490 --> 00:11:28,690
我们还可以根据题干说明

260
00:11:28,690 --> 00:11:31,470
来判断相应的循环

261
00:11:31,470 --> 00:11:32,030
边界

262
00:11:32,030 --> 00:11:33,210
判断条件

263
00:11:33,210 --> 00:11:36,590
判断相应的算法策略的使用

264
00:11:36,590 --> 00:11:38,450
根据算法策略呢

265
00:11:38,450 --> 00:11:41,640
看一看有没有一些典型的代码缺失

266
00:11:41,640 --> 00:11:44,210
比如说呢，我们动态规划法的话

267
00:11:44,210 --> 00:11:46,030
它的这种递归式的填空

268
00:11:46,030 --> 00:11:49,770
基本上是属于考察频率非常高的

269
00:11:49,770 --> 00:11:52,560
然后呢，涉及到分治法的话

270
00:11:52,560 --> 00:11:55,060
也有可能会出现子问题的划分

271
00:11:55,060 --> 00:11:58,960
并且一般会考到递归贪心法

272
00:11:58,960 --> 00:12:02,220
一般呢，会要求啊取满意解

273
00:12:02,220 --> 00:12:04,320
所以呢，经常会考满意解

274
00:12:04,320 --> 00:12:05,640
他的判断条

275
00:12:05,640 --> 00:12:09,250
回溯法呢，有可能会考到它的回退过程

276
00:12:09,250 --> 00:12:11,510
可以用 K 来进行计数

277
00:12:11,510 --> 00:12:12,600
有 K 减一

278
00:12:12,600 --> 00:12:15,070
也有可能通过呢，递归调

279
00:12:15,070 --> 00:12:17,880
来实现呢，上一步代码的探索

280
00:12:17,880 --> 00:12:21,180
那这是我们提到的代码填空的技巧

281
00:12:21,180 --> 00:12:23,200
带着这些技巧去做题啊

282
00:12:23,200 --> 00:12:26,480
大家基本上呢，会有一定的思路更好一些

283
00:12:26,480 --> 00:12:30,320
后面呢，我们会以例题的形式来给大家呢

284
00:12:30,320 --> 00:12:32,720
哎，以相应的算法策略

285
00:12:32,720 --> 00:12:35,560
举一个实例的形式带大家看一看，呃

286
00:12:35,560 --> 00:12:37,800
相应的考察形式和代码

287
00:12:37,800 --> 00:12:39,350
它的执行过程

288
00:12:39,350 --> 00:12:41,530
大家还要注意一个问题啊

289
00:12:41,530 --> 00:12:44,080
就是我们在 C 语言填空的时候

290
00:12:44,080 --> 00:12:46,560
虽然他说了是 C 语言程序

291
00:12:46,560 --> 00:12:49,290
但代码可能不完整

292
00:12:49,290 --> 00:12:53,220
代码呀，它有可能是错误的啊

293
00:12:53,220 --> 00:12:56,220
有可能不完整或者不严谨

294
00:12:56,220 --> 00:12:59,560
那我们这个时候主要还是根据题干说明

295
00:12:59,560 --> 00:13:02,340
去补充缺失的内容就可以了

296
00:13:02,340 --> 00:13:03,280
那一般呢

297
00:13:03,280 --> 00:13:06,540
考试的代码你可能不能够直接去运行

298
00:13:06,540 --> 00:13:07,840
我们还要对它呢

299
00:13:07,840 --> 00:13:10,540
做一些补充、补充和修正

300
00:13:10,540 --> 00:13:13,140
那我们在后面呢，讲例题的时候

301
00:13:13,140 --> 00:13:16,180
还会呢，给大家做一些补充的内容

302
00:13:16,180 --> 00:13:18,720
那这是呢，要求大家掌握的

303
00:13:18,720 --> 00:13:21,540
关于数据结构与算法应用题

304
00:13:21,540 --> 00:13:22,600
它的一些呢

305
00:13:22,600 --> 00:13:26,260
需要大家掌握的解题技巧和理论基础

306
00:13:26,260 --> 00:13:29,340
那前面讲到的算法策略的区分

307
00:13:29,340 --> 00:13:32,120
时间复杂度和空间复杂度的区

308
00:13:32,120 --> 00:13:33,130
也可以呢

309
00:13:33,130 --> 00:13:36,370
再看一看前面的算法基础章节的视频
