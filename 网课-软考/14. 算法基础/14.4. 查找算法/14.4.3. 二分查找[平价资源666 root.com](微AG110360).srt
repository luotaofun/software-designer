1
00:00:00,000 --> 00:00:02,940
下面我们来看到二分查找

2
00:00:02,940 --> 00:00:04,180
二分查找

3
00:00:04,180 --> 00:00:08,500
在我们查找算法当中出现的频率是最高的

4
00:00:08,500 --> 00:00:11,750
我们需要了解二分查找它的前提

5
00:00:11,750 --> 00:00:14,250
它的基本思想、它的比较过

6
00:00:14,250 --> 00:00:14,950
以及呢

7
00:00:14,950 --> 00:00:16,800
它的一些特点

8
00:00:16,800 --> 00:00:19,790
那针对二分查找来看的话

9
00:00:19,790 --> 00:00:21,820
它的基本思想啊

10
00:00:21,820 --> 00:00:24,060
就是在查找区域当中呢

11
00:00:24,060 --> 00:00:26,160
寻找中间位置

12
00:00:26,160 --> 00:00:27,510
类似于什么呢

13
00:00:27,510 --> 00:00:28,650
大家在小学的时候

14
00:00:28,650 --> 00:00:30,720
应该经常会拿到新华字典吧

15
00:00:30,720 --> 00:00:32,570
然后那本字典呢

16
00:00:32,570 --> 00:00:34,950
哎，李老师以前的时候经常碰到

17
00:00:34,950 --> 00:00:37,640
就是呢，他的目录页丢失了

18
00:00:37,640 --> 00:00:38,600
那怎么办

19
00:00:38,600 --> 00:00:42,310
我们要查的时候是不是随手去翻啊

20
00:00:42,310 --> 00:00:45,070
如果说针对一本字典

21
00:00:45,070 --> 00:00:48,710
我们要查找某一个拼音的情况下

22
00:00:48,710 --> 00:00:51,390
可以直接对半把它打开

23
00:00:51,390 --> 00:00:55,640
唉，然后判断一下这个字母在左侧还是右侧呢

24
00:00:55,640 --> 00:00:58,820
如果在左侧、右侧还需要去查看吗

25
00:00:58,820 --> 00:01:00,180
完全不用了吧

26
00:01:00,180 --> 00:01:03,550
那一本字典就变成了半本字典

27
00:01:03,550 --> 00:01:07,450
那接下来再对这半本字典进行二分

28
00:01:07,450 --> 00:01:10,530
就是一个呢，二分查找的过程啊

29
00:01:10,530 --> 00:01:13,940
那什么样的情况才能用二分查找啊

30
00:01:13,940 --> 00:01:16,860
这个字典一定是顺序存储

31
00:01:16,860 --> 00:01:19,030
并且是基本有序的吧

32
00:01:19,030 --> 00:01:21,860
如果说没有顺序存储

33
00:01:21,860 --> 00:01:26,190
我们就无法把它切成两半进行比较了

34
00:01:26,190 --> 00:01:28,030
如果是无序的

35
00:01:28,030 --> 00:01:32,090
那我们就无法判断它是否属于哪一侧吧

36
00:01:32,090 --> 00:01:35,800
所以二分查找的前提是

37
00:01:35,800 --> 00:01:40,500
诶，基物顺序存储并且基本有序

38
00:01:48,560 --> 00:01:51,840
那针对二分的过程当中

39
00:01:51,840 --> 00:01:54,490
它的基本思想就是切弯吧

40
00:01:54,490 --> 00:01:56,700
那这个切办的过程啊

41
00:01:56,700 --> 00:01:59,480
我们下面呢，以一个实例的形

42
00:01:59,480 --> 00:02:01,660
带大家看一看这段文字

43
00:02:01,660 --> 00:02:04,910
大家可以自己呢课后再去呢读一读

44
00:02:04,910 --> 00:02:07,860
实际上文字它是比较枯燥的

45
00:02:07,860 --> 00:02:09,660
我们以实例来理解

46
00:02:09,660 --> 00:02:11,780
会更加的方便一些

47
00:02:11,780 --> 00:02:13,340
更简洁一些

48
00:02:13,340 --> 00:02:17,660
那现在给了我们含有12个元素的有序表

49
00:02:17,660 --> 00:02:20,520
那12个元素如下所示

50
00:02:20,520 --> 00:02:24,150
这里给了我们相应的数组下标吧

51
00:02:24,150 --> 00:02:27,610
二分查找第一步就是做二分

52
00:02:27,610 --> 00:02:31,290
那将上标和下标

53
00:02:31,940 --> 00:02:35,420
上界和下界相加除以二

54
00:02:35,420 --> 00:02:37,830
哎，这里发现它是6.5

55
00:02:37,830 --> 00:02:39,870
完了大家很多同学开始

56
00:02:39,870 --> 00:02:41,070
6.5怎么办

57
00:02:41,070 --> 00:02:42,280
没有这个下标啊

58
00:02:42,280 --> 00:02:46,760
我们此时啊，对于二分查找它的通用情

59
00:02:46,760 --> 00:02:50,160
都是呢，向下取整的

60
00:02:53,680 --> 00:02:57,960
所以在这里我们的中间指针位置

61
00:02:57,960 --> 00:02:59,940
它是等于六的

62
00:02:59,940 --> 00:03:02,220
也就是 MID 

63
00:03:02,220 --> 00:03:05,500
那这个指针我们一般会有

64
00:03:05,500 --> 00:03:08,200
上界和下界的区别

65
00:03:08,200 --> 00:03:11,500
或者左侧和右侧的区别

66
00:03:11,500 --> 00:03:14,790
一般在比较的过程当中

67
00:03:14,790 --> 00:03:18,640
我们会首先呢，判断一个前提

68
00:03:18,640 --> 00:03:22,220
low 指针应该是小于

69
00:03:22,780 --> 00:03:24,620
hair 指针的

70
00:03:24,620 --> 00:03:28,690
否则我们说这个比较已经呢异界了

71
00:03:28,690 --> 00:03:30,250
在考试当中啊

72
00:03:30,250 --> 00:03:33,720
这里有时候也会出现等号的情况

73
00:03:33,720 --> 00:03:37,160
大家可以根据代码来进行判断

74
00:03:37,160 --> 00:03:39,520
那我们在二分的过程当中

75
00:03:39,520 --> 00:03:44,240
现在呢找到第一个中间指针是 mid 等于六

76
00:03:44,240 --> 00:03:48,380
那此时我们要查找关键字时期

77
00:03:48,380 --> 00:03:50,880
与六的位置上比一比，诶

78
00:03:50,880 --> 00:03:52,820
发现它比六要小吧

79
00:03:52,820 --> 00:03:55,640
因为数组已经是有序的了

80
00:03:55,640 --> 00:04:00,030
所以此时它一定是在左侧区域范围内

81
00:04:00,030 --> 00:04:02,790
那这个左侧的区域范围

82
00:04:02,790 --> 00:04:06,390
我们就把右侧全部排除掉了

83
00:04:06,390 --> 00:04:10,250
那这个排除的力度其实是非常大的

84
00:04:10,250 --> 00:04:13,420
那我们接下来要接着去找一个

85
00:04:13,420 --> 00:04:15,400
新的中间节点

86
00:04:15,400 --> 00:04:19,510
注意此时边界发生了变化

87
00:04:19,510 --> 00:04:22,950
我们在这里很多同学第一反应呢

88
00:04:22,950 --> 00:04:27,160
就是高部分的 head 指针应该指向六

89
00:04:27,160 --> 00:04:29,530
但其实想一想

90
00:04:29,530 --> 00:04:32,100
六的位置有没有比较过啊

91
00:04:32,100 --> 00:04:33,970
已经比较过了

92
00:04:33,970 --> 00:04:36,970
所以在后面的比较过程当中

93
00:04:36,970 --> 00:04:39,770
它是不需要参与的

94
00:04:39,980 --> 00:04:47,500
所以新的 hair 指针它是等于 MID 减一的

95
00:04:47,510 --> 00:04:53,070
而左侧区域它的 NO 指针不会发生变化

96
00:04:53,070 --> 00:04:55,750
那我们第二次 hair 指

97
00:04:55,750 --> 00:05:01,520
第二次 MD 的指针应该是1+5除以二了

98
00:05:01,520 --> 00:05:04,090
此时的 hair 是等于五

99
00:05:04,090 --> 00:05:05,950
而不是等于六的

100
00:05:05,950 --> 00:05:08,070
这个细节呢，大家要注意

101
00:05:08,070 --> 00:05:10,810
那新的 head 指针等于三

102
00:05:10,810 --> 00:05:12,710
我们与三比较

103
00:05:12,710 --> 00:05:16,000
显然17比三要大吧

104
00:05:16,000 --> 00:05:19,850
所以，唉，左侧区域被舍弃

105
00:05:19,850 --> 00:05:21,090
我们现在呢

106
00:05:21,090 --> 00:05:24,380
答案应该在右侧区域来找

107
00:05:24,380 --> 00:05:26,180
这种情况下

108
00:05:26,180 --> 00:05:28,580
我们 head 指针会不会变啊

109
00:05:28,580 --> 00:05:32,560
不会变化的是六指针前移

110
00:05:32,560 --> 00:05:34,570
移到哪里去呢

111
00:05:34,570 --> 00:05:39,100
唉，是不是 mid m i d 比较过了

112
00:05:39,100 --> 00:05:43,660
应该移到 MID 加一的位置

113
00:05:44,390 --> 00:05:51,900
所以此时 NO 指针等于 m id 加一

114
00:05:51,900 --> 00:05:54,140
它是等于四的

115
00:05:54,140 --> 00:05:58,500
注意呢，选择左侧和选择右侧的时候

116
00:05:58,500 --> 00:06:01,650
它调整的范围是不一样的

117
00:06:01,650 --> 00:06:03,390
一个是 NO 指针

118
00:06:03,390 --> 00:06:05,100
一个是 head 指针

119
00:06:05,100 --> 00:06:09,410
并且 mid 是已经被排除的

120
00:06:09,410 --> 00:06:12,110
那我们现在找到 low 指针

121
00:06:12,110 --> 00:06:13,650
它变成了四

122
00:06:13,650 --> 00:06:18,080
新的 mid 等于4+5除以二

123
00:06:18,080 --> 00:06:20,710
结果还是等于四的

124
00:06:20,710 --> 00:06:24,300
所以这里 NO 等于 MID 等于四

125
00:06:24,300 --> 00:06:26,110
here 等于五

126
00:06:26,110 --> 00:06:27,830
那我们与谁比啊

127
00:06:27,830 --> 00:06:30,570
还是与四的位置比

128
00:06:31,060 --> 00:06:32,400
对不对呢

129
00:06:32,400 --> 00:06:33,600
哎不对

130
00:06:33,600 --> 00:06:36,860
所以接下来比四的位置大

131
00:06:36,860 --> 00:06:38,270
说明什么呢

132
00:06:38,270 --> 00:06:40,990
说明四的位置也抛弃了吧

133
00:06:40,990 --> 00:06:46,610
那我们接下来 NO 指针是等于 MID 加一的

134
00:06:47,070 --> 00:06:49,770
也就是变成了五吧

135
00:06:49,770 --> 00:06:53,840
现在大家的指针变成了相等

136
00:06:53,840 --> 00:06:56,620
所以这是最后一个元素

137
00:06:56,620 --> 00:06:59,300
与这个元素进行比较的话

138
00:06:59,300 --> 00:07:02,880
它的结果刚好是等于17的

139
00:07:02,880 --> 00:07:05,320
所以查找成功了

140
00:07:05,320 --> 00:07:08,150
那如果说不等我们这里呢

141
00:07:08,150 --> 00:07:10,340
哎，还能不能接着划分啊

142
00:07:10,340 --> 00:07:11,640
不能划分呢

143
00:07:11,640 --> 00:07:15,300
所以此时呢，会退出我们的循环

144
00:07:15,300 --> 00:07:16,570
查找的过程呢

145
00:07:16,570 --> 00:07:18,020
这就是二分呢

146
00:07:18,020 --> 00:07:20,470
它的一个具体实现的过程

147
00:07:20,470 --> 00:07:22,280
那我们在这里呀

148
00:07:22,280 --> 00:07:26,160
大家需要呢，注意的点有哪些呢

149
00:07:26,160 --> 00:07:29,420
首先它一定是有序

150
00:07:30,270 --> 00:07:33,190
一前提是

151
00:07:34,150 --> 00:07:37,770
顺序存储以及呢已经有序

152
00:07:37,770 --> 00:07:41,620
其次 m id 是向下取整的

153
00:07:41,620 --> 00:07:44,210
然后再进行调整

154
00:07:44,210 --> 00:07:47,140
下一步循环范围的时候

155
00:07:47,140 --> 00:07:52,630
注意了一定是 mid 加一或者 mid 减一

156
00:07:52,630 --> 00:07:55,800
来作为相应的指针

157
00:07:58,140 --> 00:08:02,580
这些细节呢，注意不要写错了

158
00:08:02,580 --> 00:08:04,880
那我们具体比较的过程当中

159
00:08:04,880 --> 00:08:06,760
与哪些元素进行了比较

160
00:08:06,760 --> 00:08:07,900
比较了多少次

161
00:08:07,900 --> 00:08:10,070
与哪些下标进行了比较

162
00:08:10,070 --> 00:08:14,500
都有可能出现在上午的选择题当中

163
00:08:14,500 --> 00:08:16,700
这里呢，我们还要注意啊

164
00:08:16,700 --> 00:08:18,480
在比较的过程当中

165
00:08:18,480 --> 00:08:20,420
比如说我们刚刚已经查到了

166
00:08:20,420 --> 00:08:21,760
最后一个元素吧

167
00:08:21,760 --> 00:08:24,540
它其实会将整个序列啊

168
00:08:24,540 --> 00:08:28,130
把它划分成一个平衡的二叉树

169
00:08:28,130 --> 00:08:32,809
那 N 个节点能够划分成多少个层次的平衡

170
00:08:32,809 --> 00:08:33,289
呃

171
00:08:33,289 --> 00:08:34,679
排序二叉树呢

172
00:08:34,679 --> 00:08:39,500
哎，在这里应该是 log 2 N 向上取整的

173
00:08:39,500 --> 00:08:43,260
也就是 log 2 N 加一向下取整

174
00:08:43,260 --> 00:08:46,570
这也是我们在折半查找的时候啊

175
00:08:46,570 --> 00:08:51,260
查找成功的时候比较次数最多的情况

176
00:08:51,260 --> 00:08:55,490
那它的整个时间复杂度跟我们的二分，唉

177
00:08:55,490 --> 00:08:57,130
会有二的 N 次方吧

178
00:08:57,130 --> 00:08:59,360
二的 X 次方等于 N 

179
00:08:59,360 --> 00:09:02,030
那这个 X 就是它的时间复杂度

180
00:09:02,030 --> 00:09:06,080
执行的循环次数应该是等于 log 2 N 的

181
00:09:06,080 --> 00:09:09,080
也可以结合树形结构知道的

182
00:09:09,080 --> 00:09:11,980
它的时间复杂度是 log 2 N 的

183
00:09:11,980 --> 00:09:16,390
然后呢，是我们提到的折半查找的前提

184
00:09:16,390 --> 00:09:18,370
它一定是有序的

185
00:09:18,370 --> 00:09:20,210
并且是顺序存储的

186
00:09:20,210 --> 00:09:21,990
才能用折半查找

187
00:09:21,990 --> 00:09:25,180
折半查找就是二分查找

188
00:09:25,180 --> 00:09:27,570
那我们再回过头看到呢

189
00:09:27,570 --> 00:09:32,530
这里给大家的具体查找过程的文字描述

190
00:09:32,530 --> 00:09:34,590
可以自己呢再来试一试

191
00:09:34,590 --> 00:09:36,860
代入来查试一下

192
00:09:36,860 --> 00:09:39,800
下面呢，我们来看一下这一部分

193
00:09:39,800 --> 00:09:42,620
在我们软件设计师考试当中的体现

194
00:09:42,620 --> 00:09:46,370
首先，在线性表 L 当中进行二分查找

195
00:09:46,370 --> 00:09:47,490
要求什么

196
00:09:47,490 --> 00:09:51,700
要求肯定是顺序存储、有序排列

197
00:09:51,700 --> 00:09:55,590
所以在这里呢，只有 C 选项的说法是正确的

198
00:09:55,590 --> 00:09:59,650
这里考察的是二分查找它的前提

199
00:10:00,090 --> 00:10:02,370
再来看下面这道题

200
00:10:02,370 --> 00:10:06,750
在55个互异元素构成的有序表当中

201
00:10:06,750 --> 00:10:08,480
进行折半查找

202
00:10:08,480 --> 00:10:10,220
或者叫做呢二分查找

203
00:10:10,220 --> 00:10:12,470
注意呢，是向下取整的

204
00:10:12,470 --> 00:10:14,780
那我们现在要找的是 A 19

205
00:10:14,780 --> 00:10:17,120
第一个 MID 等于多少呢

206
00:10:17,120 --> 00:10:20,130
应该是1+55除以二

207
00:10:20,130 --> 00:10:22,330
它是等于28的

208
00:10:22,330 --> 00:10:26,150
那第二个 MID 应该是在

209
00:10:29,200 --> 00:10:33,100
应该是在呢，28的左侧区域吧

210
00:10:33,100 --> 00:10:35,730
所以应该是28-1

211
00:10:35,730 --> 00:10:38,310
11+27除以二

212
00:10:38,310 --> 00:10:40,610
结果是等于14的

213
00:10:40,610 --> 00:10:43,840
这个时候答案的选项其实已经出来了

214
00:10:43,840 --> 00:10:45,690
应该是 B 选项

215
00:10:45,690 --> 00:10:48,980
那我们现在找到的应该比14大

216
00:10:48,980 --> 00:10:54,600
所以 mid 应该是等于15+27

217
00:10:54,600 --> 00:10:55,980
MID 加一

218
00:10:55,980 --> 00:10:59,360
然后上范，上范围上界不变

219
00:10:59,360 --> 00:11:03,550
那这个结果应该是等于21的

220
00:11:03,550 --> 00:11:07,690
21在我们的结果右侧吧

221
00:11:07,690 --> 00:11:10,460
说明它应该比21要小

222
00:11:10,460 --> 00:11:15,380
所以接下来应该变化的是21-1

223
00:11:15,380 --> 00:11:18,960
20加上下界线不变

224
00:11:18,960 --> 00:11:21,760
那这个结果向下取整

225
00:11:21,760 --> 00:11:24,360
应该是等于17的

226
00:11:24,360 --> 00:11:27,000
最后呢，哎，我们再来看

227
00:11:27,000 --> 00:11:28,700
找到17之后

228
00:11:28,700 --> 00:11:30,390
19比17大吧

229
00:11:30,390 --> 00:11:36,630
所以下一步的 m id 应该是18+20除以二

230
00:11:36,630 --> 00:11:39,420
结果刚好是等于19

231
00:11:39,420 --> 00:11:41,600
此时查找成功

232
00:11:41,600 --> 00:11:44,280
这就是我们呢做二分查

233
00:11:44,280 --> 00:11:46,730
求 mid 的具体过程

234
00:11:46,730 --> 00:11:50,190
MID 呢，就是我们比较的元素

235
00:11:50,190 --> 00:11:52,410
一般通过下标呢就可以
