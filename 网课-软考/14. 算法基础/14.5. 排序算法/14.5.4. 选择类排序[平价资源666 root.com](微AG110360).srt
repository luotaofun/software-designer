1
00:00:00,000 --> 00:00:02,660
接下来看到选择类排序

2
00:00:02,660 --> 00:00:06,280
选择类排序呢，主要有简单选择排序

3
00:00:06,280 --> 00:00:07,870
还有呢，堆排序

4
00:00:07,870 --> 00:00:10,420
那在我们软件设计师考试当中啊

5
00:00:10,420 --> 00:00:14,120
需要大家呢，了解选择类排序它的一些特点

6
00:00:14,120 --> 00:00:15,180
然后呢

7
00:00:15,180 --> 00:00:16,580
重点了解呢

8
00:00:16,580 --> 00:00:17,940
堆它的大顶堆

9
00:00:17,940 --> 00:00:20,050
小顶堆的判断就可以了

10
00:00:20,050 --> 00:00:24,510
堆排序的具体过程是不要求大家去掌握的

11
00:00:24,510 --> 00:00:26,190
那我们首先看到呢

12
00:00:26,190 --> 00:00:29,580
简单选择排序也叫做直接选择排序

13
00:00:29,580 --> 00:00:31,210
它的基本过程呢

14
00:00:31,210 --> 00:00:32,670
就是用一个函数啊

15
00:00:32,670 --> 00:00:36,170
找出呢，每一次带排序列当中最小的记录

16
00:00:36,170 --> 00:00:39,640
那与我们相应的记录来进行交换就可以了

17
00:00:39,640 --> 00:00:40,860
那以此类推

18
00:00:40,860 --> 00:00:43,590
直到呢，将所有的数据都找完

19
00:00:43,590 --> 00:00:46,900
这种排序方法它是不稳定的

20
00:00:46,900 --> 00:00:48,340
时间复杂度呢

21
00:00:48,340 --> 00:00:51,900
由于需要遍历查找最值再进行交换

22
00:00:51,900 --> 00:00:54,660
那每一轮呢，都有这样的一个过程

23
00:00:54,660 --> 00:00:56,520
所以它的便利过程啊

24
00:00:56,520 --> 00:01:00,200
时间复杂度呢，能够达到大 O 级的 N 平方

25
00:01:00,200 --> 00:01:02,050
那我们在这个过程当中

26
00:01:02,050 --> 00:01:04,209
交换只需要一个辅助空间

27
00:01:04,209 --> 00:01:05,910
所以空间复杂度呢

28
00:01:05,910 --> 00:01:07,490
只有大 OG 的一

29
00:01:07,490 --> 00:01:10,870
那我们在这里以一个实例呢，简单看一下

30
00:01:10,870 --> 00:01:11,550
首先

31
00:01:11,550 --> 00:01:15,200
初始状态还是57、68、59、52

32
00:01:15,200 --> 00:01:18,100
那我们第一轮找最小值，诶

33
00:01:18,100 --> 00:01:21,300
我们第一次找的是第一个最小值吧

34
00:01:21,300 --> 00:01:24,130
最小值遍历一下是52

35
00:01:24,130 --> 00:01:25,810
那52找到之后

36
00:01:25,810 --> 00:01:27,750
第一个最小值应该放在哪呢

37
00:01:27,750 --> 00:01:29,860
应该放在0号位置

38
00:01:29,860 --> 00:01:34,190
所以它与0号位置做了数据交换

39
00:01:34,190 --> 00:01:36,950
那我们在这里简单提一下啊

40
00:01:36,950 --> 00:01:41,710
如果说在这中间有一个52星号

41
00:01:41,710 --> 00:01:44,610
来表示一个相同大小的52

42
00:01:44,610 --> 00:01:49,530
是不是就修改了52它的相对位置啊

43
00:01:49,530 --> 00:01:51,260
那相同的值

44
00:01:51,260 --> 00:01:55,320
相对位置发生改变的就是不稳定排序

45
00:01:55,320 --> 00:02:00,270
一般我们把这种交换的过程叫做呢隔空交换

46
00:02:00,270 --> 00:02:03,190
包括我们在讲希尔排序的时候

47
00:02:03,190 --> 00:02:06,160
其实也有这种隔空交换的过程吧

48
00:02:06,160 --> 00:02:08,250
所以有隔空交换的

49
00:02:08,250 --> 00:02:11,350
其实都是不稳定的排序过程

50
00:02:11,350 --> 00:02:12,950
那我们接着看

51
00:02:12,950 --> 00:02:15,300
找到第一个最小值之后

52
00:02:15,300 --> 00:02:18,480
那我们直接就找到了第一个最小值

53
00:02:18,480 --> 00:02:20,120
它确定的位置吧

54
00:02:20,120 --> 00:02:23,380
所以52是处理完的数据

55
00:02:23,380 --> 00:02:26,070
那接下来我们还有哪些数据呢

56
00:02:26,070 --> 00:02:28,780
唉，还有三个带排序列

57
00:02:28,780 --> 00:02:32,220
再对这三个代排序列找最小值

58
00:02:32,220 --> 00:02:33,440
谁是最小值啊

59
00:02:33,440 --> 00:02:35,920
这你找的其实就是次小值

60
00:02:35,920 --> 00:02:37,570
应该是57

61
00:02:37,570 --> 00:02:40,700
57应该放在一号位置

62
00:02:40,700 --> 00:02:44,540
所以57与一号位置做交换

63
00:02:44,540 --> 00:02:48,930
那52和57是虽然没有比较

64
00:02:48,930 --> 00:02:52,150
所有虽然没有完成最终的排序

65
00:02:52,150 --> 00:02:55,290
但是每一轮我们都可以找到一个

66
00:02:55,290 --> 00:02:57,190
合适元素的位置吧

67
00:02:57,190 --> 00:02:59,440
那第一轮排好第一个元素

68
00:02:59,440 --> 00:03:03,020
第二轮排好前两个元素了

69
00:03:03,340 --> 00:03:07,440
接下来第三轮再来找剩余带

70
00:03:07,440 --> 00:03:10,200
排元素的最小值应该是59吧

71
00:03:10,200 --> 00:03:12,870
那59应该唉，放在哪儿

72
00:03:12,870 --> 00:03:14,770
应该放在2号位置

73
00:03:14,770 --> 00:03:16,290
不需要处理

74
00:03:16,290 --> 00:03:19,250
那剩下的68他只有一个人

75
00:03:19,250 --> 00:03:20,970
不用再进行处理了吧

76
00:03:20,970 --> 00:03:24,790
此时就完成了排序的过程

77
00:03:24,790 --> 00:03:26,990
它的每一轮时间啊

78
00:03:26,990 --> 00:03:30,180
其实都耗费在找最小值当中去了

79
00:03:30,180 --> 00:03:31,620
时间复杂度呢

80
00:03:31,620 --> 00:03:34,390
能够达到大 O 级的 N 平方

81
00:03:34,390 --> 00:03:35,790
空间复杂度

82
00:03:35,790 --> 00:03:40,170
只需要给它一个 temp 做数据交换就足够了

83
00:03:40,170 --> 00:03:44,450
那这就是呢，直接选择排序堆

84
00:03:44,450 --> 00:03:46,830
排序呢，它是我们直接选择

85
00:03:46,830 --> 00:03:50,130
或者说简单选择的一个优化过程

86
00:03:50,130 --> 00:03:52,520
它在排序的过程当中

87
00:03:52,520 --> 00:03:54,800
会对我们的这个待排序列

88
00:03:54,800 --> 00:03:56,750
亚做一些细微的调

89
00:03:56,750 --> 00:03:58,280
头枕在后面呢

90
00:03:58,280 --> 00:04:02,660
就可以减少比较的或者说交换的次数了

91
00:04:02,660 --> 00:04:05,780
那我们首先了解堆的概念

92
00:04:05,780 --> 00:04:10,370
堆它的结构与树的结构其实是很相似的

93
00:04:10,370 --> 00:04:12,800
我们一般看到一个队列诶

94
00:04:12,800 --> 00:04:15,060
一个序列问大家是否满足

95
00:04:15,060 --> 00:04:18,500
堆其实就是把这个序列啊

96
00:04:19,470 --> 00:04:24,390
按照从上往下、从左往右依次填

97
00:04:24,390 --> 00:04:27,400
这一个呢，完全二叉树就可以了

98
00:04:27,400 --> 00:04:31,650
那这个填的过程当中形成的是树形结构吧

99
00:04:31,650 --> 00:04:35,440
但是这个树形结构是否满足堆的定义呢

100
00:04:35,440 --> 00:04:37,750
还需要另外判断

101
00:04:37,750 --> 00:04:42,140
那堆它可以分为大顶堆和小顶堆

102
00:04:42,140 --> 00:04:47,050
所谓大顶堆就是所有的堆顶元素

103
00:04:47,050 --> 00:04:52,580
它一定是都比相应的这个子节点要大

104
00:04:52,580 --> 00:04:56,380
那每一个父节点都比相应的子节点大

105
00:04:56,380 --> 00:04:57,980
就叫做大顶堆

106
00:04:57,980 --> 00:05:02,000
有一组不符就不符合堆的定义

107
00:05:02,380 --> 00:05:06,980
同样，小顶堆指的是每一个堆顶元素

108
00:05:06,980 --> 00:05:11,580
或者说复节点都比呢相对的子节点要小

109
00:05:11,580 --> 00:05:13,590
就叫做呢小顶堆

110
00:05:13,590 --> 00:05:17,880
我们呢，要能够识别大顶堆和小顶

111
00:05:17,880 --> 00:05:19,980
它的这种形态

112
00:05:19,980 --> 00:05:23,260
那具体关于堆排序的过程啊

113
00:05:23,260 --> 00:05:27,200
简单来说唉，就是呢，不停地调整

114
00:05:27,200 --> 00:05:30,200
把堆顶元素取走的过程

115
00:05:30,200 --> 00:05:31,960
它首先会建立堆

116
00:05:31,960 --> 00:05:34,380
那堆顶显然要么是最小值

117
00:05:34,380 --> 00:05:35,600
要么是最大值吧

118
00:05:35,600 --> 00:05:37,220
那我们把堆顶取走

119
00:05:37,220 --> 00:05:40,010
就可以确定第一个元素的位置

120
00:05:40,010 --> 00:05:43,370
然后呢，再对剩下的元素接着建堆

121
00:05:43,370 --> 00:05:44,750
再输出堆

122
00:05:44,750 --> 00:05:46,180
以此类推

123
00:05:46,180 --> 00:05:49,440
直到呢，所有元素都输出一次

124
00:05:49,440 --> 00:05:51,760
这就是呢，堆排序的过程

125
00:05:51,760 --> 00:05:55,050
那堆排序它在做处理的过程当中

126
00:05:55,050 --> 00:05:59,940
也它只需要一个元素位置来进行交换

127
00:05:59,940 --> 00:06:03,660
所以啊，对于数据量比较大的情况下

128
00:06:03,660 --> 00:06:06,650
对于排序呢，一般是比较有效的

129
00:06:06,650 --> 00:06:09,690
当然，如果说基本有序的数据量大

130
00:06:09,690 --> 00:06:12,750
我们仍然会选择插入排序啊

131
00:06:12,750 --> 00:06:15,560
他首先呢，会将这个顺序表啊

132
00:06:15,560 --> 00:06:17,210
建立一个大顶堆

133
00:06:17,210 --> 00:06:20,560
然后呢，堆顶放在了第一个元素位置

134
00:06:20,560 --> 00:06:22,760
其他的带排序列呢，哎

135
00:06:22,760 --> 00:06:24,060
为一到 N 

136
00:06:24,060 --> 00:06:25,880
那我们在这个过程当中

137
00:06:25,880 --> 00:06:28,870
会重复这个取堆顶的过程

138
00:06:28,870 --> 00:06:32,810
直到呢，将所有的这个元素啊，取出来

139
00:06:32,810 --> 00:06:34,440
因为取出堆顶之后

140
00:06:34,440 --> 00:06:35,540
我们会破坏堆

141
00:06:35,540 --> 00:06:37,260
所以在这个过程当中呢

142
00:06:37,260 --> 00:06:39,780
会重新的调整堆

143
00:06:39,780 --> 00:06:42,260
那针对这样的过程来看的话

144
00:06:42,260 --> 00:06:45,400
唉，我们会发现它的时间复杂度啊

145
00:06:45,400 --> 00:06:48,030
是大 O 级 N 倍 log 2 N 

146
00:06:48,030 --> 00:06:48,990
为什么呢

147
00:06:48,990 --> 00:06:51,670
唉，因为我们建堆的过程

148
00:06:51,670 --> 00:06:54,740
它其实就是构造二叉树的过程吧

149
00:06:54,740 --> 00:06:56,330
构造二叉树

150
00:06:56,330 --> 00:06:58,370
并且是完全二叉树

151
00:06:58,370 --> 00:07:02,470
它的时间复杂度只需要 log 2 N 

152
00:07:02,470 --> 00:07:05,910
那现在每一次取出堆顶

153
00:07:05,910 --> 00:07:07,830
我们就需要重复建堆

154
00:07:07,830 --> 00:07:11,150
取堆顶就重复建堆会取多少次啊

155
00:07:11,150 --> 00:07:13,410
N 个节点会取 N 次

156
00:07:13,410 --> 00:07:15,950
所以它会重复 N 次

157
00:07:15,950 --> 00:07:19,310
在此加上了一个外层的嵌套循环

158
00:07:19,310 --> 00:07:22,440
所以它的时间复杂度是 N 倍

159
00:07:22,440 --> 00:07:23,720
log 2n 

160
00:07:23,720 --> 00:07:27,080
那我们在这里也会写作 N 

161
00:07:27,080 --> 00:07:29,300
log n 或者 N 倍

162
00:07:29,300 --> 00:07:34,010
唉，这个 logo n 大家都是呢， log 2 N 的意思

163
00:07:34,010 --> 00:07:36,630
虽然在数学上它们有区别

164
00:07:36,630 --> 00:07:38,930
但是在我们软设考试当中

165
00:07:38,930 --> 00:07:40,740
作为时间复杂度

166
00:07:40,740 --> 00:07:42,580
它们是等价的

167
00:07:42,580 --> 00:07:44,420
了解一下这样的写法

168
00:07:44,420 --> 00:07:48,200
它们的空间复杂度呢，是大 O 级的。一

169
00:07:48,200 --> 00:07:51,040
下面我们简单看一个实例

170
00:07:51,040 --> 00:07:51,660
注意啊

171
00:07:51,660 --> 00:07:52,820
这个排序的过程

172
00:07:52,820 --> 00:07:55,800
是不要求大家自己去掌握的

173
00:07:55,800 --> 00:07:58,260
那下面给了我们一个顺序表

174
00:07:58,260 --> 00:08:00,160
哎，这个序列给我们了

175
00:08:00,160 --> 00:08:03,250
那我们接下来呢，首先按次序

176
00:08:03,250 --> 00:08:09,820
30、六、十、十、五、十、40、五、十、六、十、五、80、40、20

177
00:08:09,820 --> 00:08:11,520
依次记录下来

178
00:08:11,520 --> 00:08:15,490
然后判断一下它是否满足堆

179
00:08:15,490 --> 00:08:18,320
这个判断的过程怎么看啊

180
00:08:18,320 --> 00:08:23,230
我们首先看30比60和十要大还是小呢

181
00:08:23,230 --> 00:08:26,990
唉，我们会发现30比60小

182
00:08:26,990 --> 00:08:29,380
但是比十要大

183
00:08:29,380 --> 00:08:32,490
所以它到底满足大顶堆还是小顶堆呢

184
00:08:32,490 --> 00:08:34,230
其实都不满足

185
00:08:34,230 --> 00:08:36,940
所以此时它并不是一个堆

186
00:08:36,940 --> 00:08:39,400
不满足堆的话怎么办呢

187
00:08:39,400 --> 00:08:41,990
我们会从底层开始调整

188
00:08:41,990 --> 00:08:45,290
首先针对这一棵子树来看的话

189
00:08:45,290 --> 00:08:48,810
唉，我们要把它调整成大顶堆

190
00:08:48,810 --> 00:08:51,620
较大值往上，哎

191
00:08:51,620 --> 00:08:53,440
较大值作为子节点

192
00:08:53,440 --> 00:08:54,660
作为父节点吧

193
00:08:54,660 --> 00:08:56,780
较小值作为子节点

194
00:08:56,780 --> 00:08:59,190
所以它们之间进行交换

195
00:08:59,190 --> 00:09:00,530
此时呢，哎

196
00:09:00,530 --> 00:09:03,270
80会到达50的位置

197
00:09:03,270 --> 00:09:04,950
那这个过程当中

198
00:09:04,950 --> 00:09:08,020
形成的左侧就是一个大顶堆了

199
00:09:08,020 --> 00:09:10,630
而我们的45和20

200
00:09:10,630 --> 00:09:13,240
是满足大顶堆条件的

201
00:09:13,240 --> 00:09:15,410
接着再来分析，唉

202
00:09:15,410 --> 00:09:18,050
60、80和45

203
00:09:18,050 --> 00:09:22,890
以及呢，十、六、15和十有没有满足大顶堆呀

204
00:09:22,890 --> 00:09:25,830
我们会发现这里没有满足大顶堆吧

205
00:09:25,830 --> 00:09:26,550
谁最大

206
00:09:26,550 --> 00:09:27,610
16最大

207
00:09:27,610 --> 00:09:30,030
所以与父节点做交换

208
00:09:30,030 --> 00:09:33,130
而60、80、45谁最大

209
00:09:33,130 --> 00:09:34,250
80最大

210
00:09:34,250 --> 00:09:36,880
所以与复节点做交换

211
00:09:36,880 --> 00:09:40,220
那么交换之后还剩下一个层次

212
00:09:40,220 --> 00:09:43,100
30、80和16，谁最大呢

213
00:09:43,100 --> 00:09:44,640
哎，80最大

214
00:09:44,640 --> 00:09:47,240
所以呢，做了相应的交换

215
00:09:47,240 --> 00:09:49,580
让80作为复节点

216
00:09:49,580 --> 00:09:51,730
那80作为复节点的时候

217
00:09:51,730 --> 00:09:54,750
下面这个层次又不满足了吧

218
00:09:54,750 --> 00:09:56,480
所以接着调整

219
00:09:56,480 --> 00:09:58,660
将较大值作为父节点

220
00:09:58,660 --> 00:10:02,170
较小值交换到子节点的位置上

221
00:10:02,170 --> 00:10:05,610
再对下面的底层进行调整

222
00:10:05,610 --> 00:10:07,150
直到呢，唉

223
00:10:07,150 --> 00:10:11,510
把它调整为一个合法的大顶堆

224
00:10:11,510 --> 00:10:15,690
那这个就是完成了初始建堆的过程

225
00:10:15,690 --> 00:10:19,410
那建堆之后我们要把堆顶元素取走

226
00:10:19,410 --> 00:10:23,060
所以80放在 R 1的位置上

227
00:10:23,060 --> 00:10:27,360
接下来会把最后一个元素放到哪堆顶

228
00:10:27,360 --> 00:10:29,170
那放置之后

229
00:10:29,170 --> 00:10:31,710
这里又形成了一个，诶

230
00:10:31,710 --> 00:10:33,720
非堆的元素吧

231
00:10:33,720 --> 00:10:37,370
所以我们接着把它调整为一个呢

232
00:10:37,370 --> 00:10:39,920
诶，满足大顶堆的条件

233
00:10:39,920 --> 00:10:44,740
然后再将大顶堆的堆顶输出就可以了

234
00:10:44,740 --> 00:10:47,110
那这就是我们提到的建堆

235
00:10:47,110 --> 00:10:49,690
以及呢，输出堆顶、重建堆

236
00:10:49,690 --> 00:10:51,990
再输出堆顶的过程

237
00:10:51,990 --> 00:10:55,440
直到将所有元素都输出

238
00:10:55,440 --> 00:10:58,100
这也是呢，选择类排序

239
00:10:58,100 --> 00:11:03,360
它是每一次将最值放在堆里来进行选择的

240
00:11:03,360 --> 00:11:07,450
由于建堆的过程对元素进行了一些调整

241
00:11:07,450 --> 00:11:09,270
所以时间复杂度

242
00:11:09,270 --> 00:11:11,440
性能上有一些优化

243
00:11:11,440 --> 00:11:14,870
那不再是大 O 级的 N 平方呢

244
00:11:15,260 --> 00:11:18,760
而是呢，变成了大 O 级的 N 

245
00:11:18,760 --> 00:11:19,780
log 2n 

246
00:11:19,780 --> 00:11:22,240
注意啊，这个时间复杂度大一些

247
00:11:22,240 --> 00:11:25,610
这个时间时间复杂度会更小一些

248
00:11:25,610 --> 00:11:28,680
那这是给大家提到的关于呢

249
00:11:28,680 --> 00:11:31,340
我们的选择类排序

250
00:11:31,340 --> 00:11:33,170
下面看一下这一部分

251
00:11:33,170 --> 00:11:36,510
在我们软件设计师考试真题当中的体现

252
00:11:36,510 --> 00:11:39,280
那这这里呢，给了我们一个例题

253
00:11:39,280 --> 00:11:41,350
对于 N 个元素的关键字

254
00:11:41,350 --> 00:11:42,990
唉，一、二三、456、七

255
00:11:42,990 --> 00:11:46,390
当且仅当满足相应条件的时候

256
00:11:46,390 --> 00:11:48,290
才称之为小顶堆

257
00:11:48,290 --> 00:11:51,020
那谁不是小领队

258
00:11:51,020 --> 00:11:54,260
这些元素虽然是线性的

259
00:11:54,260 --> 00:11:55,080
我们呢

260
00:11:55,080 --> 00:11:57,560
可以从上往下

261
00:11:57,560 --> 00:12:02,280
从左往右依次去进行记录

262
00:12:03,600 --> 00:12:07,380
那此时我们会发现，记录下来之后

263
00:12:07,380 --> 00:12:11,560
这些节点父子相对关系还是比较明确的吧

264
00:12:11,560 --> 00:12:14,670
把这些图示画出来之后

265
00:12:14,670 --> 00:12:16,110
判断一下，哎

266
00:12:16,110 --> 00:12:18,030
是不是所有的父节点

267
00:12:18,030 --> 00:12:20,010
都比它的子节点要小呢

268
00:12:20,010 --> 00:12:21,530
是的，就满足

269
00:12:21,530 --> 00:12:24,860
小顶堆那 B 选项依次记录

270
00:12:24,860 --> 00:12:28,440
16、40、二、15

271
00:12:29,080 --> 00:12:34,100
五、14、15、35、1

272
00:12:34,100 --> 00:12:39,040
也是满足小顶堆的 C 选项

273
00:12:39,040 --> 00:12:40,400
16

274
00:12:41,290 --> 00:12:45,690
25、39、41

275
00:12:45,690 --> 00:12:50,690
45、43、50、哎

276
00:12:50,690 --> 00:12:52,090
它也是满

277
00:12:52,090 --> 00:12:54,210
小顶堆的 D 选项

278
00:12:54,210 --> 00:12:59,940
依次标注16、四十二十五

279
00:13:00,450 --> 00:13:06,490
53、39、55、4

280
00:13:06,670 --> 00:13:08,810
那大家有没有发现啊

281
00:13:08,810 --> 00:13:11,890
这里的40比39要大吧

282
00:13:11,890 --> 00:13:14,350
不满足小顶堆的定义

283
00:13:14,350 --> 00:13:17,120
所以在这里只有 D 选项

284
00:13:17,120 --> 00:13:19,170
它不是小顶堆

285
00:13:19,170 --> 00:13:20,990
那对于堆排序啊

286
00:13:20,990 --> 00:13:25,310
我们只要求大家能够识别堆是否满足诶

287
00:13:25,310 --> 00:13:28,510
小顶堆或者大顶堆的定义就可以了

288
00:13:28,510 --> 00:13:30,410
其他呢，选择类排序

289
00:13:30,410 --> 00:13:33,290
大家呢，还是需要了解简单选择

290
00:13:33,290 --> 00:13:35,860
或者叫做直接选择它的过程的

291
00:13:35,860 --> 00:13:36,800
堆排序

292
00:13:36,800 --> 00:13:38,380
主要了解它的时间

293
00:13:38,380 --> 00:13:41,020
复杂度和它的特点就可以了
