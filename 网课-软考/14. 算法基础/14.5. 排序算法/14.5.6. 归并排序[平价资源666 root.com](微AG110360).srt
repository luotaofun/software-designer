1
00:00:00,000 --> 00:00:02,060
下面看到归并排序

2
00:00:02,060 --> 00:00:04,210
那针对归并排序呢

3
00:00:04,210 --> 00:00:06,070
它是我们考试当中啊

4
00:00:06,070 --> 00:00:09,320
也是会涉及上午和下午题两部分的

5
00:00:09,320 --> 00:00:11,520
它所用到的也有呢

6
00:00:11,520 --> 00:00:13,680
分治法的思想在里面

7
00:00:13,680 --> 00:00:15,430
针对归并排序

8
00:00:15,430 --> 00:00:17,950
我们需要了解它的排序过程

9
00:00:17,950 --> 00:00:20,520
它的时间复杂度和它的稳定性

10
00:00:20,520 --> 00:00:24,910
以及呢，唉，它涉及到的算法策略

11
00:00:24,910 --> 00:00:27,240
针对归并排序来看的话

12
00:00:27,240 --> 00:00:28,740
它也叫做呢合并

13
00:00:28,740 --> 00:00:31,710
我们经常提到的都是呢，二路归并

14
00:00:31,710 --> 00:00:34,940
将两个或两个以上的有序子表啊

15
00:00:34,940 --> 00:00:37,160
合并成一个新的有序表

16
00:00:37,160 --> 00:00:40,400
若这两个有序表合并之后啊

17
00:00:40,400 --> 00:00:42,760
是二个，两个有序表

18
00:00:42,760 --> 00:00:44,420
我们就叫做呢二路归并

19
00:00:44,420 --> 00:00:46,520
那归并的过程当中啊

20
00:00:46,520 --> 00:00:47,880
我们说归并排序

21
00:00:47,880 --> 00:00:50,440
它的时间复杂度其实比较有优势

22
00:00:50,440 --> 00:00:51,360
为什么呢

23
00:00:51,360 --> 00:00:53,870
诶，因为它在归并的过程当中

24
00:00:53,870 --> 00:00:58,120
如果这两个有序表注意已经有序了啊

25
00:00:58,120 --> 00:00:59,510
比较完了之后

26
00:00:59,510 --> 00:01:02,950
第一个元素比最后一个元素还要大

27
00:01:02,950 --> 00:01:04,390
那我们比完了之后

28
00:01:04,390 --> 00:01:06,250
后面这些元素要不要比啊

29
00:01:06,250 --> 00:01:07,090
不用了

30
00:01:07,090 --> 00:01:09,470
直接复制过来就可以了

31
00:01:09,470 --> 00:01:11,130
所以它的时间优势啊

32
00:01:11,130 --> 00:01:13,750
主要在哪复制这一块出现的

33
00:01:13,750 --> 00:01:16,450
那针对归并排序来看的话

34
00:01:16,450 --> 00:01:19,970
由于它是从两两来进行归并的

35
00:01:19,970 --> 00:01:21,640
所以它相对来说呢

36
00:01:21,640 --> 00:01:24,670
是相邻进行比较和归并

37
00:01:24,670 --> 00:01:28,520
它的实，它的稳定性来看，它是稳定的

38
00:01:28,520 --> 00:01:30,850
其次，它的时间复杂度

39
00:01:30,850 --> 00:01:34,750
由于涉及到二路归并这种二分的思想啊

40
00:01:34,750 --> 00:01:37,500
时间复杂度呢，都是 log 2 N 

41
00:01:37,500 --> 00:01:39,710
再加上归并的过程呢

42
00:01:39,710 --> 00:01:42,010
唉，就有了 N 倍 log n 

43
00:01:42,010 --> 00:01:44,920
它的划分时间复杂度是 log n 

44
00:01:44,920 --> 00:01:46,460
而归并是 N 

45
00:01:46,460 --> 00:01:47,820
所以综合来看

46
00:01:47,820 --> 00:01:50,650
时间复杂度是 N 倍 log n 

47
00:01:50,650 --> 00:01:52,460
那这个过程当中啊

48
00:01:52,460 --> 00:01:55,320
由于我们归归并的时候

49
00:01:55,320 --> 00:01:57,300
是需要由数组空间

50
00:01:57,300 --> 00:02:00,230
来给他们提供归并过程的

51
00:02:00,230 --> 00:02:02,650
所以它的空间复杂度呢

52
00:02:02,650 --> 00:02:03,950
相对来说较大

53
00:02:03,950 --> 00:02:06,000
需要大 O 级的 N 

54
00:02:06,000 --> 00:02:07,770
那我们综合来看的话

55
00:02:07,770 --> 00:02:09,169
大家可以回忆一下

56
00:02:09,169 --> 00:02:12,080
N 倍 log 2 N 出现了多少次啊

57
00:02:12,080 --> 00:02:15,540
我们在讲堆排序的时候

58
00:02:16,100 --> 00:02:20,580
它的时间复杂度也是呢， N 倍 log n 

59
00:02:20,580 --> 00:02:23,340
而堆排序有什么区别呢

60
00:02:23,340 --> 00:02:25,580
它是选择类排序

61
00:02:25,580 --> 00:02:27,980
所以它不稳定

62
00:02:28,300 --> 00:02:31,730
其次还有一个快速排序

63
00:02:31,730 --> 00:02:36,440
注意快速排序在最优和平均情况下

64
00:02:36,440 --> 00:02:40,070
时间复杂度也是呢， N 倍 log 2 N 

65
00:02:40,070 --> 00:02:42,510
它也是呢不稳定的

66
00:02:42,510 --> 00:02:44,120
所以我们会发现啊

67
00:02:44,120 --> 00:02:47,860
N 倍 log 2 N 唯一稳定的排序算

68
00:02:47,860 --> 00:02:49,940
其实只有归并

69
00:02:49,940 --> 00:02:51,900
而在这之间啊

70
00:02:51,900 --> 00:02:55,610
堆排序它只需要一个辅助空间吧

71
00:02:55,610 --> 00:02:56,800
快速排序

72
00:02:56,800 --> 00:03:00,840
我们所提到的辅助空间是大 O 级的 N 

73
00:03:00,840 --> 00:03:03,800
或者大 O 级的 log 2 N 

74
00:03:03,800 --> 00:03:07,480
所以综合来看，谁空间最有优势呢

75
00:03:07,480 --> 00:03:10,950
唉，应该堆排序最有空间优势

76
00:03:10,950 --> 00:03:13,440
如果数据量较大的时候

77
00:03:13,440 --> 00:03:17,430
我们会建议呢，用堆排序来解决问题

78
00:03:17,430 --> 00:03:18,370
那这是呢

79
00:03:18,370 --> 00:03:22,600
通过 N 倍 log 2 N 的一个拓展延伸

80
00:03:22,600 --> 00:03:24,830
归并排序的具体过程

81
00:03:24,830 --> 00:03:27,150
我们以一个实例来看一下

82
00:03:27,150 --> 00:03:28,740
那我们首先呢

83
00:03:28,740 --> 00:03:30,260
对于归并排序

84
00:03:30,260 --> 00:03:32,160
它其实也可以用递归

85
00:03:32,160 --> 00:03:33,110
或者说呢

86
00:03:33,110 --> 00:03:35,460
诶，分治的思想来进行实现的

87
00:03:35,460 --> 00:03:36,980
那我们首先呢

88
00:03:36,980 --> 00:03:40,160
会以两个元素来进行归并

89
00:03:40,160 --> 00:03:42,800
有很多同学都会问了老师哈

90
00:03:42,800 --> 00:03:45,280
万一多了一个元素怎么办呢

91
00:03:45,280 --> 00:03:47,410
唉，三个元素怎么办呢

92
00:03:47,410 --> 00:03:49,460
其实我们在归并的时候

93
00:03:49,460 --> 00:03:52,840
它的目的是让两个元素合并呢

94
00:03:52,840 --> 00:03:53,710
不是吧

95
00:03:53,710 --> 00:03:57,310
我们是为了要让两个数组来进行合并的

96
00:03:57,310 --> 00:03:59,010
所以多了一个元素

97
00:03:59,010 --> 00:04:02,790
我们在后面仍然可以让这个元素来参与

98
00:04:02,790 --> 00:04:04,000
它的归并过程

99
00:04:04,000 --> 00:04:07,700
在这里并没有要求归并排序

100
00:04:07,700 --> 00:04:10,460
一定要是偶数个数值啊

101
00:04:10,460 --> 00:04:11,500
啊

102
00:04:11,830 --> 00:04:15,790
至于涉及到真的有奇数出现吗

103
00:04:15,790 --> 00:04:17,790
其实在我们的考试当中

104
00:04:17,790 --> 00:04:20,440
上五题是不会这样来坑大家的

105
00:04:20,440 --> 00:04:21,980
而在下午题当中

106
00:04:21,980 --> 00:04:24,900
它会有具体的代码来告诉大家

107
00:04:24,900 --> 00:04:28,300
这种数据应该如何来处理的

108
00:04:28,300 --> 00:04:30,090
那我们首先看到呢

109
00:04:30,090 --> 00:04:32,650
诶，两个元素进行归并

110
00:04:32,650 --> 00:04:36,340
那57和68可以直接排序了吧

111
00:04:36,340 --> 00:04:40,940
哎，52、59、72、28、96、33

112
00:04:40,940 --> 00:04:45,290
其实都可以通过归并的方式来进行处理

113
00:04:45,290 --> 00:04:46,980
那处理过后

114
00:04:46,980 --> 00:04:50,460
哎，我们两个元素其实是看不出来的

115
00:04:50,460 --> 00:04:54,310
我们以两两归并来看一看

116
00:04:54,310 --> 00:04:57,630
那这里给了大家两个数组

117
00:04:57,630 --> 00:04:58,630
一个57

118
00:04:58,630 --> 00:05:00,610
一个68

119
00:05:00,810 --> 00:05:05,380
然后下一个数组是52和59

120
00:05:05,380 --> 00:05:10,200
假设我们把它记作 RS 

121
00:05:10,200 --> 00:05:12,940
然后呢，最后给它一个

122
00:05:12,940 --> 00:05:14,800
呃， P 数组吧

123
00:05:14,800 --> 00:05:17,700
那我们在进行归并的过程当中

124
00:05:17,700 --> 00:05:22,610
其实是，诶， RI 与 S 接进行比较

125
00:05:22,610 --> 00:05:25,370
大家都从零开始

126
00:05:25,370 --> 00:05:28,250
二零有没有小于 S 0

127
00:05:28,250 --> 00:05:30,730
220小于 S 0吗

128
00:05:30,730 --> 00:05:33,190
没有， S 阶更小一些

129
00:05:33,190 --> 00:05:37,990
所以接下来 S 0把它放在这个位置

130
00:05:38,360 --> 00:05:39,800
放置之后

131
00:05:39,800 --> 00:05:42,480
说明我们这个数据已经比较过了吧

132
00:05:42,480 --> 00:05:47,280
下一步接加加让数据到达59

133
00:05:47,280 --> 00:05:50,190
59与57进行比较

134
00:05:50,190 --> 00:05:51,170
水比较小

135
00:05:51,170 --> 00:05:52,510
57较小

136
00:05:52,510 --> 00:05:55,250
所以57的数据放在这里

137
00:05:55,250 --> 00:05:56,600
下一步做什么

138
00:05:56,600 --> 00:05:58,220
做 I 加夹

139
00:05:58,220 --> 00:06:02,580
所以此时 I 指针指向了68吧

140
00:06:02,580 --> 00:06:04,490
而我们指向之

141
00:06:04,490 --> 00:06:07,290
68与59进行比较

142
00:06:07,290 --> 00:06:08,170
谁比较小

143
00:06:08,170 --> 00:06:09,680
59较小

144
00:06:09,680 --> 00:06:12,010
数据放置过来之后

145
00:06:12,010 --> 00:06:16,960
哎，我们发现 J 加加溢出边界了吧

146
00:06:16,960 --> 00:06:20,000
我们的截止到一就结束了

147
00:06:20,000 --> 00:06:21,860
所以停止比较

148
00:06:21,860 --> 00:06:23,660
那68怎么办呢

149
00:06:23,660 --> 00:06:27,470
把后面的数据直接复制到

150
00:06:27,470 --> 00:06:29,970
剩余的空间当中来

151
00:06:29,970 --> 00:06:34,510
那此时它就完成了一个归并的过程

152
00:06:34,510 --> 00:06:37,260
同样，哎，后面这一部分

153
00:06:37,260 --> 00:06:39,840
28比33要小

154
00:06:39,840 --> 00:06:45,390
所以 I 加加33比72要小

155
00:06:45,390 --> 00:06:47,450
所以33放过来

156
00:06:47,450 --> 00:06:51,070
接加加72比96要小

157
00:06:51,070 --> 00:06:52,920
72翻过来

158
00:06:52,920 --> 00:06:55,090
I 加加，哎，溢出

159
00:06:55,090 --> 00:06:58,130
将剩下的数据复制过来

160
00:06:58,130 --> 00:07:00,200
这就没有呢比较了

161
00:07:00,200 --> 00:07:04,600
那我们再来看最后两个数组进行合并

162
00:07:05,200 --> 00:07:08,960
同样，52和28比较

163
00:07:08,960 --> 00:07:10,850
28较小

164
00:07:10,850 --> 00:07:14,130
那我们呢，接加加下一个元素

165
00:07:14,130 --> 00:07:16,960
33比52要小

166
00:07:16,960 --> 00:07:20,790
接着接加加72与52比较

167
00:07:20,790 --> 00:07:22,760
52较小

168
00:07:22,760 --> 00:07:24,350
然后 I 加加

169
00:07:24,350 --> 00:07:27,370
57比72小， I 加加

170
00:07:27,370 --> 00:07:30,770
59比72小， I 加加

171
00:07:30,770 --> 00:07:34,010
然后68比72还小

172
00:07:34,010 --> 00:07:34,950
I 加加

173
00:07:34,950 --> 00:07:36,890
那此时加完了吧

174
00:07:36,890 --> 00:07:38,370
溢出边界了

175
00:07:38,370 --> 00:07:42,810
那我们剩下的，剩下的两个元素复制下来

176
00:07:42,810 --> 00:07:44,890
所以这种复制的过程啊

177
00:07:44,890 --> 00:07:47,430
其实才是我们归并排序当中

178
00:07:47,430 --> 00:07:50,190
最省时间的一个部分

179
00:07:50,190 --> 00:07:54,090
那它的整个划分以二分思想为主

180
00:07:54,090 --> 00:07:55,770
是 log 2 N 的

181
00:07:55,770 --> 00:08:01,070
而整个归并的过程是需要有 N 次比较的

182
00:08:01,070 --> 00:08:05,120
所以时间复杂度是 N 倍的， log 2 N 

183
00:08:05,120 --> 00:08:08,500
并且我们需要一个辅助空间来放置

184
00:08:08,500 --> 00:08:11,420
所以空间复杂度是 N 

185
00:08:11,420 --> 00:08:17,110
那它由于归并的过程是可以相邻交换

186
00:08:17,110 --> 00:08:20,200
所以它是稳定的排序过程

187
00:08:20,200 --> 00:08:23,480
这是呢，归并排序它的特点

188
00:08:23,840 --> 00:08:26,500
下面我们来看一下这一部分

189
00:08:26,500 --> 00:08:29,770
在软件设计师考试真题当中的体现

190
00:08:29,770 --> 00:08:31,830
对 N 个数据来排序

191
00:08:31,830 --> 00:08:35,850
最坏情况下时间复杂度最低的是谁

192
00:08:35,850 --> 00:08:38,220
考虑最坏情况啊

193
00:08:38,220 --> 00:08:41,620
插入排序和冒泡排序

194
00:08:41,620 --> 00:08:43,909
他们在最坏情况下

195
00:08:43,909 --> 00:08:47,770
时间复杂度都是大 O 级的 N 平方

196
00:08:47,770 --> 00:08:50,390
插入排序有最优

197
00:08:50,390 --> 00:08:52,810
时间复杂度是大 O 级的 N 吧

198
00:08:52,810 --> 00:08:56,560
我们现在只考虑最坏快速排序

199
00:08:56,560 --> 00:08:59,520
它最坏的情况下是基本有序

200
00:08:59,520 --> 00:09:02,110
时间复杂度为 N 平方

201
00:09:02,110 --> 00:09:03,220
只有谁呢

202
00:09:03,220 --> 00:09:04,920
只有归并排序

203
00:09:04,920 --> 00:09:09,300
它的平均最优和最坏情况都是 N 倍

204
00:09:09,300 --> 00:09:10,380
log 2n 

205
00:09:10,380 --> 00:09:14,580
注意这个时间复杂度是小于 N 平方的

206
00:09:14,580 --> 00:09:16,600
所以只有归并排序

207
00:09:16,600 --> 00:09:21,110
它的时间复杂度是相对来说最低的

208
00:09:21,110 --> 00:09:23,450
要考虑最坏情况

209
00:09:23,450 --> 00:09:24,950
这里呢，注意一下

210
00:09:24,950 --> 00:09:26,920
再来看下面这道题

211
00:09:26,920 --> 00:09:29,400
两个递增序列 A 和 B 

212
00:09:29,400 --> 00:09:31,700
它的长度分别是 M 和 N 

213
00:09:31,700 --> 00:09:32,760
M 小于 N 

214
00:09:32,760 --> 00:09:34,020
并且二者相近

215
00:09:34,020 --> 00:09:39,020
将两将二者啊归并成 M 加 N 的递增序列

216
00:09:39,020 --> 00:09:41,140
二者都是递增的结果

217
00:09:41,140 --> 00:09:42,560
也需要是递增的

218
00:09:42,560 --> 00:09:45,200
那哪一个关系归并的过程，唉

219
00:09:45,200 --> 00:09:46,780
比较次数最少呢

220
00:09:46,780 --> 00:09:50,350
这是对我们规定具体过程的考察吧

221
00:09:50,350 --> 00:09:51,780
那我们简单画一下

222
00:09:51,780 --> 00:09:53,280
对于数组 A 

223
00:09:53,280 --> 00:09:54,920
它有呢，哎

224
00:09:54,920 --> 00:09:59,670
零、一、二、三、四应该是一、二、三到 M 

225
00:09:59,670 --> 00:10:01,970
这是它的元素下标

226
00:10:01,970 --> 00:10:06,710
数组 B 它的元素下标呢是到 N 结束

227
00:10:07,030 --> 00:10:12,950
那首先 A 选项我们有哪些数据是比较放到，哎

228
00:10:12,950 --> 00:10:14,800
假设一个 C 数组吧

229
00:10:14,800 --> 00:10:19,800
C 数组它的最终长度应该是 M 加 N 的

230
00:10:19,800 --> 00:10:24,060
那这些元素的内容哪些是比较放下来的

231
00:10:24,060 --> 00:10:26,420
哪些是复制放下来的

232
00:10:26,420 --> 00:10:28,510
我们在 A 选项来看的话

233
00:10:28,510 --> 00:10:31,480
由由于 am 是结束

234
00:10:31,480 --> 00:10:33,760
到 am 结束之后

235
00:10:33,760 --> 00:10:37,880
剩余的所有的 B 元素全部是复制下来的

236
00:10:37,880 --> 00:10:39,540
所以我们发现呢

237
00:10:39,540 --> 00:10:44,260
唉， B 1会依次与一、二、三、 A 到 M 进行比较

238
00:10:44,260 --> 00:10:46,870
把这 M 个数值放置之后

239
00:10:46,870 --> 00:10:50,140
剩下的元素直接复制下来

240
00:10:50,140 --> 00:10:52,010
所以他比较了多少次啊

241
00:10:52,010 --> 00:10:54,050
应该是 M 次

242
00:10:54,050 --> 00:10:55,190
那这时呢

243
00:10:55,190 --> 00:10:57,600
哎， A 选项它比较的次数

244
00:10:57,600 --> 00:10:59,330
B 选项当中呢

245
00:10:59,330 --> 00:11:03,250
哎，我们首先看到到哪里结束呢

246
00:11:03,250 --> 00:11:05,300
哎，到 N 结束

247
00:11:05,300 --> 00:11:09,100
所以它会呢，通过 N 加加溢出

248
00:11:09,100 --> 00:11:11,760
那此时比较了多少次呢

249
00:11:11,760 --> 00:11:15,830
唉， A 1到 a am 全部是复制下来的

250
00:11:15,830 --> 00:11:20,060
那前面的 N 个元素是比较放下来的

251
00:11:20,060 --> 00:11:22,750
所以它比较了 N 次

252
00:11:22,750 --> 00:11:26,530
那同理，我们再来看 C 选项和 D 选项

253
00:11:26,530 --> 00:11:28,880
显然它是交叉性质的

254
00:11:28,880 --> 00:11:32,120
那这种交叉到什么时候结束呢

255
00:11:32,120 --> 00:11:35,530
同样看边界到 M 之后

256
00:11:35,530 --> 00:11:38,830
就 AM 加加溢出所有元素

257
00:11:38,830 --> 00:11:39,930
后面，哎

258
00:11:39,930 --> 00:11:46,550
从 M 到 N 这个数值范围是复制下来的吧

259
00:11:46,550 --> 00:11:49,650
前面有多少个 B 元素是比较下来的

260
00:11:49,650 --> 00:11:50,050
哎

261
00:11:50,050 --> 00:11:53,020
M 减一有多少个 A 元素

262
00:11:53,020 --> 00:11:55,750
是比较下来的 M 个元素

263
00:11:55,750 --> 00:12:00,810
所以它的比较次数其实是2 M 减一次

264
00:12:00,810 --> 00:12:03,410
那针对 D 选项来看的话

265
00:12:03,410 --> 00:12:06,790
同样我们到什么时候结束呢

266
00:12:06,790 --> 00:12:09,330
哎到 a am 才结束

267
00:12:09,330 --> 00:12:13,200
那前面首先 A 1与 BM ，哎

268
00:12:13,200 --> 00:12:15,910
B 1到 BM 比较了 M 次吧

269
00:12:15,910 --> 00:12:18,560
然后 BM 减一

270
00:12:18,560 --> 00:12:20,220
哎，与 M 加一啊

271
00:12:20,220 --> 00:12:24,800
与我们的 A 1和 AM 之间又比较了 M 4吧

272
00:12:24,800 --> 00:12:29,210
所以这个过程其实是比较了2 M 4

273
00:12:29,660 --> 00:12:35,320
那比较之后从这里开始才是呢，复制下来的吧

274
00:12:35,320 --> 00:12:38,370
所以它的比较次数是2 M 

275
00:12:38,370 --> 00:12:41,060
那这些次数知道之后谁最小

276
00:12:41,060 --> 00:12:43,260
肯定是 M 最小

277
00:12:43,260 --> 00:12:44,780
二者相近嘛

278
00:12:44,780 --> 00:12:47,640
并且 M 是小于 N 的

279
00:12:47,640 --> 00:12:50,700
所以此时只有 A 选项的情况

280
00:12:50,700 --> 00:12:53,180
比较次数是最少的

281
00:12:53,180 --> 00:12:55,380
那这里其实要涉及到的

282
00:12:55,380 --> 00:12:57,660
大家需要了解归并的过程

283
00:12:57,660 --> 00:13:00,330
从而呢才能去解决问题

284
00:13:00,330 --> 00:13:02,930
这些呢，就是要求大家掌握

285
00:13:02,930 --> 00:13:05,090
关于归并排序的内容
