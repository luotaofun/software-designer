1
00:00:00,000 --> 00:00:02,660
下面我们看到插入类排序

2
00:00:02,660 --> 00:00:04,080
插入类排序啊

3
00:00:04,080 --> 00:00:05,480
它在我们考试当中

4
00:00:05,480 --> 00:00:08,370
其实出现的频次还是比较高的

5
00:00:08,370 --> 00:00:10,220
针对插入类排序呢

6
00:00:10,220 --> 00:00:12,120
第一种叫做直接插入

7
00:00:12,120 --> 00:00:14,680
我们一般说直接插入、简单插入

8
00:00:14,680 --> 00:00:16,320
直接选择、简单选择

9
00:00:16,320 --> 00:00:17,410
其实指的呢

10
00:00:17,410 --> 00:00:19,780
都是没有经过性能优化的

11
00:00:19,780 --> 00:00:22,020
插入排序和选择排序

12
00:00:22,020 --> 00:00:23,910
首先看到直接插入啊

13
00:00:23,910 --> 00:00:25,910
它的基本过程是什么呢

14
00:00:25,910 --> 00:00:29,310
它是我们在要插入第 I 个记录的时候啊

15
00:00:29,310 --> 00:00:32,680
会认为前面 I 减一个记录都已经排好了

16
00:00:32,680 --> 00:00:35,640
这个排好的记录就是我们的关键字

17
00:00:35,640 --> 00:00:37,440
关键码或者叫做元素

18
00:00:37,440 --> 00:00:42,110
那我们接下来要插入第2 I 个元素的时候

19
00:00:42,110 --> 00:00:45,580
它会呢依次反向来进行比较

20
00:00:45,580 --> 00:00:49,630
直到找到合适的位置来进行插入

21
00:00:49,630 --> 00:00:52,460
那我们在插入比较的时候

22
00:00:52,460 --> 00:00:57,770
如果与22-1这个数值相等的情况的话

23
00:00:57,770 --> 00:01:00,690
它是不会做交换调整的

24
00:01:00,690 --> 00:01:02,100
这种情况下呢

25
00:01:02,100 --> 00:01:04,480
唉，我们会发现相对位置不变

26
00:01:04,480 --> 00:01:07,610
这是一种稳定的排序方法啊

27
00:01:07,610 --> 00:01:11,700
那我们在排序实现代码的过程当中啊

28
00:01:11,700 --> 00:01:17,110
它会呢，针对每一个元素依次遍历比较一次

29
00:01:17,110 --> 00:01:19,170
所以它的时间复杂度呢

30
00:01:19,170 --> 00:01:21,290
会涉及到循环的过程

31
00:01:21,290 --> 00:01:23,110
并且一般会有呢

32
00:01:23,110 --> 00:01:25,320
两个嵌套循环

33
00:01:25,320 --> 00:01:26,920
一个呢是比较

34
00:01:26,920 --> 00:01:29,530
一个呢，唉，是否需要交换

35
00:01:29,530 --> 00:01:31,000
那这种情况下

36
00:01:31,000 --> 00:01:32,720
它的时间复杂度啊

37
00:01:32,720 --> 00:01:35,550
是大 O 级的 N 平方

38
00:01:35,550 --> 00:01:37,900
那我们在进行交换的时候

39
00:01:37,900 --> 00:01:39,420
进行排序的时候

40
00:01:39,420 --> 00:01:44,660
这个数组元占据的存储空间是不变的

41
00:01:44,660 --> 00:01:49,220
那我们在此之外需要增加一个 temp 

42
00:01:49,660 --> 00:01:51,440
拿来干嘛呢

43
00:01:51,440 --> 00:01:53,160
放置数据元素

44
00:01:53,160 --> 00:01:55,900
以方便我们来做交换

45
00:01:55,900 --> 00:01:57,110
所以它需要一个

46
00:01:57,110 --> 00:01:59,940
元素的辅助空间来进行交换

47
00:01:59,940 --> 00:02:02,480
那此时空间复杂度呢

48
00:02:02,480 --> 00:02:04,200
只有大 O 级的一

49
00:02:04,200 --> 00:02:08,070
这是他的呢，基本情况稍微呢了解一下

50
00:02:08,070 --> 00:02:10,370
那我们对于插入排序啊

51
00:02:10,370 --> 00:02:11,710
它特殊在呢

52
00:02:11,710 --> 00:02:15,060
适用于基本有序的情况下

53
00:02:15,060 --> 00:02:21,060
如果说一个排代排序列它是基本有序的

54
00:02:21,060 --> 00:02:24,360
那么相应的元素在当前位

55
00:02:24,360 --> 00:02:27,090
都是不需要进行交换的

56
00:02:27,090 --> 00:02:29,980
那我们只比较不交换

57
00:02:29,980 --> 00:02:34,720
这种情况他只需要比较 N 次就可以了

58
00:02:34,720 --> 00:02:39,600
此时，唉，它的时间复杂度可以说是近乎线性

59
00:02:39,600 --> 00:02:41,590
也就是大 OGN 的

60
00:02:41,590 --> 00:02:45,490
这是我们插入排序它的特殊情况

61
00:02:45,490 --> 00:02:49,000
接下来我们以一个例子来说明

62
00:02:49,000 --> 00:02:50,830
直接插入它的过程

63
00:02:50,830 --> 00:02:52,970
那首先会给大家一个呢

64
00:02:52,970 --> 00:02:55,170
代排序列或者带牌记录

65
00:02:55,170 --> 00:02:56,630
带牌元素啊

66
00:02:56,630 --> 00:02:59,990
分别是57、68、59和52

67
00:02:59,990 --> 00:03:03,230
那此时其实相当于我们把这些数据啊

68
00:03:03,230 --> 00:03:04,830
放在了一个数组当中

69
00:03:04,830 --> 00:03:07,800
注意这些数组是输入变量

70
00:03:07,800 --> 00:03:11,090
并没有涉及辅助存储空间啊

71
00:03:11,090 --> 00:03:13,450
那我们有了这些数据之后

72
00:03:13,450 --> 00:03:17,410
首先呢，0号是57元素吧

73
00:03:17,410 --> 00:03:20,420
此时它可以直接插入

74
00:03:20,420 --> 00:03:23,240
需不需要跟其他元素进行比较啊

75
00:03:23,240 --> 00:03:24,990
不需要进行比较

76
00:03:24,990 --> 00:03:28,310
所以比较次数是零次

77
00:03:28,310 --> 00:03:32,050
接下来处理一号元素68

78
00:03:32,050 --> 00:03:35,740
它会与0号元素进行比较

79
00:03:35,740 --> 00:03:38,990
比较之后发现它比68呀

80
00:03:38,990 --> 00:03:40,720
比57要大

81
00:03:40,720 --> 00:03:42,270
那我们在这里呢

82
00:03:42,270 --> 00:03:46,530
直接插入在57后面的位置就可以了

83
00:03:46,530 --> 00:03:49,860
其实这里就相当于不做调整

84
00:03:49,860 --> 00:03:53,840
那接下来2号元素59

85
00:03:53,840 --> 00:03:57,240
它会与68进行比较

86
00:03:57,240 --> 00:04:00,340
比较之后比68要小吧

87
00:04:00,340 --> 00:04:04,100
然后呢，再与57进行比较

88
00:04:04,100 --> 00:04:07,150
比较之后比57要大

89
00:04:07,150 --> 00:04:09,390
说明它的位置在哪里啊

90
00:04:09,390 --> 00:04:14,030
它的位置应该在57和68之间

91
00:04:14,030 --> 00:04:17,310
所以我们在这里会将5

92
00:04:17,310 --> 00:04:21,089
插入在相应正确的位置上

93
00:04:21,089 --> 00:04:23,350
那这个插入的过程啊

94
00:04:23,350 --> 00:04:26,310
相当于我们用一个 temp 数组

95
00:04:26,310 --> 00:04:29,680
temp 辅助空间存储了59

96
00:04:29,680 --> 00:04:34,200
然后呢，让它们进行了一个元素的交换过程

97
00:04:34,200 --> 00:04:36,450
那这里虽然说的是交换

98
00:04:36,450 --> 00:04:40,550
但我们的处理过程其实就是插入的过程

99
00:04:40,550 --> 00:04:45,160
让我们的不对的元素啊后移就可以了

100
00:04:45,160 --> 00:04:48,280
这是一个呢，元素后移处理的过程

101
00:04:48,280 --> 00:04:52,880
那我们接着再来看3号元素52

102
00:04:52,880 --> 00:04:57,160
它会与我们的2号元素进行比较

103
00:04:57,160 --> 00:04:59,080
唉，比59要小吧

104
00:04:59,080 --> 00:05:00,600
呃，比68要小

105
00:05:00,600 --> 00:05:02,080
我们这里应该处理过了

106
00:05:02,080 --> 00:05:04,120
这个元素应该是68

107
00:05:04,120 --> 00:05:06,460
这个元素应该是59

108
00:05:06,460 --> 00:05:10,770
这三个元素是处理完成之后的数据

109
00:05:10,770 --> 00:05:13,070
那52并没有处理完

110
00:05:13,070 --> 00:05:16,430
所以它会与68进行比较

111
00:05:16,430 --> 00:05:18,900
在与59进行比较

112
00:05:18,900 --> 00:05:22,200
最后与57进行比较

113
00:05:22,200 --> 00:05:25,050
那此时比这三个数都要小吧

114
00:05:25,050 --> 00:05:29,930
所以此时它会插入在57的前面

115
00:05:29,930 --> 00:05:31,440
怎么插入

116
00:05:31,440 --> 00:05:34,670
用 temp 记录52

117
00:05:34,670 --> 00:05:40,340
然后将前面的零、一、二位置元素全部后移

118
00:05:40,340 --> 00:05:43,230
然后将0号位置空出来

119
00:05:43,230 --> 00:05:45,860
存放52数据就可以了

120
00:05:45,860 --> 00:05:48,090
那这个过程当中，唉

121
00:05:48,090 --> 00:05:51,650
我们把相应的比较次数给大家记下来了吧

122
00:05:51,650 --> 00:05:55,190
那比较之后需不需要调整

123
00:05:55,190 --> 00:05:58,600
我们在这里调整是否需要呢

124
00:05:58,600 --> 00:06:01,020
诶，0号元素不需要

125
00:06:01,020 --> 00:06:02,980
一号元素不需要

126
00:06:02,980 --> 00:06:05,440
2号元素需要

127
00:06:05,570 --> 00:06:08,710
3号元素同样需要调整

128
00:06:08,710 --> 00:06:10,190
所以这个过程啊

129
00:06:10,190 --> 00:06:13,090
就是我们做直接插入的过程

130
00:06:13,090 --> 00:06:17,490
他会把前面的元素当作呢，已经处理完成

131
00:06:17,490 --> 00:06:21,120
然后呢，才会去处理后续元素

132
00:06:21,120 --> 00:06:22,710
那我们以一个呢

133
00:06:22,710 --> 00:06:24,800
基本有序的情况来看

134
00:06:24,800 --> 00:06:27,490
那基本有序指的就是呢

135
00:06:27,490 --> 00:06:29,790
唉，我们要按照递增

136
00:06:29,790 --> 00:06:31,490
非递减顺序来的话

137
00:06:31,490 --> 00:06:35,090
它本身呢，就是按照这种顺序来的

138
00:06:35,280 --> 00:06:37,980
那针对这个序列来看的话

139
00:06:37,980 --> 00:06:39,320
0号位置是谁啊

140
00:06:39,320 --> 00:06:40,500
是52吧

141
00:06:40,500 --> 00:06:44,090
52我们是否需要比较，哎

142
00:06:44,090 --> 00:06:45,250
不需要比较

143
00:06:45,250 --> 00:06:46,860
不需要调整

144
00:06:46,860 --> 00:06:48,130
一号位

145
00:06:48,130 --> 00:06:51,870
57比较一次比52要大

146
00:06:51,870 --> 00:06:54,220
所以插入在52后面

147
00:06:54,220 --> 00:06:56,060
不需要调整

148
00:06:56,060 --> 00:07:00,050
2号位置59比57要大

149
00:07:00,050 --> 00:07:02,550
比较一次就找到了位置吧

150
00:07:02,550 --> 00:07:04,460
插入在57的后面

151
00:07:04,460 --> 00:07:05,810
不需要调整

152
00:07:05,810 --> 00:07:06,890
3号位置

153
00:07:06,890 --> 00:07:09,750
68与59进行比较

154
00:07:09,750 --> 00:07:11,850
比59要大

155
00:07:11,850 --> 00:07:14,480
插入在59的后面，诶

156
00:07:14,480 --> 00:07:15,720
不需要调整

157
00:07:15,720 --> 00:07:19,440
所以会发现在基本有序的情况下

158
00:07:19,440 --> 00:07:22,280
直接插入它是非常简单的

159
00:07:22,280 --> 00:07:26,410
只需要各自比较一次就可以了

160
00:07:26,410 --> 00:07:28,910
那此时它的时间复杂度

161
00:07:28,910 --> 00:07:32,750
只需要大 O 级的 N 近乎线性就行了

162
00:07:32,750 --> 00:07:35,360
这是呢，它特殊的地方

163
00:07:35,360 --> 00:07:36,800
注意一下

164
00:07:37,260 --> 00:07:39,740
那这是呢，直接插入

165
00:07:39,740 --> 00:07:43,860
下面我们来看一个优化之后的插入排序

166
00:07:43,860 --> 00:07:46,270
叫做呢，希尔排序

167
00:07:46,270 --> 00:07:47,770
希尔排序呢

168
00:07:47,770 --> 00:07:50,730
它会先取一个小于 N 的整数

169
00:07:50,730 --> 00:07:54,620
作为第一个增量给记录进行分组

170
00:07:54,620 --> 00:07:56,920
那我们分组之后啊

171
00:07:56,920 --> 00:08:00,950
以它为倍数的同一个记录在一个分组

172
00:08:00,950 --> 00:08:03,790
在分组内进行直接插入

173
00:08:03,790 --> 00:08:06,840
然后呢，重复这个分组的过程

174
00:08:06,840 --> 00:08:09,110
直到呢，唉，增量为一

175
00:08:09,110 --> 00:08:11,630
就是大家在同一组的情况下

176
00:08:11,630 --> 00:08:14,300
进行最后一轮直接插入

177
00:08:14,300 --> 00:08:16,240
那这种方式啊

178
00:08:16,240 --> 00:08:20,390
它其实就是为了将一个无序的代排序列

179
00:08:20,390 --> 00:08:23,830
让它尽可能的先调整为基本有序

180
00:08:23,830 --> 00:08:25,910
再来进行排序

181
00:08:25,910 --> 00:08:29,880
所以它对我们的整个插入排序啊

182
00:08:29,880 --> 00:08:31,450
做了一个优化

183
00:08:31,450 --> 00:08:35,419
那优化之后它是一种不稳定的排序过程

184
00:08:35,419 --> 00:08:38,419
并且它的时间复杂度比较特殊

185
00:08:38,419 --> 00:08:41,120
它在统计分析的结果当中呢

186
00:08:41,120 --> 00:08:44,360
应该是大约等于 N 的1.3次方的

187
00:08:44,360 --> 00:08:47,240
知道有这个时间复杂度就可以了

188
00:08:47,240 --> 00:08:49,160
排序过程仍然呢

189
00:08:49,160 --> 00:08:52,140
只需要一个辅助空间做交换

190
00:08:52,140 --> 00:08:56,880
所以它空间复杂度也是 DAOG 的一

191
00:08:57,560 --> 00:08:59,120
我们下面呢

192
00:08:59,120 --> 00:09:03,330
同样以一个实例来看一下它的排序过程

193
00:09:03,330 --> 00:09:06,430
那针对希尔排序来看的话

194
00:09:06,430 --> 00:09:08,990
首先它会进行分组

195
00:09:08,990 --> 00:09:13,090
对相应的十个元素分组的话会除以二

196
00:09:13,090 --> 00:09:15,770
先分成 A 5个

197
00:09:15,770 --> 00:09:18,830
如何来分相差为五的

198
00:09:18,830 --> 00:09:21,050
哎，比如说我们这里依次记录

199
00:09:21,050 --> 00:09:25,450
零、一、二三、四、五、六、七、八、九

200
00:09:26,020 --> 00:09:29,300
那针对这十个元素相差为五的

201
00:09:29,300 --> 00:09:31,220
零和五作为一组

202
00:09:31,220 --> 00:09:33,350
一和六、二和七

203
00:09:33,350 --> 00:09:37,410
三和八、四和九各自作为一组

204
00:09:37,410 --> 00:09:40,330
那我们针对两个元素做插入排序

205
00:09:40,330 --> 00:09:41,680
就比较简单了吧

206
00:09:41,680 --> 00:09:44,410
那我们现在先把57放在这里

207
00:09:44,410 --> 00:09:46,050
28比57小

208
00:09:46,050 --> 00:09:50,430
所以，唉，插入到57前面的位置上

209
00:09:50,430 --> 00:09:52,670
那28和57

210
00:09:52,670 --> 00:09:56,350
68和我们的96，哎

211
00:09:56,350 --> 00:09:59,160
比较之后不用调整

212
00:09:59,160 --> 00:10:02,370
59和33，哎

213
00:10:02,370 --> 00:10:06,070
需要把33插入在59后面

214
00:10:06,070 --> 00:10:09,480
59前面那调整一下位置

215
00:10:09,480 --> 00:10:12,990
52和24调整位置

216
00:10:12,990 --> 00:10:16,040
19和72调整位置

217
00:10:16,040 --> 00:10:19,290
那这里是每两个元素一组

218
00:10:19,290 --> 00:10:22,600
然后呢，进行插入排序

219
00:10:22,600 --> 00:10:24,760
接下来再来呢

220
00:10:24,760 --> 00:10:27,920
哎，对我们的5÷2

221
00:10:28,690 --> 00:10:33,530
注意，此时的结果是取奇数的，都是

222
00:10:33,530 --> 00:10:36,170
那我们在除的过程当中

223
00:10:36,170 --> 00:10:37,190
结果等于三

224
00:10:37,190 --> 00:10:40,710
那么零和三以及呢

225
00:10:40,710 --> 00:10:44,410
六、九作为同一组数据

226
00:10:44,410 --> 00:10:47,240
一和四以及呢

227
00:10:47,240 --> 00:10:49,690
七作为同一组数据

228
00:10:49,690 --> 00:10:52,530
二和五以及呢

229
00:10:52,530 --> 00:10:56,880
唉，我们的这个八作为同一组数据

230
00:10:56,880 --> 00:10:58,200
分完组之后

231
00:10:58,200 --> 00:11:01,630
同组同样作为插入排序

232
00:11:01,630 --> 00:11:02,580
注意啊

233
00:11:02,580 --> 00:11:04,740
每一轮排序的结果

234
00:11:04,740 --> 00:11:08,600
会作为下一轮排序的初始情况

235
00:11:08,600 --> 00:11:11,010
那首先，28在这里

236
00:11:11,010 --> 00:11:13,450
24与28比较

237
00:11:13,450 --> 00:11:14,910
调整位置，诶

238
00:11:14,910 --> 00:11:16,270
24、28

239
00:11:16,270 --> 00:11:20,380
接下来96与20与28

240
00:11:20,380 --> 00:11:21,340
24比较

241
00:11:21,340 --> 00:11:23,350
哎，这里位置不用交换吧

242
00:11:23,350 --> 00:11:26,680
那我们96是不用交换的，诶

243
00:11:26,680 --> 00:11:29,000
72与它进行对比

244
00:11:29,000 --> 00:11:31,500
然后呢，找到相应的位置

245
00:11:31,500 --> 00:11:33,000
看一看是否要交换

246
00:11:33,000 --> 00:11:34,490
哎，需要交换吧

247
00:11:34,490 --> 00:11:38,980
72它应该是位于24和96之间的

248
00:11:38,980 --> 00:11:42,300
所以插入在96的位置上

249
00:11:42,300 --> 00:11:44,220
把这组数据啊处理完

250
00:11:44,220 --> 00:11:46,860
呃，这里呢，尽量不要提交换

251
00:11:46,860 --> 00:11:49,190
容易呢，让大家产生混淆

252
00:11:49,190 --> 00:11:49,880
注意啊

253
00:11:49,880 --> 00:11:52,000
我们不是交换的过程

254
00:11:52,000 --> 00:11:54,000
而是找到位置之后

255
00:11:54,000 --> 00:11:56,270
将后续元素后移

256
00:11:56,270 --> 00:11:59,180
有这样的一个移动的过程

257
00:11:59,980 --> 00:12:04,020
再来看68、19和59

258
00:12:04,020 --> 00:12:06,160
首先68不变吧

259
00:12:06,160 --> 00:12:08,990
19与68进行比较

260
00:12:08,990 --> 00:12:11,250
应该插入在前面

261
00:12:11,250 --> 00:12:13,950
那59与68比较

262
00:12:13,950 --> 00:12:18,130
应该插入在68和19的中间

263
00:12:18,130 --> 00:12:21,070
最后呢，哎，68的位置

264
00:12:21,070 --> 00:12:23,320
那我们在这里，第三组

265
00:12:23,320 --> 00:12:28,430
33和57以及52进行插入排序

266
00:12:28,430 --> 00:12:30,320
排完序之后

267
00:12:30,320 --> 00:12:33,990
当我们的增量为一的情况下

268
00:12:33,990 --> 00:12:38,970
那就是从头到尾做一次插入排序就可以了

269
00:12:38,970 --> 00:12:43,660
同样呢，相当于我们用一个数组放置

270
00:12:43,660 --> 00:12:46,740
首先呢，唉，这是0号元素吧

271
00:12:46,740 --> 00:12:48,900
接下来跟一号元素比较

272
00:12:48,900 --> 00:12:50,480
一号元素较小

273
00:12:50,480 --> 00:12:54,290
那一号元素应该在零的位置上插入

274
00:12:54,290 --> 00:12:55,550
在零的位置

275
00:12:55,550 --> 00:12:56,690
24呢

276
00:12:56,690 --> 00:13:00,690
后移33与19，哎

277
00:13:00,690 --> 00:13:03,960
33应该与24进行比较

278
00:13:03,960 --> 00:13:05,940
那比较比24大

279
00:13:05,940 --> 00:13:10,160
应该插入在24后面的位置上

280
00:13:10,160 --> 00:13:14,210
28与33比较，比33小

281
00:13:14,210 --> 00:13:15,590
这个时候不确定吧

282
00:13:15,590 --> 00:13:16,950
还要往前面比较

283
00:13:16,950 --> 00:13:20,030
28比24要大

284
00:13:20,030 --> 00:13:24,330
所以插入在33和28之间

285
00:13:24,330 --> 00:13:27,210
应该插入在24的后面吧

286
00:13:27,210 --> 00:13:28,730
那插入之后

287
00:13:28,730 --> 00:13:31,860
原本的33就会呢后移

288
00:13:31,860 --> 00:13:35,820
59与53与33比较

289
00:13:35,820 --> 00:13:40,040
那这个位置呢，可以插入在33的后面

290
00:13:40,040 --> 00:13:42,550
52与59比较

291
00:13:42,550 --> 00:13:44,170
比52要小

292
00:13:44,170 --> 00:13:46,310
比33要大

293
00:13:46,310 --> 00:13:50,090
应该插入在33的后面位置

294
00:13:50,090 --> 00:13:52,400
59后乙

295
00:13:52,400 --> 00:13:54,290
那59、52

296
00:13:54,290 --> 00:13:56,170
接下来72吧

297
00:13:56,170 --> 00:14:00,320
然后呢，依次去进行比较和插入

298
00:14:00,320 --> 00:14:03,930
以及呢，不符数据后移的过程

299
00:14:03,930 --> 00:14:08,370
直到将所有数据进行一次插入排序

300
00:14:08,370 --> 00:14:11,290
那此时最终得到的就是一个呢

301
00:14:11,290 --> 00:14:14,490
完全有序的这个序列了

302
00:14:14,760 --> 00:14:17,960
我们一般提到有序啊，要注意

303
00:14:17,960 --> 00:14:21,720
如果说让大家非递增

304
00:14:24,460 --> 00:14:29,140
也就是说，我们可以有32110

305
00:14:29,140 --> 00:14:32,460
这就是呢，非递增排序

306
00:14:32,460 --> 00:14:34,610
非递减排序

307
00:14:37,820 --> 00:14:39,480
就是呢，唉

308
00:14:39,480 --> 00:14:42,350
01123这种排序

309
00:14:42,350 --> 00:14:43,660
所以注意一下呢

310
00:14:43,660 --> 00:14:47,080
有时候他没有说递增排序或者递减排序啊

311
00:14:47,080 --> 00:14:48,620
而是以非递增

312
00:14:48,620 --> 00:14:50,750
非递减的要求给大家

313
00:14:50,750 --> 00:14:54,400
那我们一般说满足要求的才叫基本有序

314
00:14:54,400 --> 00:14:57,190
反向的情况下不叫有序

315
00:14:57,190 --> 00:14:58,490
一定要搞清楚呢

316
00:14:58,490 --> 00:15:00,280
有这样的一个区别

317
00:15:00,280 --> 00:15:03,680
那我们接下来看一下关于插入类排序

318
00:15:03,680 --> 00:15:06,920
在我们软件设计师考试当中的考察

319
00:15:06,920 --> 00:15:08,560
下面呢，告诉我们

320
00:15:08,560 --> 00:15:12,440
现在需要对一个基本有序的数组进行排序

321
00:15:12,440 --> 00:15:15,220
此时最适合采用的是谁呢

322
00:15:15,220 --> 00:15:18,820
基本有序采用的是插入排序

323
00:15:18,820 --> 00:15:22,030
它的时间复杂度会近乎线性

324
00:15:22,030 --> 00:15:25,080
所以是大 O 级的 N 次方，呃

325
00:15:25,080 --> 00:15:26,080
大 O 级的 N 

326
00:15:26,080 --> 00:15:28,800
那这个其实就是对插入排序

327
00:15:28,800 --> 00:15:31,600
它的特殊情况的考察

328
00:15:31,630 --> 00:15:34,330
下面再来看呢，这一道题

329
00:15:34,330 --> 00:15:36,060
在某个应用当中啊

330
00:15:36,060 --> 00:15:38,720
需要先排序一组大规模的记录

331
00:15:38,720 --> 00:15:40,270
关键字都是整数

332
00:15:40,270 --> 00:15:41,750
并且这些记录啊

333
00:15:41,750 --> 00:15:44,060
它都是呢基本有序的

334
00:15:44,060 --> 00:15:46,290
在基本有序的条件下

335
00:15:46,290 --> 00:15:49,280
选择的都是呢插入排序

336
00:15:49,280 --> 00:15:52,630
那我们若这组关键字啊

337
00:15:52,630 --> 00:15:55,970
取值均在零和九之间

338
00:15:56,150 --> 00:15:59,050
应该采用什么排序呢

339
00:15:59,050 --> 00:16:01,330
很多同学当时看到这里呀

340
00:16:01,330 --> 00:16:04,620
都会呢与后面的奇数排序联系起来

341
00:16:04,620 --> 00:16:07,020
我们这里拓展给大家讲一下

342
00:16:07,020 --> 00:16:09,410
什么是计数排序

343
00:16:09,410 --> 00:16:11,800
那我们现在知道

344
00:16:11,800 --> 00:16:15,230
所有的关键字都在零和九之间吧

345
00:16:15,230 --> 00:16:17,740
那你有1000个关键字

346
00:16:17,740 --> 00:16:21,540
那我们把这1000个关键字进行统计

347
00:16:22,780 --> 00:16:28,090
零一、二、三、四、五、六、七、八、

348
00:16:28,090 --> 00:16:31,400
那各自有十个元素的话

349
00:16:32,040 --> 00:16:35,100
统计相应元素的个数

350
00:16:35,100 --> 00:16:37,120
当元素个数知道了

351
00:16:37,120 --> 00:16:39,420
它的排序结果是不是很明确啊

352
00:16:39,420 --> 00:16:45,120
零个、十个、零、十个一、十个20个、三、十个四

353
00:16:45,120 --> 00:16:47,030
直到十个九吧

354
00:16:47,030 --> 00:16:50,170
这种情况下就是通过统计之后

355
00:16:50,170 --> 00:16:52,150
将关键字进行排序

356
00:16:52,150 --> 00:16:54,330
叫做呢计数排序

357
00:16:54,330 --> 00:16:58,710
所以当数值的个数或者说数值的取值

358
00:16:58,710 --> 00:17:00,740
在有限范围内的时候

359
00:17:00,740 --> 00:17:03,980
我们是可以呢在有限个数的情况下

360
00:17:03,980 --> 00:17:07,280
可以统计个数再来进行排序

361
00:17:07,280 --> 00:17:10,339
这种呢就叫做技术排序

362
00:17:10,339 --> 00:17:13,420
那我们会发现对于插入类排序啊

363
00:17:13,420 --> 00:17:15,780
它的考察主要就集中在

364
00:17:15,780 --> 00:17:18,390
插入排序的过程当中

365
00:17:18,390 --> 00:17:20,260
对于希尔排序

366
00:17:20,260 --> 00:17:23,650
在考试当中涉及到的并不是很多

367
00:17:23,650 --> 00:17:25,740
这是要求大家呢掌握的

368
00:17:25,740 --> 00:17:27,819
关于插入排序的内容
