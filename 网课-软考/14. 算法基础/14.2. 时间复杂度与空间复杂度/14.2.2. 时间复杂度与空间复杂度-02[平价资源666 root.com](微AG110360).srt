1
00:00:00,000 --> 00:00:01,660
N 倍 log 2 N 呢

2
00:00:01,660 --> 00:00:04,340
一方面是我们刚刚讲的 log 2 N 

3
00:00:04,340 --> 00:00:06,220
外层有嵌套循环吧

4
00:00:06,220 --> 00:00:10,090
其次呢，还有典型的排序算法

5
00:00:10,090 --> 00:00:13,870
排序算法当中啊，堆排序

6
00:00:15,380 --> 00:00:19,860
归并排序以及呢快速排

7
00:00:19,860 --> 00:00:23,430
都有可能涉及到这个时间复杂度

8
00:00:23,430 --> 00:00:25,240
所以这个时间复杂度

9
00:00:25,240 --> 00:00:29,010
一般是结合排序算法考的多一些

10
00:00:29,010 --> 00:00:31,600
那对于堆排序来说

11
00:00:31,600 --> 00:00:34,520
它的建堆过程就是构造数

12
00:00:34,520 --> 00:00:35,930
所以是 log 2 N 

13
00:00:35,930 --> 00:00:37,560
并且建堆之后

14
00:00:37,560 --> 00:00:40,000
每一次就会取出唯一的一个

15
00:00:40,000 --> 00:00:42,470
最大值或者最小值的堆顶

16
00:00:42,470 --> 00:00:45,130
所以重建堆取堆顶

17
00:00:45,130 --> 00:00:46,670
见顶取堆

18
00:00:46,670 --> 00:00:48,610
重复循环 N 次

19
00:00:48,610 --> 00:00:51,780
时间复杂度就是 N 倍 log 2 N 

20
00:00:51,780 --> 00:00:54,320
归并排序是二分诶

21
00:00:54,320 --> 00:00:56,930
然后进行二路归并的过程

22
00:00:56,930 --> 00:01:00,180
所以它在进行归并之后啊

23
00:01:00,180 --> 00:01:02,660
里面每一次分割的时候

24
00:01:02,660 --> 00:01:04,510
时间复杂度是 log 2 N 

25
00:01:04,510 --> 00:01:06,920
归并的时候就是 N 层循环

26
00:01:06,920 --> 00:01:10,160
嵌套起来就是 N 倍 log n 了

27
00:01:10,160 --> 00:01:11,720
那这个时间复杂度

28
00:01:11,720 --> 00:01:14,100
我们在后面讲排序算法的时候

29
00:01:14,100 --> 00:01:17,220
大家可以留意一下这个时间复杂度

30
00:01:17,220 --> 00:01:20,250
最后再来看呢，二的 N 次方

31
00:01:20,250 --> 00:01:23,310
这个时间复杂度就比较特殊了

32
00:01:23,310 --> 00:01:27,840
二的 N 次方其实就是2×2乘以多少啊

33
00:01:27,840 --> 00:01:30,160
乘以 N 个二八

34
00:01:30,810 --> 00:01:33,170
那这种情况

35
00:01:35,420 --> 00:01:40,750
它的整个时间复杂度的规模其实会非常大

36
00:01:40,750 --> 00:01:42,700
一般出现在哪里呢

37
00:01:42,700 --> 00:01:46,400
一般出现在我们动态规划法

38
00:01:46,400 --> 00:01:48,700
自顶向下的情况下

39
00:01:48,700 --> 00:01:50,510
那为什么这么说呢

40
00:01:50,510 --> 00:01:54,150
因为我们在做一些问题求解的时候

41
00:01:54,150 --> 00:01:56,550
经常会用划分子问题来求

42
00:01:56,550 --> 00:01:58,370
而划分子问题

43
00:01:58,370 --> 00:02:02,280
它的最好的解决方案是求一个小问题

44
00:02:02,280 --> 00:02:03,640
把答案记下来

45
00:02:03,640 --> 00:02:05,520
第二个小问题查表

46
00:02:05,520 --> 00:02:09,699
从而呢，将整个过程变成循环的过程

47
00:02:09,699 --> 00:02:12,550
而我们的动态规划法

48
00:02:12,550 --> 00:02:14,970
如果自顶向下来求的时候

49
00:02:14,970 --> 00:02:18,220
会发现他求问题等于 NA 

50
00:02:18,220 --> 00:02:21,110
然后需要分解、分解再求取

51
00:02:21,110 --> 00:02:24,960
而中间分解的中间结果完全没有记录

52
00:02:24,960 --> 00:02:27,530
因为我们此时的目标是 N 

53
00:02:27,530 --> 00:02:30,240
接下来才是 N 减一、 N 减二

54
00:02:30,240 --> 00:02:31,930
直到二和一

55
00:02:31,930 --> 00:02:34,560
所以此时二合一到底是多少

56
00:02:34,560 --> 00:02:35,720
他并不知道

57
00:02:35,720 --> 00:02:39,190
那这种反向分析自顶向下唉

58
00:02:39,190 --> 00:02:40,710
就叫做自顶向下

59
00:02:40,710 --> 00:02:44,170
变量从 N 向 E 进行变化

60
00:02:44,170 --> 00:02:47,810
那时间复杂度会有多次的重复求取

61
00:02:47,810 --> 00:02:51,360
所以它的量级一般在二的 N 次方

62
00:02:51,360 --> 00:02:54,130
而最长公共子序列

63
00:02:54,130 --> 00:02:57,500
它会结合子序列来进行分析

64
00:02:57,500 --> 00:03:01,570
我们在讲串的时候提到了子序列吧

65
00:03:01,570 --> 00:03:05,960
子序列指的是在一个字符串当中

66
00:03:05,960 --> 00:03:08,800
取出某一些字符

67
00:03:08,800 --> 00:03:13,270
并且取的时候我们只要保持相对位置

68
00:03:13,270 --> 00:03:14,590
没有发生变化

69
00:03:14,590 --> 00:03:17,340
就是属于上面的子序列了吧

70
00:03:17,340 --> 00:03:18,860
所以我们在这里呢

71
00:03:18,860 --> 00:03:21,870
曾经给大家讲过一个快速的分析方式

72
00:03:21,870 --> 00:03:26,980
我们假设，诶，某一个位置的元素出现了记作一

73
00:03:26,980 --> 00:03:28,950
没出现记作零

74
00:03:28,950 --> 00:03:31,340
那按照这种方式

75
00:03:31,340 --> 00:03:35,740
可以将所有位置的元素是否出现

76
00:03:35,740 --> 00:03:38,750
用一和零分别来进行编码吧

77
00:03:38,750 --> 00:03:41,770
每一个位置有两种可能性

78
00:03:41,770 --> 00:03:44,730
长度为 N ，有多少种可能性啊

79
00:03:44,730 --> 00:03:46,550
就是二的 N 次方

80
00:03:46,550 --> 00:03:49,350
所以这种求子序列的时候

81
00:03:49,350 --> 00:03:50,330
它的个数啊

82
00:03:50,330 --> 00:03:51,750
就是二的 N 次

83
00:03:51,750 --> 00:03:53,860
也有这样的时间量级在

84
00:03:53,860 --> 00:03:55,150
所以我们在这里啊

85
00:03:55,150 --> 00:03:58,490
二的 N 次方其实不要求大家计算了解

86
00:03:58,490 --> 00:04:02,250
它有哪些规模可能会出现就足够了

87
00:04:02,250 --> 00:04:06,980
目前呢，对于考试当中涉及时间复杂度比较，呃

88
00:04:06,980 --> 00:04:08,300
深入的就是呢

89
00:04:08,300 --> 00:04:12,030
利用递归的时间公式来进行求取

90
00:04:12,030 --> 00:04:14,120
但实际上这一类公式

91
00:04:14,120 --> 00:04:16,440
就不会出现在下午题当中了

92
00:04:16,440 --> 00:04:19,899
上午题出现的频率也不会很高

93
00:04:19,899 --> 00:04:23,950
我们后面以例题的形式来进行说明

94
00:04:23,950 --> 00:04:26,240
下面来看一下这一部分

95
00:04:26,240 --> 00:04:29,290
在我们软件设计师考试当中的例题

96
00:04:29,290 --> 00:04:34,660
首先，下面这道题根据渐进分析表达式序列，哎

97
00:04:34,660 --> 00:04:36,640
从低到高排序是谁

98
00:04:36,640 --> 00:04:39,500
这是根据时间复杂度来排序吧

99
00:04:39,500 --> 00:04:42,340
那这个排序当中1000 N 

100
00:04:42,340 --> 00:04:45,520
它的时间量级其实就是 N 

101
00:04:45,520 --> 00:04:49,120
那我们前面给大家介绍到的不等式

102
00:04:49,120 --> 00:04:51,140
比较常规的是什么

103
00:04:51,140 --> 00:04:55,980
log 2 NN 以及二的 N 次方

104
00:04:55,980 --> 00:04:58,880
那我们在这里会看到

105
00:04:58,880 --> 00:05:03,560
log 2 N 乙一定是小于 N 的

106
00:05:03,590 --> 00:05:09,070
其次，我们的二的 N 次方一定是大于 N 的

107
00:05:09,070 --> 00:05:11,070
那剩下的再来看

108
00:05:11,070 --> 00:05:15,030
N 的四次方和 N 的2/3次方

109
00:05:15,030 --> 00:05:18,810
这里其实都是与 N 的 K 次方来比吧

110
00:05:18,810 --> 00:05:23,380
那 N 以及 N 的3/2分之二次方

111
00:05:23,380 --> 00:05:24,680
N 的四次方

112
00:05:24,680 --> 00:05:27,770
这是呢关于 N 的 K 次方排序

113
00:05:27,770 --> 00:05:30,390
找到这些熟悉的规模之后

114
00:05:30,390 --> 00:05:31,390
我们再来看

115
00:05:31,390 --> 00:05:36,360
首先 log 2 N 它一定是小于 N 的

116
00:05:36,360 --> 00:05:38,600
所以 B 它是错误的

117
00:05:38,600 --> 00:05:39,700
然后呢

118
00:05:39,700 --> 00:05:42,180
二的 N 的2/3次方

119
00:05:42,180 --> 00:05:44,880
一定是小于 N 的一次方的

120
00:05:44,880 --> 00:05:47,240
所以它也是错的

121
00:05:47,240 --> 00:05:50,520
那我们排除错误选项之后

122
00:05:50,520 --> 00:05:53,720
正确答案就只有 D 选项了吧

123
00:05:53,720 --> 00:05:56,850
那 N 的2/3次方小于 N 

124
00:05:56,850 --> 00:05:59,220
log 2 N 也小于 N 

125
00:05:59,220 --> 00:06:01,060
在这个过程当中

126
00:06:01,060 --> 00:06:04,040
AN 的四次方是大于 N 的

127
00:06:04,040 --> 00:06:05,900
其他规模当中

128
00:06:05,900 --> 00:06:09,410
N 的阶乘表示 N 乘以 N 减一

129
00:06:09,410 --> 00:06:11,480
N 减二直到乘以一

130
00:06:11,480 --> 00:06:14,950
那这里呢，就是它的最大的规模了

131
00:06:14,950 --> 00:06:17,210
那这个规模比我们前面讲的

132
00:06:17,210 --> 00:06:18,930
二的 N 次方更大

133
00:06:18,930 --> 00:06:21,070
但是它具体是什么样的特点

134
00:06:21,070 --> 00:06:23,210
其实就没有要求大家掌握了吧

135
00:06:23,210 --> 00:06:27,510
这道题就是对时间复杂度不等式的考察

136
00:06:28,640 --> 00:06:30,640
下面这道题

137
00:06:30,640 --> 00:06:35,470
已知算法 A 的时间复杂度函数啊，是 tn 

138
00:06:35,470 --> 00:06:40,690
然后等于八倍的 T 2分之 N 加上呢， N 平方

139
00:06:40,690 --> 00:06:45,750
那其中 N 表示的应该是呢，问题的规模

140
00:06:45,750 --> 00:06:49,200
整个算法的时间复杂度是多少呢

141
00:06:49,200 --> 00:06:52,240
已知另外呢，已知算法 B 啊

142
00:06:52,240 --> 00:06:56,630
它的运行时间函数是 X 乘以 T 的

143
00:06:56,630 --> 00:06:58,660
四分之 N 加 N 平方

144
00:06:58,660 --> 00:07:01,760
那其中 N 呢，表示问题的规模

145
00:07:01,760 --> 00:07:03,690
对充分大的 N 

146
00:07:03,690 --> 00:07:05,610
若要 B 比 A 快

147
00:07:05,610 --> 00:07:08,680
那我们的 X 最大值是多少

148
00:07:08,680 --> 00:07:15,110
那这里涉及到 A 乘以 T 1的 N 除以 B 

149
00:07:15,110 --> 00:07:17,190
这样的时间规模

150
00:07:17,190 --> 00:07:19,030
其实就是递归式

151
00:07:19,030 --> 00:07:21,240
它的时间递归式

152
00:07:21,240 --> 00:07:23,780
那我们一般可以通过呢

153
00:07:23,780 --> 00:07:25,840
举例假设法去求

154
00:07:25,840 --> 00:07:28,990
然后呢，还可以就是代入法去求

155
00:07:28,990 --> 00:07:31,670
还有呢，涉及到递归数去求

156
00:07:31,670 --> 00:07:34,340
显然，呃，都是非常麻烦的吧

157
00:07:34,340 --> 00:07:39,060
我们在这里只给大家介绍一种叫做呢，主定理

158
00:07:40,060 --> 00:07:43,560
主定理只考它的规律

159
00:07:43,560 --> 00:07:46,840
那这种主定理就限定于呢

160
00:07:46,840 --> 00:07:50,890
A 乘以 T 的 N 除以 B 次方啊

161
00:07:50,890 --> 00:07:52,650
B 分之 N 这样的参数

162
00:07:52,650 --> 00:07:53,740
这种形式

163
00:07:53,740 --> 00:07:58,270
对于 N 减一这种形式下是不能用主定理

164
00:07:58,270 --> 00:08:00,630
只能代入分析的

165
00:08:03,620 --> 00:08:05,200
我们可以啊

166
00:08:05,200 --> 00:08:07,620
下面这个问题可以依次带入

167
00:08:07,620 --> 00:08:11,880
NN 减一、 N 减1-1、 N 减1-1

168
00:08:11,880 --> 00:08:12,700
再减一

169
00:08:12,700 --> 00:08:16,130
以这种形式再反向进行计算的

170
00:08:16,130 --> 00:08:18,520
那我们先来看这道题当中

171
00:08:18,520 --> 00:08:19,630
给大家呢

172
00:08:19,630 --> 00:08:20,700
唉，这个问题啊

173
00:08:20,700 --> 00:08:24,240
我们在这里就不再去给大家进行说明了

174
00:08:24,240 --> 00:08:27,960
主要呢，给大家讲一下主定理的部分

175
00:08:28,430 --> 00:08:31,130
那针对主定理来看的话

176
00:08:31,130 --> 00:08:33,570
它所针对的是这种形式吧

177
00:08:33,570 --> 00:08:35,630
在这个形式当中

178
00:08:35,630 --> 00:08:36,770
我们说呢

179
00:08:36,770 --> 00:08:40,250
A 和 B 它都是呢，大于等于一

180
00:08:40,250 --> 00:08:41,669
A 大于等于一

181
00:08:41,669 --> 00:08:44,390
B 大于一是长数

182
00:08:44,390 --> 00:08:47,650
FN 呢，是它后面的参数

183
00:08:47,650 --> 00:08:51,280
那我们针对这样的 FN 函数

184
00:08:51,280 --> 00:08:53,500
在这里就是 N 平方

185
00:08:53,500 --> 00:08:57,030
A 的话是等于八的

186
00:08:57,190 --> 00:09:00,380
B 的话是等于二的

187
00:09:00,380 --> 00:09:02,140
那我们在这里呢

188
00:09:02,140 --> 00:09:03,960
哎，可以进行分析

189
00:09:03,960 --> 00:09:05,980
一共有三种情况

190
00:09:05,980 --> 00:09:06,620
注意啊

191
00:09:06,620 --> 00:09:11,050
主定理只有三种情况判断 FN 

192
00:09:11,050 --> 00:09:16,710
那 FN 如果是等于 N 平方的话

193
00:09:16,710 --> 00:09:21,610
显然它是满足 log 以 B 为底

194
00:09:21,610 --> 00:09:22,710
A 的对数

195
00:09:22,710 --> 00:09:24,090
以二为底

196
00:09:24,090 --> 00:09:26,380
八的对数它是等于三的

197
00:09:26,380 --> 00:09:30,620
那我们看一看 N 的三次方和 FN 谁大呀

198
00:09:30,620 --> 00:09:34,840
应该是 FN 要小于 N 的三次方

199
00:09:34,840 --> 00:09:36,620
所以这是呢，诶

200
00:09:36,620 --> 00:09:38,440
小于的情况

201
00:09:38,440 --> 00:09:41,190
应该是呢，满足第一种情况的

202
00:09:41,190 --> 00:09:43,480
那第一种情况当中啊

203
00:09:43,480 --> 00:09:45,220
它的时间复杂度

204
00:09:45,220 --> 00:09:47,760
我们现在把所有的这种符号啊

205
00:09:47,760 --> 00:09:51,130
看作呢，都看作大 O 来进行理解

206
00:09:51,130 --> 00:09:53,010
那我们现在发现，诶

207
00:09:53,010 --> 00:09:55,150
他小于这个数值

208
00:09:55,150 --> 00:09:59,470
但它可以等于这个数值减去一个常量吧

209
00:09:59,470 --> 00:10:00,990
这个常量是多少

210
00:10:00,990 --> 00:10:03,630
3-1=2

211
00:10:03,630 --> 00:10:08,780
所以这里这个符号应该是等于一的

212
00:10:08,780 --> 00:10:12,070
那我们求出来了这个参数之后

213
00:10:12,070 --> 00:10:16,120
那我们最终满足的整体时间复杂度

214
00:10:16,120 --> 00:10:17,240
它就是呢

215
00:10:17,240 --> 00:10:21,580
诶，等与我们渐进的 N 的 log ba 的

216
00:10:21,580 --> 00:10:24,590
那这种情况下 log ba 是多少啊

217
00:10:24,590 --> 00:10:27,490
应该是 N 的三次方吧

218
00:10:27,490 --> 00:10:29,830
所以对于第一问

219
00:10:29,830 --> 00:10:31,630
我们算法 A 

220
00:10:31,630 --> 00:10:35,420
它的时间复杂度应该是 N 的三次方

221
00:10:35,420 --> 00:10:36,450
怎么来的

222
00:10:36,450 --> 00:10:39,990
先求 log ba ，以 log ba 

223
00:10:39,990 --> 00:10:44,110
然后呢， N 的 log ba 次方与 FN 进行比较

224
00:10:44,110 --> 00:10:48,060
选择满足哪一种情况再来进行分析

225
00:10:48,060 --> 00:10:51,270
那再来看第二个填空当中

226
00:10:51,270 --> 00:10:53,350
对于算法 B 

227
00:10:53,350 --> 00:10:56,120
它的 A 是等于 X 的

228
00:10:56,120 --> 00:10:58,680
它的 B 是等于四的

229
00:10:58,680 --> 00:11:01,180
那 log 以 B 为底

230
00:11:01,180 --> 00:11:03,130
AX 的对数

231
00:11:03,130 --> 00:11:05,250
那现在是多少呢

232
00:11:05,250 --> 00:11:10,580
唉，此时我们 N 的平方是等于 FN 

233
00:11:10,580 --> 00:11:12,680
是等于 N 的平方的吧

234
00:11:12,910 --> 00:11:17,570
那二者之间又满足什么样的关系呢

235
00:11:17,570 --> 00:11:19,380
其实现在还不知道吧

236
00:11:19,380 --> 00:11:23,560
但是我们在题目当中后面给了一个条件

237
00:11:23,560 --> 00:11:24,970
什么样的条件呢

238
00:11:24,970 --> 00:11:29,070
我们要求算法 B 比 A 要快

239
00:11:29,070 --> 00:11:31,750
从时间复杂度来看

240
00:11:31,750 --> 00:11:34,220
N 比较快还是 N 平方比较快

241
00:11:34,220 --> 00:11:37,280
或者说一比较快还是 N 比较快啊

242
00:11:37,280 --> 00:11:40,500
肯定是量级越小越快

243
00:11:40,500 --> 00:11:43,800
所以最终这个时间量级呀

244
00:11:43,800 --> 00:11:49,120
他应该是要小于 N 的三次方

245
00:11:49,120 --> 00:11:52,290
也就是上面的这个时间量级吧

246
00:11:52,290 --> 00:11:56,310
那如何分析它的小鱼情况呢

247
00:11:56,310 --> 00:12:00,500
唉，如果说满足第一种情况下

248
00:12:00,500 --> 00:12:05,510
那我们刚好等于三肯定是不够的

249
00:12:05,510 --> 00:12:08,490
我们至少呢是小于三的

250
00:12:08,490 --> 00:12:11,210
如果要小于三

251
00:12:13,680 --> 00:12:19,200
那 X 应该是小于64的

252
00:12:19,540 --> 00:12:21,520
为什么小于64

253
00:12:21,520 --> 00:12:23,960
因为 log 以 B 为底

254
00:12:23,960 --> 00:12:26,860
X 的对数是小于三的

255
00:12:26,860 --> 00:12:28,340
根据这个来源

256
00:12:28,340 --> 00:12:30,340
当 X 等于64

257
00:12:30,340 --> 00:12:31,600
结果等于三

258
00:12:31,600 --> 00:12:34,720
所以 X 应该是小于64

259
00:12:34,720 --> 00:12:38,050
他应该呢选择的是 C 选项

260
00:12:38,050 --> 00:12:41,980
那如果是第二个填空当中来看的话

261
00:12:41,980 --> 00:12:45,460
其实如果满足第二种情况

262
00:12:45,460 --> 00:12:46,620
我们就会发现

263
00:12:46,620 --> 00:12:50,380
这个时间量级好像不太好去比较了吧

264
00:12:50,380 --> 00:12:55,960
那它至少应该是等于 N 的平方乘以 log n 的

265
00:12:55,960 --> 00:12:59,900
这种情况才会小于 N 的三次方

266
00:12:59,900 --> 00:13:01,970
那此时我们看一看

267
00:13:01,970 --> 00:13:04,690
要想小于 N 平方

268
00:13:04,690 --> 00:13:08,810
那 log b a 应该是等于二的

269
00:13:09,390 --> 00:13:11,820
B 是等于四

270
00:13:11,820 --> 00:13:15,220
而 A 的话应该是等于16

271
00:13:15,220 --> 00:13:17,980
也就是 X 应该是小于16

272
00:13:17,980 --> 00:13:19,490
可以取15吧

273
00:13:19,490 --> 00:13:21,660
这里也符合答案

274
00:13:21,660 --> 00:13:24,660
那我们会发现，诶，15也可以

275
00:13:24,660 --> 00:13:26,470
64也可以

276
00:13:26,470 --> 00:13:28,560
为什么我们选择了 C 选

277
00:13:28,560 --> 00:13:30,100
而不是 A 选项呢

278
00:13:30,100 --> 00:13:34,580
唉，在这里我们要求的是 X 的最大值

279
00:13:34,580 --> 00:13:37,750
所以既然15也可以的话

280
00:13:37,750 --> 00:13:39,670
63也可以

281
00:13:39,670 --> 00:13:40,850
它的值更大

282
00:13:40,850 --> 00:13:44,700
所以选择的仍然是 C 选项

283
00:13:44,700 --> 00:13:47,490
那我们下面的这种算法当中

284
00:13:47,490 --> 00:13:50,080
第三种情况来看的话

285
00:13:50,080 --> 00:13:53,680
那有没有可能满足第三种情况啊

286
00:13:53,680 --> 00:13:56,260
如果满足第三种情况

287
00:13:56,260 --> 00:13:58,460
它的时间复杂度就是呢

288
00:13:58,460 --> 00:14:02,370
N 平方同样是满足小于 N 3次方的

289
00:14:02,370 --> 00:14:04,830
但此时我们会发现，唉

290
00:14:04,830 --> 00:14:08,750
我们只有大于 log 2 NA 

291
00:14:08,750 --> 00:14:10,370
N 的 log 以 B 为底

292
00:14:10,370 --> 00:14:11,620
A 的层面

293
00:14:11,620 --> 00:14:15,700
这种形式才能够有这种结果存在吧

294
00:14:15,700 --> 00:14:18,680
那我们满足这种形式的情况下

295
00:14:18,680 --> 00:14:22,740
这个数值已经让 FN 大于它了

296
00:14:22,740 --> 00:14:25,820
所以 N 的 log 以 B 为底

297
00:14:25,820 --> 00:14:30,280
A 的对数这个数值是小于二的

298
00:14:30,280 --> 00:14:32,810
那它小于二的情况下

299
00:14:32,810 --> 00:14:35,750
加上一个数值作为 FN 

300
00:14:35,750 --> 00:14:39,120
那我们在这里会发现能不能小于二呢

301
00:14:39,120 --> 00:14:41,520
如果要求它小于二

302
00:14:41,520 --> 00:14:45,380
A 的 B 的数值已经确定是四了吧

303
00:14:45,380 --> 00:14:49,240
而我们 A 的数值只能够确定

304
00:14:49,240 --> 00:14:51,740
它仍然是小于15

305
00:14:51,740 --> 00:14:54,240
15的应该是小于16

306
00:14:54,240 --> 00:14:56,100
取值应该是15吧

307
00:14:56,100 --> 00:14:58,070
所以这样分析来看的话

308
00:14:58,070 --> 00:15:02,010
我们能够得到的参数只有15和63

309
00:15:02,010 --> 00:15:04,710
其中最大值是63

310
00:15:04,710 --> 00:15:05,980
那综合来看

311
00:15:05,980 --> 00:15:08,540
这种问题其实相对来说比较复杂

312
00:15:08,540 --> 00:15:10,760
而我们需要掌握什么呢

313
00:15:10,760 --> 00:15:13,460
只需要了解一下主定理

314
00:15:13,460 --> 00:15:17,500
它的分析方式给了大家相应参数之后

315
00:15:17,500 --> 00:15:19,480
找到 A 是谁

316
00:15:19,480 --> 00:15:20,500
B 是谁

317
00:15:20,500 --> 00:15:23,650
从而求出 log ba 

318
00:15:23,650 --> 00:15:26,340
然后呢，唉，还有 FN 

319
00:15:26,340 --> 00:15:28,070
把它呢记录下来

320
00:15:28,070 --> 00:15:33,390
找到 log b a 之后判断 log b a 

321
00:15:34,130 --> 00:15:39,240
与 FN 它的关

322
00:15:39,240 --> 00:15:43,050
大于等于还是小于

323
00:15:43,050 --> 00:15:45,160
如果是大于

324
00:15:45,160 --> 00:15:48,840
它就是能诶，我们的第一种情况

325
00:15:48,840 --> 00:15:52,210
小于就是第三种情况

326
00:15:52,210 --> 00:15:54,380
等于就是第二种情况

327
00:15:54,380 --> 00:15:57,140
判断出相应情况之后

328
00:15:57,140 --> 00:16:01,090
依次找到它的相应的其他参数

329
00:16:01,090 --> 00:16:04,270
比如说这里的 theta 到底是谁

330
00:16:04,270 --> 00:16:08,770
然后呢，判断出它的时间复杂度

331
00:16:13,480 --> 00:16:16,400
所以这道题呀，看起来很复杂

332
00:16:16,400 --> 00:16:19,260
但它呢，更多的是记忆性质的东西

333
00:16:19,260 --> 00:16:21,140
了解三种情况

334
00:16:21,140 --> 00:16:23,050
它的时间复杂度、类型

335
00:16:23,050 --> 00:16:27,000
从而呢，代入进行分析就可以了

336
00:16:27,000 --> 00:16:28,850
那如果记不住的话

337
00:16:28,850 --> 00:16:30,670
可以做题呢，巩固一下

338
00:16:30,670 --> 00:16:34,350
当然，这种题型在我们考试当中多不多呢

339
00:16:34,350 --> 00:16:35,990
并不是特别多啊

340
00:16:35,990 --> 00:16:39,570
在我们综合十次的考察情况来看的话

341
00:16:39,570 --> 00:16:42,280
大约呢，是出现了一到两次

342
00:16:42,280 --> 00:16:46,570
所以呢，这种题型我们主要是介绍让大家了解

343
00:16:46,570 --> 00:16:49,760
但并没有要求大家来掌握

344
00:16:49,760 --> 00:16:50,730
那这是呢

345
00:16:50,730 --> 00:16:53,070
关于主定理它的应用

346
00:16:53,070 --> 00:16:55,390
最后看一下时间复杂度

347
00:16:55,390 --> 00:16:58,570
综合运用情景的分析

348
00:16:58,820 --> 00:17:00,700
下面告诉我们呢

349
00:17:00,700 --> 00:17:03,320
求解两个长度为 N 的序列

350
00:17:03,320 --> 00:17:04,500
X 和 Y 

351
00:17:04,500 --> 00:17:07,710
那它们的一个最长公共子序列

352
00:17:07,710 --> 00:17:08,740
那比如说呢

353
00:17:08,740 --> 00:17:11,160
其中 B 、 C 、 B 、 A 是这两个，哎

354
00:17:11,160 --> 00:17:12,900
序列当中的公共子序列

355
00:17:12,900 --> 00:17:15,200
并且要求是最长的吧

356
00:17:15,200 --> 00:17:18,170
那我们可以采用多种计算方法

357
00:17:18,170 --> 00:17:20,680
比如呢，可以采用蛮力法

358
00:17:20,680 --> 00:17:24,099
这种就是典型的对算法进行描述了

359
00:17:24,099 --> 00:17:25,910
用自然语言来描述

360
00:17:25,910 --> 00:17:30,570
那对 X 的每一个子序列来判断

361
00:17:30,570 --> 00:17:33,680
是否也是 Y 的子序列

362
00:17:33,680 --> 00:17:35,840
如果要写代码的话

363
00:17:35,840 --> 00:17:40,980
显然我们要查找 X 子序列函数

364
00:17:41,180 --> 00:17:44,850
那它的子序列查找需要查多少次啊

365
00:17:44,850 --> 00:17:48,060
我们说长度为 N 的情况下

366
00:17:48,060 --> 00:17:51,820
子序列个数有二的 N 次方个吧

367
00:17:51,820 --> 00:17:54,050
所以它的这个函数啊

368
00:17:54,050 --> 00:17:57,010
会重复执行二的 N 次方

369
00:17:57,010 --> 00:17:59,940
那找到二的 N 次方之后

370
00:17:59,940 --> 00:18:03,930
下面唉，把每一次判断的结

371
00:18:03,930 --> 00:18:04,970
判断呢

372
00:18:04,970 --> 00:18:08,890
哎，每一次子序列的结果与 Y 进行判断

373
00:18:08,890 --> 00:18:11,790
是否是 Y 的子序列

374
00:18:12,520 --> 00:18:15,900
是我们就把它留下来

375
00:18:15,900 --> 00:18:17,810
不是就跳出去了吧

376
00:18:17,810 --> 00:18:19,870
所以在这个过程当中

377
00:18:19,870 --> 00:18:23,310
我们会发现它有两层嵌套过程

378
00:18:23,310 --> 00:18:27,120
以一层呢，是判断 X 的子序列有哪些

379
00:18:27,120 --> 00:18:30,680
另一层是判断提出来的子序列

380
00:18:30,680 --> 00:18:33,900
与 Y 是否满足子序列的关系

381
00:18:33,900 --> 00:18:35,720
那这种情况下

382
00:18:35,720 --> 00:18:37,880
它的时间复杂度是多少呢

383
00:18:37,880 --> 00:18:42,820
哎，包括二的 N 次方以及它的 N 层嵌套

384
00:18:42,820 --> 00:18:44,830
所以这里啊，应该是 N 

385
00:18:44,830 --> 00:18:46,130
二的 N 次方

386
00:18:46,130 --> 00:18:49,190
作为它的时间复杂度量级

387
00:18:49,190 --> 00:18:52,360
那经分析可以发现呢

388
00:18:52,360 --> 00:18:55,050
这个问题具有最优子结构

389
00:18:55,050 --> 00:18:57,190
一般提到最优子结构啊

390
00:18:57,190 --> 00:19:00,080
是贪心法和动态规划法的描述

391
00:19:00,080 --> 00:19:03,050
而下面给了我们一个呢

392
00:19:03,050 --> 00:19:05,800
呃， CIIJ 的数组来记录

393
00:19:05,800 --> 00:19:08,630
有数组记录中间结果

394
00:19:08,630 --> 00:19:10,470
还有递归式的表示

395
00:19:10,470 --> 00:19:15,050
显然这里采用了动态规划法来实现

396
00:19:17,060 --> 00:19:21,740
那我们在动态规划法实现的过程当中

397
00:19:21,740 --> 00:19:26,610
其实就是用代码来计算这个表达式，诶

398
00:19:26,610 --> 00:19:27,730
数组当中啊

399
00:19:27,730 --> 00:19:29,660
每一个元素的数值

400
00:19:29,660 --> 00:19:33,120
现在告诉我们采用自底向上来求

401
00:19:33,120 --> 00:19:36,700
也就是说变量从零开始分析

402
00:19:36,700 --> 00:19:38,720
直到 N 结束

403
00:19:38,720 --> 00:19:42,890
那此时我们要对这个二维数组进行填空吧

404
00:19:42,890 --> 00:19:45,510
二维数组的填空需要

405
00:19:45,510 --> 00:19:46,970
诶，几维的

406
00:19:46,970 --> 00:19:49,410
二维的需要几层循环啊

407
00:19:49,410 --> 00:19:52,250
至少两层嵌套循环

408
00:19:52,250 --> 00:19:55,290
所以它的时间复杂度应该呢

409
00:19:55,290 --> 00:19:57,800
是大 O 级的 N 平方

410
00:19:57,800 --> 00:19:59,720
我们也可以理解为

411
00:19:59,720 --> 00:20:02,660
在填写相应数值的时候

412
00:20:02,660 --> 00:20:06,310
我们至少也要有两层嵌套 for 循环

413
00:20:06,310 --> 00:20:10,360
对 I 和 J 分别进行取值

414
00:20:10,360 --> 00:20:13,540
那这就是我们提到的关于呢

415
00:20:13,540 --> 00:20:17,220
唉，我们的公共子序列求解的问题

416
00:20:17,220 --> 00:20:19,760
其实就是给了大家一个算法描述

417
00:20:19,760 --> 00:20:21,580
让大家根据描

418
00:20:21,580 --> 00:20:22,440
或者呢

419
00:20:22,440 --> 00:20:27,570
根据这种递归式来判断时间复杂度的结果

420
00:20:27,570 --> 00:20:32,490
那时间复杂度更多的还是呢，会结合代码

421
00:20:32,490 --> 00:20:36,880
或者结合我们的查找排序算法来考大家

422
00:20:36,880 --> 00:20:39,500
那这里的例题相对来说呢

423
00:20:39,500 --> 00:20:42,140
考的频率并不是特别高

424
00:20:42,140 --> 00:20:45,450
单纯考时间复杂度的题目不是很多

425
00:20:45,450 --> 00:20:48,270
那这就是要求大家掌握的

426
00:20:48,270 --> 00:20:50,920
关于时间复杂度内容

427
00:20:50,920 --> 00:20:52,410
呃，也希望大家呢

428
00:20:52,410 --> 00:20:53,690
通过这几个例题啊

429
00:20:53,690 --> 00:20:55,690
可以熟悉一下相应问题

430
00:20:55,690 --> 00:20:56,970
他的分析思路
