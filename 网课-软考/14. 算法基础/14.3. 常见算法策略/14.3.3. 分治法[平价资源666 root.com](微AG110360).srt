1
00:00:00,000 --> 00:00:03,760
接下来我们看到分治法它的算法策略

2
00:00:03,760 --> 00:00:06,040
那针对分治法的特点呢

3
00:00:06,040 --> 00:00:08,860
就是将问题啊，划分成一些子问题

4
00:00:08,860 --> 00:00:11,000
那划分过程当中呢

5
00:00:11,000 --> 00:00:12,500
它有分解

6
00:00:12,500 --> 00:00:15,620
然后呢，解决和合并的过程

7
00:00:15,620 --> 00:00:19,320
那针对分制法在我们软件设计师考试当中

8
00:00:19,320 --> 00:00:20,960
考察的非常局限

9
00:00:20,960 --> 00:00:23,880
只会涉及到把问题二分

10
00:00:23,880 --> 00:00:26,340
包括二分查找、归并、排序

11
00:00:26,340 --> 00:00:30,020
还有呢，快速排序它的这种啊，引用

12
00:00:30,020 --> 00:00:32,659
那分治法它的基本思想啊

13
00:00:32,659 --> 00:00:36,590
由于一个问题规模为 N 的时候太大了不好求

14
00:00:36,590 --> 00:00:40,870
所以我们呢，唉，如果说规模小的时候容易求

15
00:00:40,870 --> 00:00:42,170
那我们就可以呢

16
00:00:42,170 --> 00:00:45,620
先减简单的去计算较小规模的解

17
00:00:45,620 --> 00:00:47,920
然后呢，将这些解啊

18
00:00:47,920 --> 00:00:50,400
进行处理之后进行合并

19
00:00:50,400 --> 00:00:53,200
从而得出呢，最终问题的解

20
00:00:53,200 --> 00:00:54,670
那我们主要呢

21
00:00:54,670 --> 00:00:58,750
了解我们二分查找、归并、排序和快速排

22
00:00:58,750 --> 00:01:00,230
它的算法应用

23
00:01:00,230 --> 00:01:02,070
那针对分治法的话

24
00:01:02,070 --> 00:01:05,110
它一定会用到递归的技术

25
00:01:05,110 --> 00:01:06,560
什么是递归啊

26
00:01:06,560 --> 00:01:09,300
递归就是呢，自己调用自己

27
00:01:09,300 --> 00:01:11,480
我们在函数调用的过程当中

28
00:01:11,480 --> 00:01:14,570
递归一般呢，也会用栈来实现啊

29
00:01:14,570 --> 00:01:17,150
那我们下面简单看一个例子

30
00:01:17,150 --> 00:01:19,810
给了我们一个呢，斐波拉契数列

31
00:01:19,810 --> 00:01:21,260
斐波拉契数列啊

32
00:01:21,260 --> 00:01:22,300
它是什么呢

33
00:01:22,300 --> 00:01:25,380
它是属于 FN 

34
00:01:25,590 --> 00:01:28,130
F 0等于一

35
00:01:28,130 --> 00:01:30,910
F 1等于一

36
00:01:31,180 --> 00:01:34,180
FN 等于 F 

37
00:01:34,180 --> 00:01:37,980
N 减一加上 FN 减二

38
00:01:38,020 --> 00:01:41,950
这就是呢，斐波拉切数列它的表示形式

39
00:01:41,950 --> 00:01:43,930
而针对菲布拉切数列

40
00:01:43,930 --> 00:01:45,790
可以用分治法来解决

41
00:01:45,790 --> 00:01:48,850
也可以用动态规划法来解决

42
00:01:48,850 --> 00:01:53,170
这里呢，主要是让大家了解到什么是递归

43
00:01:53,170 --> 00:01:57,460
我们会发现 FN 是我们的函数目标吧

44
00:01:57,460 --> 00:02:02,340
但它的组成会由 FN 减一、 N 减二相加

45
00:02:02,340 --> 00:02:05,650
那大家都是 F ，用 F 来

46
00:02:05,650 --> 00:02:07,330
F 其实就是递归

47
00:02:07,330 --> 00:02:10,120
也就是用自己来调用自己

48
00:02:10,120 --> 00:02:12,470
那我们在定义的过程当中

49
00:02:12,470 --> 00:02:14,430
N 等于零就返回一

50
00:02:14,430 --> 00:02:16,730
N 等于一也返回一

51
00:02:16,730 --> 00:02:19,410
如果 N 大于一的情况下

52
00:02:19,410 --> 00:02:22,730
返回 N 减一加上 N 减二

53
00:02:22,730 --> 00:02:24,390
那这个递归的规模

54
00:02:24,390 --> 00:02:25,470
我们就会发

55
00:02:25,470 --> 00:02:27,970
原本的问题规模是 N 吧

56
00:02:28,200 --> 00:02:32,160
现在变成了 N 减一加 N 减二

57
00:02:32,160 --> 00:02:34,520
那 N 减一不知道怎么办

58
00:02:34,520 --> 00:02:36,360
求 N 减一

59
00:02:36,360 --> 00:02:38,330
所以求 F 4，哎

60
00:02:38,330 --> 00:02:40,170
再求 FN 减二

61
00:02:40,170 --> 00:02:40,930
不知道怎么办

62
00:02:40,930 --> 00:02:42,830
哎，求 F 2

63
00:02:42,830 --> 00:02:47,050
然后呢， FN 减二分别再去进行求取

64
00:02:47,050 --> 00:02:51,710
那它可以变成 FN 减二与 FN 减三

65
00:02:51,720 --> 00:02:56,120
FN 减三与 FN 减四相加吧

66
00:02:56,120 --> 00:02:59,070
那问题显然规模由大到小

67
00:02:59,070 --> 00:03:03,030
这就是典型的自顶向下的分析过程

68
00:03:04,620 --> 00:03:07,220
所以我们说到的自底向上

69
00:03:07,220 --> 00:03:08,300
自顶向下呀

70
00:03:08,300 --> 00:03:10,020
他就是典型的问题

71
00:03:10,020 --> 00:03:11,680
规模的变化方向

72
00:03:11,680 --> 00:03:18,540
那 N 到 N 减一到 N 减2~21

73
00:03:18,540 --> 00:03:20,480
这是自顶向下

74
00:03:20,480 --> 00:03:24,080
如果说自底向上的话

75
00:03:26,240 --> 00:03:32,080
它是呢，由一、二、三到问题规模 N 来的

76
00:03:32,080 --> 00:03:34,560
这只是一个呢，变化的方向

77
00:03:34,560 --> 00:03:37,470
那我们在代入递归式之后

78
00:03:37,470 --> 00:03:39,470
如果要求 F 5

79
00:03:39,470 --> 00:03:40,510
F 5不知道

80
00:03:40,510 --> 00:03:43,000
所以返回的是4+3

81
00:03:43,000 --> 00:03:44,120
四不知道

82
00:03:44,120 --> 00:03:46,900
所以返回的是求3+2

83
00:03:46,900 --> 00:03:47,980
三不知道

84
00:03:47,980 --> 00:03:50,110
那我们求2+1

85
00:03:50,110 --> 00:03:51,650
哎，一知道吧

86
00:03:51,650 --> 00:03:53,770
二不知道，用1+0

87
00:03:53,770 --> 00:03:55,010
以此类推

88
00:03:55,010 --> 00:03:58,070
那我们最终呢，可以把 F 4求出

89
00:03:58,070 --> 00:03:59,130
再返回

90
00:03:59,130 --> 00:04:02,330
这个时间复杂度其实是比较大的

91
00:04:02,330 --> 00:04:04,240
这里只提到了递归

92
00:04:04,240 --> 00:04:06,000
但没有二分的思想

93
00:04:06,000 --> 00:04:07,680
所以我们在考试当中啊

94
00:04:07,680 --> 00:04:09,400
考分制法基本上呢

95
00:04:09,400 --> 00:04:12,170
不会涉及这样的复杂时间复杂度

96
00:04:12,170 --> 00:04:13,580
那我们在这里呢

97
00:04:13,580 --> 00:04:15,460
了解什么是递归自己

98
00:04:15,460 --> 00:04:18,540
调用自己函数名是本身变化的

99
00:04:18,540 --> 00:04:19,380
是参数

100
00:04:19,380 --> 00:04:21,850
了解递归它的变化方向

101
00:04:21,850 --> 00:04:23,890
自顶向下和自底向上

102
00:04:23,890 --> 00:04:26,470
有什么样的含义就可以了

103
00:04:26,470 --> 00:04:28,090
那针对分治法的话

104
00:04:28,090 --> 00:04:30,870
我们啊，典型的就是二分查找

105
00:04:30,870 --> 00:04:33,810
二分查找是在一个表当中

106
00:04:33,810 --> 00:04:37,030
L 当中给了指针范围

107
00:04:37,030 --> 00:04:41,940
A 和 B 查找某一个元素 X 是否在表当中

108
00:04:41,940 --> 00:04:42,850
然后呢

109
00:04:42,850 --> 00:04:47,060
我们要判断一下 ab 它们的指针有没有错位

110
00:04:47,060 --> 00:04:49,210
如果说 A 大于 B 

111
00:04:49,210 --> 00:04:51,330
说明上下界位置不对

112
00:04:51,330 --> 00:04:53,310
返回一查找失败

113
00:04:53,310 --> 00:04:54,480
否则的话

114
00:04:54,480 --> 00:04:57,500
我们呢会二分查找中间位置

115
00:04:57,500 --> 00:05:01,750
也就是二分之 A 加 B 向下取整作为 M 

116
00:05:01,750 --> 00:05:03,710
那 M 找到了之后

117
00:05:03,710 --> 00:05:06,170
如果等于要找的元素

118
00:05:06,170 --> 00:05:09,020
所以刚好诶，返回查找成功

119
00:05:09,020 --> 00:05:14,300
如果说大于这个数值或者小于这个数值

120
00:05:14,300 --> 00:05:17,000
就分别在左侧或者右侧吧

121
00:05:17,000 --> 00:05:21,720
我们可以针对性地来对它进行下一轮的递归

122
00:05:21,720 --> 00:05:23,750
接着进行二分查找

123
00:05:23,750 --> 00:05:27,410
因为原本的函数就是二分查找函数

124
00:05:27,410 --> 00:05:31,410
那在里面返回的还是二分查找函数吧

125
00:05:31,410 --> 00:05:34,390
那这个过程就是呢，递归自己

126
00:05:34,390 --> 00:05:38,040
调用自己参数还是这个表格

127
00:05:38,040 --> 00:05:42,070
但是发生变化的是它的上下键

128
00:05:42,070 --> 00:05:46,060
如果元素 X 大于中间元素

129
00:05:46,060 --> 00:05:48,120
那它就在右侧变化

130
00:05:48,120 --> 00:05:51,090
下界是中间值 M 加一

131
00:05:51,090 --> 00:05:52,490
上界不变

132
00:05:52,490 --> 00:05:54,410
查找的还是 X 

133
00:05:54,410 --> 00:05:56,910
否则的话递归唉

134
00:05:56,910 --> 00:06:00,270
我们查找本身还是这个元素

135
00:06:00,270 --> 00:06:01,620
下界不变

136
00:06:01,620 --> 00:06:04,640
上界变成了 M 减一

137
00:06:04,640 --> 00:06:07,480
左侧部分来进行查找

138
00:06:08,150 --> 00:06:12,790
那我们会发现针对二分啊来进行实现的时候

139
00:06:12,790 --> 00:06:16,100
它的代码一般呢是对称的

140
00:06:16,100 --> 00:06:20,930
如果让大家进行填写参数结合诶

141
00:06:20,930 --> 00:06:23,720
我们函数定义的参数就可以了

142
00:06:23,720 --> 00:06:28,620
取值一定要注意上下界变化的范围

143
00:06:28,620 --> 00:06:32,110
唉，它的中间值是不用去取的

144
00:06:32,110 --> 00:06:35,420
那这里呢，涉及到的就是分治

145
00:06:35,420 --> 00:06:36,660
以及呢，二

146
00:06:36,660 --> 00:06:39,320
查找它的具体实现过程
