1
00:00:00,000 --> 00:00:02,160
接下来我们展开来看一下

2
00:00:02,160 --> 00:00:04,200
事物并发控制当中呢

3
00:00:04,200 --> 00:00:05,470
它的特性

4
00:00:05,470 --> 00:00:10,570
那事物是我们数据库执行的一个呢基本单位

5
00:00:10,570 --> 00:00:12,050
针对事物而言

6
00:00:12,050 --> 00:00:13,810
它具有一定的特性

7
00:00:13,810 --> 00:00:17,460
简称为 A 、 CID 4个特性

8
00:00:17,460 --> 00:00:19,260
那什么是 A 呢

9
00:00:19,260 --> 00:00:21,380
A 是原子性

10
00:00:21,380 --> 00:00:23,950
对于事物的原子性表示呢

11
00:00:23,950 --> 00:00:25,590
这个事物啊，是原子的

12
00:00:25,590 --> 00:00:27,850
要么都做，要么都不做

13
00:00:27,850 --> 00:00:30,550
类似于我们讲操作系统的时候啊

14
00:00:30,550 --> 00:00:32,810
PV 操作它有呢

15
00:00:32,810 --> 00:00:34,190
两个语句吧

16
00:00:34,190 --> 00:00:35,810
一个是加1-1

17
00:00:35,810 --> 00:00:37,410
一个呢是做比较

18
00:00:37,410 --> 00:00:40,220
那我们执行的过程当中，要么都做

19
00:00:40,220 --> 00:00:41,940
要么呢都不做

20
00:00:41,940 --> 00:00:42,920
比如说呢

21
00:00:42,920 --> 00:00:44,880
假设你的老板

22
00:00:46,800 --> 00:00:49,300
要给你转100块钱

23
00:00:49,300 --> 00:00:51,500
那他余额是1000

24
00:00:51,500 --> 00:00:53,620
首先要减100吧

25
00:00:53,620 --> 00:00:56,300
你的余额也是1000

26
00:00:56,300 --> 00:00:56,960
那你呢

27
00:00:56,960 --> 00:00:58,880
现在要加100

28
00:00:58,880 --> 00:01:01,680
那这肯定是分步来完成的

29
00:01:01,680 --> 00:01:04,780
也就是说当老板减100之后

30
00:01:04,780 --> 00:01:07,250
你的数据一定会加100

31
00:01:07,250 --> 00:01:09,760
那如果中间失败了

32
00:01:09,760 --> 00:01:11,600
比如说呢，老板减了100

33
00:01:11,600 --> 00:01:13,540
你的100没加上去

34
00:01:13,540 --> 00:01:16,020
那这个事物会不会减啊

35
00:01:16,020 --> 00:01:17,460
如果减了，哎

36
00:01:17,460 --> 00:01:19,000
老板说钱给你发了

37
00:01:19,000 --> 00:01:20,540
你说我没有收到呀

38
00:01:20,540 --> 00:01:23,080
那这个时候就会产生纠纷了吧

39
00:01:23,080 --> 00:01:27,160
所以呀，对减100的操作会进行还原

40
00:01:27,160 --> 00:01:29,780
这个事物呢，就不再执行了

41
00:01:29,780 --> 00:01:31,330
所以要么都做

42
00:01:31,330 --> 00:01:32,850
要么都不做

43
00:01:32,850 --> 00:01:35,350
事物在执行的时候啊

44
00:01:35,350 --> 00:01:38,770
有开始哎， begin 状态

45
00:01:39,590 --> 00:01:42,770
然后呢，有结束 and 的状态

46
00:01:42,770 --> 00:01:45,910
还有呢成功提交 commit 

47
00:01:45,910 --> 00:01:48,250
哎，表示我们都做了

48
00:01:48,250 --> 00:01:50,350
那要么都不做呢

49
00:01:50,350 --> 00:01:52,030
还有 roll back 

50
00:01:54,990 --> 00:01:58,010
表示回滚状态

51
00:01:58,010 --> 00:01:59,790
所有的修改

52
00:01:59,790 --> 00:02:02,390
包括对我们变量的修改

53
00:02:02,390 --> 00:02:03,390
状态的修改

54
00:02:03,390 --> 00:02:06,320
所有的修改都会呢进行还原

55
00:02:06,320 --> 00:02:10,449
表示呢，这个事物我们从来都没有开始过一样

56
00:02:10,449 --> 00:02:12,810
那这就是呢，原子性

57
00:02:12,810 --> 00:02:16,340
其次，事物的 C 表示呢，一致性

58
00:02:16,340 --> 00:02:18,510
一致性指的是事物啊

59
00:02:18,510 --> 00:02:19,990
它执行的结

60
00:02:19,990 --> 00:02:24,040
必须要保证数据库从某一个一致性状态

61
00:02:24,040 --> 00:02:26,460
变到另一个一致性状态

62
00:02:26,460 --> 00:02:31,270
比如说我们刚刚如果抽成功执行了，诶

63
00:02:31,270 --> 00:02:32,670
转账操作的话

64
00:02:32,670 --> 00:02:35,560
那么对于银行这个数据库而言

65
00:02:35,560 --> 00:02:37,650
它在减100之后

66
00:02:37,650 --> 00:02:40,790
针对你的数据也会呢加100

67
00:02:40,790 --> 00:02:44,060
那它会从原有1000、1000的状

68
00:02:44,060 --> 00:02:47,990
变成另一个900、1100的一致性状态

69
00:02:47,990 --> 00:02:50,010
这就是呢，一致性

70
00:02:50,010 --> 00:02:53,250
第三个 I 表示的是隔离性

71
00:02:53,250 --> 00:02:56,310
事物相互之间应该是隔离的

72
00:02:56,310 --> 00:02:59,860
也就是说我们事务在执行完成之前啊

73
00:02:59,860 --> 00:03:03,130
对其他事物应该是不可见的

74
00:03:03,130 --> 00:03:05,260
但是我们在事物并发的时候

75
00:03:05,260 --> 00:03:07,080
经常会破坏隔离性

76
00:03:07,080 --> 00:03:08,720
所以呢需要枷锁

77
00:03:08,720 --> 00:03:10,560
我们在后面呢会提到

78
00:03:10,560 --> 00:03:16,070
比如说老板同时还要呢给张三也呢

79
00:03:16,070 --> 00:03:17,810
转100块钱

80
00:03:19,760 --> 00:03:23,480
那张三的这100块钱的过程

81
00:03:23,480 --> 00:03:26,750
与你的100块钱的过程有没有关系啊

82
00:03:26,750 --> 00:03:27,950
老板有没有说

83
00:03:27,950 --> 00:03:29,930
哎，我给你发100块钱

84
00:03:29,930 --> 00:03:32,070
要先看给张三要不要发

85
00:03:32,070 --> 00:03:35,080
哎，那这个地方一般是不需要考虑的吧

86
00:03:35,080 --> 00:03:37,560
这是两个不同的事物

87
00:03:37,560 --> 00:03:40,600
它们之间呢，应该是相互不可见

88
00:03:40,600 --> 00:03:42,140
相互隔离的

89
00:03:42,140 --> 00:03:44,110
这就是呢隔离性

90
00:03:44,110 --> 00:03:47,000
最后事物呢具有持续性

91
00:03:47,000 --> 00:03:50,070
持续性也叫做呢持久性

92
00:03:50,070 --> 00:03:52,790
它的意思呢是我们的事物啊

93
00:03:52,790 --> 00:03:56,680
一旦 commit 从成功的提交了

94
00:03:56,680 --> 00:03:59,480
那么即使数据库崩溃了

95
00:03:59,480 --> 00:04:03,120
这个更新的操作也是呢永久有效的

96
00:04:03,120 --> 00:04:05,180
对于数据库而言

97
00:04:05,180 --> 00:04:10,810
它是先写日志再写数据的

98
00:04:13,600 --> 00:04:15,140
也就是说

99
00:04:15,140 --> 00:04:18,459
我们的数据在更新之前

100
00:04:18,459 --> 00:04:21,329
会先记录在日志当中

101
00:04:21,329 --> 00:04:26,000
那么记录在日志一旦有了 commit 的标志

102
00:04:26,000 --> 00:04:28,800
表示这个数据已经成功

103
00:04:28,800 --> 00:04:31,560
写到我们的数据库当中呢

104
00:04:31,560 --> 00:04:34,490
如果说数据库发生了一些

105
00:04:34,490 --> 00:04:36,650
诶，系统故障崩溃了

106
00:04:36,650 --> 00:04:39,120
那我们重启数据库之后

107
00:04:39,120 --> 00:04:43,440
数据库管理系统会去呢扫描日志

108
00:04:43,440 --> 00:04:47,960
对一切拥有 commit 提交标志的事物

109
00:04:47,960 --> 00:04:51,230
把它呢放到 redo 队列当中

110
00:04:51,230 --> 00:04:54,130
也就是重新再做一遍

111
00:04:54,130 --> 00:04:59,710
那正向对他从 begin 到 commit 之间的所有操作

112
00:04:59,710 --> 00:05:02,460
会重新去进行执行

113
00:05:02,460 --> 00:05:04,550
从而保证事物呢

114
00:05:04,550 --> 00:05:08,030
诶，它具有一个持久性的状态

115
00:05:08,030 --> 00:05:11,200
那这是呢，日志它的一个作用

116
00:05:11,200 --> 00:05:12,480
它也可以呢

117
00:05:12,480 --> 00:05:16,280
保证我们数据库的一个故障修复

118
00:05:16,580 --> 00:05:20,380
那针对这四个事物的特性而言

119
00:05:20,380 --> 00:05:24,660
要求大家呢，掌握它描述的特殊性

120
00:05:24,660 --> 00:05:26,740
唉，比如说原子性当中

121
00:05:26,740 --> 00:05:28,030
他呢，要么都做

122
00:05:28,030 --> 00:05:29,050
要么都不做

123
00:05:29,050 --> 00:05:30,070
一致性呢

124
00:05:30,070 --> 00:05:34,150
它会从一致性的状态到另一个一致性状态

125
00:05:34,150 --> 00:05:38,210
隔离性相互之间不可见持久性

126
00:05:38,210 --> 00:05:40,630
那它是永久有效的

127
00:05:40,630 --> 00:05:42,440
也叫做呢持续性

128
00:05:42,440 --> 00:05:45,110
目前在软件设计师的考

129
00:05:45,110 --> 00:05:50,250
只在呢，上五题出现过对相关概念的考察啊

130
00:05:50,250 --> 00:05:54,120
那我们在整个数据库啊当中

131
00:05:54,120 --> 00:05:57,380
一旦呢，这个钱转账转过去了

132
00:05:57,380 --> 00:05:59,880
就不能够，诶，表示，诶

133
00:05:59,880 --> 00:06:01,160
我没有收到了吧

134
00:06:01,160 --> 00:06:03,700
这个事物只要成功提交、修改

135
00:06:03,700 --> 00:06:05,350
就是能永久的

136
00:06:05,350 --> 00:06:07,720
那我们在数据库当中

137
00:06:07,720 --> 00:06:09,970
事物是不是串行的呢

138
00:06:09,970 --> 00:06:13,040
也就是第一个事务做完了再做第二个

139
00:06:13,040 --> 00:06:14,960
第二个做完了再做第三个

140
00:06:14,960 --> 00:06:15,900
并不是啊

141
00:06:15,900 --> 00:06:18,520
事物它们相互之间是并发的

142
00:06:18,520 --> 00:06:20,740
否则效率太低了

143
00:06:20,740 --> 00:06:23,730
那事物在并发的过程当中呢

144
00:06:23,730 --> 00:06:26,640
还可能会产生一系列的问题

145
00:06:26,640 --> 00:06:27,660
包括呢

146
00:06:27,660 --> 00:06:32,190
丢失、更新、不可重复、读和读脏数据这一部分啊

147
00:06:32,190 --> 00:06:35,590
我们在事物并发产生的问题当中呢

148
00:06:35,590 --> 00:06:38,090
会给大家展开来介绍

149
00:06:38,090 --> 00:06:40,130
那我们在这里主要呢

150
00:06:40,130 --> 00:06:41,670
是需要大家了解

151
00:06:41,670 --> 00:06:44,840
事物 a acid 的特性

152
00:06:44,840 --> 00:06:47,570
下面我们来看一下事物的特性

153
00:06:47,570 --> 00:06:50,900
在软件设计师考试真题当中的考察

154
00:06:50,900 --> 00:06:53,000
那事物的什么特性

155
00:06:53,000 --> 00:06:56,410
指的是当事务 commit 提交之后

156
00:06:56,410 --> 00:06:58,910
对数据库的更新操作呢

157
00:06:58,910 --> 00:07:01,390
唉，它可能还停留在缓冲区

158
00:07:01,390 --> 00:07:02,600
并没有写入

159
00:07:02,600 --> 00:07:04,380
那在这个过程当中

160
00:07:04,380 --> 00:07:06,620
数据库发生故障的话

161
00:07:06,620 --> 00:07:09,210
这个结果不会丢失

162
00:07:09,210 --> 00:07:11,740
不会丢失意味着什么啊

163
00:07:11,740 --> 00:07:13,020
永久保存

164
00:07:13,020 --> 00:07:16,580
它体现的就是呢持久性啊

165
00:07:16,580 --> 00:07:19,710
原子性表示事物要么 commit 

166
00:07:19,710 --> 00:07:20,970
要么 ROBEC 

167
00:07:20,970 --> 00:07:23,280
要么都做，要么都不做

168
00:07:23,280 --> 00:07:27,110
一致性表示事物会从某一个一致性状态

169
00:07:27,110 --> 00:07:29,150
到另一个一致性状态

170
00:07:29,150 --> 00:07:33,550
隔离性表示呢，事物与事物之间是不可见的

171
00:07:33,550 --> 00:07:36,490
那这就是呢，事物的特性
