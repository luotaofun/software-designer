1
00:00:00,000 --> 00:00:02,360
接下来我们来看事物并发

2
00:00:02,360 --> 00:00:04,830
可能呢，会产生的问题

3
00:00:04,830 --> 00:00:07,550
那对于这一板块来说

4
00:00:07,550 --> 00:00:09,790
目前在软件设计师考试啊

5
00:00:09,790 --> 00:00:11,710
已经有十次左右了

6
00:00:11,710 --> 00:00:13,280
都没有出现过了

7
00:00:13,280 --> 00:00:15,760
所以大家呢，主要是了解一下

8
00:00:15,760 --> 00:00:19,000
如何来区分这三类问题

9
00:00:19,000 --> 00:00:22,590
那并发事物在并发过程当中啊

10
00:00:22,590 --> 00:00:24,430
主要呢，有三类问题

11
00:00:24,430 --> 00:00:25,910
第一类问题呢

12
00:00:25,910 --> 00:00:29,080
是可能出现丢失、更新

13
00:00:29,080 --> 00:00:32,570
所谓的更新也叫做呢，修改

14
00:00:32,570 --> 00:00:34,220
诶，丢失、修改

15
00:00:34,220 --> 00:00:36,290
第二类呢，是不可重复读

16
00:00:36,290 --> 00:00:38,950
第三类呢，是读脏数据

17
00:00:38,950 --> 00:00:40,570
什么是丢失更新

18
00:00:40,570 --> 00:00:42,800
或者叫做呢，丢失修改

19
00:00:42,800 --> 00:00:45,060
他所谓的丢失啊

20
00:00:45,060 --> 00:00:46,100
就是说呢

21
00:00:46,100 --> 00:00:48,880
在事务执行过程当中

22
00:00:48,880 --> 00:00:52,450
由于多个事物的并发执行

23
00:00:52,450 --> 00:00:56,780
那事物 T 1对数据进行了修改

24
00:00:56,780 --> 00:00:59,350
先读数据 A 等于十

25
00:00:59,350 --> 00:01:02,170
T 2呢，也读了数据 A 等于十

26
00:01:02,170 --> 00:01:06,520
那接下来 A 等于 A 减五进行写回

27
00:01:06,520 --> 00:01:11,680
也就是说， A 这个数据原本的值是十

28
00:01:11,680 --> 00:01:12,930
大家都读了

29
00:01:12,930 --> 00:01:16,190
现在 T 1对十进行修改

30
00:01:16,190 --> 00:01:18,030
变成了五

31
00:01:18,030 --> 00:01:21,120
那 T 1目前有没有提交呢

32
00:01:21,120 --> 00:01:23,230
还没有提交

33
00:01:23,230 --> 00:01:26,620
那接下来在这个间隔当中啊

34
00:01:26,620 --> 00:01:31,370
T 2 A 有了新的写回 A 等于 A 减八

35
00:01:31,370 --> 00:01:34,780
那这个过程 A 变成了 R 

36
00:01:34,780 --> 00:01:37,570
中间的这个变化值

37
00:01:37,570 --> 00:01:40,520
也就是呢更新的新的数值

38
00:01:40,520 --> 00:01:43,700
修改的数值就被覆盖掉了

39
00:01:43,700 --> 00:01:47,560
那这个过程我们就叫做丢失修改

40
00:01:47,560 --> 00:01:50,100
也叫做呢丢失更新

41
00:01:50,100 --> 00:01:51,560
它的特点是

42
00:01:51,560 --> 00:01:53,460
两个以上的事

43
00:01:53,460 --> 00:01:56,580
对同一个数据做了修改

44
00:01:56,580 --> 00:02:01,030
那前面的修改会被呢后面的修改覆盖掉

45
00:02:01,030 --> 00:02:03,220
那这就是呢丢失更新

46
00:02:03,220 --> 00:02:05,220
多次写回

47
00:02:08,639 --> 00:02:12,440
第一次写回被后面覆盖了

48
00:02:22,790 --> 00:02:24,150
这

49
00:02:24,710 --> 00:02:27,680
是呢，我们的丢失修改

50
00:02:27,680 --> 00:02:31,440
第二种问题呢，叫做不可重复读

51
00:02:31,440 --> 00:02:32,990
所谓重复

52
00:02:32,990 --> 00:02:36,710
我们会发现它有多次读取的过程吧

53
00:02:36,710 --> 00:02:39,520
那针对 T 1和 T 2来说

54
00:02:39,520 --> 00:02:42,170
T 1读取了 A 等于30

55
00:02:42,170 --> 00:02:43,110
B 等于三

56
00:02:43,110 --> 00:02:44,050
A 等于20

57
00:02:44,050 --> 00:02:45,110
B 等于30

58
00:02:45,110 --> 00:02:47,210
求和 A 等于50

59
00:02:47,210 --> 00:02:48,710
那我们想一想啊

60
00:02:48,710 --> 00:02:50,770
大家在拿到年终奖

61
00:02:50,770 --> 00:02:52,330
如果是现金的话

62
00:02:52,330 --> 00:02:53,950
哎，你是不是会数一数

63
00:02:53,950 --> 00:02:56,060
那数一般会数一遍吗

64
00:02:56,060 --> 00:02:56,690
不止吧

65
00:02:56,690 --> 00:02:58,310
我们一般会数两遍

66
00:02:58,310 --> 00:03:00,740
为什么？检查一下，对不对呀

67
00:03:00,740 --> 00:03:02,570
所以对事物来说

68
00:03:02,570 --> 00:03:05,050
它会呢求和两次

69
00:03:05,050 --> 00:03:07,540
从而验算是否正确

70
00:03:07,540 --> 00:03:09,480
但是可惜的是啊

71
00:03:09,480 --> 00:03:12,860
在中间的时间过程间隙的时候

72
00:03:12,860 --> 00:03:14,780
有另外一个事物

73
00:03:14,780 --> 00:03:18,090
它对数据呢，进行了修改

74
00:03:18,090 --> 00:03:20,470
他也读了 A 等于20

75
00:03:20,470 --> 00:03:23,740
但他对 A 进行了修改

76
00:03:23,740 --> 00:03:26,440
A 加上50进行写回

77
00:03:26,440 --> 00:03:29,830
也就是说新的 A 变成了70

78
00:03:29,830 --> 00:03:34,550
从而导致前面的事物在读数据的时候

79
00:03:34,550 --> 00:03:39,020
读到的 A 值与第一次读到的值不一样呢

80
00:03:39,020 --> 00:03:41,090
从而呢，验算失败

81
00:03:41,090 --> 00:03:44,820
那我们一般看到验算不正确就可以知道呢

82
00:03:44,820 --> 00:03:46,780
这女士不可重复读

83
00:03:46,780 --> 00:03:49,590
因为两次的数据不一样

84
00:03:49,590 --> 00:03:52,810
那他是因为什么样的原因啊

85
00:03:52,810 --> 00:03:56,630
因为在第二次诶验算之前

86
00:03:56,630 --> 00:04:00,900
我们呢其他数据对事物进行了诶

87
00:04:00,900 --> 00:04:02,080
其他事物啊

88
00:04:02,080 --> 00:04:04,760
对这个数据进行了修改

89
00:04:04,760 --> 00:04:07,250
这就是呢不可重复读

90
00:04:09,800 --> 00:04:11,720
验算前

91
00:04:13,120 --> 00:04:20,399
对事、对数据、其他事物、对数据进行了修改

92
00:04:33,260 --> 00:04:36,780
导致我们验算不正确

93
00:04:36,920 --> 00:04:41,020
第三个问题呢，叫做读脏数据

94
00:04:41,020 --> 00:04:44,230
所谓的读脏意味着什么呢

95
00:04:44,230 --> 00:04:46,150
这是一个垃圾数据吧

96
00:04:46,150 --> 00:04:49,600
这是我们不需要的、不要的、没有用的数据

97
00:04:49,600 --> 00:04:52,200
那为什么会有脏数据呢

98
00:04:52,200 --> 00:04:56,500
我们的事物在处理数据的过程当中

99
00:04:56,500 --> 00:04:58,530
唉，比如说读 A 等于20

100
00:04:58,530 --> 00:05:01,710
A 进行了一个新的修改写回

101
00:05:01,710 --> 00:05:04,630
那这个写回被 T 2读走了

102
00:05:04,630 --> 00:05:08,860
但实际上 T 1这个事物有没有进行到最后

103
00:05:08,860 --> 00:05:11,620
很可惜他没有坚持到最后

104
00:05:11,620 --> 00:05:14,040
这个事物并没有成功提交

105
00:05:14,040 --> 00:05:16,280
而是 roll back 回滚了

106
00:05:16,280 --> 00:05:17,890
那回滚之后

107
00:05:17,890 --> 00:05:20,650
我们对 A 的修改会被呢

108
00:05:20,650 --> 00:05:23,750
唉，回复恢复成了 A 等于20

109
00:05:23,750 --> 00:05:25,850
那这个70还有没有啊

110
00:05:25,850 --> 00:05:27,730
其实并没有存在

111
00:05:27,730 --> 00:05:28,930
因为这个事物

112
00:05:28,930 --> 00:05:33,780
它的数据实际上并没有被修改成功

113
00:05:33,780 --> 00:05:37,640
所以这是一个无效的中间数据

114
00:05:37,640 --> 00:05:41,270
那无无效的中间数据就是呢

115
00:05:41,270 --> 00:05:42,650
诶，无效的数据

116
00:05:42,650 --> 00:05:45,190
我们就叫做呢读脏数据

117
00:05:45,190 --> 00:05:46,660
为什么无效

118
00:05:46,660 --> 00:05:49,140
因为被回滚呢

119
00:05:53,260 --> 00:05:56,620
也就是说我们在描述的过程当中啊

120
00:05:56,620 --> 00:05:58,960
如果在事物当中看到 rob 

121
00:05:58,960 --> 00:06:03,760
很有可能呢就会读到中间回滚的脏数据

122
00:06:03,760 --> 00:06:06,290
那我们呢，主要对这三类数

123
00:06:06,290 --> 00:06:07,910
这三类问题啊

124
00:06:07,910 --> 00:06:10,880
它的特点加以区分就可以了

125
00:06:10,880 --> 00:06:13,580
目前在软件设计师考试当中呢

126
00:06:13,580 --> 00:06:16,990
已经有呃将近5年的时间没有考它了

127
00:06:16,990 --> 00:06:19,070
那大家呢，重在了解即可
