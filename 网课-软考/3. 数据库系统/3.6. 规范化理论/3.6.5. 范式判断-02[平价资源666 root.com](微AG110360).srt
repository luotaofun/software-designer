1
00:00:00,639 --> 00:00:04,290
那最后呢，我们来看一下 BC 范式

2
00:00:04,290 --> 00:00:06,160
对于 BC 范式啊

3
00:00:06,160 --> 00:00:08,140
我们要求大家是

4
00:00:08,140 --> 00:00:12,620
只要能够掌握它的判断依据就可以了

5
00:00:12,620 --> 00:00:15,450
拆分过程是不需要再拆的

6
00:00:15,450 --> 00:00:18,810
我们在进行关系模式设计的时候

7
00:00:18,810 --> 00:00:22,230
拆到 BC 范式已经呢比较高了

8
00:00:22,230 --> 00:00:24,370
一般达到第三范式

9
00:00:24,370 --> 00:00:27,460
规范化程度就已经能足够了

10
00:00:27,460 --> 00:00:29,730
我们先看下面这个例子

11
00:00:29,730 --> 00:00:31,850
给了我们一个关系模式

12
00:00:31,850 --> 00:00:35,200
S 、 T 、 J ， S 表示学生

13
00:00:35,200 --> 00:00:36,420
T 表示老师

14
00:00:36,420 --> 00:00:37,810
皆表示课程

15
00:00:37,810 --> 00:00:40,340
一个老师只教一门课

16
00:00:40,340 --> 00:00:44,190
所以老师可以决定课程

17
00:00:44,190 --> 00:00:46,740
每个课程有多名老师

18
00:00:46,740 --> 00:00:49,500
说明课程不能决定老师

19
00:00:49,500 --> 00:00:53,450
那学生选定课程当时的时候呢

20
00:00:53,450 --> 00:00:55,730
就固定对应一个老师了

21
00:00:55,730 --> 00:00:59,200
所以学生加课程可以呢决定老师

22
00:00:59,200 --> 00:01:02,140
这是它的函数依赖集合吧

23
00:01:02,140 --> 00:01:04,750
有两个函数依赖

24
00:01:04,750 --> 00:01:07,650
首先我们做范式判断

25
00:01:07,650 --> 00:01:08,790
第一步干嘛

26
00:01:08,790 --> 00:01:10,690
找候选键

27
00:01:14,600 --> 00:01:16,960
这里的候选键唉

28
00:01:16,960 --> 00:01:19,620
入度为零的属性是 S 

29
00:01:19,620 --> 00:01:21,910
能不能便利全图不能

30
00:01:21,910 --> 00:01:23,840
S 阶可以找到 T 

31
00:01:23,840 --> 00:01:26,580
所以 S 阶是候选键

32
00:01:26,580 --> 00:01:29,610
ST 通过 T 可以找到街

33
00:01:29,610 --> 00:01:32,720
所以 s st 也是候选键吧

34
00:01:32,720 --> 00:01:35,250
这有两个候选键

35
00:01:35,250 --> 00:01:38,150
有没有非主属性呢

36
00:01:38,150 --> 00:01:41,730
唉， S 阶梯都是主属性

37
00:01:41,730 --> 00:01:44,910
所以非主属性没有

38
00:01:45,780 --> 00:01:48,540
那没有非主属性

39
00:01:48,540 --> 00:01:51,550
会不会存在非主属性对

40
00:01:51,550 --> 00:01:52,590
呃，这些呢

41
00:01:52,590 --> 00:01:53,790
至少不可再分

42
00:01:53,790 --> 00:01:55,890
那有没有非主属性

43
00:01:55,890 --> 00:01:58,170
对候选键的部分函数依赖啊

44
00:01:58,170 --> 00:01:59,720
没有非主属性啊

45
00:01:59,720 --> 00:02:03,300
哪来的它对候选键的部分函数依赖呢

46
00:02:03,300 --> 00:02:05,660
所以能够满足第二范式

47
00:02:05,660 --> 00:02:08,389
那会不会有非主属性

48
00:02:08,389 --> 00:02:11,280
对候选键的传递函数依赖呢

49
00:02:11,280 --> 00:02:14,140
也没有非主属性了，也不存在

50
00:02:14,140 --> 00:02:16,920
至少可以满足第三范式

51
00:02:16,920 --> 00:02:21,160
所以这里又有一个快速判断的依据

52
00:02:21,240 --> 00:02:24,240
没有非主属性

53
00:02:29,680 --> 00:02:33,560
至少满足第三范式

54
00:02:35,700 --> 00:02:38,160
这是我们呢

55
00:02:38,160 --> 00:02:41,320
关于范式判断

56
00:02:41,320 --> 00:02:43,100
快速判断的依据

57
00:02:43,100 --> 00:02:45,830
那这里没有非主属性的

58
00:02:45,830 --> 00:02:47,710
所以我们在这里，哎

59
00:02:47,710 --> 00:02:51,560
它能够判断一下有没有满足第二范式

60
00:02:51,560 --> 00:02:54,310
有没有满足第三范式

61
00:02:54,310 --> 00:02:56,550
满足第三范式了

62
00:02:56,550 --> 00:02:58,810
再考虑呢， BC 范式

63
00:02:58,810 --> 00:03:03,110
那 BC 范式的判断根据定义来看

64
00:03:03,110 --> 00:03:05,520
什么叫根据定义来看呢

65
00:03:05,520 --> 00:03:08,220
BC 范式它的要求是

66
00:03:08,220 --> 00:03:13,030
当且仅当函数依赖集合 F 当中

67
00:03:13,030 --> 00:03:16,070
每个依赖两个依赖当

68
00:03:16,070 --> 00:03:18,710
每个依赖的决定因素

69
00:03:18,710 --> 00:03:22,000
箭头的左侧是决定因素

70
00:03:22,000 --> 00:03:28,160
T 1和 S 阶必定包含 R 当中的某个候选码

71
00:03:28,160 --> 00:03:33,810
那我们看一下第一个函数依赖 AT 这个属性

72
00:03:33,810 --> 00:03:36,360
有没有包含候选键啊

73
00:03:36,360 --> 00:03:38,560
它能不能包含 ST 呀

74
00:03:38,560 --> 00:03:40,940
我们说 ST 包含 S 和 T 

75
00:03:40,940 --> 00:03:43,080
有没有说 T 包含 ST 啊

76
00:03:43,080 --> 00:03:43,940
不可能哦

77
00:03:43,940 --> 00:03:46,240
所以它不满足定义

78
00:03:46,240 --> 00:03:48,560
那只要有一个不满足

79
00:03:48,560 --> 00:03:52,130
他就不能够满足 BC 范式了

80
00:03:52,130 --> 00:03:54,910
所以它的规范化程度最高

81
00:03:54,910 --> 00:03:57,060
只有第三范式

82
00:03:57,060 --> 00:04:01,230
那对于第二个函数依赖 S 

83
00:04:01,230 --> 00:04:02,980
包含了 S 阶

84
00:04:02,980 --> 00:04:05,580
所以能够呢满足要求

85
00:04:05,580 --> 00:04:07,480
但有一个不满足

86
00:04:07,480 --> 00:04:10,250
我们就不用呢去考虑了

87
00:04:10,250 --> 00:04:14,550
这里呢，是关于 BC 范式的判断

88
00:04:14,550 --> 00:04:19,500
主要还是呢找候选键和非主属性

89
00:04:19,500 --> 00:04:21,620
那这里给大家呢

90
00:04:21,620 --> 00:04:23,420
讲到的就是范

91
00:04:23,420 --> 00:04:25,280
它的判断过程

92
00:04:25,280 --> 00:04:27,420
我们来总结一下

93
00:04:27,420 --> 00:04:29,840
首先判断的依据

94
00:04:29,840 --> 00:04:33,770
它的整个规范化程度是层层递进的

95
00:04:33,770 --> 00:04:36,530
先判断是否满足第一范式

96
00:04:36,530 --> 00:04:37,730
怎么判断啊

97
00:04:37,730 --> 00:04:40,270
不可再分属性

98
00:04:40,270 --> 00:04:43,070
都是不可再分的原子值

99
00:04:43,070 --> 00:04:46,080
满足第一范式之后

100
00:04:46,080 --> 00:04:48,670
消除非主属性

101
00:04:48,670 --> 00:04:52,370
对候选键的部分函数依赖

102
00:04:52,870 --> 00:04:57,010
消除了没有这一类部分函数依赖了

103
00:04:57,010 --> 00:04:59,670
我们说它能满足第二范式

104
00:04:59,670 --> 00:05:02,330
那第二范式基础上

105
00:05:02,330 --> 00:05:08,190
消除非主属性对候选件的传递函数依赖

106
00:05:08,190 --> 00:05:10,690
没有这一类传递函数依赖了

107
00:05:10,690 --> 00:05:12,750
就满足第三范式了

108
00:05:12,750 --> 00:05:16,380
那第三范式到 BC 范式的过程

109
00:05:16,380 --> 00:05:20,030
它消除的是主属性之间

110
00:05:20,030 --> 00:05:21,890
它的候选件啊

111
00:05:21,890 --> 00:05:24,690
主属性和候选键之间的部分

112
00:05:24,690 --> 00:05:26,590
和传递函数依赖

113
00:05:26,590 --> 00:05:28,440
我们在这里只要呢

114
00:05:28,440 --> 00:05:31,420
能够根据 BC 的定义来判断

115
00:05:31,420 --> 00:05:34,980
它是否满足 BC 范式就可以了

116
00:05:34,980 --> 00:05:38,770
那对于规范化程度提升之后呢

117
00:05:38,770 --> 00:05:41,750
它可以呀逐步的进行优化

118
00:05:41,750 --> 00:05:43,810
来解决相应的问题

119
00:05:43,810 --> 00:05:47,400
范式之间呢，存在一定的包含关系

120
00:05:47,400 --> 00:05:49,950
那也就是说呢，满足第一范

121
00:05:49,950 --> 00:05:51,290
再考虑第二范式

122
00:05:51,290 --> 00:05:53,010
满足第二再考虑第三

123
00:05:53,010 --> 00:05:54,030
满足第三呢

124
00:05:54,030 --> 00:05:55,430
才考虑 B

125
00:05:55,430 --> 00:05:58,710
关于第二范式的快速判断

126
00:05:58,710 --> 00:05:59,850
判断依据

127
00:05:59,850 --> 00:06:03,670
那主候选键是单属性

128
00:06:07,960 --> 00:06:11,320
至少满足第二范式

129
00:06:11,320 --> 00:06:14,280
没有非主属性

130
00:06:14,320 --> 00:06:17,720
至少满足第三范式

131
00:06:18,480 --> 00:06:21,500
这两个点呢，大家了解一下

132
00:06:21,500 --> 00:06:23,640
做题的时候可以帮助大家呢

133
00:06:23,640 --> 00:06:25,340
快速的来判断一下

134
00:06:25,340 --> 00:06:28,500
它是否满足第二或者第三范式

135
00:06:28,500 --> 00:06:31,700
我们呢，以一个表格来总结一下

136
00:06:31,700 --> 00:06:33,640
对于 D 1、 D 2、 D 3

137
00:06:33,640 --> 00:06:35,360
还有 BC 范式啊

138
00:06:35,360 --> 00:06:38,720
它们的属性都是不可再分的

139
00:06:38,720 --> 00:06:42,190
那这种情况下是至少满足第一范式嘛

140
00:06:42,190 --> 00:06:44,830
那在第一范式的基础上

141
00:06:44,830 --> 00:06:48,150
才会去考虑有没有非主属性

142
00:06:48,150 --> 00:06:48,570
诶

143
00:06:48,570 --> 00:06:51,620
不分函数依赖于候选键

144
00:06:51,620 --> 00:06:52,720
有的话

145
00:06:52,720 --> 00:06:55,720
那我们呢，说它只满足第一范式

146
00:06:55,720 --> 00:06:57,360
不能往下推导了

147
00:06:57,360 --> 00:06:58,940
消除了这一部

148
00:06:58,940 --> 00:07:01,090
不存在非主属性

149
00:07:01,090 --> 00:07:03,690
对候选键的部分函数依赖了

150
00:07:03,690 --> 00:07:06,270
我们呢，才考虑第二范式

151
00:07:06,270 --> 00:07:08,990
第三范式和 BC 范式

152
00:07:09,040 --> 00:07:12,480
在第二范式的基础上

153
00:07:12,480 --> 00:07:14,840
是否存在非主属性

154
00:07:14,840 --> 00:07:17,890
对候选件的传递函数依赖呢

155
00:07:17,890 --> 00:07:21,650
如果存在只能够达到第二范式

156
00:07:21,650 --> 00:07:22,870
不用考虑第三了

157
00:07:22,870 --> 00:07:23,750
达不到了

158
00:07:23,750 --> 00:07:27,810
那如果不存在才满足第三范式

159
00:07:27,810 --> 00:07:30,650
才考虑呢 BC 范式

160
00:07:30,650 --> 00:07:33,830
那对于候选键当中

161
00:07:33,830 --> 00:07:38,950
如果左侧决定因素包含了候选键

162
00:07:38,950 --> 00:07:41,530
每一个都包含的话

163
00:07:41,530 --> 00:07:44,070
如果说有一个不满足

164
00:07:44,070 --> 00:07:46,350
就只能达到第三范式

165
00:07:46,350 --> 00:07:48,320
大家都满足的话

166
00:07:48,320 --> 00:07:51,140
就是呢，属于 BC 范式了

167
00:07:51,140 --> 00:07:52,280
可以自己啊

168
00:07:52,280 --> 00:07:55,360
对相应的规范化程度的特点呢

169
00:07:55,360 --> 00:07:59,380
进行一些自己比较熟悉的汇总

170
00:07:59,380 --> 00:08:01,150
那这些啊，就是呢

171
00:08:01,150 --> 00:08:03,330
关于规范化理论当

172
00:08:03,330 --> 00:08:05,190
范式判断的部分

173
00:08:05,190 --> 00:08:07,120
在考试当中呢

174
00:08:07,120 --> 00:08:11,300
我们在上午题经常呢，会考两到四分

175
00:08:11,300 --> 00:08:12,490
综合考察

176
00:08:12,490 --> 00:08:16,620
给大家一些情景来判断它的规范化程度

177
00:08:16,620 --> 00:08:18,520
那下午题当中呢

178
00:08:18,520 --> 00:08:20,280
也可能会出

179
00:08:20,280 --> 00:08:23,740
对规范化问题和解决的

180
00:08:23,740 --> 00:08:26,040
这种形式的考察

181
00:08:26,040 --> 00:08:31,180
下面呢，我们来看一下对规范化程度的判

182
00:08:31,180 --> 00:08:32,679
以及呢，解决

183
00:08:32,679 --> 00:08:34,909
下面给了我们一个呢

184
00:08:34,909 --> 00:08:38,409
公司数据库当中原件的关系模式

185
00:08:38,409 --> 00:08:40,429
包含原件名称

186
00:08:40,429 --> 00:08:45,270
供应商、供应商所在地、库存量、函数、依赖集

187
00:08:45,270 --> 00:08:46,370
给我们呢

188
00:08:46,370 --> 00:08:50,870
原件可以推原件名称、原件号、供应商号

189
00:08:50,870 --> 00:08:53,780
推库存量、供应商可以决定呢

190
00:08:53,780 --> 00:08:55,460
供应商所在地

191
00:08:55,460 --> 00:08:57,860
那首先第一步找什么

192
00:08:57,860 --> 00:08:59,100
找候选键

193
00:08:59,100 --> 00:09:01,050
也就是主键

194
00:09:01,050 --> 00:09:02,190
是啊

195
00:09:02,190 --> 00:09:05,040
它的候选键是什么呢

196
00:09:05,040 --> 00:09:07,800
入度为零的属

197
00:09:07,800 --> 00:09:11,990
集合有原件和供应商

198
00:09:14,840 --> 00:09:18,200
这是入度为零的属性集合

199
00:09:18,200 --> 00:09:21,060
那原件可以推原件名

200
00:09:21,060 --> 00:09:24,240
供应商，可以推供应商所在地组合

201
00:09:24,240 --> 00:09:26,080
还能推库存量吧

202
00:09:26,080 --> 00:09:28,920
所以可以便利全图

203
00:09:28,920 --> 00:09:31,290
这就是他的候选键

204
00:09:31,290 --> 00:09:33,070
也就是主见了

205
00:09:33,070 --> 00:09:34,280
那我们会发现

206
00:09:34,280 --> 00:09:38,270
找到入度为零的原件号和供应商

207
00:09:38,270 --> 00:09:40,140
我们的候选键和主键

208
00:09:40,140 --> 00:09:43,060
其实就已经呢找到选项了吧

209
00:09:43,060 --> 00:09:45,070
找到这个选项之后

210
00:09:45,070 --> 00:09:48,850
哎，我们再来看非主属性

211
00:09:51,560 --> 00:09:55,720
有哪些原件名称

212
00:09:57,440 --> 00:09:59,800
供应商名

213
00:09:59,920 --> 00:10:02,400
供应商所在地

214
00:10:05,120 --> 00:10:07,440
以及库存量

215
00:10:09,800 --> 00:10:12,420
对于这一部分而言的话

216
00:10:12,420 --> 00:10:16,460
我们会发现原件名称依赖于原件吧

217
00:10:16,460 --> 00:10:20,030
供应商所在地依赖于供应商

218
00:10:20,030 --> 00:10:21,360
那很显然

219
00:10:21,360 --> 00:10:24,120
他们这两个非主属性

220
00:10:24,120 --> 00:10:27,090
都是部分依赖于候选键吧

221
00:10:27,090 --> 00:10:31,680
所以它能够达到的规范化程度

222
00:10:31,680 --> 00:10:36,720
其实只有第一范式达不到第二范式

223
00:10:36,720 --> 00:10:39,860
就会呢存在相应的这些问题

224
00:10:39,860 --> 00:10:42,000
那为了解决这些问题

225
00:10:42,000 --> 00:10:44,030
我们就需要进行分解

226
00:10:44,030 --> 00:10:45,510
怎么来分解

227
00:10:45,510 --> 00:10:50,110
这里没有要求我们分解的规范化程度吧

228
00:10:50,110 --> 00:10:54,180
那我们其实是需要根据四个选项来看

229
00:10:54,180 --> 00:10:57,690
哪一种分解会更好一些

230
00:10:57,690 --> 00:11:00,790
那我们不满足第二范式

231
00:11:00,790 --> 00:11:03,650
至少要给它达到第二份是吧

232
00:11:03,650 --> 00:11:05,500
才有分解的意义呀

233
00:11:05,500 --> 00:11:08,610
那哪里不符我们就拆哪里

234
00:11:08,610 --> 00:11:11,900
原件决定原件名称不符

235
00:11:11,900 --> 00:11:16,630
那我们把原件号和原件名称拆出来

236
00:11:16,630 --> 00:11:20,900
供应商决定供应商所在地不符

237
00:11:20,900 --> 00:11:21,980
那我们呢

238
00:11:21,980 --> 00:11:27,060
就把供应商和供应商所在地拆出来

239
00:11:28,330 --> 00:11:32,130
我们会发现，对于 A 选项来说

240
00:11:32,130 --> 00:11:35,790
这一部分仍然存在部分函数依赖吧

241
00:11:35,790 --> 00:11:38,350
而对于 B 选项来说

242
00:11:38,350 --> 00:11:41,910
这一部分也存在 A 部分函数依赖

243
00:11:41,910 --> 00:11:44,530
所以还是达不到第二范式

244
00:11:44,530 --> 00:11:47,480
我们就不会考虑 ab 选项了

245
00:11:47,480 --> 00:11:50,840
那看 C 和 D 两个选项的话

246
00:11:50,840 --> 00:11:54,090
我们会发现对于原件

247
00:11:54,090 --> 00:11:58,950
它的整个原件号和供应商是组合

248
00:11:58,950 --> 00:12:00,510
决定库存量的

249
00:12:00,510 --> 00:12:06,110
所以 D 选项的拆分会丢失这个函数依赖

250
00:12:06,110 --> 00:12:08,390
并且我们会发现呢

251
00:12:08,390 --> 00:12:10,590
诶，我们拆了之

252
00:12:10,590 --> 00:12:13,940
没办法把相应的供应商啊

253
00:12:13,940 --> 00:12:16,850
对应的库存量给它呢还原回来

254
00:12:16,850 --> 00:12:20,270
所以 D 选项的拆分并不合适

255
00:12:20,270 --> 00:12:22,840
不满足我们的业务需求

256
00:12:22,840 --> 00:12:27,510
那这里满足要求的应该呢，是 C 选项

257
00:12:27,510 --> 00:12:29,970
针对 C 选项来看的话

258
00:12:29,970 --> 00:12:35,630
唉，首先第 A 个关系模式主键是原件号

259
00:12:35,630 --> 00:12:38,450
单属性，至少满足第二范式吧

260
00:12:38,450 --> 00:12:40,240
那只有一个函数依赖

261
00:12:40,240 --> 00:12:41,220
不会有传递

262
00:12:41,220 --> 00:12:43,860
至少满足第三范式

263
00:12:43,860 --> 00:12:47,570
对第二个关系模式组合键

264
00:12:47,570 --> 00:12:49,920
只有一个函数依赖

265
00:12:49,920 --> 00:12:51,540
一定是完全依赖

266
00:12:51,540 --> 00:12:53,540
这里没有部分函数依赖了

267
00:12:53,540 --> 00:12:54,900
也不存在传递

268
00:12:54,900 --> 00:12:57,930
哎，至少满足第三范式

269
00:12:57,930 --> 00:12:59,180
原件三

270
00:12:59,180 --> 00:13:02,470
同样呢，只有唉，一个函数依

271
00:13:02,470 --> 00:13:04,530
候选件供应商

272
00:13:04,530 --> 00:13:07,340
至少满足第三范式

273
00:13:07,340 --> 00:13:11,250
所以它能够达到的规范化程度啊

274
00:13:11,250 --> 00:13:13,860
其实是第三范式

275
00:13:13,860 --> 00:13:16,180
如果有 B 、 C 的话

276
00:13:16,180 --> 00:13:19,380
它是能够达到 B 、 C 范式的

277
00:13:20,140 --> 00:13:23,180
那第一、第四个选项

278
00:13:23,180 --> 00:13:26,900
第四范式跟我们这里是没有关系的

279
00:13:26,900 --> 00:13:30,110
第四范式它的判断依据

280
00:13:30,110 --> 00:13:33,790
特指的是多值函数依赖

281
00:13:37,640 --> 00:13:39,820
多值函数依赖

282
00:13:39,820 --> 00:13:44,140
跟我们平常的函数依赖是不一样的

283
00:13:44,140 --> 00:13:45,660
那我们在这里呢

284
00:13:45,660 --> 00:13:48,500
没有给大家讲到过多值函数依赖

285
00:13:48,500 --> 00:13:50,650
也没有提到第四范式

286
00:13:50,650 --> 00:13:53,110
它不在我们的考虑范围

287
00:13:53,110 --> 00:13:55,040
目前第四范式呢

288
00:13:55,040 --> 00:13:58,180
只在数据库工程师当中有考察

289
00:13:58,180 --> 00:14:01,590
其他软考科目目前都没有涉及

290
00:14:01,590 --> 00:14:05,760
所以了解到它所描述的是多值函数依赖

291
00:14:05,760 --> 00:14:10,200
跟我们这一类函数依赖不一样就可以了

292
00:14:10,200 --> 00:14:12,480
我们一般在写多值的时候

293
00:14:12,480 --> 00:14:14,540
会用两个箭头来表示啊

294
00:14:14,540 --> 00:14:16,970
所以在这里没有关系，呃

295
00:14:16,970 --> 00:14:19,450
也不需要呢去考虑多职了

296
00:14:19,450 --> 00:14:22,140
如果给个 BC 范式的选项

297
00:14:22,140 --> 00:14:25,260
它是能够达到 BC 范式的

298
00:14:25,260 --> 00:14:29,060
那以上呢，就是我们本章关于呢

299
00:14:29,060 --> 00:14:30,720
规范化理论当

300
00:14:30,720 --> 00:14:34,230
范式的判断，也是属于本章当中啊

301
00:14:34,230 --> 00:14:37,080
既有难度也有深度的内容了

302
00:14:37,080 --> 00:14:39,780
大家呢，需要花一些时间和精力呢

303
00:14:39,780 --> 00:14:41,740
自己去整理理解一下
