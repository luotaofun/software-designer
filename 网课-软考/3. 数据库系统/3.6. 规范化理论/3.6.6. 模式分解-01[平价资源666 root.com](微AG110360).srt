1
00:00:00,000 --> 00:00:01,920
在前面的视频当中呢

2
00:00:01,920 --> 00:00:03,560
我们给大家介绍到了

3
00:00:03,560 --> 00:00:06,080
规范化理论的一些基本概念

4
00:00:06,080 --> 00:00:09,580
以及呢，对规范化程度的判断

5
00:00:09,580 --> 00:00:11,370
也就是范式的判断

6
00:00:11,370 --> 00:00:13,100
那么对于范式

7
00:00:13,100 --> 00:00:15,820
它的规范化程度的提高啊

8
00:00:15,820 --> 00:00:19,560
通常都是通过分割表来实现的

9
00:00:19,560 --> 00:00:21,840
对于表格的分割

10
00:00:21,840 --> 00:00:26,880
其实它的实质就是将关系模式进行了分解

11
00:00:26,880 --> 00:00:29,770
那这种分解的过程当中

12
00:00:29,770 --> 00:00:31,770
为什么不是随机的呢

13
00:00:31,770 --> 00:00:32,780
我们会发现

14
00:00:32,780 --> 00:00:35,440
并不是每一种分解的方式

15
00:00:35,440 --> 00:00:38,010
都能够达到我们的需求吧

16
00:00:38,010 --> 00:00:41,340
那对于这样的关系模式的分解

17
00:00:41,340 --> 00:00:44,550
我们是有一定的判定维度的

18
00:00:44,550 --> 00:00:47,510
那它的维度包含两个方面

19
00:00:47,510 --> 00:00:52,660
一个呢，是判断是否保持了函数依赖

20
00:00:52,660 --> 00:00:57,100
一种呢，是判断是否是无损分解

21
00:00:57,100 --> 00:00:59,970
所以我们在下面的视频当中呢

22
00:00:59,970 --> 00:01:03,090
会给大家介绍到模式分解呀

23
00:01:03,090 --> 00:01:04,750
它的判断过程

24
00:01:04,750 --> 00:01:06,780
那这里的判断呢

25
00:01:06,780 --> 00:01:09,900
我们一般是综合起来进行判断的

26
00:01:09,900 --> 00:01:11,940
虽然是两个不同的维度

27
00:01:11,940 --> 00:01:14,410
但做题的时候大家会发现

28
00:01:14,410 --> 00:01:16,390
我们是针对两个维度

29
00:01:16,390 --> 00:01:18,490
有四种不同的组合方

30
00:01:18,490 --> 00:01:19,910
让大家来判断

31
00:01:19,910 --> 00:01:22,200
那判断的过程啊

32
00:01:22,200 --> 00:01:24,840
我们在软件设计师考试呢

33
00:01:24,840 --> 00:01:27,470
主要出现在上午题当中

34
00:01:27,470 --> 00:01:30,270
它的考查分值一般呢

35
00:01:30,270 --> 00:01:33,000
会结合候选键

36
00:01:33,000 --> 00:01:38,550
主键以及呢范式判断综合来进行考察

37
00:01:38,550 --> 00:01:40,750
那它的考查分值啊

38
00:01:40,750 --> 00:01:45,060
一般呢，也是在两分到四分的范围内

39
00:01:45,060 --> 00:01:47,580
针对这种考察形式呢

40
00:01:47,580 --> 00:01:50,600
我们需要了解到模式判断

41
00:01:50,600 --> 00:01:56,580
首先，唉，如何来判定它是否保持函数依赖

42
00:01:56,580 --> 00:01:58,610
那什么是函数依赖啊

43
00:01:58,610 --> 00:02:02,620
我们在规范化理论的基本概念当中提到过

44
00:02:02,620 --> 00:02:04,310
函数依赖啊

45
00:02:04,310 --> 00:02:07,490
它就是呢 X 决定 Y 就叫呢

46
00:02:07,490 --> 00:02:09,360
哎，这是一组函数依赖

47
00:02:09,360 --> 00:02:11,740
那我们在写关系模式的时候

48
00:02:11,740 --> 00:02:14,780
一般会写出函数依赖的集合

49
00:02:14,780 --> 00:02:15,910
F 集合

50
00:02:15,910 --> 00:02:19,010
针对这个 F 集合而言

51
00:02:19,010 --> 00:02:22,840
它里面会有多个函数依赖关系

52
00:02:22,840 --> 00:02:24,210
那我们说呢

53
00:02:24,210 --> 00:02:28,270
函数依赖的实质是在属性之间的

54
00:02:28,270 --> 00:02:32,530
属性在函数依赖就可以呢存在了

55
00:02:32,530 --> 00:02:35,620
那我们在分析的过程当中会发现

56
00:02:35,620 --> 00:02:37,110
模式分解

57
00:02:37,110 --> 00:02:39,490
也就是分割表的过程当中

58
00:02:39,490 --> 00:02:43,200
会将原关系模式当中的属性啊

59
00:02:43,200 --> 00:02:46,010
拆分到不同的表格当中

60
00:02:46,010 --> 00:02:48,560
那拆分之后，诶

61
00:02:48,560 --> 00:02:52,470
这不同的子表或者说分割表当中啊

62
00:02:52,470 --> 00:02:54,220
不同的属性之间呢

63
00:02:54,220 --> 00:02:57,140
可以保留一些关系模式

64
00:02:57,140 --> 00:02:59,540
也可以保留呢一些函数依赖

65
00:02:59,540 --> 00:03:04,760
那最终这些函数依赖与分解前的函数

66
00:03:04,760 --> 00:03:05,900
依赖集合

67
00:03:05,900 --> 00:03:08,020
是不是一致的呢

68
00:03:08,020 --> 00:03:10,140
如果是一致的

69
00:03:10,140 --> 00:03:13,000
我们就叫做保持函数依赖

70
00:03:13,000 --> 00:03:16,110
否则就没有保持了

71
00:03:16,110 --> 00:03:18,060
那我们在这里啊

72
00:03:18,060 --> 00:03:20,450
需要注意一个特殊的地方

73
00:03:20,450 --> 00:03:25,790
我们对关系模式这样的分解集合来看的话

74
00:03:25,790 --> 00:03:29,900
每一些属性也就是分解之后的关系模式啊

75
00:03:29,900 --> 00:03:33,320
都会呢，有自己的函数依赖集合

76
00:03:33,320 --> 00:03:36,090
那这些函数依赖集合

77
00:03:36,090 --> 00:03:38,530
将它们呢并起来之后

78
00:03:38,530 --> 00:03:42,640
与圆函数依赖集合是不是等价的

79
00:03:42,640 --> 00:03:44,260
如果等价

80
00:03:44,260 --> 00:03:47,100
那就能称之为保持函数依赖了

81
00:03:47,100 --> 00:03:49,850
不等价也就是没有保持

82
00:03:49,850 --> 00:03:51,720
那这个等价的地

83
00:03:51,720 --> 00:03:54,230
其实有一个特殊的概念

84
00:03:54,230 --> 00:03:58,000
我们对于冗余函数依赖

85
00:03:58,000 --> 00:04:00,540
是不需要保留的

86
00:04:12,970 --> 00:04:15,890
我们啊，以一个简单的例子呢

87
00:04:15,890 --> 00:04:19,950
先来说明一下保持函数依赖的概念

88
00:04:19,950 --> 00:04:22,940
假设原关系模式 R 

89
00:04:22,940 --> 00:04:25,320
它的二元组包含属性

90
00:04:25,320 --> 00:04:27,640
U 集合和函数依赖集合

91
00:04:27,640 --> 00:04:28,230
f 

92
00:04:28,230 --> 00:04:29,950
那属性集合有

93
00:04:29,950 --> 00:04:31,090
a 、 b 、 c 、 d 、 e 

94
00:04:31,090 --> 00:04:34,670
哎，我们的函数依赖集合包括

95
00:04:34,670 --> 00:04:40,670
A 决定 B 、 C 、 C 决定 D 、 BC 决定一、一决定 A 

96
00:04:40,670 --> 00:04:46,000
那我们分解之后包含的关系模式有

97
00:04:46,000 --> 00:04:49,860
R 1、 A 、 B 、 C 、 D 、 E 、 R 2和 CD 

98
00:04:49,860 --> 00:04:53,750
有没有保持相应的函数依赖呢

99
00:04:53,750 --> 00:04:55,010
那我们说啊

100
00:04:55,010 --> 00:04:57,380
当属性存在的时候

101
00:04:57,380 --> 00:04:59,140
它的函数依赖集合

102
00:04:59,140 --> 00:05:03,430
其实就已经随着属性保留下来了

103
00:05:03,430 --> 00:05:06,840
针对 ABCD 、 E 来看的话

104
00:05:06,840 --> 00:05:07,380
唉

105
00:05:07,380 --> 00:05:09,060
ABC 、 E 来

106
00:05:09,060 --> 00:05:13,570
这些属性之间存在哪些函数依赖呢

107
00:05:13,570 --> 00:05:18,290
它包含 A 决定 B 、 C 属性在

108
00:05:18,290 --> 00:05:20,350
所以呢，函数依赖在了

109
00:05:20,350 --> 00:05:24,530
然后哎， B 、 C 决定 E 也在

110
00:05:27,470 --> 00:05:30,710
E 决定 A 哎也在

111
00:05:33,620 --> 00:05:37,310
那这是第一个函数依赖集合

112
00:05:37,310 --> 00:05:38,890
剩下还有呢

113
00:05:38,890 --> 00:05:41,870
第二个关系模式是 C 、 D 

114
00:05:41,870 --> 00:05:46,000
那 C 和 D 之间包含的函数依赖集合是什么啊

115
00:05:46,000 --> 00:05:48,740
是 C 决定 D 

116
00:05:48,790 --> 00:05:53,170
将这两个函数依赖集合合并起来

117
00:05:53,170 --> 00:05:54,330
我们会发现

118
00:05:54,330 --> 00:05:58,540
刚好将原集合的四个函数依赖

119
00:05:58,540 --> 00:06:00,400
都保留下来了吧

120
00:06:00,400 --> 00:06:01,960
所以很显然

121
00:06:01,960 --> 00:06:04,820
第一种分解它是呢

122
00:06:04,820 --> 00:06:07,460
保持函数依赖的

123
00:06:08,760 --> 00:06:12,440
那再来看第二种分解方式

124
00:06:12,440 --> 00:06:14,750
R 1是 A 、 B 、 E 

125
00:06:14,750 --> 00:06:16,850
R 2是 C 、 D 

126
00:06:16,850 --> 00:06:19,370
那很明显我们会发现呢

127
00:06:19,370 --> 00:06:23,750
哎，我们把第一个关系模式的 C 去掉

128
00:06:23,750 --> 00:06:26,630
那 A 到 B 、 C 有没有保留啊

129
00:06:26,630 --> 00:06:29,250
没有，因为 C 不见呢

130
00:06:29,250 --> 00:06:31,880
那 BC 到 E 有没有保留呢

131
00:06:31,880 --> 00:06:34,210
没有，因为 C 不见了

132
00:06:34,210 --> 00:06:37,010
那我们保留下来的函数依赖

133
00:06:37,010 --> 00:06:40,250
只有 E 到 AC 到 D 

134
00:06:40,250 --> 00:06:44,680
那与原关系模式当中的函数依赖集合

135
00:06:44,680 --> 00:06:46,250
有没有等价

136
00:06:46,250 --> 00:06:47,940
没有等价了

137
00:06:47,940 --> 00:06:50,800
所以第二种分解方式

138
00:06:50,800 --> 00:06:54,780
它没有保持函数依赖

139
00:06:55,590 --> 00:06:57,450
那这就是呢

140
00:06:57,450 --> 00:07:00,770
关于函数依赖集合哎

141
00:07:00,770 --> 00:07:03,650
有没有保留下来的判断

142
00:07:03,650 --> 00:07:06,030
它主要呢是针对啊

143
00:07:06,030 --> 00:07:08,400
了解到这样一个特性

144
00:07:08,400 --> 00:07:10,260
属性留下来

145
00:07:10,260 --> 00:07:14,910
那相应的函数依赖也就随之保留下来了

146
00:07:14,910 --> 00:07:17,340
判断函数依赖集合

147
00:07:17,340 --> 00:07:21,960
其实判断的是函数依赖当中

148
00:07:21,960 --> 00:07:26,780
两端的决定因素和被决定因素的属性

149
00:07:26,780 --> 00:07:32,030
有没有随之保留在同一个关系模式当中

150
00:07:32,030 --> 00:07:36,000
这就是呢，保持函数依赖的判断

151
00:07:36,000 --> 00:07:40,320
那我们前面呢，还提到了一个冗余函数依赖

152
00:07:40,320 --> 00:07:42,420
它不需要被保留

153
00:07:42,420 --> 00:07:43,400
为什么呢

154
00:07:43,400 --> 00:07:46,730
我们假设还有第三种分解

155
00:07:46,730 --> 00:07:49,140
它的分解过程当中

156
00:07:49,140 --> 00:07:52,020
R 1是 A 、 B 、 C 

157
00:07:52,380 --> 00:07:56,780
R 2是 B 、 C 、 E 

158
00:07:58,440 --> 00:08:01,680
R 3是 C 和 D 

159
00:08:02,470 --> 00:08:08,500
那问大家这一种分解有没有保持函数依赖呢

160
00:08:08,500 --> 00:08:09,920
我们会发现

161
00:08:09,920 --> 00:08:11,780
针对 R 1来看

162
00:08:11,780 --> 00:08:18,030
它的函数依赖集合是 A 决定 BC 被保留了吧

163
00:08:18,030 --> 00:08:21,250
那对于第二个 F 222

164
00:08:21,250 --> 00:08:23,620
来看它的函数依赖集合

165
00:08:23,620 --> 00:08:26,880
将 BC 到一保留下来了

166
00:08:26,880 --> 00:08:29,200
再看 F 3

167
00:08:29,200 --> 00:08:34,010
它保留的函数依赖集合是 C 决定 D 吧

168
00:08:34,010 --> 00:08:39,000
那我们将这三个函数依赖集合并起来

169
00:08:39,000 --> 00:08:42,220
并入到原有的函数依赖集

170
00:08:42,220 --> 00:08:43,100
F 1撇

171
00:08:43,100 --> 00:08:44,300
我们区分一下

172
00:08:44,300 --> 00:08:48,220
F 1撇的话有 A 决定 BC 

173
00:08:48,220 --> 00:08:50,370
BC 决定 E 

174
00:08:50,370 --> 00:08:54,720
那这个地方大家会不会觉得他很熟悉呢

175
00:08:54,720 --> 00:08:59,610
其实这个就是典型的传递函数依赖吧

176
00:08:59,610 --> 00:09:03,770
那我们对保持函数依赖还提到了一个点吧

177
00:09:03,770 --> 00:09:07,460
对于冗余函数依赖不需要保留

178
00:09:07,460 --> 00:09:08,860
如何来理解

179
00:09:08,860 --> 00:09:11,620
同样我们以一个例子来说明

180
00:09:11,620 --> 00:09:13,900
假设呢，有一个关系模式

181
00:09:13,900 --> 00:09:14,340
r 

182
00:09:14,340 --> 00:09:19,550
它里面的属性集合只有 A 、 B 、 C 函数依赖集

183
00:09:19,550 --> 00:09:22,960
A 决定 BB ，决定 ca 决定 C 

184
00:09:22,960 --> 00:09:27,410
那假设分解 R 1是 ab 集合 A 

185
00:09:27,410 --> 00:09:29,860
R 1包含的是 ab 

186
00:09:29,860 --> 00:09:34,570
那它所对应的函数依赖集合是什么呢

187
00:09:34,570 --> 00:09:38,550
F 1保留的应该是 A 决定 B 

188
00:09:38,550 --> 00:09:42,650
再来看还有呢，第二个关系模式诶

189
00:09:42,650 --> 00:09:44,610
R 2包含 B 、 C 

190
00:09:44,610 --> 00:09:47,360
它所包括的函数依赖集合

191
00:09:47,360 --> 00:09:50,800
保留下来的是 B 决定 C 

192
00:09:50,800 --> 00:09:53,960
将这两个集合并入起来

193
00:09:53,960 --> 00:09:55,640
唉，我们区分一下

194
00:09:55,640 --> 00:09:57,530
记作 F 1撇的话

195
00:09:57,530 --> 00:10:01,560
它里面存在了 A 决定 B 

196
00:10:01,560 --> 00:10:03,450
B 决定 C 

197
00:10:03,450 --> 00:10:06,740
那这里大家有没有觉得很熟悉啊

198
00:10:06,740 --> 00:10:08,020
A 决定 B 

199
00:10:08,020 --> 00:10:12,430
B 决定 C 是很典型的传递函数依赖吧

200
00:10:12,430 --> 00:10:15,940
这两个函数依赖同时存在的话

201
00:10:15,940 --> 00:10:20,420
我们可以推导得出 A 决定 C 

202
00:10:20,420 --> 00:10:23,310
那这个函数依赖集合

203
00:10:23,310 --> 00:10:26,390
与原有的函数依赖集合

204
00:10:26,390 --> 00:10:29,220
是不是就等价起来了

205
00:10:29,220 --> 00:10:32,730
它所差别的 A 决定 C 

206
00:10:32,730 --> 00:10:36,340
其实是一个冗余的函数依赖吧

207
00:10:36,340 --> 00:10:40,060
所以在这里是不需要被保留的

208
00:10:40,060 --> 00:10:41,260
那也就是说

209
00:10:41,260 --> 00:10:44,400
能够被推导得出的函数依赖

210
00:10:44,400 --> 00:10:47,980
即使在分解之后的关系模式当

211
00:10:47,980 --> 00:10:49,220
没有保留

212
00:10:49,220 --> 00:10:52,620
我们也可以说它呢，逻辑蕴含

213
00:10:52,620 --> 00:10:55,330
因为可以呢，推导得出

214
00:10:55,330 --> 00:10:58,370
根据已有的函数依赖来进行推导

215
00:10:58,370 --> 00:11:01,780
仍然是保持函数依赖的

216
00:11:01,780 --> 00:11:03,980
那这里就是呢，哎

217
00:11:03,980 --> 00:11:05,020
告诉大家

218
00:11:05,020 --> 00:11:07,180
冗余函数依赖

219
00:11:07,180 --> 00:11:10,700
不需要去考虑保持函数依赖了

220
00:11:10,700 --> 00:11:12,140
那这是呢

221
00:11:12,140 --> 00:11:16,260
关于保持函数依赖的判断

222
00:11:16,540 --> 00:11:19,820
我们还有第二个维度的判断

223
00:11:19,820 --> 00:11:24,320
看分解之后的关系模式是否无损

224
00:11:24,320 --> 00:11:28,180
那什么样的分解是无损的分解呢

225
00:11:28,180 --> 00:11:31,110
我们经常在压缩的时候提到

226
00:11:31,110 --> 00:11:33,470
无损压缩这种概念

227
00:11:33,470 --> 00:11:35,160
什么叫无损压缩

228
00:11:35,160 --> 00:11:36,270
大家想一想

229
00:11:36,270 --> 00:11:37,870
平常说到压缩

230
00:11:37,870 --> 00:11:39,730
大家就想到打压缩包吧

231
00:11:39,730 --> 00:11:41,390
用好一、二、三，诶

232
00:11:41,390 --> 00:11:42,550
你打个压缩

233
00:11:42,550 --> 00:11:44,050
解压之后

234
00:11:44,050 --> 00:11:46,900
原文件是不会发生变化的吧

235
00:11:46,900 --> 00:11:49,200
也就是可以还原的

236
00:11:49,200 --> 00:11:51,930
这种呢，就叫做无损

237
00:11:51,930 --> 00:11:54,150
那还有一些压缩呢

238
00:11:54,150 --> 00:11:56,400
是可能产生损失的

239
00:11:56,400 --> 00:11:57,330
比如说呢

240
00:11:57,330 --> 00:11:58,730
像图片的话

241
00:11:58,730 --> 00:12:02,150
一般我们在用摄像机去拍摄的话

242
00:12:02,150 --> 00:12:05,500
可能是一些像 PNG 这类格式

243
00:12:05,500 --> 00:12:09,360
它的文件大小、容量其实挺大的

244
00:12:09,360 --> 00:12:12,240
那我们呢，想要给它压缩一下，诶

245
00:12:12,240 --> 00:12:14,550
把它另存为 JPG 

246
00:12:14,550 --> 00:12:15,830
这个过程呢

247
00:12:15,830 --> 00:12:18,850
我们发现图片的容量压缩很小了啊

248
00:12:18,850 --> 00:12:21,010
哎，但是一旦放大

249
00:12:21,010 --> 00:12:23,740
里面会看到马赛克能不能还原

250
00:12:23,740 --> 00:12:24,900
不能还原

251
00:12:24,900 --> 00:12:27,830
那这一类呢，就是有损的

252
00:12:27,830 --> 00:12:31,610
对于我们分解之后的关系模式

253
00:12:31,610 --> 00:12:37,580
如果啊，把大家进行自然连接和投影操作

254
00:12:37,580 --> 00:12:40,600
能够呢，还原到原来的关系模式

255
00:12:40,600 --> 00:12:44,580
我们就就叫它是无损分解

256
00:12:44,940 --> 00:12:47,480
那如果不能还原的话

257
00:12:47,480 --> 00:12:50,640
我们就说呢，它是有损的分解

258
00:12:50,640 --> 00:12:52,880
那注意我们在这里啊

259
00:12:52,880 --> 00:12:57,300
是通过自然连接仍然能够还原

260
00:12:57,300 --> 00:12:59,060
并且在这之中啊

261
00:12:59,060 --> 00:13:00,360
自然连接之后

262
00:13:00,360 --> 00:13:03,300
我们可以呢去投影相关的属性

263
00:13:03,300 --> 00:13:06,270
但是不能进行选择操作啊

264
00:13:06,270 --> 00:13:07,620
如果进行选择

265
00:13:07,620 --> 00:13:09,770
那基本上都能够还原了啊

266
00:13:09,770 --> 00:13:13,500
所以注意我们在这里只考虑自然连

267
00:13:13,500 --> 00:13:16,950
以及呢投影操作来进行还原

268
00:13:16,950 --> 00:13:20,960
那我们首先呢，从概念来进行分析的话

269
00:13:20,960 --> 00:13:25,710
假设我们现在有一个呢，关系模式成绩

270
00:13:25,710 --> 00:13:30,630
它包含学号、姓名、课程号、课程名以及分数

271
00:13:30,630 --> 00:13:32,840
函数。依赖的集合呢

272
00:13:32,840 --> 00:13:34,760
也明确告诉大家了

273
00:13:34,760 --> 00:13:39,040
学号可以决定姓名、课程号决定课程名

274
00:13:39,040 --> 00:13:42,410
学号、课程号组合决定分数

275
00:13:42,410 --> 00:13:42,810
诶

276
00:13:42,810 --> 00:13:46,190
大家首先思考一下这个关系模式

277
00:13:46,190 --> 00:13:48,250
候选键是什么啊

278
00:13:48,250 --> 00:13:49,620
第一步，诶

279
00:13:49,620 --> 00:13:51,700
判断候选件

280
00:13:54,390 --> 00:13:58,670
应该是学号、课程号的组合键吧

281
00:14:00,520 --> 00:14:03,500
那既然存在组合键

282
00:14:03,500 --> 00:14:06,730
我们就要考虑在范式判断的时候啊

283
00:14:06,730 --> 00:14:09,050
首先大家呢，没有明确说明

284
00:14:09,050 --> 00:14:11,660
都是不可再分满足第一范式

285
00:14:11,660 --> 00:14:16,030
那其中呢，非主属性姓名和课程名唉

286
00:14:16,030 --> 00:14:19,130
都是呢，部分依赖于候选键的吧

287
00:14:19,130 --> 00:14:22,210
所以它不能满足第二范式

288
00:14:22,210 --> 00:14:26,570
它的规范化程度只能达到第一范式

289
00:14:26,570 --> 00:14:28,620
达不到第二范式

290
00:14:28,620 --> 00:14:30,530
那达不到第二范式

291
00:14:30,530 --> 00:14:32,440
规范化问题就会很多

292
00:14:32,440 --> 00:14:33,270
怎么办

293
00:14:33,270 --> 00:14:36,390
哪里不符我们就拆哪里吧

294
00:14:36,390 --> 00:14:38,960
那学号、课程号不符

295
00:14:38,960 --> 00:14:41,460
我们呢，就拆学号诶

296
00:14:41,460 --> 00:14:42,640
学号、姓名不符

297
00:14:42,640 --> 00:14:44,780
把学号、姓名拆出来

298
00:14:44,780 --> 00:14:46,950
课程号、课程名不符

299
00:14:46,950 --> 00:14:50,300
把课程号、课程名拆出来

300
00:14:50,300 --> 00:14:52,970
原有的关系模式当中

301
00:14:52,970 --> 00:14:57,250
学号、课程号和分数诶，保留下来

302
00:14:57,250 --> 00:15:01,200
为什么学号和课程号要重复记录啊

303
00:15:01,200 --> 00:15:04,960
如果学号和课程号不保留

304
00:15:04,960 --> 00:15:07,810
首先我们就会知道呢

305
00:15:07,810 --> 00:15:11,620
对于分解之后的函数关系模式啊

306
00:15:11,620 --> 00:15:15,020
有没有保持函数依赖

307
00:15:23,920 --> 00:15:27,510
如果完全的去分割

308
00:15:27,510 --> 00:15:30,580
将学号、课程号给他呢

309
00:15:30,580 --> 00:15:33,610
诶，记录之后不再重复记录的话

310
00:15:33,610 --> 00:15:36,830
诶，这个函数依赖集合当中啊

311
00:15:36,830 --> 00:15:38,890
函数依赖就有丢失了

312
00:15:38,890 --> 00:15:41,380
就不会保持函数依赖了

313
00:15:41,380 --> 00:15:44,680
所以啊，学号、课程号和分

314
00:15:44,680 --> 00:15:48,900
一定呢，要一起放在关系模式当中

315
00:15:48,900 --> 00:15:52,420
那这种分解方式我们发现呢

316
00:15:52,420 --> 00:15:55,360
哎，相应的函数依赖，学号课

317
00:15:55,360 --> 00:15:58,620
学号、姓名、课程号、课程名

318
00:15:58,620 --> 00:16:03,320
还有呢，学号、课程号到分数都保留下来了吧

319
00:16:03,320 --> 00:16:05,580
那这是第一个维度

320
00:16:05,580 --> 00:16:07,820
保持函数依赖

321
00:16:07,820 --> 00:16:09,660
再来看还原

322
00:16:09,660 --> 00:16:12,320
利用自然连接来还原的话

323
00:16:12,320 --> 00:16:15,780
自然连接大家在关系代数当中呢

324
00:16:15,780 --> 00:16:19,500
学到了自然连接是同名属性列

325
00:16:19,500 --> 00:16:20,800
取值相等

326
00:16:20,800 --> 00:16:24,490
那同名的属性列有哪些呢

327
00:16:24,490 --> 00:16:27,210
首先成绩和学

328
00:16:27,210 --> 00:16:31,500
他有呢，学号来作为同名属性列吧

329
00:16:31,500 --> 00:16:36,780
那我们首先根据学号来进行还原

330
00:16:36,780 --> 00:16:40,010
还原的过程当中可以呢

331
00:16:40,010 --> 00:16:43,030
诶，找到同名属性列

332
00:16:43,030 --> 00:16:47,400
同名学号还原对应的一个姓

333
00:16:47,400 --> 00:16:48,580
与之对应

334
00:16:48,580 --> 00:16:51,320
为什么能够这样去还原

335
00:16:51,320 --> 00:16:52,780
一定要注意

336
00:16:52,780 --> 00:16:55,940
我们在做分解还原的时候

337
00:16:55,940 --> 00:16:58,730
是有一定前提条件的

338
00:16:58,730 --> 00:17:02,520
首先存在同名属性列

339
00:17:11,740 --> 00:17:15,740
并且哎，这个属性列啊

340
00:17:15,740 --> 00:17:18,300
以该属性列

341
00:17:23,980 --> 00:17:26,540
为左侧

342
00:17:28,180 --> 00:17:30,620
决定因素的

343
00:17:34,480 --> 00:17:37,360
函数依赖保留下来了

344
00:17:48,150 --> 00:17:50,070
那我们来看一下

345
00:17:50,070 --> 00:17:53,240
首先，自然连接是同名属性列

346
00:17:53,240 --> 00:17:54,300
取值相等吧

347
00:17:54,300 --> 00:17:58,990
所以一定要有同名属性列才能做自然连接

348
00:17:58,990 --> 00:17:59,330
唉

349
00:17:59,330 --> 00:18:03,550
比如说之前如果成绩没有保留学号、课程号的话

350
00:18:03,550 --> 00:18:05,900
分数跟谁做自然连接啊

351
00:18:05,900 --> 00:18:08,080
没有办法来进行还原的

352
00:18:08,080 --> 00:18:11,740
第一个前提呢，是一定有同名属性列

353
00:18:11,740 --> 00:18:16,150
其次，这个同名属性列一定是，诶

354
00:18:16,150 --> 00:18:20,210
有一个以他为左侧决定因素的函数

355
00:18:20,210 --> 00:18:22,170
依赖保留下来了

356
00:18:22,170 --> 00:18:25,450
我们呢才能随之还原

357
00:18:25,450 --> 00:18:28,440
那我们啊，可以来验证一下

358
00:18:28,440 --> 00:18:32,200
假设在这个关系模式当中

359
00:18:32,200 --> 00:18:36,500
我们分解所包含的

360
00:18:36,660 --> 00:18:42,820
成绩、学号、课程号、分数以及学生

361
00:18:44,780 --> 00:18:47,020
课程号姓名

362
00:18:51,940 --> 00:18:54,240
那在这个过程当中

363
00:18:54,240 --> 00:18:58,030
学生和成绩有没有同名属性

364
00:18:58,030 --> 00:18:59,890
列有，是谁啊

365
00:18:59,890 --> 00:19:01,710
是课程号吧

366
00:19:01,710 --> 00:19:06,390
那我们还原的时候会依次记录学号

367
00:19:06,390 --> 00:19:09,110
课程号、分数以及姓名

368
00:19:09,110 --> 00:19:12,720
看起来，诶，好像结果是一样的呀

369
00:19:12,720 --> 00:19:15,850
但是我们会发现课程

370
00:19:15,850 --> 00:19:18,760
他的姓名会产生什么情况呢

371
00:19:18,760 --> 00:19:22,610
C 01的课程号对应的姓名

372
00:19:22,610 --> 00:19:26,450
张三、李四、王五

373
00:19:26,450 --> 00:19:26,990
诶

374
00:19:26,990 --> 00:19:29,570
甚至有100条记录吧

375
00:19:29,570 --> 00:19:31,900
那我们在还原的时候

376
00:19:31,900 --> 00:19:36,870
每一个课程号 C 01对应的张三，哎

377
00:19:36,870 --> 00:19:38,010
他的分数

378
00:19:38,010 --> 00:19:40,170
根据课程号来看的话

379
00:19:40,170 --> 00:19:43,830
C 01在张三里面呢有100分

380
00:19:43,830 --> 00:19:46,230
唉，在张三里面有100分

381
00:19:46,230 --> 00:19:47,810
李四里面90分

382
00:19:47,810 --> 00:19:50,120
王五里面有85分

383
00:19:50,120 --> 00:19:53,520
这里面有没有与学号对应起来啊

384
00:19:53,520 --> 00:19:56,870
姓名与学号没有对应

385
00:19:56,870 --> 00:20:00,380
也许我们 C 01他的课程啊

386
00:20:00,380 --> 00:20:03,280
原本对应的张三学号是零一

387
00:20:03,280 --> 00:20:06,800
但是在进行自然连接还原的时候

388
00:20:06,800 --> 00:20:09,510
这里变成了 A 01

389
00:20:09,510 --> 00:20:12,090
它对应张三、李四、王五

390
00:20:12,090 --> 00:20:14,200
全部都对应了一遍

391
00:20:14,200 --> 00:20:19,330
所以啊，形成的并不是我们想要的关系模式

392
00:20:19,330 --> 00:20:23,180
它并不能唯一的与之对应

393
00:20:23,180 --> 00:20:26,460
什么样的情况下才能与之对应呢

394
00:20:26,460 --> 00:20:29,060
首先，同名属性

395
00:20:29,060 --> 00:20:32,070
它是一个左侧决定因素

396
00:20:32,070 --> 00:20:35,160
所以根据原有的学号

397
00:20:35,160 --> 00:20:39,580
可以呢，唯一确定一个姓名来进行还原

398
00:20:39,580 --> 00:20:43,080
其次，在学生关系当中

399
00:20:43,080 --> 00:20:48,570
学号和姓名之间的对应是已经保留下来的

400
00:20:48,570 --> 00:20:51,330
所以才能呢与之还原

401
00:20:51,330 --> 00:20:55,170
那还原是有呢，一定前提的

402
00:20:55,170 --> 00:20:58,310
首先要有同名属性列

403
00:20:58,390 --> 00:21:04,130
其次，以这个属性为左侧决定因素的函数

404
00:21:04,130 --> 00:21:05,760
依赖保留下来了

405
00:21:05,760 --> 00:21:09,340
那这两个条件同时满足

406
00:21:09,340 --> 00:21:10,960
我们可以呢

407
00:21:10,960 --> 00:21:15,510
在所有包含该属性列的关系模式当中

408
00:21:15,510 --> 00:21:20,390
来还原与之对应的被决定因素

409
00:21:33,470 --> 00:21:38,130
这才是唯一对应准确还原的过程

410
00:21:38,130 --> 00:21:41,620
那同样，我们再来看

411
00:21:41,620 --> 00:21:44,280
在还原的中间结果

412
00:21:44,280 --> 00:21:46,920
我们同样的可以拿来使用

413
00:21:46,920 --> 00:21:52,110
那新的成绩和课程之间有没有同名属性列

414
00:21:52,110 --> 00:21:54,200
诶，有课程号

415
00:21:54,200 --> 00:21:58,160
那有没有以课程号为左侧

416
00:21:58,160 --> 00:22:00,100
决定因素的函数依赖

417
00:22:00,100 --> 00:22:02,830
有课程号决定课程名

418
00:22:02,830 --> 00:22:05,960
这个函数依赖有没有被保留

419
00:22:05,960 --> 00:22:07,660
唉，在课程号

420
00:22:07,660 --> 00:22:10,320
课程名当中保留下来了

421
00:22:10,320 --> 00:22:15,390
那我们就可以在其他的关系模式当中

422
00:22:15,390 --> 00:22:21,240
随着课程号来还原唯一对应的课程名

423
00:22:21,240 --> 00:22:23,230
这就是呢

424
00:22:23,230 --> 00:22:25,660
做还原的过程

425
00:22:25,660 --> 00:22:27,380
考虑还原

426
00:22:27,380 --> 00:22:29,720
首先自然连接的前

427
00:22:29,720 --> 00:22:31,030
同名属性链

428
00:22:31,030 --> 00:22:36,670
其次要保留以它为左侧因素的函数依赖

429
00:22:36,670 --> 00:22:41,270
才能够还原与之对应的被决定因素

430
00:22:41,270 --> 00:22:43,950
那看起来这个分析过程

431
00:22:43,950 --> 00:22:45,610
大家是不是觉得，诶

432
00:22:45,610 --> 00:22:47,840
老师口述的比较多了呀

433
00:22:47,840 --> 00:22:49,020
那怎么办呢

434
00:22:49,020 --> 00:22:53,630
我们可以以表格法的形式来进行还原

435
00:22:53,630 --> 00:22:55,500
什么是表格法呢

436
00:22:55,500 --> 00:22:59,420
大家的教程上有标注了一定的 ab 

437
00:22:59,420 --> 00:23:01,870
这样的字母来区分

438
00:23:01,870 --> 00:23:03,920
相对来说呢，不是很明显

439
00:23:03,920 --> 00:23:05,640
所以我们做了一个优化

440
00:23:05,640 --> 00:23:08,740
直接呢，打勾、打叉表示在不在

441
00:23:08,740 --> 00:23:11,240
那我们对于表格法

442
00:23:11,240 --> 00:23:13,840
首先画一个初始表

443
00:23:13,840 --> 00:23:15,590
什么是初始表呢

444
00:23:15,590 --> 00:23:17,570
在这个表格当中

445
00:23:17,570 --> 00:23:21,210
它的列名是分解前的属性

446
00:23:21,210 --> 00:23:24,750
那原关系模式的属性包

447
00:23:24,750 --> 00:23:28,400
学号、姓名、课程号、课程名、分数

448
00:23:28,400 --> 00:23:32,280
那分解之后的属性有哪些呢

449
00:23:32,280 --> 00:23:36,430
唉，成绩包含有学号、课程号、分数

450
00:23:36,430 --> 00:23:40,920
成绩包含的学号、课程号、分数打勾

451
00:23:40,920 --> 00:23:42,460
其他呢，可以打叉

452
00:23:42,460 --> 00:23:43,910
当然你可以不打

453
00:23:43,910 --> 00:23:49,120
然后呢，学生包含学号和姓名打勾

454
00:23:49,120 --> 00:23:53,080
课程包含课程号、课程名打勾

455
00:23:53,080 --> 00:23:56,110
那这就得出了一个初始表

456
00:23:56,110 --> 00:23:59,070
那我们在分析的过程当中

457
00:23:59,070 --> 00:24:02,550
就是利用同名属性列

458
00:24:02,550 --> 00:24:08,690
查看以该属性为左侧决定因素的函数依赖

459
00:24:08,690 --> 00:24:10,030
是否保留

460
00:24:10,030 --> 00:24:11,020
保留了

461
00:24:11,020 --> 00:24:15,240
那这个同名属性列就可以随之还原

462
00:24:15,240 --> 00:24:17,640
右侧的被决定因素

463
00:24:17,640 --> 00:24:20,890
还原之后，将叉改成 J 

464
00:24:21,050 --> 00:24:25,940
那么直到有一排结果全为勾

465
00:24:25,940 --> 00:24:29,580
就说明我们呢，有一种还原方式

466
00:24:29,580 --> 00:24:32,640
可以将所有的属性还原出来

467
00:24:32,640 --> 00:24:35,090
就是呢，无损分解了

468
00:24:35,090 --> 00:24:38,550
那我们首先分析的过程找什么

469
00:24:38,550 --> 00:24:42,150
在表格当中去找同名属性列

470
00:24:42,150 --> 00:24:43,990
那这个地方就是呢

471
00:24:43,990 --> 00:24:47,110
垂直方向，在列方向上，诶

472
00:24:47,110 --> 00:24:50,380
大家呢，同时画勾的第一个学号

473
00:24:50,380 --> 00:24:55,020
那以学号为左侧决定因素的函数依赖

474
00:24:55,020 --> 00:24:58,030
去函数依赖集合看一看有没有

475
00:24:58,030 --> 00:24:59,900
有的话我们再看呢

476
00:24:59,900 --> 00:25:01,680
有没有保留下来

477
00:25:01,680 --> 00:25:04,200
唉，两个属性同时存在

478
00:25:04,200 --> 00:25:05,410
保留下来了吧

479
00:25:05,410 --> 00:25:06,470
那我们呢

480
00:25:06,470 --> 00:25:10,830
同样所有相交的学号都可以呢

481
00:25:10,830 --> 00:25:15,600
随之还原出右侧被决定因素姓名

482
00:25:15,600 --> 00:25:19,870
那再接着往下找还原之后

483
00:25:19,870 --> 00:25:22,550
下一个同名属性列是谁呢

484
00:25:22,550 --> 00:25:24,540
其实是姓名

485
00:25:24,540 --> 00:25:29,290
那有没有姓名为左侧决定因素的函数依赖

486
00:25:29,290 --> 00:25:30,030
没有

487
00:25:30,030 --> 00:25:31,830
所以它没有用

488
00:25:31,830 --> 00:25:34,790
下面呢，再来看同名属性列

489
00:25:34,790 --> 00:25:37,620
下一个应该是课程号了

490
00:25:37,620 --> 00:25:39,940
那课程号有没有

491
00:25:39,940 --> 00:25:44,140
以课程号为左侧决定因素的函数依赖呢

492
00:25:44,140 --> 00:25:45,660
哎，同样有

493
00:25:45,660 --> 00:25:49,000
那看一看下一步考虑有没有保留

494
00:25:49,000 --> 00:25:50,340
保留下来了

495
00:25:50,340 --> 00:25:52,590
我们就可以呢，进行还原

496
00:25:52,590 --> 00:25:58,390
那将课程号与之对应的课程名来进行还原

497
00:25:58,390 --> 00:26:00,470
这种还原之后啊

498
00:26:00,470 --> 00:26:02,010
就会发现，诶

499
00:26:02,010 --> 00:26:05,150
某一排，也就是成绩

500
00:26:05,150 --> 00:26:08,440
这一排五个属性都画勾了

501
00:26:08,440 --> 00:26:11,700
只要有一排全部为勾

502
00:26:11,700 --> 00:26:15,520
那说明我们就是可以还原

503
00:26:15,520 --> 00:26:16,920
它也就是呢

504
00:26:16,920 --> 00:26:19,160
无损分解的形式
