1
00:00:00,000 --> 00:00:03,520
接下来，我们来看到规范化理论当中

2
00:00:03,520 --> 00:00:05,320
很重要的一个部分

3
00:00:05,320 --> 00:00:06,860
规范化程度

4
00:00:06,860 --> 00:00:07,780
也就是呢

5
00:00:07,780 --> 00:00:09,140
范式的判断

6
00:00:09,140 --> 00:00:13,210
我们在正向做数据库设计的时候啊

7
00:00:13,210 --> 00:00:15,050
我们的关系模式呢

8
00:00:15,050 --> 00:00:16,390
生成的过程当中

9
00:00:16,390 --> 00:00:19,450
需要考虑压转关系模式的原则

10
00:00:19,450 --> 00:00:22,770
还需要呢，考虑规范化理论的原则

11
00:00:22,770 --> 00:00:25,230
当然，在现今阶段的话

12
00:00:25,230 --> 00:00:28,830
我们啊，考虑到数据查询用的比较多呢

13
00:00:28,830 --> 00:00:31,520
也有反规范化的实现

14
00:00:31,520 --> 00:00:34,930
呃，但是在我们的软件设计师考试当中

15
00:00:34,930 --> 00:00:39,250
目前要求大家掌握的还是规范化理论这方面

16
00:00:39,250 --> 00:00:42,080
那规范化理论的考察呢

17
00:00:42,080 --> 00:00:44,480
主要在上午题部分

18
00:00:44,480 --> 00:00:47,130
会给大家一定的情景

19
00:00:47,130 --> 00:00:49,250
来判断相应关系模

20
00:00:49,250 --> 00:00:50,950
它的规范化程度

21
00:00:50,950 --> 00:00:52,730
而在下午题当中

22
00:00:52,730 --> 00:00:56,740
可能会考察大家出现的规范化问题

23
00:00:56,740 --> 00:00:59,300
以及呢，如何来解决

24
00:00:59,300 --> 00:01:02,530
那针对这一部分而言的话

25
00:01:02,530 --> 00:01:06,320
我们啊，主要呢，是掌握范式的判断

26
00:01:06,320 --> 00:01:09,260
那第一范式、第二范式、第三范

27
00:01:09,260 --> 00:01:11,400
以及 BC 范式的判断

28
00:01:11,400 --> 00:01:13,270
还要求大家掌握呢

29
00:01:13,270 --> 00:01:14,850
一、二、三范式

30
00:01:14,850 --> 00:01:17,290
它不满足的时候如何呢

31
00:01:17,290 --> 00:01:19,900
来提高它的规范化程度

32
00:01:19,900 --> 00:01:21,920
首先我们看到，诶

33
00:01:21,920 --> 00:01:23,760
为什么要有规范化

34
00:01:23,760 --> 00:01:26,260
下面给了我们一个关系模式

35
00:01:26,260 --> 00:01:27,670
它比较简单啊

36
00:01:27,670 --> 00:01:29,420
这个关系模式当中呢

37
00:01:29,420 --> 00:01:30,860
有学生姓名

38
00:01:30,860 --> 00:01:34,820
选修课名、任课教师名和任课教师地址

39
00:01:34,820 --> 00:01:39,320
那我们呢，首先会看到下面这个表格

40
00:01:39,320 --> 00:01:41,300
看上去第一反应

41
00:01:41,300 --> 00:01:43,970
大家会发现什么样的问题啊

42
00:01:43,970 --> 00:01:44,710
啊

43
00:01:44,710 --> 00:01:48,630
这里有大部分的大篇幅的数据

44
00:01:48,630 --> 00:01:50,580
都是重复记录吧

45
00:01:50,580 --> 00:01:53,000
为什么会有重复记录啊

46
00:01:53,000 --> 00:01:57,920
这里面其实就是规范化程度不高形成的

47
00:01:57,920 --> 00:02:02,060
那我们会发现这一类关系模式存在的

48
00:02:02,060 --> 00:02:03,100
第一个问题呢

49
00:02:03,100 --> 00:02:04,890
就是数据冗余

50
00:02:04,890 --> 00:02:08,009
有大量的重复数据记录

51
00:02:08,009 --> 00:02:09,800
占用了我们的空间

52
00:02:09,800 --> 00:02:13,400
并且这些记录其实是没有必要的

53
00:02:13,400 --> 00:02:15,560
那这就是呢，数据冗余

54
00:02:15,560 --> 00:02:18,490
其次，在这个数据当中

55
00:02:18,490 --> 00:02:22,290
如果我们的老师发生了变化

56
00:02:22,290 --> 00:02:25,190
或者他居住的地址发生变化的话

57
00:02:25,190 --> 00:02:27,980
我们在修改的过程当中啊

58
00:02:27,980 --> 00:02:30,840
容易呢出现不一致的情况

59
00:02:30,840 --> 00:02:32,800
因为数据量比较多的话

60
00:02:32,800 --> 00:02:35,990
可能呢会产生修改异常

61
00:02:35,990 --> 00:02:39,270
也就是修改数据不一致

62
00:02:43,440 --> 00:02:45,020
不仅如此

63
00:02:45,020 --> 00:02:47,340
我们在这个过程当中啊

64
00:02:47,340 --> 00:02:50,590
如果要插入一个新的数据

65
00:02:50,590 --> 00:02:51,550
比如说呢

66
00:02:51,550 --> 00:02:53,110
新来了一名老师

67
00:02:53,110 --> 00:02:57,380
但是他还没有参与选修课程的话

68
00:02:57,380 --> 00:02:59,410
记录老师信息

69
00:02:59,410 --> 00:03:01,490
但没有学生姓名

70
00:03:01,490 --> 00:03:03,160
能不能插入进去啊

71
00:03:03,160 --> 00:03:06,020
我们会发现在这个关系模式当中

72
00:03:06,020 --> 00:03:09,280
它的主见其实是学生姓名

73
00:03:09,280 --> 00:03:12,240
而学生姓名为空的时候

74
00:03:12,240 --> 00:03:14,660
我们会插入异常

75
00:03:14,660 --> 00:03:16,590
所以插不进去

76
00:03:16,590 --> 00:03:18,030
逐渐会为空

77
00:03:18,030 --> 00:03:19,770
那这个情况下呢

78
00:03:19,770 --> 00:03:22,110
诶，就叫做插入异常

79
00:03:22,110 --> 00:03:24,130
最后还有一个问题呢

80
00:03:24,130 --> 00:03:26,090
就是删除异常

81
00:03:26,090 --> 00:03:28,410
删除异常一方面呢

82
00:03:28,410 --> 00:03:30,970
是当学生毕业了

83
00:03:30,970 --> 00:03:34,250
我们把相应的选课记录删掉的话

84
00:03:34,250 --> 00:03:37,860
这个教师信息啊，会被删除掉

85
00:03:37,860 --> 00:03:41,510
其次，如果这个教师离职了

86
00:03:41,510 --> 00:03:44,360
我们将教师信息删除的话

87
00:03:44,360 --> 00:03:48,840
相应的学生选课记录也会呢，随之被删除

88
00:03:48,840 --> 00:03:51,840
这就是呢，删除异常

89
00:03:52,220 --> 00:03:54,200
那我们目前啊

90
00:03:54,200 --> 00:03:57,920
不管规范化程度到了第几级别

91
00:03:57,920 --> 00:04:01,860
只要没有到达第三范式

92
00:04:03,000 --> 00:04:06,200
我们认为啊，这个关系模

93
00:04:06,200 --> 00:04:10,160
这四个规范化问题都会存在

94
00:04:10,160 --> 00:04:14,420
所以如果在考试当中碰到问大家

95
00:04:14,420 --> 00:04:17,980
这个关系模式存在什么样的规范化问题

96
00:04:17,980 --> 00:04:20,410
只要没有达到第三范式

97
00:04:20,410 --> 00:04:22,630
这些问题都避免不了

98
00:04:22,630 --> 00:04:26,530
那大家呢，可以把这些都给呢，列举出来

99
00:04:26,530 --> 00:04:30,660
那如果在下午的软件数据库设计题当中啊

100
00:04:30,660 --> 00:04:31,850
问大家的话

101
00:04:31,850 --> 00:04:35,400
一般呢，把问题的名称写出来就可以了

102
00:04:35,400 --> 00:04:38,180
不需要大家呢详细的去描述

103
00:04:38,180 --> 00:04:41,660
具体啊，可以呢，看分值来决定

104
00:04:41,660 --> 00:04:44,400
那这是规范化存在的问题

105
00:04:44,400 --> 00:04:47,110
有这样的问题如何来解决呢

106
00:04:47,110 --> 00:04:49,630
就有了规范化的过程

107
00:04:49,630 --> 00:04:50,810
那我们啊

108
00:04:50,810 --> 00:04:54,440
先来看一下规范化它的程度判断

109
00:04:54,440 --> 00:04:57,670
首先判断的是第一范式

110
00:04:57,670 --> 00:04:59,700
什么是第一范式呢

111
00:04:59,700 --> 00:05:02,740
它是要求在关系模式当中

112
00:05:02,740 --> 00:05:05,100
所有的属性都是呢

113
00:05:05,100 --> 00:05:07,430
不可再分的数据项

114
00:05:07,430 --> 00:05:09,680
那什么是可再分

115
00:05:09,680 --> 00:05:11,240
什么是不可再分呢

116
00:05:11,240 --> 00:05:14,350
一般题目会明确告诉大家

117
00:05:14,350 --> 00:05:16,490
比如说呢，关系模式二

118
00:05:16,490 --> 00:05:19,890
有系名称和高级职称人数

119
00:05:19,890 --> 00:05:22,270
给了我们相应的表格

120
00:05:22,270 --> 00:05:22,730
诶

121
00:05:22,730 --> 00:05:25,170
系名称、高级职称人数

122
00:05:25,170 --> 00:05:26,250
很显然

123
00:05:26,250 --> 00:05:28,240
将高级职称人

124
00:05:28,240 --> 00:05:29,360
细分为了

125
00:05:29,360 --> 00:05:31,900
教授人数和副教授人数吧

126
00:05:31,900 --> 00:05:35,030
那这个可再分的情况下

127
00:05:35,030 --> 00:05:37,860
形成的还是不是二维表啊

128
00:05:37,860 --> 00:05:39,700
并不是二维表了

129
00:05:39,700 --> 00:05:43,250
也就是说，我们在建表的过程当中

130
00:05:43,250 --> 00:05:47,010
它至少是满足第一范式才能建表

131
00:05:47,010 --> 00:05:48,980
也在这里呀

132
00:05:48,980 --> 00:05:52,120
这种过程当中我们会发现呢

133
00:05:52,120 --> 00:05:55,360
哎，不满足第一范式见表都会呢

134
00:05:55,360 --> 00:05:56,670
失败怎么办

135
00:05:56,670 --> 00:06:01,900
我们需要把它拆成教授和副教授人数

136
00:06:01,900 --> 00:06:05,550
当然我们也可以呢，单独列一个表

137
00:06:05,550 --> 00:06:09,220
高级职称总人数来求和

138
00:06:09,220 --> 00:06:12,190
能够求和的是什么样的属性啊

139
00:06:12,190 --> 00:06:13,490
大家想一想

140
00:06:13,630 --> 00:06:16,590
能够求和求出来

141
00:06:16,590 --> 00:06:19,090
我们叫做呢，派生属性

142
00:06:19,090 --> 00:06:22,240
那这就是呢，第一范式的判断

143
00:06:22,240 --> 00:06:24,820
那我们在做题的过程当中啊

144
00:06:24,820 --> 00:06:28,460
一般至少是能够达到第一范式的

145
00:06:28,460 --> 00:06:30,170
如果没有达到

146
00:06:30,170 --> 00:06:34,230
他会明确告诉你哪些属性可拆分

147
00:06:34,230 --> 00:06:38,060
那再来看，对于第二范式来说的话

148
00:06:38,060 --> 00:06:42,620
它一定是在第一范式基础上的一个递进

149
00:06:42,620 --> 00:06:47,910
那第二范式它是当且仅当满足第一范式

150
00:06:47,910 --> 00:06:54,280
并且每一个非主属性完全依赖于候选键

151
00:06:54,280 --> 00:06:56,790
也就是说没有不完全依赖了

152
00:06:56,790 --> 00:06:58,580
那这个过程当中

153
00:06:58,580 --> 00:07:00,940
大家看到的关键字有哪些啊

154
00:07:00,940 --> 00:07:06,230
非主属性完全依赖和候选键

155
00:07:06,230 --> 00:07:09,980
那我们根据下面的例题来看

156
00:07:09,980 --> 00:07:12,650
假设有一个关系模式

157
00:07:12,650 --> 00:07:15,890
包含学号、课程号、成绩和分数

158
00:07:15,890 --> 00:07:19,120
其中学号、课程号决定成绩

159
00:07:19,120 --> 00:07:21,350
课程后决定学分

160
00:07:21,350 --> 00:07:25,050
那我们在这个表格当中

161
00:07:25,050 --> 00:07:27,300
首先会看到，诶

162
00:07:27,300 --> 00:07:31,540
相应的部分有很大一部分的数据冗余吧

163
00:07:31,540 --> 00:07:34,500
那这一部分数据冗余，唉

164
00:07:34,500 --> 00:07:38,140
很明显有数据冗余其实就会存在

165
00:07:38,140 --> 00:07:40,490
更新的时候很容易呢

166
00:07:40,490 --> 00:07:43,390
更新不完全导致呢，数据不一致

167
00:07:43,390 --> 00:07:44,570
更新异常

168
00:07:44,570 --> 00:07:48,100
那如果新加一个课程没有人选修呢

169
00:07:48,100 --> 00:07:50,540
诶，就会有插入异常

170
00:07:50,540 --> 00:07:54,860
如果说删除相应的这些记录

171
00:07:54,860 --> 00:07:58,800
很有可能的课程信息就直接被删除了

172
00:07:58,800 --> 00:08:01,920
那这是呢，非规范化的问题吧

173
00:08:01,930 --> 00:08:04,190
从这里来看的话

174
00:08:04,190 --> 00:08:06,150
首先我们判断一

175
00:08:06,150 --> 00:08:08,730
对于这个关系模式

176
00:08:08,730 --> 00:08:10,860
它的候选键是什么

177
00:08:10,860 --> 00:08:15,980
做范式判断的第一步是找候选键

178
00:08:22,000 --> 00:08:23,660
大家想一想

179
00:08:23,660 --> 00:08:26,500
根据函数依赖来看的话

180
00:08:26,500 --> 00:08:30,810
入度为零的属性是学号课程号

181
00:08:30,810 --> 00:08:33,440
诶，很明显这是一个组合键吧

182
00:08:33,440 --> 00:08:35,900
缺了一部分都不行

183
00:08:35,900 --> 00:08:40,200
那对于这个组合键找到了是候选键

184
00:08:40,200 --> 00:08:41,480
第二步诶

185
00:08:41,480 --> 00:08:43,840
找非主属性

186
00:08:47,460 --> 00:08:49,740
非主属性有哪些呢

187
00:08:49,740 --> 00:08:55,260
除了学号、课程号以外的有成绩和学分

188
00:08:59,060 --> 00:09:01,900
那第三步判断呢

189
00:09:01,900 --> 00:09:03,740
哎，我们的判断依据

190
00:09:03,740 --> 00:09:05,220
这里我们呢

191
00:09:05,220 --> 00:09:08,130
首先在第一范式的基础

192
00:09:08,130 --> 00:09:09,930
判断是否有

193
00:09:09,930 --> 00:09:14,410
哎，第二范式判断是否存在

194
00:09:18,100 --> 00:09:25,460
非主属性对候选键的部分函数依赖

195
00:09:25,460 --> 00:09:27,670
那什么是部分函数依赖

196
00:09:27,670 --> 00:09:28,570
还记得吗

197
00:09:28,570 --> 00:09:31,030
候选键是一个整体

198
00:09:31,030 --> 00:09:34,060
其中的一部分课程号

199
00:09:34,060 --> 00:09:37,920
它可以决定非主属性学分

200
00:09:37,920 --> 00:09:40,540
所以这里存在

201
00:09:40,540 --> 00:09:43,940
非主属性对候选键的部分函数依赖吧

202
00:09:43,940 --> 00:09:47,330
存在这种部分函数依赖

203
00:09:47,330 --> 00:09:50,460
是不是就没有满足完全依赖啦

204
00:09:50,460 --> 00:09:52,120
所以在这里

205
00:09:52,120 --> 00:09:55,540
它能够满足的规范化程度

206
00:09:55,540 --> 00:09:59,280
只有第一范式最高

207
00:09:59,280 --> 00:10:01,880
能不能达到第二范式呢

208
00:10:01,880 --> 00:10:04,250
没有达到第二范式

209
00:10:04,250 --> 00:10:08,070
那如何来解决这些问题呢

210
00:10:08,070 --> 00:10:11,950
我们现在不满足第二范式是为什么

211
00:10:11,950 --> 00:10:15,810
是因为课程号能够决定学

212
00:10:15,810 --> 00:10:16,790
这一部分

213
00:10:16,790 --> 00:10:18,790
是部分函数依赖吧

214
00:10:18,790 --> 00:10:21,460
既然存在部分函数依赖

215
00:10:21,460 --> 00:10:23,240
所以不满足第二范式

216
00:10:23,240 --> 00:10:26,460
那我们就把它呢分割出

217
00:10:26,460 --> 00:10:28,400
新的关系模式

218
00:10:28,400 --> 00:10:31,580
将课程号学分

219
00:10:32,400 --> 00:10:33,880
分割

220
00:10:35,340 --> 00:10:39,660
分割之后剩余的关系模式

221
00:10:39,660 --> 00:10:41,610
哎，学号还在

222
00:10:41,610 --> 00:10:44,740
课程号能不能完全被分出去呢

223
00:10:44,740 --> 00:10:45,340
不能

224
00:10:45,340 --> 00:10:47,140
如果完全分割了

225
00:10:47,140 --> 00:10:48,720
这就形成了两个表

226
00:10:48,720 --> 00:10:51,060
我们没办法还原了

227
00:10:51,060 --> 00:10:52,970
那我们在后面呢，会讲

228
00:10:52,970 --> 00:10:55,410
在做模式分解的时

229
00:10:55,410 --> 00:10:57,490
要保持函数依赖

230
00:10:57,490 --> 00:10:58,790
还要呢，哎

231
00:10:58,790 --> 00:11:00,010
可还原吧

232
00:11:00,010 --> 00:11:01,850
那这个过程当中

233
00:11:01,850 --> 00:11:04,750
学号还有课程

234
00:11:04,890 --> 00:11:07,810
可以呢，决定成绩

235
00:11:07,810 --> 00:11:12,650
那这一部分如果做分割课程号的话

236
00:11:12,650 --> 00:11:15,100
这个函数依赖其实也会丢失

237
00:11:15,100 --> 00:11:16,580
我们可以认为啊

238
00:11:16,580 --> 00:11:18,640
在分割的过程当中

239
00:11:18,640 --> 00:11:21,820
候选键是不会发生变化的

240
00:11:21,820 --> 00:11:26,120
只需要呢，把相应的函数依赖分割之后

241
00:11:26,120 --> 00:11:30,260
保留剩下的非主属性就可以了

242
00:11:30,260 --> 00:11:33,550
那这样的分割结束之后啊

243
00:11:33,550 --> 00:11:38,180
就可以解决我们学分的诶，冗余了

244
00:11:38,180 --> 00:11:41,880
那相应的数据冗余产生的一系列问题呢

245
00:11:41,880 --> 00:11:44,270
也就随之可以避免了

246
00:11:44,270 --> 00:11:45,680
这种情况下

247
00:11:45,680 --> 00:11:50,220
它是能够达到第二范式的

248
00:11:51,620 --> 00:11:56,480
那这是关于第二范式它的判断以及呢分解

249
00:11:56,480 --> 00:12:00,120
接下来再来看一下第三范式

250
00:12:00,120 --> 00:12:03,570
那第三范式他的判断依据

251
00:12:03,570 --> 00:12:06,600
首先是至少满足第二范式的

252
00:12:06,600 --> 00:12:10,500
我们的范式判断是层层递进的

253
00:12:10,500 --> 00:12:13,790
满足第一范式才会考虑第二范式

254
00:12:13,790 --> 00:12:18,040
满足第二范式才会考虑呢第三范式

255
00:12:18,040 --> 00:12:21,460
那第三范式他的要求

256
00:12:21,460 --> 00:12:23,970
没有非主属性

257
00:12:23,970 --> 00:12:26,510
传递依赖于候选键

258
00:12:26,510 --> 00:12:28,430
又是三个关键字吧

259
00:12:28,430 --> 00:12:30,230
非主属性候选键

260
00:12:30,230 --> 00:12:32,530
还有传递函数依赖

261
00:12:32,530 --> 00:12:34,810
我们看一下下面这个例子

262
00:12:34,810 --> 00:12:40,660
假设学生关系有学号、姓名、序号、姓名称、系位置

263
00:12:40,660 --> 00:12:43,130
那我们在这个过程当中

264
00:12:43,130 --> 00:12:46,210
属性分别第二代表了学号

265
00:12:46,210 --> 00:12:48,700
姓名所在的系号

266
00:12:48,700 --> 00:12:50,680
那这个过程当中

267
00:12:50,680 --> 00:12:53,780
系号能不能决定姓名啊

268
00:12:53,780 --> 00:12:54,780
肯定可以呀

269
00:12:54,780 --> 00:12:59,460
戏号能不能决定系位置也是可以的

270
00:12:59,460 --> 00:13:01,830
下面给了我们一个表格

271
00:13:01,830 --> 00:13:06,270
我们发现里面又有大篇幅的数据冗余吧

272
00:13:06,270 --> 00:13:08,750
那数据冗余就会存在

273
00:13:08,750 --> 00:13:12,430
哎，如果说修改计算机相关信息的话

274
00:13:12,430 --> 00:13:14,620
可能呢，会修改异常

275
00:13:14,620 --> 00:13:18,180
有一个新增的这种呢系还没有呢

276
00:13:18,180 --> 00:13:20,810
招生会插入异常

277
00:13:20,810 --> 00:13:23,550
再加上呢，哎，一旦删除

278
00:13:23,550 --> 00:13:26,010
可能会删除掉相应信息

279
00:13:26,010 --> 00:13:29,180
所以可能会有呢删除异常

280
00:13:29,180 --> 00:13:31,170
哎，插入的时候没有主见

281
00:13:31,170 --> 00:13:32,110
没办法插

282
00:13:32,110 --> 00:13:33,670
更新的时候可能不一致

283
00:13:33,670 --> 00:13:36,770
这些啊，都是它的非规范化问题

284
00:13:36,770 --> 00:13:39,790
那从这个例子来看的话

285
00:13:39,790 --> 00:13:41,710
它的主见是谁啊

286
00:13:41,710 --> 00:13:44,750
第一步还是找候选键吧

287
00:13:50,760 --> 00:13:53,080
我们会发现唉

288
00:13:53,080 --> 00:13:55,240
所谓的函数依赖

289
00:13:55,240 --> 00:13:58,920
其实就是存在于属性之间的吧

290
00:13:58,920 --> 00:14:00,440
找到学号

291
00:14:00,440 --> 00:14:02,700
我们可以找到对应的姓名

292
00:14:02,700 --> 00:14:04,500
和他所在的信号吧

293
00:14:04,500 --> 00:14:08,820
那再通过信号可以找到其他的非主属性

294
00:14:08,820 --> 00:14:11,830
那他的候选件是什么呢

295
00:14:11,830 --> 00:14:14,930
候选键就是学号

296
00:14:14,930 --> 00:14:17,090
那我们想一想啊

297
00:14:17,090 --> 00:14:19,310
针对学号来看

298
00:14:19,310 --> 00:14:21,710
它只有单属性吧

299
00:14:21,710 --> 00:14:24,430
单属性候选键

300
00:14:34,940 --> 00:14:38,930
会不会存在非主属性的部分函数依赖啊

301
00:14:38,930 --> 00:14:40,590
只有一个属性

302
00:14:40,590 --> 00:14:42,010
你还怎么不分呢

303
00:14:42,010 --> 00:14:43,510
是切不开的

304
00:14:43,510 --> 00:14:45,700
那这种情况下

305
00:14:45,700 --> 00:14:49,630
至少是满足第二范式的

306
00:14:51,240 --> 00:14:54,460
因为我们在分析的过程当中啊

307
00:14:54,460 --> 00:14:57,330
一般属性是默认不可再分的

308
00:14:57,330 --> 00:15:01,220
所以他至少满足第一范式不可再分

309
00:15:01,220 --> 00:15:04,710
现在候选件又只有单个属性

310
00:15:04,710 --> 00:15:06,950
不存在非主属性

311
00:15:06,950 --> 00:15:09,330
对候选键的部分函数依赖了吧

312
00:15:09,330 --> 00:15:12,250
所以至少满足了第二范式

313
00:15:12,250 --> 00:15:15,170
那满足第二范式的基础上

314
00:15:15,170 --> 00:15:17,790
再来看是否满足第三范式

315
00:15:17,790 --> 00:15:19,760
有了学号

316
00:15:19,760 --> 00:15:23,830
其他的都是非主属性

317
00:15:23,830 --> 00:15:27,300
那对这个非主属性而言

318
00:15:27,300 --> 00:15:30,960
我们发现学号决定系号

319
00:15:30,960 --> 00:15:32,920
系号决定姓名

320
00:15:32,920 --> 00:15:34,420
决定系位置

321
00:15:34,420 --> 00:15:39,070
那非主属性通过非主属性传递

322
00:15:39,070 --> 00:15:40,570
依赖于候选键

323
00:15:40,570 --> 00:15:41,870
这种情况下

324
00:15:41,870 --> 00:15:43,430
我们说他呢

325
00:15:43,430 --> 00:15:46,230
不满足第三范式

326
00:15:46,230 --> 00:15:49,600
那这个地方找到相应的候选键

327
00:15:49,600 --> 00:15:50,840
非主属性呢

328
00:15:50,840 --> 00:15:53,930
下面判断呢，是否满足第二范式

329
00:15:53,930 --> 00:15:55,780
满足第二范式的话

330
00:15:55,780 --> 00:16:00,080
再考虑呢，是否满足第三范式的过程

331
00:16:00,080 --> 00:16:04,380
那这就是呢，我们规范化判断的依据

332
00:16:04,380 --> 00:16:07,170
那既然说存在这些问题

333
00:16:07,170 --> 00:16:09,900
因为传递函数依赖才存在的

334
00:16:09,900 --> 00:16:12,460
那我们把传递函数依赖，哎

335
00:16:12,460 --> 00:16:14,360
把它分割出来

336
00:16:14,360 --> 00:16:17,490
哪里不满足我们就拆哪里

337
00:16:17,490 --> 00:16:19,300
信号决定姓名

338
00:16:19,300 --> 00:16:21,180
系号决定细位置

339
00:16:21,180 --> 00:16:23,780
那不满足我们就拆出来

340
00:16:23,780 --> 00:16:25,120
系号

341
00:16:25,640 --> 00:16:29,120
姓名系位置

342
00:16:31,720 --> 00:16:35,540
相应的，剩余部分学号不变

343
00:16:35,540 --> 00:16:36,930
姓名不变

344
00:16:36,930 --> 00:16:40,030
那为了保持将它还原的话

345
00:16:40,030 --> 00:16:44,310
我们的信号也要呢随之保留下来

346
00:16:44,310 --> 00:16:46,720
分割出去的候选键啊

347
00:16:46,720 --> 00:16:49,800
要与它呢能够啊联系起来

348
00:16:49,800 --> 00:16:52,130
所以这个信号呢也会保留

349
00:16:52,130 --> 00:16:53,740
这种情况下

350
00:16:53,740 --> 00:16:56,420
候选键这里的候选键是学号

351
00:16:56,420 --> 00:16:58,940
这里的候选键呢，是细号

352
00:16:58,940 --> 00:17:03,650
哎，这两个关系模式都能够满足第三范式了

353
00:17:03,650 --> 00:17:05,109
首先不可再分

354
00:17:05,109 --> 00:17:07,130
然后没有部分函数依赖

355
00:17:07,130 --> 00:17:09,680
最后呢，没有传递函数依赖

356
00:17:09,680 --> 00:17:12,380
所以呢，满足第三范式

357
00:17:12,380 --> 00:17:15,200
这就是第三范式的判断
