1
00:00:00,000 --> 00:00:01,880
那接下来我们呢

2
00:00:01,880 --> 00:00:04,260
来看一个简单的例子

3
00:00:04,260 --> 00:00:07,640
诶，这个例子呢，相对来说要简单一些

4
00:00:07,640 --> 00:00:09,820
画表格呢，也比较简洁

5
00:00:09,820 --> 00:00:13,920
首先我们假设 A 的属性有 A 、 B 、 

6
00:00:13,920 --> 00:00:15,400
函数依赖集合

7
00:00:15,400 --> 00:00:16,510
A 决定 B 

8
00:00:16,510 --> 00:00:17,560
那我们看

9
00:00:17,560 --> 00:00:21,420
对于分解 R 1 A 、 B 22、 A 、 C 来看的话

10
00:00:21,420 --> 00:00:22,990
先看这种

11
00:00:22,990 --> 00:00:25,620
那我们第一步干什么呢

12
00:00:25,620 --> 00:00:27,910
画一个初始表

13
00:00:27,910 --> 00:00:31,860
A 、 B 、 C 属性在集合当中

14
00:00:31,860 --> 00:00:33,940
R 1包含 A 、 B 

15
00:00:33,940 --> 00:00:36,440
R 2包含 A 、 C 

16
00:00:36,440 --> 00:00:37,590
找什么

17
00:00:37,590 --> 00:00:41,620
接下来找同名属性列 A 

18
00:00:41,620 --> 00:00:47,310
有没有以 A 为左侧决定因素的函数依赖呢

19
00:00:47,310 --> 00:00:48,210
有

20
00:00:48,210 --> 00:00:51,750
那 A 到 B 有没有保留下来

21
00:00:51,750 --> 00:00:53,130
保留下来了

22
00:00:53,130 --> 00:00:56,360
那我们可以通过相交的属性

23
00:00:56,360 --> 00:00:58,060
来还原

24
00:00:58,060 --> 00:01:01,040
右侧的被决定因素

25
00:01:01,040 --> 00:01:03,800
那将 B 的 J 换成 A 

26
00:01:03,800 --> 00:01:05,379
B 的差换成 J 

27
00:01:05,379 --> 00:01:09,100
那这在现在在 R 2当中

28
00:01:09,100 --> 00:01:11,480
ABC 全围够了吧

29
00:01:11,480 --> 00:01:14,360
也就是说此时还原呢

30
00:01:14,360 --> 00:01:17,860
这种呢，就是无损分解了

31
00:01:17,860 --> 00:01:19,420
那我们可以看到

32
00:01:19,420 --> 00:01:21,530
在这个分解当中

33
00:01:21,530 --> 00:01:25,340
A 决定 B 函数依赖有没有保留啊

34
00:01:25,340 --> 00:01:26,280
保留了

35
00:01:26,280 --> 00:01:29,720
所以它保持函数依赖

36
00:01:29,720 --> 00:01:31,790
并且无损

37
00:01:35,260 --> 00:01:38,560
注意，这是两个不同的维度

38
00:01:38,560 --> 00:01:40,880
有四种排列组合方式啊

39
00:01:40,880 --> 00:01:44,090
那接下来再看第二种分解

40
00:01:44,090 --> 00:01:47,670
R 1、 A 、 B 2、三、 B 、 C 

41
00:01:47,670 --> 00:01:50,170
同样先画初始表

42
00:01:50,170 --> 00:01:53,660
那 A 、 B 包含 A 到 B 吧

43
00:01:53,660 --> 00:01:56,410
然后呢， B 、 C 、 A 、 B 和 

44
00:01:56,410 --> 00:02:00,700
在这里， A 、 B 保持了函数依赖

45
00:02:03,240 --> 00:02:05,340
能否还原呢

46
00:02:05,340 --> 00:02:09,380
我们会发现 ab 和 B

47
00:02:09,380 --> 00:02:11,890
第一步找同名属性列

48
00:02:11,890 --> 00:02:15,140
有没有有比有没有

49
00:02:15,140 --> 00:02:19,070
以 B 为左侧决定因素的函数依

50
00:02:19,070 --> 00:02:20,610
A 没有

51
00:02:20,610 --> 00:02:23,210
所以能不能往下去分析

52
00:02:23,210 --> 00:02:24,130
不能

53
00:02:24,130 --> 00:02:25,780
B 没有用

54
00:02:25,780 --> 00:02:28,910
有没有其他的同名属性列

55
00:02:28,910 --> 00:02:30,490
唉，没有了

56
00:02:30,490 --> 00:02:33,060
所以做不了还原的工作

57
00:02:33,060 --> 00:02:36,000
那这里第二种分解就是呢

58
00:02:36,000 --> 00:02:38,680
有损的啊

59
00:02:41,000 --> 00:02:43,740
所以对于分解二来说

60
00:02:43,740 --> 00:02:46,240
它是保持了函数依赖

61
00:02:46,240 --> 00:02:49,310
但它是呢有损分解

62
00:02:49,310 --> 00:02:54,420
那有没有哎，既不保持函数依赖

63
00:02:55,150 --> 00:02:57,290
也有损的呢

64
00:02:57,290 --> 00:03:00,710
哎，有，我们在这里会发现呢

65
00:03:00,710 --> 00:03:03,470
如果分解的过程当中

66
00:03:03,470 --> 00:03:05,420
我们把 A 分开

67
00:03:05,420 --> 00:03:07,890
然后呢 B 、 C 分开

68
00:03:07,890 --> 00:03:09,430
这个过程当

69
00:03:09,430 --> 00:03:11,570
既没有保持函数依赖

70
00:03:11,570 --> 00:03:14,970
还是呢一个有损的分解

71
00:03:14,970 --> 00:03:19,330
那有没有不保持函数依赖

72
00:03:20,960 --> 00:03:24,280
但是无损的分解呢

73
00:03:26,480 --> 00:03:28,140
在这里呀

74
00:03:28,140 --> 00:03:31,860
我们对于这个例子当中是没有的

75
00:03:31,860 --> 00:03:35,690
但是其他粒子是可以存在的

76
00:03:35,690 --> 00:03:39,480
比如说我们在这里如果存

77
00:03:39,480 --> 00:03:44,830
R 等于 A 、 B 、 C 函数依赖集合

78
00:03:47,880 --> 00:03:50,000
再加一个 A 、 B 、 C 、 D 吧

79
00:03:50,000 --> 00:03:51,420
A 决定 B 

80
00:03:51,420 --> 00:03:52,320
然后呢

81
00:03:52,320 --> 00:03:54,720
还有 B 决定 C 

82
00:03:57,080 --> 00:03:59,480
C 决定！ D 

83
00:04:00,100 --> 00:04:03,740
这三个连续的函数依赖集合

84
00:04:03,740 --> 00:04:05,960
那这里假设呢

85
00:04:05,960 --> 00:04:11,510
R 1包含 A 、 B 、 D 、 R 2包含

86
00:04:12,510 --> 00:04:14,030
bc 

87
00:04:14,840 --> 00:04:19,440
那我们会发现，首先有没有保持函数依赖呢

88
00:04:19,440 --> 00:04:22,850
我们会发现 C 到 D 的函数依赖

89
00:04:22,850 --> 00:04:24,900
并没有被保留下来

90
00:04:24,900 --> 00:04:28,380
所以不保持函数依赖能不能还原呢

91
00:04:28,380 --> 00:04:31,840
我们可以通过 B 到 C 函数依赖

92
00:04:31,840 --> 00:04:34,310
从而将 B 还原

93
00:04:34,310 --> 00:04:36,150
哎，与之对应的 C 

94
00:04:36,150 --> 00:04:38,290
从而呢让 R 1还原

95
00:04:38,290 --> 00:04:41,010
所以它是呢，不保持函数依赖

96
00:04:41,010 --> 00:04:44,140
但无损的一种呢，分解方式

97
00:04:44,140 --> 00:04:47,720
也就是说，这两个维度是完全独立的

98
00:04:47,720 --> 00:04:50,790
可以形成四种不同的形式

99
00:04:50,790 --> 00:04:53,400
这里呢，不要把它混淆了

100
00:04:53,400 --> 00:04:56,210
那么针对这一组例子来看啊

101
00:04:56,210 --> 00:04:58,690
其实函数依赖，诶

102
00:04:58,690 --> 00:05:00,760
其实关系模式啊

103
00:05:00,760 --> 00:05:05,230
如果分解成仅仅两个子模式的话

104
00:05:05,230 --> 00:05:08,850
我们可以通过公式法来进行验

105
00:05:08,850 --> 00:05:10,080
它的无损

106
00:05:10,080 --> 00:05:11,740
如何来验证呢

107
00:05:11,740 --> 00:05:13,180
对于公式法

108
00:05:13,180 --> 00:05:17,090
它只要满足一定的充分必要条件就可以了

109
00:05:17,090 --> 00:05:22,620
只要啊，能够通过交集得出差几

110
00:05:22,620 --> 00:05:26,330
只要存在一种这样的函数依赖

111
00:05:26,330 --> 00:05:29,210
我们就说它呢是无损的

112
00:05:29,210 --> 00:05:32,600
那以我们刚刚的例子为例的话

113
00:05:32,600 --> 00:05:35,580
A 决定 B 是函数依赖

114
00:05:35,580 --> 00:05:38,240
第一种分解 R 1等于 A 

115
00:05:38,240 --> 00:05:40,500
B ， R 2等于 A ， C 

116
00:05:40,500 --> 00:05:42,570
让二者相交

117
00:05:42,570 --> 00:05:44,750
它们的交集是什么呢

118
00:05:44,750 --> 00:05:47,620
R 1交二二等于 A 吧

119
00:05:47,620 --> 00:05:50,500
那它们的差积是什么呢

120
00:05:50,500 --> 00:05:53,730
哎， I 1减 R 2等于 B 

121
00:05:53,730 --> 00:05:57,040
R 2减 R 1等于 C 

122
00:05:57,040 --> 00:06:02,060
只要满足 A 决定 C 或 A 决定 B 

123
00:06:02,060 --> 00:06:05,490
任意满足其中一个函数依赖

124
00:06:05,490 --> 00:06:07,850
唉，我们有 A 决定 B 吧

125
00:06:07,850 --> 00:06:10,440
所以它是无损的

126
00:06:10,440 --> 00:06:14,260
那对第二个关系模式的分解

127
00:06:14,260 --> 00:06:16,760
R 1交二二

128
00:06:16,840 --> 00:06:20,760
R 1加 R 3是等于 B 的

129
00:06:21,410 --> 00:06:24,690
R 1-23等于 

130
00:06:24,690 --> 00:06:28,410
23-21等于 C 

131
00:06:28,940 --> 00:06:31,800
那有没有 B 决定 A 

132
00:06:31,800 --> 00:06:34,750
或者 B 决定 C 的函数依赖呢

133
00:06:34,750 --> 00:06:37,470
只要存在一个就是无损

134
00:06:37,470 --> 00:06:39,790
然而二者都不存在

135
00:06:39,790 --> 00:06:42,960
所以它是有损的分解

136
00:06:42,960 --> 00:06:45,220
那这就是呢，公式法

137
00:06:45,220 --> 00:06:49,060
只要存在交集决定差距的函数依赖

138
00:06:49,060 --> 00:06:51,050
我们就说它无损

139
00:06:51,050 --> 00:06:55,240
那这些呢，就是关于无损分解的判断

140
00:06:55,240 --> 00:06:58,210
针对模式分解的判断啊

141
00:06:58,210 --> 00:07:00,880
我们在软件设计师的考试当中

142
00:07:00,880 --> 00:07:02,290
主要呢，就是

143
00:07:02,290 --> 00:07:04,730
诶，判断我们的分解

144
00:07:04,730 --> 00:07:07,600
它到底达到了什么样的程度

145
00:07:07,600 --> 00:07:10,740
下面呢，以一个例子来看一看

146
00:07:10,740 --> 00:07:13,680
首先告诉我们，关系模式 U 、 F 

147
00:07:13,680 --> 00:07:15,620
它包含 A 、 B 、 C 、 D 、 E 、 E 

148
00:07:15,620 --> 00:07:18,510
A 可以决定 B 、 D 、 E 决定 B 

149
00:07:18,510 --> 00:07:19,570
CB 决定一

150
00:07:19,570 --> 00:07:21,850
E 决定 ab 决定 D 

151
00:07:21,850 --> 00:07:24,140
那谁是他的候选关键字

152
00:07:24,140 --> 00:07:28,160
大家回忆一下关于候选关键字的判断

153
00:07:28,160 --> 00:07:31,180
从入度为零的属性开始吧

154
00:07:31,180 --> 00:07:32,740
B 有入度

155
00:07:32,740 --> 00:07:34,080
E 有入度

156
00:07:34,080 --> 00:07:36,920
A 和 D 是没有入度的

157
00:07:36,920 --> 00:07:38,980
唉， A 和 D 啊，也有入度

158
00:07:38,980 --> 00:07:41,220
那 A 、 B 、 D 、 E 都有了

159
00:07:41,220 --> 00:07:42,550
谁没有入度啊

160
00:07:42,550 --> 00:07:44,430
C 是没有入度的

161
00:07:44,430 --> 00:07:48,330
所以候选关键字一定要包含 C 

162
00:07:48,330 --> 00:07:52,640
那四个选项只有 D 选项满足要求

163
00:07:52,640 --> 00:07:58,440
我们会发现通过 C 11可以呢还原出 A 

164
00:07:58,440 --> 00:08:00,350
唉，我们已经有了 C 

165
00:08:00,350 --> 00:08:03,330
C 1通过一还原出 A 

166
00:08:03,330 --> 00:08:05,770
通过 A 还原 B 

167
00:08:05,770 --> 00:08:08,760
通过 B 可以还原 D 

168
00:08:08,760 --> 00:08:11,160
从而便利全图

169
00:08:11,160 --> 00:08:14,940
所以它可以作为候选键

170
00:08:15,330 --> 00:08:20,470
那以下的分解哪一个是无损连接

171
00:08:20,470 --> 00:08:23,440
并且保持函数依赖

172
00:08:23,440 --> 00:08:26,600
我们首先看无损连接

173
00:08:26,600 --> 00:08:30,780
无损是可以通过表格法来还原的

174
00:08:30,780 --> 00:08:32,610
能不能用公式法

175
00:08:32,610 --> 00:08:38,059
公式法针对的仅仅是分解成两个关系模式

176
00:08:38,059 --> 00:08:41,880
超过两个关系模式是不能用公式法的

177
00:08:41,880 --> 00:08:45,990
那所有的情况都能用表格法来解决

178
00:08:45,990 --> 00:08:48,360
表格法是通用的

179
00:08:48,360 --> 00:08:51,280
接下来我们呢，先画初始表

180
00:08:51,280 --> 00:08:53,420
针对 A 选项来看的话

181
00:08:53,420 --> 00:08:55,860
第一个分解 A 、 C 

182
00:08:55,860 --> 00:08:58,060
第二个分解1 D 

183
00:08:58,060 --> 00:08:59,900
第三个分解 B 

184
00:08:59,900 --> 00:09:01,860
有没有同名属性链

185
00:09:01,860 --> 00:09:05,640
它们之间完全没有相交的属性列吧

186
00:09:05,640 --> 00:09:09,670
所以肯肯定是没有保持诶

187
00:09:09,670 --> 00:09:11,670
肯定是有损的

188
00:09:11,670 --> 00:09:13,990
其次，我们会发现

189
00:09:13,990 --> 00:09:16,380
所有的函数依赖当中

190
00:09:16,380 --> 00:09:20,210
关于 B 的函数依赖都没有被保留下来

191
00:09:20,210 --> 00:09:23,280
因为它是孤零零的一个属性

192
00:09:23,280 --> 00:09:27,840
那与之类似的 B 选项的划分当中

193
00:09:27,840 --> 00:09:32,060
所有与单独属性 E 相关的函数依赖

194
00:09:32,060 --> 00:09:33,690
都没有被保留

195
00:09:33,690 --> 00:09:38,180
并且它们之间没有任何的同名属性列

196
00:09:38,180 --> 00:09:39,830
无法还原

197
00:09:39,830 --> 00:09:41,890
所以这两个都是呢

198
00:09:41,890 --> 00:09:44,430
不保持函数依赖

199
00:09:45,110 --> 00:09:47,390
并且有损的

200
00:09:55,080 --> 00:09:57,360
再往下 C 选项

201
00:09:57,360 --> 00:09:59,870
我们来看一下 C 选项

202
00:09:59,870 --> 00:10:02,970
这些属性呢，先把它列出来

203
00:10:02,970 --> 00:10:04,450
a 、 b 、 c 、 d 、 e 

204
00:10:04,450 --> 00:10:07,040
那针对这些属性而言

205
00:10:07,040 --> 00:10:11,110
同名属性列第一个是 A 属性

206
00:10:11,110 --> 00:10:14,270
R 1和 R 3做自然连接的话

207
00:10:14,270 --> 00:10:16,010
可以通过，唉

208
00:10:16,010 --> 00:10:20,770
有一个以 A 为左侧决定因素的函数依赖

209
00:10:20,770 --> 00:10:22,510
A 到 B 保留了

210
00:10:22,510 --> 00:10:27,760
所以我们呢，可以将上面 R 1的 B 与之对

211
00:10:27,760 --> 00:10:29,360
进行还原

212
00:10:29,360 --> 00:10:30,700
还原之后

213
00:10:30,700 --> 00:10:34,380
下一个同名属性列是还原

214
00:10:34,380 --> 00:10:35,470
B 属性

215
00:10:35,470 --> 00:10:39,420
以它为左侧决定因素的是 B 决定

216
00:10:39,420 --> 00:10:42,720
D 这个函数依赖有没有保留呢

217
00:10:42,720 --> 00:10:44,460
哎，没有保留

218
00:10:44,460 --> 00:10:46,930
所以我们在这里不能用

219
00:10:46,930 --> 00:10:51,010
那接下来的同名属性列还有没有

220
00:10:51,010 --> 00:10:52,220
唉，没有了

221
00:10:52,220 --> 00:10:53,700
那我们在这里

222
00:10:53,700 --> 00:10:54,780
C 没有同名

223
00:10:54,780 --> 00:10:55,700
D 没有同名

224
00:10:55,700 --> 00:10:56,860
E 没有同名

225
00:10:56,860 --> 00:10:59,210
没法往下还原了

226
00:10:59,210 --> 00:11:00,990
所以戛然而止了

227
00:11:00,990 --> 00:11:03,890
这里呢，是有损的

228
00:11:05,380 --> 00:11:08,740
有没有保持函数依赖呢

229
00:11:08,740 --> 00:11:10,440
唉，我们可以看到

230
00:11:10,440 --> 00:11:13,440
A 决定 B 保留了 D 1到 B 

231
00:11:13,440 --> 00:11:14,920
哎，没有保留

232
00:11:14,920 --> 00:11:17,780
所以不保持函数依赖

233
00:11:21,420 --> 00:11:24,460
最后还有一个呢， D 选项

234
00:11:24,460 --> 00:11:26,840
这道题其实很尴尬的是

235
00:11:26,840 --> 00:11:29,090
它是没有正确选项的

236
00:11:29,090 --> 00:11:30,900
那我们分析之后呢

237
00:11:30,900 --> 00:11:32,840
可以找一个最接近的

238
00:11:32,840 --> 00:11:35,840
那首先呢，看到同名属性列

239
00:11:35,840 --> 00:11:39,780
A 属性以 A 为左侧决定因素

240
00:11:39,780 --> 00:11:41,230
A 决定 B 吧

241
00:11:41,230 --> 00:11:43,950
那与之相关的函数依赖

242
00:11:43,950 --> 00:11:47,750
以 A 为左侧决定因素的函数依赖保留下来了

243
00:11:47,750 --> 00:11:52,670
我们随之还原与之对应的 B 属性

244
00:11:52,670 --> 00:11:54,740
可以通过 R 3啊

245
00:11:54,740 --> 00:11:56,160
通过这个函数依

246
00:11:56,160 --> 00:11:59,720
将 R 3的 B 呢，还原成 go ，诶

247
00:11:59,720 --> 00:12:04,590
还原了下一个同名属性列是 B 属性

248
00:12:04,590 --> 00:12:08,450
以 B 为左侧决定因素的函数依赖

249
00:12:08,450 --> 00:12:09,430
B 决定低

250
00:12:09,430 --> 00:12:10,230
没有保留

251
00:12:10,230 --> 00:12:12,890
所以再看下一个同名属性列

252
00:12:12,890 --> 00:12:14,960
应该是 C 属性

253
00:12:14,960 --> 00:12:20,300
以 C 为左侧决定因素的有 CB 到一

254
00:12:20,300 --> 00:12:24,360
那左侧决定因素 CB 有没有都保留啊

255
00:12:24,360 --> 00:12:30,170
唉，在这里 R 1和 R 3都有 CB 属性吧

256
00:12:30,170 --> 00:12:34,850
并且 CB 到一属性在 R 3属性

257
00:12:34,850 --> 00:12:36,680
在二三关系模式

258
00:12:36,680 --> 00:12:39,340
我们已经还原出来了一个勾吧

259
00:12:39,340 --> 00:12:44,630
所以与之对应的函数依赖已经保留下来了

260
00:12:44,630 --> 00:12:49,700
那与之对应的右侧决定因素在 R 1当中

261
00:12:49,700 --> 00:12:52,380
可以呢，将 E 属性还原

262
00:12:52,380 --> 00:12:56,520
下一个同名属性列就是 E 属性的

263
00:12:56,520 --> 00:13:02,560
那以 E 为左侧决定因素的函数依赖是 E 到 A 

264
00:13:02,560 --> 00:13:07,650
那我们可以随之还原 R 2的 A 属性

265
00:13:07,650 --> 00:13:10,620
注意到这里有没有结束

266
00:13:10,620 --> 00:13:12,040
没有结束

267
00:13:12,040 --> 00:13:16,560
我们啊，下一轮可以呢，再进行分析

268
00:13:16,560 --> 00:13:18,820
A 属性还原之后

269
00:13:18,820 --> 00:13:20,880
与之对应的 R 2

270
00:13:20,880 --> 00:13:24,690
可以通过 A 还原出 B 属性吧

271
00:13:24,690 --> 00:13:27,730
这是我们刚刚用到的一组函数依赖

272
00:13:27,730 --> 00:13:29,180
来进行还原的

273
00:13:29,180 --> 00:13:32,630
那再通过 B 来进行还原的话

274
00:13:32,630 --> 00:13:35,760
B 到 D 随之保留下来

275
00:13:35,760 --> 00:13:38,520
同名属性列 B 属性

276
00:13:38,520 --> 00:13:41,710
与之对应的 R 1的低属性

277
00:13:41,710 --> 00:13:45,600
R 3的 D 属性都可以随之还原

278
00:13:45,600 --> 00:13:48,200
此时 R 1全为 J 

279
00:13:48,200 --> 00:13:50,540
R 3也全为勾了

280
00:13:50,540 --> 00:13:53,600
所以对于 D 选项来看

281
00:13:53,600 --> 00:13:55,720
它是无损的

282
00:13:56,310 --> 00:14:01,490
那 D 数 D 选项有没有保持函数依赖呢

283
00:14:01,490 --> 00:14:04,250
首先 A 决定 B 保留了

284
00:14:04,250 --> 00:14:08,620
其次 DE 1决定 B 其实也没有保留

285
00:14:08,620 --> 00:14:12,880
所以 D 选项并不是完全正确的答案

286
00:14:12,880 --> 00:14:15,670
但是四个选项对比来看

287
00:14:15,670 --> 00:14:18,190
只有 D 选项最接近

288
00:14:18,190 --> 00:14:19,630
它是无损

289
00:14:19,630 --> 00:14:24,780
但是呢，没有保持函数依赖的分解方式

290
00:14:24,780 --> 00:14:27,480
同样我们在考试当中啊

291
00:14:27,480 --> 00:14:29,790
碰到这类问题的话

292
00:14:29,790 --> 00:14:32,640
如果出现四个选项不合适

293
00:14:32,640 --> 00:14:36,600
我们呢也需要去找到最接近的选项

294
00:14:36,600 --> 00:14:41,020
从而呢，选出来最好呢，不要啊空余

295
00:14:41,020 --> 00:14:42,720
只要呢做

296
00:14:42,720 --> 00:14:46,680
所有的选项最好都要呢把它找到

297
00:14:46,680 --> 00:14:51,140
那如果你不确定四个选项是不是都正确

298
00:14:51,140 --> 00:14:53,960
你找一个呢最接近的答案

299
00:14:53,960 --> 00:14:57,940
那这些呢，就是关于模式分解的判断
