1
00:00:00,000 --> 00:00:04,280
下面我们详细来看一下关系模式当中啊

2
00:00:04,280 --> 00:00:05,940
它的相关概念

3
00:00:05,940 --> 00:00:07,140
我们说呢

4
00:00:07,140 --> 00:00:09,660
在数据库设计过程当中

5
00:00:09,660 --> 00:00:11,280
先是需求分析

6
00:00:11,280 --> 00:00:13,360
然后呢，推出概念模型

7
00:00:13,360 --> 00:00:18,020
从概念模型转换成了它的结构设计阶段

8
00:00:18,020 --> 00:00:19,920
那结构设计阶段

9
00:00:19,920 --> 00:00:21,520
其实是从概念模型

10
00:00:21,520 --> 00:00:23,890
转换为数据模型的一个步骤

11
00:00:23,890 --> 00:00:25,800
典型的数据模型啊

12
00:00:25,800 --> 00:00:30,340
包含层次模型、网状模型、关系模型以及呢

13
00:00:30,340 --> 00:00:31,810
面向对象模型

14
00:00:31,810 --> 00:00:33,960
所谓层次模型

15
00:00:33,960 --> 00:00:36,380
它类似于树形结构

16
00:00:36,380 --> 00:00:38,180
有典型的这种呢

17
00:00:38,180 --> 00:00:41,240
分层父子关系常用在哪里呢

18
00:00:41,240 --> 00:00:43,500
比如说我们一些组织结构图啊

19
00:00:43,500 --> 00:00:46,210
经常呢，会看到这种层次模型

20
00:00:46,210 --> 00:00:49,470
网状模型呢，相对来说比较乱

21
00:00:49,470 --> 00:00:52,140
它的这些各个组成部

22
00:00:52,140 --> 00:00:53,880
相互之间可以呢

23
00:00:53,880 --> 00:00:56,520
有无厘头的、随意的这种联系

24
00:00:56,520 --> 00:00:58,520
没有呢，层次关系了

25
00:00:58,520 --> 00:01:00,210
面向对象模型呢

26
00:01:00,210 --> 00:01:03,650
是以面向对象当中的对象为单位

27
00:01:03,650 --> 00:01:05,970
来组织的数据模型

28
00:01:05,970 --> 00:01:09,490
那我们在软件设计师考试当中

29
00:01:09,490 --> 00:01:12,910
主要掌握的是关系模式

30
00:01:13,210 --> 00:01:14,950
关系模式啊

31
00:01:14,950 --> 00:01:17,010
我们的大致结构呢

32
00:01:17,010 --> 00:01:19,890
是关系模式的名称

33
00:01:22,340 --> 00:01:26,800
然后对应的属性用括号括起来

34
00:01:26,800 --> 00:01:30,140
哎，属性一属性二

35
00:01:30,700 --> 00:01:32,100
等等

36
00:01:32,460 --> 00:01:35,480
那这就是呢，典型的关系模式

37
00:01:35,480 --> 00:01:36,440
它的结构

38
00:01:36,440 --> 00:01:39,310
那对于关系模式而言的话

39
00:01:39,310 --> 00:01:43,020
它典型的形式呢，其实是二维表

40
00:01:43,020 --> 00:01:44,840
对于二维表来说

41
00:01:44,840 --> 00:01:46,800
它有相应的行列吧

42
00:01:46,800 --> 00:01:48,410
对于这种行列

43
00:01:48,410 --> 00:01:52,840
这个表格的名称就是关系模式的名称

44
00:01:52,840 --> 00:01:55,710
属性一就是呢，列名一

45
00:01:55,710 --> 00:01:58,190
属性二作为列名二

46
00:01:58,190 --> 00:02:00,260
依次来进行对应

47
00:02:00,260 --> 00:02:02,790
所以我们所说的关系模式呢

48
00:02:02,790 --> 00:02:05,240
就是二维表的形式

49
00:02:05,240 --> 00:02:07,150
那这是呢，数据模型

50
00:02:07,150 --> 00:02:09,509
对于数据模型来说的话

51
00:02:09,509 --> 00:02:11,410
它有呢三要素

52
00:02:11,410 --> 00:02:13,640
一个呢，是数据的结构

53
00:02:13,640 --> 00:02:18,020
比如说呢，关系模式当中我们划分的哪些属性

54
00:02:18,020 --> 00:02:19,810
其实就是它的结

55
00:02:19,810 --> 00:02:22,480
与我们啊，算法当中的数据结

56
00:02:22,480 --> 00:02:23,820
不是一个意思啊

57
00:02:23,820 --> 00:02:25,900
其次，数据的操作

58
00:02:25,900 --> 00:02:27,930
针对这些数据而言

59
00:02:27,930 --> 00:02:30,290
有哪些操作方式

60
00:02:30,290 --> 00:02:33,170
以及呢，相应的约束条件

61
00:02:33,170 --> 00:02:37,130
那我们后面呢，还会讲到关系数据库当

62
00:02:37,130 --> 00:02:39,030
完整性约束等等

63
00:02:39,030 --> 00:02:39,920
那这是呢

64
00:02:39,920 --> 00:02:41,740
数据模型的三要素

65
00:02:41,740 --> 00:02:44,040
数据结构、数据操作以及呢

66
00:02:44,040 --> 00:02:46,280
数据的约束条件

67
00:02:46,950 --> 00:02:49,570
针对关系模型而言的话

68
00:02:49,570 --> 00:02:50,930
我们再来看一下呢

69
00:02:50,930 --> 00:02:52,850
哎，关系模型当

70
00:02:52,850 --> 00:02:55,690
属性的个数我们称之为目

71
00:02:55,690 --> 00:02:59,710
或者呢都在相应的属性当中

72
00:02:59,710 --> 00:03:01,770
有一些呢特殊的属性

73
00:03:01,770 --> 00:03:03,630
比如说候选码

74
00:03:03,630 --> 00:03:06,250
那候选马它是呢

75
00:03:06,250 --> 00:03:08,530
可以唯一标识元组

76
00:03:08,530 --> 00:03:11,770
并且呢不会存在冗余的诶

77
00:03:11,770 --> 00:03:13,830
相应的属性集合

78
00:03:13,830 --> 00:03:17,620
注意它是一个属性集合

79
00:03:21,400 --> 00:03:24,280
对于候选码而言

80
00:03:24,280 --> 00:03:29,160
它可以有多个、可以有一个

81
00:03:29,800 --> 00:03:32,560
可以有多个

82
00:03:34,420 --> 00:03:37,740
可以是单个属性

83
00:03:40,940 --> 00:03:44,860
可以呢，是多个属性的集合

84
00:03:48,060 --> 00:03:49,440
比如说呢

85
00:03:49,440 --> 00:03:52,160
唉，如果给大家一个例子

86
00:03:52,160 --> 00:03:55,380
那什么是唯一标识且无冗余

87
00:03:55,380 --> 00:03:57,500
什么是单属性、多属性

88
00:03:57,500 --> 00:03:59,610
什么是一个，什么是多个呢

89
00:03:59,610 --> 00:04:00,990
我们假设啊

90
00:04:00,990 --> 00:04:03,790
有一个学生关系模式

91
00:04:03,790 --> 00:04:09,940
那我们记录了相应的学号、姓名、身份证号

92
00:04:13,140 --> 00:04:14,580
等等

93
00:04:15,130 --> 00:04:17,550
那在这个过程当中

94
00:04:17,550 --> 00:04:20,110
如果让大家记录的时候

95
00:04:20,110 --> 00:04:23,320
我们会发现这是一个学生表吧

96
00:04:23,320 --> 00:04:26,260
学生表里面可能会有呢

97
00:04:26,260 --> 00:04:28,840
哎，001张三

98
00:04:29,740 --> 00:04:34,580
然后给他一个身份证号002李四

99
00:04:34,780 --> 00:04:39,460
又给他一个身份证号 A 003、004等等

100
00:04:39,460 --> 00:04:41,910
对于这张表而言

101
00:04:41,910 --> 00:04:45,580
每一条横向的就叫做呢记录

102
00:04:45,580 --> 00:04:49,060
那每一条记录都是一个实体吧

103
00:04:49,060 --> 00:04:50,950
都是一个实例

104
00:04:50,950 --> 00:04:53,690
那对于不同的实例而言

105
00:04:53,690 --> 00:04:56,960
这是呢，表示每一个学生

106
00:04:56,960 --> 00:04:59,920
如何来区分这每一个学生呢

107
00:04:59,920 --> 00:05:03,280
那我们会发现可以通过学号吧

108
00:05:03,280 --> 00:05:04,840
唉，只要找到学号

109
00:05:04,840 --> 00:05:06,490
我知道你找的就是谁

110
00:05:06,490 --> 00:05:08,660
也可以通过身份证号吧

111
00:05:08,660 --> 00:05:09,740
我可以呢

112
00:05:09,740 --> 00:05:11,040
诶，知道身份证号

113
00:05:11,040 --> 00:05:13,020
我就知道呢，找的是张三了

114
00:05:13,020 --> 00:05:18,620
那通通过某一些属性能够唯一标识元组

115
00:05:18,620 --> 00:05:20,640
这就是呢唯一标识

116
00:05:20,640 --> 00:05:22,870
那什么叫五冗余呢

117
00:05:22,870 --> 00:05:25,490
学号可以唯一标识了

118
00:05:25,490 --> 00:05:27,510
我有必要将学号

119
00:05:27,510 --> 00:05:31,730
身份证号放到一个集合当中去

120
00:05:31,730 --> 00:05:34,040
来进行唯一标识吗

121
00:05:34,040 --> 00:05:34,980
不需要

122
00:05:34,980 --> 00:05:38,050
那这种不需要的就是冗余

123
00:05:38,050 --> 00:05:39,710
那我们会发现

124
00:05:39,710 --> 00:05:41,730
对于这个关系而言啊

125
00:05:41,730 --> 00:05:44,410
他的候选键其实有两个

126
00:05:44,410 --> 00:05:47,230
一个呢，是学号

127
00:05:47,850 --> 00:05:51,810
然后还有一个是身份证号

128
00:05:53,040 --> 00:05:58,080
这里表示呢，我们有两个候选键

129
00:05:58,080 --> 00:06:01,810
那有一些一个属性不能唯一标识的

130
00:06:01,810 --> 00:06:04,950
就可能呢有多个属性来标识了

131
00:06:04,950 --> 00:06:06,930
哎，比如说成绩

132
00:06:08,440 --> 00:06:12,060
我们需要记录相应的学号

133
00:06:12,060 --> 00:06:15,600
还有课程号以及成绩

134
00:06:21,300 --> 00:06:23,480
在这个情况下

135
00:06:23,480 --> 00:06:26,180
一个学号能不能唯一标识啊

136
00:06:26,180 --> 00:06:28,880
一个学生他可能有100条成绩

137
00:06:28,880 --> 00:06:31,200
那一个课程号能不能标识啊

138
00:06:31,200 --> 00:06:34,300
一个课程100个人学就有100个成绩啊

139
00:06:34,300 --> 00:06:36,540
所以都不能唯一标识

140
00:06:36,540 --> 00:06:38,110
组合起来

141
00:06:38,110 --> 00:06:42,000
每一个学生在一个课程最终只有一个成绩

142
00:06:42,000 --> 00:06:45,920
所以这个候选键是组合键

143
00:06:45,920 --> 00:06:48,140
两个属性的组合键

144
00:06:48,140 --> 00:06:51,550
学号课程号作为候选键

145
00:06:51,600 --> 00:06:53,260
那这就是呢

146
00:06:53,260 --> 00:06:55,780
多属性作为候选键了

147
00:06:55,780 --> 00:06:56,400
注意

148
00:06:56,400 --> 00:06:59,260
多个候选键和多属性组合

149
00:06:59,260 --> 00:07:01,630
候选键是不一样的

150
00:07:01,630 --> 00:07:03,710
那这是呢？候选键

151
00:07:03,710 --> 00:07:07,310
候选键它可以有多个

152
00:07:08,010 --> 00:07:10,290
那我们类似于呢

153
00:07:10,290 --> 00:07:13,270
在做总统选举的时候

154
00:07:13,270 --> 00:07:15,560
我们可以有多个候选人啊

155
00:07:15,560 --> 00:07:17,770
但最终有几个总

156
00:07:17,770 --> 00:07:19,530
还是只有一个吧

157
00:07:19,530 --> 00:07:21,490
所以我们最终呢

158
00:07:21,490 --> 00:07:25,150
会从候选件当中选择一个

159
00:07:25,150 --> 00:07:28,540
任选一个作为我们的主见

160
00:07:28,540 --> 00:07:30,430
也叫做呢，竹马

161
00:07:30,430 --> 00:07:32,390
在数据库当中

162
00:07:32,390 --> 00:07:35,130
马和箭啊是同一个概念

163
00:07:35,130 --> 00:07:37,490
都是用 K 来表示的

164
00:07:37,490 --> 00:07:38,370
它只是呢

165
00:07:38,370 --> 00:07:39,970
翻译不一样了

166
00:07:39,970 --> 00:07:44,580
那我们啊，一般在做相应的程序设计的时候

167
00:07:44,580 --> 00:07:47,760
会选择有一定逻辑意义的，诶

168
00:07:47,760 --> 00:07:49,980
属性作为它的主见

169
00:07:49,980 --> 00:07:51,410
比如说学生表

170
00:07:51,410 --> 00:07:53,470
身份证号也可以唯一标识

171
00:07:53,470 --> 00:07:57,880
但我们一般会选择学号来作为主件

172
00:07:57,880 --> 00:07:58,800
那这是呢

173
00:07:58,800 --> 00:08:00,660
主见的概念

174
00:08:00,660 --> 00:08:02,820
除了主线以外啊

175
00:08:02,820 --> 00:08:04,200
我们还有一个呢

176
00:08:04,200 --> 00:08:08,010
唉，主属性和非主属性需要大家区别

177
00:08:08,010 --> 00:08:09,440
什么是主属性

178
00:08:09,440 --> 00:08:11,160
什么是非主属性呢

179
00:08:11,160 --> 00:08:15,240
组成候选码的属性就是主属性

180
00:08:15,250 --> 00:08:18,030
其他的就是呢，非主属性

181
00:08:18,030 --> 00:08:20,830
比如说针对学生来看的话

182
00:08:20,830 --> 00:08:22,770
它有两个候选键吧

183
00:08:22,770 --> 00:08:25,170
学号和身份证号

184
00:08:25,170 --> 00:08:28,280
那这两个属性都是主属性

185
00:08:28,280 --> 00:08:31,020
其他才是呢，非主属性

186
00:08:31,020 --> 00:08:32,710
对于成绩来说

187
00:08:32,710 --> 00:08:35,730
学号、课程号组合建设后卷件吧

188
00:08:35,730 --> 00:08:39,409
所以学号、课程号都是主属性

189
00:08:39,409 --> 00:08:42,450
只有成绩是非主属性

190
00:08:42,450 --> 00:08:44,410
它们与候选件啊

191
00:08:44,410 --> 00:08:47,050
是有一定的对应关系的

192
00:08:47,050 --> 00:08:50,760
那我们在这里还有一组呢，特殊的箭

193
00:08:50,760 --> 00:08:53,750
叫做呢外马或者呢外键

194
00:08:53,750 --> 00:08:55,590
所谓的外界啊

195
00:08:55,590 --> 00:08:58,270
它指的是其他关系的主线

196
00:08:58,270 --> 00:09:01,550
它体现的其实是我们的参照完整性

197
00:09:01,550 --> 00:09:02,980
我们可以看到

198
00:09:02,980 --> 00:09:04,980
对于成绩而言

199
00:09:04,980 --> 00:09:07,400
有没有一个属性大家很熟悉啊

200
00:09:07,400 --> 00:09:08,800
诶，很很眼熟

201
00:09:08,800 --> 00:09:09,660
学号

202
00:09:09,660 --> 00:09:13,450
那学号参照的是谁的学号啊

203
00:09:13,450 --> 00:09:15,800
是学生的学号吧

204
00:09:15,800 --> 00:09:19,490
我们的成绩记录学号的时候

205
00:09:19,490 --> 00:09:21,890
一定跟学生学号是统一的

206
00:09:21,890 --> 00:09:22,950
才可以记录

207
00:09:22,950 --> 00:09:24,490
那也就是说呢

208
00:09:24,490 --> 00:09:26,510
在成绩当中

209
00:09:26,510 --> 00:09:30,130
学号是学生的主见

210
00:09:30,130 --> 00:09:32,750
也就是成绩的外界

211
00:09:32,750 --> 00:09:37,000
所谓的外界是在成绩的这些属性当中

212
00:09:37,000 --> 00:09:42,410
找到有一些属性来源于其他关系的主见

213
00:09:42,410 --> 00:09:45,530
这就是呢，外界的来源

214
00:09:45,890 --> 00:09:47,440
那注意啊

215
00:09:47,440 --> 00:09:50,740
如果我们在这里改了一个名字，诶

216
00:09:50,740 --> 00:09:52,440
也可以作为外界

217
00:09:52,440 --> 00:09:56,990
而外界是以本关系的名称为主的

218
00:09:56,990 --> 00:09:58,780
这里呢，注意一下

219
00:09:58,780 --> 00:10:00,990
那这是呢，外线的概念

220
00:10:00,990 --> 00:10:02,750
有一个特殊的地方

221
00:10:02,750 --> 00:10:03,950
大家了解一下

222
00:10:03,950 --> 00:10:06,660
还有一种呢，叫做犬马 o key 

223
00:10:06,660 --> 00:10:08,920
所谓的犬马指的是呢

224
00:10:08,920 --> 00:10:12,520
关系模式当中所有的属性组啊

225
00:10:12,520 --> 00:10:15,580
才是呢，这个关系的诶，候选马

226
00:10:15,580 --> 00:10:18,400
那比如说呢，我们看到这个成绩的话

227
00:10:18,400 --> 00:10:23,010
学号、课程号和成绩并不能作为全马哈

228
00:10:23,010 --> 00:10:28,960
因为这个成绩并不是我们的候选码组成部分

229
00:10:28,960 --> 00:10:31,890
注意呢，全马的区别

230
00:10:32,700 --> 00:10:37,580
那这些啊，是关系模型当中的一些呢，基本概念

231
00:10:37,580 --> 00:10:39,420
大家呢，了解一下

232
00:10:39,420 --> 00:10:42,000
关于候选键的求取

233
00:10:42,000 --> 00:10:44,460
我们在这里呢，知道，诶

234
00:10:44,460 --> 00:10:47,070
关于候选键或者说主见

235
00:10:47,070 --> 00:10:50,300
它是呢，唯一不会重复的，诶

236
00:10:50,300 --> 00:10:54,030
并且呢，没有冗余的这样的属性集合就可以了

237
00:10:54,030 --> 00:10:56,570
在规范化的基础理论当中

238
00:10:56,570 --> 00:10:59,850
我们会教大家如何来解决

239
00:10:59,850 --> 00:11:02,930
通用的候选键求取过程

240
00:11:03,240 --> 00:11:05,400
接下来我们再来看呢

241
00:11:05,400 --> 00:11:07,460
关系模式的其他概念

242
00:11:07,460 --> 00:11:10,010
那关系有三种类型

243
00:11:10,010 --> 00:11:13,690
其实体现在我们数据库管理系统当中的话

244
00:11:13,690 --> 00:11:16,650
就是呢，有一个基本关系表

245
00:11:16,650 --> 00:11:18,440
然后呢，有查询表

246
00:11:18,440 --> 00:11:19,940
还有呢试图表

247
00:11:19,940 --> 00:11:21,800
所谓的基本关系表

248
00:11:21,800 --> 00:11:26,560
就是我们存储建表的时候会有一定的实质

249
00:11:26,560 --> 00:11:29,450
那这个实质的话就是呢，基本关系表

250
00:11:29,450 --> 00:11:30,830
它的这种结构啊

251
00:11:30,830 --> 00:11:33,830
会存在我们的数据库当中

252
00:11:33,830 --> 00:11:36,450
那我们对于这些内容呢

253
00:11:36,450 --> 00:11:40,110
可以抽取一部分作为视图对外展示

254
00:11:40,110 --> 00:11:42,070
那这就是呢，视图表

255
00:11:42,070 --> 00:11:43,910
我们在用 SQL 语言

256
00:11:43,910 --> 00:11:45,690
诶，进行查询的时候

257
00:11:45,690 --> 00:11:47,410
有一些查询结果

258
00:11:47,410 --> 00:11:51,080
那这种查询结果的话就是呢查询表

259
00:11:51,080 --> 00:11:54,370
查询表和视图表其实都是虚表

260
00:11:54,370 --> 00:11:56,950
并没有进行实质的存储

261
00:11:56,950 --> 00:11:59,970
这是呢关系的三种类型

262
00:12:00,320 --> 00:12:04,760
下面呢，简单看一下完整性约束的内容

263
00:12:04,760 --> 00:12:06,820
对于完整性约束啊

264
00:12:06,820 --> 00:12:09,660
它针对的是我们记录数据的时候

265
00:12:09,660 --> 00:12:12,090
不能破坏数据的完整性

266
00:12:12,090 --> 00:12:15,860
那它的完整性约束呢，主要分三大类

267
00:12:15,860 --> 00:12:16,880
第一大类

268
00:12:16,880 --> 00:12:19,000
实体完整性约束

269
00:12:19,000 --> 00:12:21,520
它表示的是主见

270
00:12:21,520 --> 00:12:24,580
一定呢是唯一的

271
00:12:25,460 --> 00:12:28,560
也就是说一个主键是不能重复的

272
00:12:28,560 --> 00:12:30,780
我们只能有一个001学

273
00:12:30,780 --> 00:12:31,900
不能有两个

274
00:12:31,900 --> 00:12:33,660
否则是区分不了的

275
00:12:33,660 --> 00:12:35,210
主见是唯一的

276
00:12:35,210 --> 00:12:37,740
并且主见一定非空

277
00:12:37,740 --> 00:12:40,100
如果主线为空的话

278
00:12:40,100 --> 00:12:43,020
是无法正常插入数据的

279
00:12:43,020 --> 00:12:44,000
那这是呢

280
00:12:44,000 --> 00:12:46,180
唉，实体完整性

281
00:12:46,180 --> 00:12:48,340
第二个，参照完整性

282
00:12:48,340 --> 00:12:51,240
所谓的参照是参照其他的表

283
00:12:51,240 --> 00:12:53,540
如何体现参照其他表啊

284
00:12:53,540 --> 00:12:55,680
就是呢外键

285
00:12:55,710 --> 00:12:59,410
那外界只有两种可能

286
00:12:59,410 --> 00:13:03,110
要么是其他关系的主线

287
00:13:08,360 --> 00:13:11,880
要么是为空的，要么是空

288
00:13:15,580 --> 00:13:18,900
因为啊，我们在设定外键的时候

289
00:13:18,900 --> 00:13:22,230
其实初始情况下可能会存在

290
00:13:22,230 --> 00:13:24,220
没有分配的情况

291
00:13:24,220 --> 00:13:25,140
比如说呢

292
00:13:25,140 --> 00:13:27,680
我们常见的外键，诶

293
00:13:27,680 --> 00:13:29,700
我们在常见外键的时候

294
00:13:29,700 --> 00:13:32,000
经常会看到部门号

295
00:13:32,000 --> 00:13:34,750
作为员工的外界员工

296
00:13:34,750 --> 00:13:38,460
我们会记录相应的员工号、姓名、所属部门号吧

297
00:13:38,460 --> 00:13:40,650
那如果一个员工刚来

298
00:13:40,650 --> 00:13:42,270
还没有分配部门呢

299
00:13:42,270 --> 00:13:45,660
那这个时候部门号就可以为空了

300
00:13:45,660 --> 00:13:48,450
所以啊，外界要么是其他关系，唉

301
00:13:48,450 --> 00:13:51,230
比如说部门关系的部门号主见

302
00:13:51,230 --> 00:13:53,290
要么呢就是为空的

303
00:13:53,290 --> 00:13:55,850
这是它的参照完整性

304
00:13:55,850 --> 00:13:59,070
最后，用户自定义完整性约束

305
00:13:59,070 --> 00:14:03,250
我们经常呢，会用 check 来表示一个呢，条件约束

306
00:14:03,250 --> 00:14:06,040
那这个约束是自定义的诶

307
00:14:06,040 --> 00:14:08,140
每个人有每个人的想法

308
00:14:08,140 --> 00:14:11,100
比如说呢，对于男和女的性别

309
00:14:11,100 --> 00:14:12,400
有人喜欢用汉字

310
00:14:12,400 --> 00:14:13,680
有人喜欢用零一

311
00:14:13,680 --> 00:14:15,540
还有人呢，喜欢用字母

312
00:14:15,540 --> 00:14:17,040
那不同的人可以呢

313
00:14:17,040 --> 00:14:18,610
约束不同的条件

314
00:14:18,610 --> 00:14:20,750
那比如说呢，对于年龄来说

315
00:14:20,750 --> 00:14:22,890
有人呢喜欢用0~150

316
00:14:22,890 --> 00:14:25,170
有人喜欢用0~190

317
00:14:25,170 --> 00:14:27,290
那这种情况下就看呢

318
00:14:27,290 --> 00:14:30,330
唉，每个人自己的想法来参加

319
00:14:30,330 --> 00:14:32,070
来制定了一些呢

320
00:14:32,070 --> 00:14:34,290
自定义的完整性约束

321
00:14:34,290 --> 00:14:35,270
这就是呢

322
00:14:35,270 --> 00:14:36,990
完整性约束的内容

323
00:14:36,990 --> 00:14:38,510
最后，触发器的话

324
00:14:38,510 --> 00:14:41,170
在我们软件设计师考试当中呢

325
00:14:41,170 --> 00:14:44,410
呃，没有考过它的代码书写

326
00:14:44,410 --> 00:14:46,850
我们只需要知道触发器

327
00:14:46,850 --> 00:14:50,080
它可以完成一些复杂的

328
00:14:50,080 --> 00:14:52,420
完整性约束条件的设定

329
00:14:52,420 --> 00:14:54,710
那它的设定过程当中

330
00:14:54,710 --> 00:14:57,730
可以针对单条元组或者呢

331
00:14:57,730 --> 00:15:01,680
属性相应的变化来添加监听

332
00:15:01,680 --> 00:15:03,620
一旦发生变化之后

333
00:15:03,620 --> 00:15:06,280
我们呢就可以随之触发一些

334
00:15:06,280 --> 00:15:09,060
随之更新一些呢，新的内容

335
00:15:09,060 --> 00:15:11,660
这就是呢，触发器他的思想

336
00:15:11,660 --> 00:15:13,110
以上这些啊

337
00:15:13,110 --> 00:15:15,390
是我们数据库当

338
00:15:15,390 --> 00:15:17,540
关系模式的一些呢，概念

339
00:15:17,540 --> 00:15:19,590
这一部分概念啊

340
00:15:19,590 --> 00:15:21,910
在我们的上午题当中

341
00:15:21,910 --> 00:15:26,580
目前呢出现考察的频度呢，并不是很高

342
00:15:26,580 --> 00:15:28,740
那我们呢，掌握这些内容的话

343
00:15:28,740 --> 00:15:31,080
一方面是上午题可能出现

344
00:15:31,080 --> 00:15:32,240
另一方面呢

345
00:15:32,240 --> 00:15:36,100
它是我们后面的一些知识体系的基础

346
00:15:36,100 --> 00:15:38,620
所以大家呢还是需要了解到的
