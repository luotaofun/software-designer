1
00:00:00,000 --> 00:00:01,960
我们在前面讲到呢

2
00:00:01,960 --> 00:00:03,480
对于关系模式

3
00:00:03,480 --> 00:00:07,210
它是呢，数据库设计逻辑阶段设计的产物

4
00:00:07,210 --> 00:00:09,410
那对于关系模式而言

5
00:00:09,410 --> 00:00:11,980
它的实质啊，就是呢，二维表

6
00:00:11,980 --> 00:00:13,810
在二维表当中

7
00:00:13,810 --> 00:00:15,670
也就是关系模式之间呢

8
00:00:15,670 --> 00:00:18,190
我们可以进行关系代数的运算

9
00:00:18,190 --> 00:00:19,990
关系代数的运算

10
00:00:19,990 --> 00:00:22,510
在我们软件设计师考试当中

11
00:00:22,510 --> 00:00:25,810
上五题相对来说考察的比较频繁

12
00:00:25,810 --> 00:00:28,610
可能会涉及到结果的木

13
00:00:28,610 --> 00:00:29,530
或者说呢

14
00:00:29,530 --> 00:00:31,850
诶，属性个数要求大家判断

15
00:00:31,850 --> 00:00:35,900
然后呢，相应的计算结果让大家进行选择

16
00:00:35,900 --> 00:00:39,070
甚至呢，涉及到自然连接和笛卡尔基

17
00:00:39,070 --> 00:00:41,050
它们之间的等价表达式

18
00:00:41,050 --> 00:00:42,470
需要大家呢掌握

19
00:00:42,470 --> 00:00:44,780
并且在这之间啊

20
00:00:44,780 --> 00:00:45,960
我们还会呢

21
00:00:45,960 --> 00:00:50,010
唉，还需要大家了解到相应的一些查询

22
00:00:50,010 --> 00:00:52,690
与我们的关系代数的结合

23
00:00:52,690 --> 00:00:55,200
考察相应的表达式

24
00:00:55,200 --> 00:00:58,090
它的一些呢，性能方面的比较

25
00:00:58,090 --> 00:01:00,210
一旦考察关系代数

26
00:01:00,210 --> 00:01:01,370
它的分值啊

27
00:01:01,370 --> 00:01:05,069
基本上呢是两到四分的分值范围

28
00:01:05,069 --> 00:01:08,570
下面呢，我们先来看简单的关系代

29
00:01:08,570 --> 00:01:09,650
并交叉

30
00:01:09,650 --> 00:01:10,750
并交

31
00:01:10,750 --> 00:01:15,500
它所针对的诶，是两个表格之间的并交叉

32
00:01:15,500 --> 00:01:17,640
那在这种情况下

33
00:01:17,640 --> 00:01:22,890
这两个关系模式的表格结构一定是相同的

34
00:01:22,890 --> 00:01:26,790
也就是属性列和名称一定呢是一致的

35
00:01:26,790 --> 00:01:28,800
才能进行并交叉

36
00:01:28,800 --> 00:01:30,870
那对关系表来说

37
00:01:30,870 --> 00:01:32,510
它有两个维度

38
00:01:32,510 --> 00:01:35,390
一个呢，是垂直方向上的

39
00:01:35,390 --> 00:01:37,840
我们叫做呢属性列

40
00:01:37,840 --> 00:01:40,100
唉，也就是垂直方向

41
00:01:40,100 --> 00:01:42,080
它有呢属性列

42
00:01:47,400 --> 00:01:50,180
这个属性列的个数啊

43
00:01:50,180 --> 00:01:54,130
我们也可以叫它呢木或者呢度

44
00:01:54,130 --> 00:01:59,380
这里我们在关系模式的基本概念当中

45
00:01:59,380 --> 00:02:00,890
也有呢提到

46
00:02:00,890 --> 00:02:02,940
那除了垂直方向

47
00:02:02,940 --> 00:02:05,200
还有呢水平方向

48
00:02:05,200 --> 00:02:09,479
水平方向我们叫做呢元组行

49
00:02:11,720 --> 00:02:15,300
那我们说一个元组也叫呢

50
00:02:15,300 --> 00:02:16,920
一条记录

51
00:02:18,810 --> 00:02:21,850
它也是一个实例

52
00:02:23,180 --> 00:02:24,820
我们一般说啊

53
00:02:24,820 --> 00:02:25,820
关系模式

54
00:02:25,820 --> 00:02:27,200
尤其是实体

55
00:02:27,200 --> 00:02:29,440
它其实是一个实体的集合吧

56
00:02:29,440 --> 00:02:31,380
比如说在这个表格当中

57
00:02:31,380 --> 00:02:34,040
它应该呢是一个学生表格

58
00:02:34,040 --> 00:02:35,840
包含相应的学号

59
00:02:35,840 --> 00:02:38,430
姓名和所属的姓名称

60
00:02:38,430 --> 00:02:42,580
那每一行也就是水平方向

61
00:02:42,580 --> 00:02:44,910
来看这一条记录啊

62
00:02:44,910 --> 00:02:50,230
它表示的其实是 number 0001这一个学生吧

63
00:02:50,230 --> 00:02:52,550
所以在表格当中啊

64
00:02:52,550 --> 00:02:54,950
我们水平方向可以呢

65
00:02:54,950 --> 00:02:56,610
理解为一个实例

66
00:02:56,610 --> 00:02:59,200
它也是呢，一个整体

67
00:02:59,200 --> 00:03:01,700
所谓并交叉运算

68
00:03:01,700 --> 00:03:05,880
就是对 S 1、 S 2进行集合运算

69
00:03:05,880 --> 00:03:08,830
那我们对 S 1来看的话

70
00:03:08,830 --> 00:03:13,840
它里面会包含一些相应的实例

71
00:03:13,840 --> 00:03:16,350
包含 number 0001

72
00:03:16,350 --> 00:03:20,300
然后 number 0003 lab 0004

73
00:03:20,300 --> 00:03:24,950
S 2当中也包含 number 0001、0008

74
00:03:24,950 --> 00:03:27,640
还有呢，0021这样的实例

75
00:03:27,640 --> 00:03:32,710
那它们之间相交的是0001 S 1

76
00:03:32,710 --> 00:03:37,030
还包含0003、0004

77
00:03:37,030 --> 00:03:43,660
S 2它还包含0008、0021

78
00:03:43,660 --> 00:03:47,590
那针对这两个集合来看的话

79
00:03:47,590 --> 00:03:49,350
所谓的并

80
00:03:49,350 --> 00:03:50,910
其实呢，就是

81
00:03:50,910 --> 00:03:54,430
诶，将这些元组依次记录下来

82
00:03:54,430 --> 00:03:57,910
重复的元组记录一次就可以了

83
00:03:57,910 --> 00:04:04,300
那 S 1的一、三、四、 S 2、一已经记录过了

84
00:04:04,300 --> 00:04:07,860
记录呢，八和21的元组就可以了

85
00:04:07,860 --> 00:04:10,660
这里呢，就是并集

86
00:04:11,790 --> 00:04:13,730
并集可以呢

87
00:04:13,730 --> 00:04:17,070
用向上的 U 字符号来表示

88
00:04:17,070 --> 00:04:18,990
那接下来还有呢

89
00:04:18,990 --> 00:04:19,670
交集

90
00:04:19,670 --> 00:04:22,700
那它们二者之间相交的是谁啊

91
00:04:22,700 --> 00:04:26,610
就是 lab .0001的记录

92
00:04:26,810 --> 00:04:29,790
最后差几差级

93
00:04:29,790 --> 00:04:32,270
它具有一定的方向性

94
00:04:32,270 --> 00:04:37,490
S 1减 S 2与 S 2减 S 1是不一样的

95
00:04:40,700 --> 00:04:42,860
那我们可以看到呢

96
00:04:42,860 --> 00:04:47,570
S 1减 S 2是以 S 1为主体

97
00:04:47,570 --> 00:04:51,380
那 S 1当中减去 S 2的内容

98
00:04:51,380 --> 00:04:54,160
其实就是减去了它的交集

99
00:04:54,160 --> 00:04:59,410
剩下的三和四就是呢，它的最终结果

100
00:04:59,410 --> 00:05:03,150
那如果是 S 2减去 S 1

101
00:05:03,150 --> 00:05:08,300
在 S 2集合当中减去 S 1包含的部分

102
00:05:08,300 --> 00:05:09,740
剩下的就是呢

103
00:05:09,740 --> 00:05:13,690
0008和0021的记录吧

104
00:05:13,690 --> 00:05:14,830
那这里呢

105
00:05:14,830 --> 00:05:18,780
涉及到的就是差几并交叉

106
00:05:18,780 --> 00:05:23,060
它们参与运算的关系模式和结果

107
00:05:23,060 --> 00:05:26,650
关系模式结构都是一致的

108
00:05:26,650 --> 00:05:29,660
并集以向上的 U 来表示

109
00:05:29,660 --> 00:05:33,210
交集以向下的 U 来表示

110
00:05:33,210 --> 00:05:37,310
那差级就是我们平常用到的减号

111
00:05:37,310 --> 00:05:41,370
就是呢，比较简单的并交叉集合运算

112
00:05:41,370 --> 00:05:44,480
那还有复杂的关系代数

113
00:05:44,480 --> 00:05:45,520
比如说呢

114
00:05:45,520 --> 00:05:47,230
哎，笛卡尔基

115
00:05:47,230 --> 00:05:49,750
对于笛卡尔基来说啊

116
00:05:49,750 --> 00:05:54,120
它所针对的两个参与笛卡尔基的对象

117
00:05:54,120 --> 00:05:56,520
可以是相同结构的

118
00:05:56,520 --> 00:05:58,840
也可以是不同结构的

119
00:05:58,840 --> 00:06:01,790
这里没有要求笛卡尔基

120
00:06:01,790 --> 00:06:05,050
我们一般呢，就用乘号来表示

121
00:06:05,050 --> 00:06:09,270
那 S 1与 S 2的笛卡尔基

122
00:06:09,360 --> 00:06:14,080
首先结果的属性列数

123
00:06:17,260 --> 00:06:19,980
是二者之和

124
00:06:21,170 --> 00:06:25,870
我们会将 S 1的属性列依次记录

125
00:06:25,870 --> 00:06:28,930
S 2的属性列依次记录

126
00:06:28,930 --> 00:06:31,540
那这就是它的属性列数

127
00:06:31,540 --> 00:06:34,680
对于这种同名的属性链

128
00:06:34,680 --> 00:06:38,010
我们一般啊是需要加上表明

129
00:06:38,010 --> 00:06:40,270
从而呢进行区分的

130
00:06:40,270 --> 00:06:42,110
那这是 S 1

131
00:06:42,110 --> 00:06:44,120
这是呢？ S 2

132
00:06:44,870 --> 00:06:49,730
由于增加了表明点的形式来引用

133
00:06:49,730 --> 00:06:53,140
包括呢有很多的这种列名啊

134
00:06:53,140 --> 00:06:55,430
它的名字很长

135
00:06:55,430 --> 00:07:00,040
所以我们可以用一、二、三、四、五、

136
00:07:00,040 --> 00:07:03,430
来依次表示相应的列明

137
00:07:03,430 --> 00:07:08,460
也就是说序号可以表示列名进行替代

138
00:07:08,460 --> 00:07:12,500
那这是从垂直方向属性列看

139
00:07:12,500 --> 00:07:15,780
那针对水平方向来看的话

140
00:07:15,780 --> 00:07:18,780
它们的元组行数

141
00:07:21,360 --> 00:07:24,520
是二者的乘积

142
00:07:27,100 --> 00:07:32,200
它的元组结果其实是二者的排列组合

143
00:07:32,200 --> 00:07:35,670
还是将每一个行看作整体

144
00:07:35,670 --> 00:07:39,230
number 001这一个整体

145
00:07:39,230 --> 00:07:42,270
与 number 002的三个整体

146
00:07:42,270 --> 00:07:45,250
来进行不同的排列组合

147
00:07:45,250 --> 00:07:48,640
再以 S 1的第二条记录

148
00:07:48,640 --> 00:07:52,850
与 S 2的三条记录进行排列组合

149
00:07:52,850 --> 00:07:57,690
S 1的第三条记录与 S 2的三条记录

150
00:07:57,690 --> 00:07:59,810
来进行排列组合

151
00:07:59,810 --> 00:08:03,890
那最终的结果会有九条记录

152
00:08:03,890 --> 00:08:05,470
所以笛卡尔基啊

153
00:08:05,470 --> 00:08:09,530
它其实是很庞大的一个结果集合

154
00:08:09,530 --> 00:08:11,820
那笛卡尔基因以外呢

155
00:08:11,820 --> 00:08:16,620
我们还经常会与投影选择来进行结合

156
00:08:16,620 --> 00:08:20,570
投影和选择它是一元计算

157
00:08:20,570 --> 00:08:21,650
也就是说

158
00:08:21,650 --> 00:08:25,070
投影选择针对的是一个表格

159
00:08:25,070 --> 00:08:26,830
不需要多个表格

160
00:08:26,830 --> 00:08:28,750
那对于投影

161
00:08:28,750 --> 00:08:32,520
我们一般呢用这种大写的派来表示

162
00:08:32,520 --> 00:08:36,030
投影的对象是一个表

163
00:08:36,030 --> 00:08:37,950
针对这个表

164
00:08:37,950 --> 00:08:41,419
投影是垂直方向选

165
00:08:41,419 --> 00:08:43,360
我们针对的属性列

166
00:08:43,360 --> 00:08:49,230
比如说 S 1针对 s number 、 s name 来进行投影

167
00:08:49,230 --> 00:08:53,080
那它是垂直方向选择列

168
00:08:53,080 --> 00:08:56,720
没有选到的就不需要展示了

169
00:08:56,720 --> 00:08:58,410
那最终的结果

170
00:08:58,410 --> 00:09:04,090
s number 、 s name 对应的相应数据把它呢列举出来

171
00:09:04,090 --> 00:09:06,250
这就是呢，投影

172
00:09:06,250 --> 00:09:09,640
同样我们还有水平方向的

173
00:09:09,640 --> 00:09:13,820
水平方向我们叫做呢选择操作

174
00:09:13,820 --> 00:09:20,450
那选本则它其实是对元组进行条件筛选

175
00:09:20,450 --> 00:09:23,750
那它是水平方向的

176
00:09:23,750 --> 00:09:27,610
我们用了这种小写的 sigma 来表示

177
00:09:27,870 --> 00:09:30,230
那对于这个 C 它来看的话

178
00:09:30,230 --> 00:09:33,130
它是 s number 等于0003

179
00:09:33,130 --> 00:09:35,970
针对的同样是一个表格

180
00:09:35,970 --> 00:09:36,300
唉

181
00:09:36,300 --> 00:09:37,940
一个对象 S 1

182
00:09:37,940 --> 00:09:42,660
满足 s number 等于 number 0003的记录只有一条

183
00:09:42,660 --> 00:09:46,240
所以它的最终结果只有那一条

184
00:09:46,240 --> 00:09:49,220
记录在这里啊

185
00:09:49,220 --> 00:09:53,640
选择操作是不会修改表格结构的

186
00:09:53,640 --> 00:09:55,960
但是投影和笛卡尔基因呢

187
00:09:55,960 --> 00:09:57,810
哎，一般会修改

188
00:09:57,810 --> 00:10:01,900
那这里呢，是关于笛卡尔基投影选择

189
00:10:01,900 --> 00:10:06,180
我们在这里出现的属性列名都可以呢

190
00:10:06,180 --> 00:10:08,460
依据相应表格的序号

191
00:10:08,460 --> 00:10:12,500
把它替换成相应的序号就可以了

192
00:10:12,500 --> 00:10:19,230
那如果我们写 S 1.1等于 S 2.1

193
00:10:19,230 --> 00:10:22,580
它其实表示的是 S 1点

194
00:10:22,580 --> 00:10:25,270
s number 等于 S 2点 s number 

195
00:10:25,270 --> 00:10:28,650
那一等于二表示的是什么

196
00:10:28,650 --> 00:10:32,250
第一列的结果等于第二列的结果

197
00:10:32,250 --> 00:10:35,110
这是考虑列的取值

198
00:10:35,110 --> 00:10:38,910
那第一列取值等于一怎么办

199
00:10:38,910 --> 00:10:40,960
第一列取值等于一

200
00:10:40,960 --> 00:10:47,350
我们会用引号对取值来进行一个引用标识

201
00:10:47,350 --> 00:10:49,530
注意呢，这些区别

202
00:10:49,530 --> 00:10:52,310
这是关于列号的应用

203
00:10:52,310 --> 00:10:54,920
最后我们来看一下自然连接

204
00:10:54,920 --> 00:10:58,090
自然连接也是一个呢，二元运算

205
00:10:58,090 --> 00:11:00,880
由两个表格来进行自然连接

206
00:11:00,880 --> 00:11:03,780
那么进行自然连接的时候啊

207
00:11:03,780 --> 00:11:07,560
它们的符号我们会用了两个，诶

208
00:11:07,560 --> 00:11:11,180
顶对顶的三角形来表示

209
00:11:11,180 --> 00:11:16,190
那 S 1与 S 2进行自然连接的话

210
00:11:16,190 --> 00:11:20,510
我们啊，对于二者的结果同样呢

211
00:11:20,510 --> 00:11:23,590
首先考虑属性列数

212
00:11:26,800 --> 00:11:29,140
是不是二者之和呢

213
00:11:29,140 --> 00:11:31,800
哎，不再是二者之和了

214
00:11:31,800 --> 00:11:36,620
它们啊，会减去乘重复属性列数

215
00:11:40,880 --> 00:11:45,280
比如说 S 1和 S 2进行自然连接的话

216
00:11:45,280 --> 00:11:50,790
我们首先会将 S 1的属性依次记录下来

217
00:11:50,790 --> 00:11:54,460
S 2的属性不会呢，依次记录

218
00:11:54,460 --> 00:11:56,260
同名的属性列

219
00:11:56,260 --> 00:11:58,240
只需要记录一次

220
00:11:58,240 --> 00:12:01,260
所以要减去有一个重复

221
00:12:01,260 --> 00:12:03,000
那就能减去一

222
00:12:03,000 --> 00:12:05,170
二者之和是五

223
00:12:05,170 --> 00:12:07,000
重复列数是一

224
00:12:07,000 --> 00:12:11,040
所以最终的结果只有四个属性列

225
00:12:11,040 --> 00:12:13,420
这是它的属性列数

226
00:12:13,420 --> 00:12:15,570
元组行数呢

227
00:12:15,570 --> 00:12:17,730
哎，没有具体的数值

228
00:12:17,730 --> 00:12:20,170
因为它需要进行筛选

229
00:12:20,170 --> 00:12:23,740
它是呢，同名属性列

230
00:12:25,220 --> 00:12:27,700
取值相等

231
00:12:32,300 --> 00:12:37,080
所以我们并不是将所有的记录都列下来

232
00:12:37,080 --> 00:12:39,200
我们需要呢进行筛选

233
00:12:39,200 --> 00:12:42,780
那同名属性列 S 1点 s number 

234
00:12:42,780 --> 00:12:45,380
是等于 S 2点 s number 的

235
00:12:45,380 --> 00:12:49,110
满足要求的只有呢第一条记录

236
00:12:49,110 --> 00:12:53,250
所以将 LAMBER 0001的信息记录下来

237
00:12:53,250 --> 00:12:55,390
随之对应 S 2

238
00:12:55,390 --> 00:12:59,620
它有一个呢，23的年龄与之对应

239
00:12:59,620 --> 00:13:02,220
这就是呢自然连接

240
00:13:02,790 --> 00:13:06,030
对于自然连接和笛卡尔基

241
00:13:06,030 --> 00:13:07,810
它们二者之间啊

242
00:13:07,810 --> 00:13:10,170
是有一定对应关系的

243
00:13:10,170 --> 00:13:12,950
可以呢，有等价表达式

244
00:13:12,950 --> 00:13:14,690
那我们可以看到呢

245
00:13:14,690 --> 00:13:17,570
等价表达式这个过程当中

246
00:13:17,570 --> 00:13:20,480
我们需要筛选元组列数

247
00:13:20,480 --> 00:13:21,560
属性列数吧

248
00:13:21,560 --> 00:13:23,950
那它有投影的过程

249
00:13:23,950 --> 00:13:27,390
需要呢筛选满足条件的元组行数

250
00:13:27,390 --> 00:13:29,480
所以呢，有选择的过程

251
00:13:29,480 --> 00:13:33,440
那到底是先做选择再做投影

252
00:13:33,440 --> 00:13:36,600
还是先做投影再做选择呢

253
00:13:36,600 --> 00:13:38,280
唉，大家思考一下

254
00:13:38,280 --> 00:13:43,090
这两个表达式最终的结果是不是一样的

255
00:13:43,090 --> 00:13:46,760
那哪一个才是与自然连接的结果

256
00:13:46,760 --> 00:13:49,160
保持一致的呢

257
00:13:50,280 --> 00:13:52,020
我们来看一下

258
00:13:52,020 --> 00:13:54,950
首先先看我们啊

259
00:13:54,950 --> 00:13:58,610
对 S 1 S 2进行笛卡尔基的话

260
00:13:58,610 --> 00:14:03,400
笛卡尔基的结果包含几个属性列哎

261
00:14:03,400 --> 00:14:06,140
会包含二者之和

262
00:14:06,140 --> 00:14:10,420
所以 S 1点 SLAMBO 

263
00:14:10,760 --> 00:14:13,560
然后 S 1点 s name 

264
00:14:13,560 --> 00:14:17,600
没有同名的可以不标 SDPT 

265
00:14:18,620 --> 00:14:21,040
S 2点， s number 

266
00:14:21,040 --> 00:14:23,060
还有呢， A 、 G 、 E 

267
00:14:23,400 --> 00:14:25,960
这是笛卡尔基的结果吧

268
00:14:25,960 --> 00:14:29,220
它的属性列数是二者之和

269
00:14:29,220 --> 00:14:30,510
有五个列

270
00:14:30,510 --> 00:14:34,500
那针对这里面的结果来筛选

271
00:14:34,500 --> 00:14:36,780
同名属性列相等

272
00:14:36,780 --> 00:14:41,240
也就是第一列与第四列取值相等吧

273
00:14:41,240 --> 00:14:43,520
所以这是呢，选择

274
00:14:43,520 --> 00:14:44,970
选择之后

275
00:14:44,970 --> 00:14:47,130
我们在运算的过程当中啊

276
00:14:47,130 --> 00:14:51,310
应该是从括号内部往外来进行推算的

277
00:14:51,310 --> 00:14:54,440
那选择之后再进行投影

278
00:14:54,440 --> 00:14:58,540
只需要列出1235列就行了

279
00:14:58,540 --> 00:15:02,190
第四列同名属性列不需要展示

280
00:15:02,190 --> 00:15:06,030
那这个结果跟我们的自然连

281
00:15:06,030 --> 00:15:09,190
S 1、 S 2是等价的

282
00:15:09,190 --> 00:15:13,610
那这就是呢，先做选择再做投影

283
00:15:13,610 --> 00:15:18,740
那如果我们对笛卡尔基先做投影会怎么样呢

284
00:15:18,740 --> 00:15:20,870
投影1235

285
00:15:20,870 --> 00:15:25,160
我们会发现第四列的结果没有了

286
00:15:25,160 --> 00:15:27,170
那再做选择

287
00:15:27,170 --> 00:15:29,130
针对的这个子表啊

288
00:15:29,130 --> 00:15:30,980
有几个属性列

289
00:15:30,980 --> 00:15:32,570
四个属性列吧

290
00:15:32,570 --> 00:15:35,880
这里是新的1234

291
00:15:35,880 --> 00:15:39,450
选择一等于四的元组

292
00:15:39,450 --> 00:15:41,740
筛选的是 S 1

293
00:15:41,740 --> 00:15:45,670
s number 等于 S 2点 A 级一

294
00:15:45,670 --> 00:15:48,920
还是不是同名属性列取值相等啊

295
00:15:48,920 --> 00:15:50,220
不再是了

296
00:15:50,220 --> 00:15:54,430
所以它与自然连接并不等价

297
00:15:54,430 --> 00:15:58,520
这个过程呢，一定要注意要看清楚

298
00:15:58,520 --> 00:16:01,920
先做选择再做投影

299
00:16:03,150 --> 00:16:05,610
针对笛卡尔基的投影

300
00:16:05,610 --> 00:16:08,410
选择跟自然连接是有等价的吧

301
00:16:08,410 --> 00:16:10,440
那在这个过程当中啊

302
00:16:10,440 --> 00:16:15,820
我们还要呢了解到它们之间的性能比较

303
00:16:15,820 --> 00:16:20,420
如果说 S 1、 S 2都做自然连接

304
00:16:20,420 --> 00:16:22,890
S 1、 S 2做笛卡尔基

305
00:16:22,890 --> 00:16:28,190
相对来说我们会认为自然连接的性能更优

306
00:16:31,780 --> 00:16:35,580
其次，我们在运算的过程当中

307
00:16:35,580 --> 00:16:38,500
两侧的表格应该呢

308
00:16:38,500 --> 00:16:40,840
尽可能的先压缩

309
00:16:40,840 --> 00:16:45,080
也就是说如果有筛选条件可用的话

310
00:16:45,080 --> 00:16:48,640
先筛选再做呢，连接或者笛卡尔机

311
00:16:48,640 --> 00:16:50,400
唉，因为呢，笛卡尔基啊

312
00:16:50,400 --> 00:16:54,180
比如说呢，满足条件的 S 1只有十行

313
00:16:54,180 --> 00:16:56,230
我们筛选之后，唉

314
00:16:56,230 --> 00:16:58,470
原本 S 1有100行

315
00:16:58,470 --> 00:17:00,060
S 2有100行

316
00:17:00,060 --> 00:17:03,030
做笛卡尔机会有100行记录

317
00:17:03,030 --> 00:17:06,329
先做筛选就成了10×100

318
00:17:06,329 --> 00:17:08,310
只有1000条记录了

319
00:17:08,310 --> 00:17:11,589
那如果二者都先做筛选

320
00:17:11,589 --> 00:17:13,970
最终呢只有100条记录

321
00:17:13,970 --> 00:17:17,089
所以啊，一定呢要看清楚

322
00:17:17,089 --> 00:17:19,400
如果判断性能的话

323
00:17:19,400 --> 00:17:22,060
要考虑两侧

324
00:17:25,079 --> 00:17:27,599
运算对象尽可能小

325
00:17:27,599 --> 00:17:29,960
运算表格尽可能小

326
00:17:30,550 --> 00:17:35,720
咕嘟咕嘟咕嘟咕嘟咕嘟

327
00:17:35,720 --> 00:17:39,870
那这是呢，关于我们的性能问题

328
00:17:39,870 --> 00:17:41,940
那我们在考试当中啊

329
00:17:41,940 --> 00:17:43,560
一般考察性能的话

330
00:17:43,560 --> 00:17:46,590
就是关于自然连接和笛卡尔基的对比

331
00:17:46,590 --> 00:17:51,060
以及呢，唉，他们运算对象大小不一致的情况下

332
00:17:51,060 --> 00:17:54,110
应该呢选择什么样的情况

333
00:17:54,110 --> 00:17:57,860
那这是关于啊，关系代数的运算

334
00:17:57,860 --> 00:17:59,420
关系代数啊

335
00:17:59,420 --> 00:18:02,160
它在我们的 SQL 语句当中呢

336
00:18:02,160 --> 00:18:03,660
其实也有结合

337
00:18:03,660 --> 00:18:05,650
那在这里先给大家呢

338
00:18:05,650 --> 00:18:07,270
简单做一下介绍

339
00:18:07,270 --> 00:18:09,450
后面讲 SQL 语句的时候呢

340
00:18:09,450 --> 00:18:12,420
再来详细的给大家进行说明

341
00:18:12,420 --> 00:18:17,590
我们常见的 circle 语句是 select 查询语句

342
00:18:18,100 --> 00:18:23,620
查询语句的基本格式是查询相应的属性

343
00:18:23,620 --> 00:18:26,920
列从对应的表格当中

344
00:18:26,920 --> 00:18:30,040
然后呢，判断物业条件

345
00:18:32,480 --> 00:18:35,100
那在这个过程当中

346
00:18:35,100 --> 00:18:39,410
选择的属性列其实是投影的结果

347
00:18:39,410 --> 00:18:44,450
那对应的表格如果用逗号隔开多个表格

348
00:18:44,450 --> 00:18:47,590
是对笛卡尔基的结果来进行的

349
00:18:47,590 --> 00:18:51,550
where 条件，它是一个元组行的筛选

350
00:18:51,550 --> 00:18:54,810
所以对应的是选择条件

351
00:18:54,810 --> 00:18:56,230
这个对应关系啊

352
00:18:56,230 --> 00:18:58,430
自己呢可以理一理

353
00:18:58,430 --> 00:19:01,540
并且我们在满足条件的时候

354
00:19:01,540 --> 00:19:04,700
如果 where 有多个条件的话

355
00:19:04,700 --> 00:19:07,180
我们会用 and 来表示

356
00:19:07,180 --> 00:19:11,580
and 也可以用下尖上尖角符号来表示

357
00:19:11,580 --> 00:19:15,620
or 呢，满足其中一个条件就可以了

358
00:19:15,620 --> 00:19:17,280
以 V 呢来表示

359
00:19:17,280 --> 00:19:18,580
这种形式啊

360
00:19:18,580 --> 00:19:20,700
大家呢，也要了解一下

361
00:19:20,700 --> 00:19:25,920
这是呢，关于关系代数与 select 语句的一个呢结合

362
00:19:25,920 --> 00:19:28,430
接下来我们来看一下关系代数

363
00:19:28,430 --> 00:19:31,510
在软件设计师考试真题当中的体现

364
00:19:31,510 --> 00:19:33,150
首先第一道题呢

365
00:19:33,150 --> 00:19:36,210
是关于自然连接它的结果

366
00:19:36,210 --> 00:19:39,950
以及呢，自然连接与笛卡尔基的对应关系

367
00:19:39,950 --> 00:19:42,940
首先看到呢，给了我们关系模

368
00:19:42,940 --> 00:19:45,270
包含 ABCD 4个属性

369
00:19:45,270 --> 00:19:49,880
那现在呢，还有 S 、 A 、 C 、 E 、 F 4个属性

370
00:19:49,880 --> 00:19:54,360
我们现在要对这两个关系表进行自然连接

371
00:19:54,360 --> 00:19:56,140
那自然连接之后

372
00:19:56,140 --> 00:19:58,020
属性列数有多少呢

373
00:19:58,020 --> 00:20:03,670
唉，应该是二者之和减去重复列数 A 、 A 和 C 吧

374
00:20:03,670 --> 00:20:05,950
所以最终它的结果呢

375
00:20:05,950 --> 00:20:08,030
应该是有六个属性列

376
00:20:08,030 --> 00:20:11,160
分别是 R 的 ABCD 以及呢

377
00:20:11,160 --> 00:20:12,820
S 的 E 和 F 

378
00:20:12,820 --> 00:20:15,730
那与之对应的笛卡尔

379
00:20:15,730 --> 00:20:17,880
结果我们会发现呢

380
00:20:17,880 --> 00:20:19,920
四个选项都是笛卡尔基

381
00:20:19,920 --> 00:20:23,080
并且笛卡尔基是以12345、六、

382
00:20:23,080 --> 00:20:25,100
这种列序来表示的

383
00:20:25,100 --> 00:20:26,200
那我们看

384
00:20:26,200 --> 00:20:29,240
对 R 和 S 进行低开耳机的话

385
00:20:29,240 --> 00:20:32,150
属性列数是二者之和吧

386
00:20:32,150 --> 00:20:34,910
每一个属性列都会保留下来

387
00:20:34,910 --> 00:20:39,750
它们的列号依次为一、二、三、四、五、六、七、八

388
00:20:39,750 --> 00:20:43,380
那针对这个笛卡尔基的结果

389
00:20:43,380 --> 00:20:46,080
与之对应的自然连接表达式

390
00:20:46,080 --> 00:20:47,660
首先我们要知道

391
00:20:47,660 --> 00:20:49,600
笛卡尔基与自然连

392
00:20:49,600 --> 00:20:51,600
同名属性列，哎

393
00:20:51,600 --> 00:20:54,100
一和五、三和六

394
00:20:54,100 --> 00:20:57,150
同名属性列和，哎

395
00:20:57,150 --> 00:21:00,050
它们之间啊，应该呢取值相等

396
00:21:00,050 --> 00:21:01,770
同名属性列取值相等

397
00:21:01,770 --> 00:21:02,710
一等于五

398
00:21:02,710 --> 00:21:04,240
三等于六

399
00:21:04,240 --> 00:21:08,750
并且还要满足二点 B 大于 S 点 E 

400
00:21:08,750 --> 00:21:10,570
也就是二

401
00:21:11,090 --> 00:21:12,960
大于七

402
00:21:12,960 --> 00:21:16,190
这是呢，必须要满足的三个条件

403
00:21:16,190 --> 00:21:18,110
并且是同时满足

404
00:21:18,110 --> 00:21:20,470
所以用 and 来表示

405
00:21:20,470 --> 00:21:24,980
那满足条件的很明显只有 B 选项

406
00:21:24,980 --> 00:21:28,020
并且我们筛选元组之后

407
00:21:28,020 --> 00:21:30,610
投影的属性列也要呢

408
00:21:30,610 --> 00:21:32,350
哎，与自然连接相同

409
00:21:32,350 --> 00:21:35,350
只有呢，一、二、三、四和七、八

410
00:21:35,350 --> 00:21:38,800
那这是能满足要求的选项

411
00:21:38,800 --> 00:21:40,790
对于 A 选项来看

412
00:21:40,790 --> 00:21:43,490
它只考虑了大于符号

413
00:21:43,490 --> 00:21:47,400
没有考虑呢同名属性列取值相等

414
00:21:47,400 --> 00:21:50,130
并且没有呢做投影

415
00:21:50,130 --> 00:21:53,170
C 选项和 D 选项当中

416
00:21:53,170 --> 00:21:57,590
注意打引号的七表示的是它的取值

417
00:21:57,590 --> 00:22:00,540
而不是列号之间的对比

418
00:22:00,540 --> 00:22:03,360
不是属性取值的对比了

419
00:22:03,360 --> 00:22:06,640
那这里呢，注意一下这种区别

420
00:22:06,640 --> 00:22:08,900
这是呢，关于自然连接

421
00:22:08,900 --> 00:22:12,920
还有呢，自然连接与笛卡尔基的等价关系

422
00:22:12,920 --> 00:22:14,580
下面这道题呢

423
00:22:14,580 --> 00:22:16,760
看到关于查询效率

424
00:22:16,760 --> 00:22:19,070
也就是性能的对比

425
00:22:19,070 --> 00:22:22,990
那下列查询 B 等于大数据

426
00:22:22,990 --> 00:22:24,920
F 等于开发平台

427
00:22:24,920 --> 00:22:28,330
结果属性列为 A 、 B 、 C 、 F 的关系

428
00:22:28,330 --> 00:22:32,350
表达式中查询效率最高的是谁

429
00:22:32,890 --> 00:22:36,760
首先啊，这道题给的并不是很完全

430
00:22:36,760 --> 00:22:39,940
我们并不知道，唉，我们的关系

431
00:22:39,940 --> 00:22:41,520
R 包含哪些属性

432
00:22:41,520 --> 00:22:43,140
S 包含哪些属性

433
00:22:43,140 --> 00:22:45,700
但是根据四个选项来对比

434
00:22:45,700 --> 00:22:48,200
其实是能够对比出效率的

435
00:22:48,200 --> 00:22:50,270
那在对比的过程当中

436
00:22:50,270 --> 00:22:54,030
我们发现它的所有运算都是笛卡尔基吧

437
00:22:54,030 --> 00:22:57,510
笛卡尔基与笛卡尔基有区别的是什么呢

438
00:22:57,510 --> 00:23:00,830
两侧的相应的这个列啊

439
00:23:00,830 --> 00:23:04,930
和属性的元组数是不是一样的

440
00:23:04,930 --> 00:23:07,470
那首先第一种方式呢

441
00:23:07,470 --> 00:23:10,020
是先做完整的笛卡尔机

442
00:23:10,020 --> 00:23:13,350
第二种方式对 R 先筛选记录

443
00:23:13,350 --> 00:23:15,150
再与 S 做笛卡尔基

444
00:23:15,150 --> 00:23:18,330
第三种方式呢，先对 S 筛选

445
00:23:18,330 --> 00:23:20,450
再做呢，相应的笛卡尔基

446
00:23:20,450 --> 00:23:25,450
那第四种方式对两者同时进行筛选

447
00:23:25,450 --> 00:23:27,400
再来做呢，笛卡尔基

448
00:23:27,400 --> 00:23:28,590
那很明显

449
00:23:28,590 --> 00:23:30,130
第四种方式

450
00:23:30,130 --> 00:23:34,250
它两侧参与笛卡尔基运算的表格记录

451
00:23:34,250 --> 00:23:36,030
应该是最少的

452
00:23:36,030 --> 00:23:40,340
那比如说呢，我们假设 I 有100条记录

453
00:23:40,340 --> 00:23:44,180
满足二等于大数据的

454
00:23:47,570 --> 00:23:50,800
有十条 S 呢

455
00:23:50,800 --> 00:23:52,700
有50条记

456
00:23:52,700 --> 00:23:57,380
满足四等于开发平台的

457
00:23:59,790 --> 00:24:02,390
有20条记录

458
00:24:02,830 --> 00:24:04,790
那我们可以看到

459
00:24:04,790 --> 00:24:08,920
首先 A 选项对 R 和 S 做笛卡尔基

460
00:24:08,920 --> 00:24:13,510
它所针对的笛卡尔基结果有5000条记录吧

461
00:24:13,510 --> 00:24:17,610
后面我们针对5000条记录进行筛选

462
00:24:17,610 --> 00:24:20,160
以及呢，相应的投影

463
00:24:20,160 --> 00:24:21,680
B 选项呢

464
00:24:21,680 --> 00:24:24,160
我们先筛选记录

465
00:24:24,160 --> 00:24:26,220
哎，它是呢，大数据

466
00:24:26,220 --> 00:24:29,180
也就是 R 当中的十条记录

467
00:24:29,180 --> 00:24:31,540
那我们筛选的过程当中

468
00:24:31,540 --> 00:24:34,160
可能呢，我扫描了100条记录

469
00:24:34,160 --> 00:24:35,300
这是第一次

470
00:24:35,300 --> 00:24:36,510
第二次呢

471
00:24:36,510 --> 00:24:39,410
哎，对笛卡尔基的结果进行筛选的话

472
00:24:39,410 --> 00:24:43,950
就是呢，十条记录与50条记录进行筛选

473
00:24:43,950 --> 00:24:47,380
那这是500条的笛卡尔基结果吧

474
00:24:47,380 --> 00:24:49,300
那加上原有的100条

475
00:24:49,300 --> 00:24:52,440
只做了600条记录的筛选

476
00:24:52,440 --> 00:24:54,870
对于 C 选项来看的话

477
00:24:54,870 --> 00:24:57,910
首先对 S 进行扫描

478
00:24:57,910 --> 00:25:00,470
S 只有50条记录吧

479
00:25:00,470 --> 00:25:03,280
他们在做低卡尔基的时候

480
00:25:03,280 --> 00:25:06,670
筛选结果只剩下20条了

481
00:25:06,670 --> 00:25:10,230
20条与100条进行，哎

482
00:25:10,230 --> 00:25:12,390
20条和100条进行

483
00:25:12,390 --> 00:25:16,290
笛卡尔积变成了2050

484
00:25:16,600 --> 00:25:18,540
最后 D 选项

485
00:25:18,540 --> 00:25:23,200
那我们先对 R 这个表格做，呃

486
00:25:23,200 --> 00:25:24,900
扫描100条记录

487
00:25:24,900 --> 00:25:28,820
然后呢，对开发平台 S 呢，进行扫描

488
00:25:28,820 --> 00:25:30,120
50条记录

489
00:25:30,120 --> 00:25:33,310
然后对二者做笛卡尔基，诶

490
00:25:33,310 --> 00:25:37,330
他筛选之后的子表只有10×20

491
00:25:37,330 --> 00:25:39,190
只有200条记录

492
00:25:39,190 --> 00:25:41,520
最终我们扫描了多少次啊

493
00:25:41,520 --> 00:25:44,780
只扫描了350次

494
00:25:44,850 --> 00:25:47,800
很明显，这个数据谁最小

495
00:25:47,800 --> 00:25:50,030
D 选项是最小的吧

496
00:25:50,030 --> 00:25:52,650
其实就是我们之前提到的

497
00:25:52,650 --> 00:25:55,080
做自然连接和笛卡尔机的时候

498
00:25:55,080 --> 00:25:59,560
应该让两侧参与运算的表格尽可能小

499
00:25:59,560 --> 00:26:03,970
因为笛卡尔基本身是一个庞大的结果集合

500
00:26:03,970 --> 00:26:05,830
做完筛选之后啊

501
00:26:05,830 --> 00:26:07,570
它们二者的乘积呢

502
00:26:07,570 --> 00:26:09,720
才会尽可能的小

503
00:26:09,720 --> 00:26:14,580
那这是呢，关于它们之间性能的一个比较

504
00:26:14,770 --> 00:26:19,880
以上呢，就是关于关系代数给大家介绍的内容

505
00:26:19,880 --> 00:26:21,240
大家回去之后呢

506
00:26:21,240 --> 00:26:22,880
自己动手算一算

507
00:26:22,880 --> 00:26:26,480
做一下呢，相关的例题来巩固一下
