1
00:00:00,000 --> 00:00:03,840
接下来我们展开看一下存储系统当中

2
00:00:03,840 --> 00:00:05,430
catch 这一部分

3
00:00:05,430 --> 00:00:10,760
CCH ，它是呢处于 CPU 与主存之间的存储结构

4
00:00:10,760 --> 00:00:14,590
我们在层次化存储体系当中提到了 CCH 

5
00:00:14,590 --> 00:00:17,800
它可以呀解决 CPU 与主存之间

6
00:00:17,800 --> 00:00:20,170
速度、容量不匹配的问题

7
00:00:20,170 --> 00:00:23,060
在我们的软件设计师考试当中

8
00:00:23,060 --> 00:00:28,200
对 cash 的考察呢，主要体现在 cash 它的特点

9
00:00:28,200 --> 00:00:33,640
以及呢它的三种定值映射方式的区分

10
00:00:33,640 --> 00:00:37,030
首先我们来了解一下 cash 的概念

11
00:00:37,030 --> 00:00:38,140
KH 的话

12
00:00:38,140 --> 00:00:39,520
它可以啊

13
00:00:39,520 --> 00:00:43,700
解决 CPU 与主存之间速度、容量不匹配的问题

14
00:00:43,700 --> 00:00:45,510
它的存取速度呢

15
00:00:45,510 --> 00:00:47,940
比储存要快很多

16
00:00:47,940 --> 00:00:51,730
那我们一般将 catch 

17
00:00:53,820 --> 00:00:55,300
储存

18
00:00:56,580 --> 00:00:58,140
储存

19
00:01:00,680 --> 00:01:04,280
称为呢，三级存储体系

20
00:01:04,280 --> 00:01:08,530
注意呢，三级存储体系是不包含寄存器的

21
00:01:08,530 --> 00:01:12,080
那我们在层次化存储体系当中提

22
00:01:12,080 --> 00:01:15,350
寄存器，它是离 CPU 最近的

23
00:01:15,350 --> 00:01:17,010
各个存储层

24
00:01:17,010 --> 00:01:20,640
从 CPU 往外速度会越来越慢

25
00:01:20,640 --> 00:01:23,060
容量呢，是可以越来越大的

26
00:01:23,060 --> 00:01:25,230
在整个体系当中啊

27
00:01:25,230 --> 00:01:29,390
存取速度最快的还是呢，寄存器最快

28
00:01:29,390 --> 00:01:31,630
而除寄存器以外

29
00:01:31,630 --> 00:01:33,800
最快的呢，是 KH 

30
00:01:33,800 --> 00:01:36,870
也就是说，在三级存储体系当中

31
00:01:36,870 --> 00:01:39,910
CAH 呢，是访问速度最快的一个呢

32
00:01:39,910 --> 00:01:45,010
层次考试当中会出现速度相关的描述

33
00:01:45,010 --> 00:01:46,950
让大家呢判断正误

34
00:01:46,950 --> 00:01:49,060
或者给大家一些选项

35
00:01:49,060 --> 00:01:52,000
让大家呢来判断谁最快

36
00:01:52,000 --> 00:01:53,690
有寄存器的时候

37
00:01:53,690 --> 00:01:54,930
寄存器最快

38
00:01:54,930 --> 00:01:56,210
没有的时候

39
00:01:56,210 --> 00:01:58,430
catch 呢，是最快的

40
00:01:58,430 --> 00:02:00,230
在这里呀

41
00:02:00,390 --> 00:02:02,690
我们经常提到的

42
00:02:02,690 --> 00:02:06,930
catch 是可以解决 CPU 与主存之间速度

43
00:02:06,930 --> 00:02:08,389
容量不匹配的问题

44
00:02:08,389 --> 00:02:11,920
那它是如何来解决呢

45
00:02:11,920 --> 00:02:15,060
它对于整个系统性能啊

46
00:02:15,060 --> 00:02:17,060
能够呢改善

47
00:02:17,060 --> 00:02:19,520
那它改善的依据啊

48
00:02:19,520 --> 00:02:22,210
主要呢，就体现在 K

49
00:02:22,210 --> 00:02:26,830
它的访问速度比储存要快很多

50
00:02:26,830 --> 00:02:30,600
以及呢，局部性原理的支撑

51
00:02:30,600 --> 00:02:35,220
局部性原理是层次化存储体系的理论基础

52
00:02:35,220 --> 00:02:37,750
我们在前面呢，已经讲过了

53
00:02:37,750 --> 00:02:42,420
大家呢，可以回顾一下什么是局部性原理

54
00:02:42,420 --> 00:02:47,120
它可以分为时间局部性和空间局部性

55
00:02:47,120 --> 00:02:51,540
用到的数据很可能接下来频繁要用

56
00:02:51,540 --> 00:02:52,380
那就是呢

57
00:02:52,380 --> 00:02:55,260
时间局部性用到的东西

58
00:02:55,260 --> 00:02:56,320
接下来呢

59
00:02:56,320 --> 00:02:59,940
要用与它相邻的一些呢内容

60
00:02:59,940 --> 00:03:00,920
那就是呢

61
00:03:00,920 --> 00:03:02,360
空间局部性

62
00:03:02,360 --> 00:03:05,060
大家可以自己啊，再回顾一下

63
00:03:05,060 --> 00:03:09,850
那我们在这里重点看到的是 CCH 

64
00:03:09,850 --> 00:03:11,680
它的速度问题

65
00:03:11,680 --> 00:03:14,170
那为什么 KH 访问速度快

66
00:03:14,170 --> 00:03:16,900
就可以提升系统性能呢

67
00:03:16,900 --> 00:03:20,380
我们以一个生活的例子简单说明一下

68
00:03:20,380 --> 00:03:23,720
我们说啊，计算机它可以加工数据

69
00:03:23,720 --> 00:03:27,850
那我们在日常生活当中经常会碰到呢

70
00:03:27,850 --> 00:03:30,850
加工一些食材，诶，做饭

71
00:03:30,850 --> 00:03:36,010
那做饭的时候我们要加工一些食材

72
00:03:36,010 --> 00:03:39,460
那这些食材是用的时候

73
00:03:39,460 --> 00:03:43,050
从超市临时买回来的

74
00:03:43,050 --> 00:03:45,720
还是呢，提前买好

75
00:03:45,720 --> 00:03:47,680
放在家里用的时

76
00:03:47,680 --> 00:03:50,170
直接呢，就近就取

77
00:03:50,170 --> 00:03:52,530
哪一种速度比较快呀

78
00:03:52,530 --> 00:03:55,660
很显然后者更快一些吧

79
00:03:55,660 --> 00:03:57,840
在计算机当中

80
00:03:57,840 --> 00:03:59,940
它加工数据的时候

81
00:03:59,940 --> 00:04:02,820
数据的来源可以呢

82
00:04:02,820 --> 00:04:06,800
从储存用的时候临时去取

83
00:04:06,800 --> 00:04:09,770
那这种存取速度会慢很多吧

84
00:04:09,770 --> 00:04:13,820
但是如果我们提前把数据准备好

85
00:04:13,820 --> 00:04:16,230
放到 catch 当中去的话

86
00:04:16,230 --> 00:04:20,260
那很显然整体的速度就会有所提升了

87
00:04:20,260 --> 00:04:25,470
如果说我们想要的东西一直在 catch 当中

88
00:04:25,470 --> 00:04:26,410
可以找到

89
00:04:26,410 --> 00:04:29,680
整体的性能提升就更高了吧

90
00:04:29,680 --> 00:04:31,560
那这个过程其实呢

91
00:04:31,560 --> 00:04:35,820
也会体现到我们 catch 的命中率

92
00:04:36,080 --> 00:04:39,900
对于 catch 它存储的内容啊

93
00:04:39,900 --> 00:04:43,260
其实就是从主存复制了一部分

94
00:04:43,260 --> 00:04:45,350
放到我们的 catch 当中

95
00:04:45,350 --> 00:04:46,470
用的时候呢

96
00:04:46,470 --> 00:04:48,170
直接去拿

97
00:04:48,170 --> 00:04:51,790
那我们访问数据的时候

98
00:04:51,790 --> 00:04:55,620
如果这个内容刚好在 catch 

99
00:04:55,620 --> 00:04:58,040
我们就叫做呢命中

100
00:04:58,040 --> 00:05:01,320
一般 catch 它的命中率啊

101
00:05:01,320 --> 00:05:04,200
会在90%以上

102
00:05:04,200 --> 00:05:08,250
所以它的性能才会呢，提升的那么多

103
00:05:08,250 --> 00:05:11,690
那对于 catch 它的命中

104
00:05:11,690 --> 00:05:14,420
一般呢，是以他的这种呢

105
00:05:14,420 --> 00:05:16,520
淘汰算法来决定的

106
00:05:16,520 --> 00:05:18,080
注意啊，是由算法

107
00:05:18,080 --> 00:05:21,570
并不是算法的时间复杂度来决定

108
00:05:21,570 --> 00:05:23,210
既然有命中

109
00:05:23,210 --> 00:05:24,850
就有呢未命中

110
00:05:24,850 --> 00:05:26,860
如果我们要找的内

111
00:05:26,860 --> 00:05:28,380
是不是百分之百

112
00:05:28,380 --> 00:05:29,780
一定在 catch 啊

113
00:05:29,780 --> 00:05:31,480
没有这么好的事情

114
00:05:31,480 --> 00:05:33,780
还有一部分可能不在

115
00:05:33,780 --> 00:05:36,040
如果不在 tech 当中

116
00:05:36,040 --> 00:05:38,140
我们就叫它呢未命中

117
00:05:38,140 --> 00:05:40,400
或者呢，叫做失效

118
00:05:40,810 --> 00:05:43,070
失效的概率就是呢

119
00:05:43,070 --> 00:05:44,970
一减90%

120
00:05:44,970 --> 00:05:47,970
也就是呢，10%

121
00:05:48,300 --> 00:05:54,100
我们一般认为 catch 它的存取速度是非常快的

122
00:05:54,100 --> 00:05:57,450
假设 catch 它的访问周期

123
00:05:57,450 --> 00:06:00,390
也就是完成对 catch 的存取

124
00:06:00,390 --> 00:06:02,090
它的时间是

125
00:06:02,090 --> 00:06:04,350
诶，一毫秒的话

126
00:06:04,750 --> 00:06:09,190
那对于储存访问时间就比较慢了

127
00:06:09,190 --> 00:06:11,530
假设这个时间完成

128
00:06:11,530 --> 00:06:14,510
在储存当中存取数

129
00:06:14,510 --> 00:06:16,830
时间呢，用 T 2来记录

130
00:06:16,830 --> 00:06:19,550
假设是100 ms 

131
00:06:20,510 --> 00:06:22,870
如果我们的系统当中

132
00:06:22,870 --> 00:06:26,360
只有 CCH 加储存这种结构

133
00:06:26,360 --> 00:06:28,600
那我们读取一个数据

134
00:06:28,600 --> 00:06:31,770
它的平均时间是多少呢

135
00:06:31,770 --> 00:06:33,370
我们假设啊

136
00:06:33,370 --> 00:06:35,950
读取了100次数据

137
00:06:36,430 --> 00:06:40,250
这100次有多少次是在 catch 当中呢

138
00:06:40,250 --> 00:06:42,390
命中率90%

139
00:06:42,390 --> 00:06:44,020
所以是90次吧

140
00:06:44,020 --> 00:06:48,680
90次的存取时间都用到了一毫秒

141
00:06:48,680 --> 00:06:51,990
那还有十次是多少呢

142
00:06:51,990 --> 00:06:55,230
哎，十次是100 ms 

143
00:06:56,550 --> 00:07:00,290
平均的每次读取时间是多少呢

144
00:07:00,290 --> 00:07:01,610
除以100

145
00:07:01,610 --> 00:07:03,040
那这个数据啊

146
00:07:03,040 --> 00:07:06,760
就是我们整个系统它的平均存取时间

147
00:07:06,760 --> 00:07:09,750
也叫做呢，平均周期

148
00:07:09,750 --> 00:07:15,390
它的结果其实就是概率乘以呢，它的数值

149
00:07:15,390 --> 00:07:19,720
这是一个加权平均值的求取过程

150
00:07:19,720 --> 00:07:25,460
刚好呢，是90%乘以一毫秒

151
00:07:25,460 --> 00:07:30,230
加上呢，10%乘以100 ms 

152
00:07:30,230 --> 00:07:34,530
最终的结果是等于10.9 ms 的

153
00:07:34,530 --> 00:07:37,480
相比于100 ms 的速度来看

154
00:07:37,480 --> 00:07:40,900
它的提升呢，其实已经呢，比较高了

155
00:07:40,900 --> 00:07:45,850
那这是关于 KH 它的命中率以及呢

156
00:07:45,850 --> 00:07:48,450
平均周期的计算

157
00:07:48,450 --> 00:07:52,350
这里呢，在考试当中出现的并不多

158
00:07:52,350 --> 00:07:56,280
我们主要呢，是理解命中率的概念

159
00:07:56,280 --> 00:07:59,280
以及呢，加权平均值

160
00:07:59,280 --> 00:08:04,970
它的求取以概率乘以呢相应的数值

161
00:08:04,970 --> 00:08:07,620
从而呢求助一个平均值

162
00:08:07,620 --> 00:08:10,220
在一些性能指标当中啊

163
00:08:10,220 --> 00:08:14,080
有可能呢，会用到这种呢计算的思路

164
00:08:14,080 --> 00:08:16,160
那我们提到呢

165
00:08:16,160 --> 00:08:21,150
CCH 的内容是从那主存直接复制进去的吧

166
00:08:21,150 --> 00:08:22,630
那也就是说呢

167
00:08:22,630 --> 00:08:29,010
catch 它的内容会与主存有一定的对应关系

168
00:08:29,760 --> 00:08:33,400
这种对应关系啊

169
00:08:33,400 --> 00:08:36,330
是程序员来进行复制的吗

170
00:08:36,330 --> 00:08:42,559
不是，是由我们的硬件来直接完成的

171
00:08:42,559 --> 00:08:44,870
主存与 catch 之

172
00:08:44,870 --> 00:08:46,490
它的对应关系呢

173
00:08:46,490 --> 00:08:48,820
我们叫做地址映射

174
00:08:48,820 --> 00:08:50,900
也叫做地址映像

175
00:08:50,900 --> 00:08:54,920
这种映射呢，由硬件来直接完成

176
00:08:54,920 --> 00:08:56,980
不需要程序员参与

177
00:08:56,980 --> 00:09:00,700
也不需要操作系统来参与

178
00:09:00,700 --> 00:09:03,110
这种对应关系啊

179
00:09:03,110 --> 00:09:05,560
主要呢有三种形式

180
00:09:05,560 --> 00:09:07,970
一种是直接相连印象

181
00:09:07,970 --> 00:09:10,290
一种呢是全相连印象

182
00:09:10,290 --> 00:09:12,990
一种呢是组相连印象

183
00:09:12,990 --> 00:09:16,840
它的具体实现不需要我们去了解

184
00:09:16,840 --> 00:09:20,740
我们重点呢，是区分这三种方式

185
00:09:20,740 --> 00:09:26,550
它在硬件电路的复杂度和冲突率上的对比

186
00:09:27,260 --> 00:09:29,600
下面我们以一个例子

187
00:09:29,600 --> 00:09:32,380
简单看一下它的映射过程

188
00:09:32,380 --> 00:09:35,870
从而呢，理解它的冲突率对比

189
00:09:35,870 --> 00:09:39,270
首先，假设我们地址印象的话

190
00:09:39,270 --> 00:09:44,890
将储存与 KH 划分成相同大小的液或者块

191
00:09:44,890 --> 00:09:48,460
假设储存大小是一个 g catch 

192
00:09:48,460 --> 00:09:50,750
容量呢是八个兆

193
00:09:50,750 --> 00:09:52,930
在这个过程当中啊

194
00:09:52,930 --> 00:09:58,070
我们都划分成512 KB 大小的页或者块

195
00:09:58,070 --> 00:10:00,380
为什么要划分这么大呢

196
00:10:00,380 --> 00:10:01,930
我们想一想啊

197
00:10:01,930 --> 00:10:05,770
如果老师让大家找到讲义上

198
00:10:05,770 --> 00:10:08,790
第1000个字是什么字

199
00:10:08,790 --> 00:10:10,630
大家觉得好不好数啊

200
00:10:10,630 --> 00:10:11,470
不好数吧

201
00:10:11,470 --> 00:10:13,670
那如果老师告诉大

202
00:10:13,670 --> 00:10:16,530
找到讲义第十页

203
00:10:16,530 --> 00:10:19,210
第十排的第十个字

204
00:10:19,210 --> 00:10:21,010
是不是好理解很多啊

205
00:10:21,010 --> 00:10:22,760
在这个过程当中

206
00:10:22,760 --> 00:10:27,270
如果单一的去找比特或者字节的话

207
00:10:27,270 --> 00:10:31,260
太过细致不方便我们去查找调用

208
00:10:31,260 --> 00:10:33,810
一次调一个字不用了

209
00:10:33,810 --> 00:10:35,970
淘汰出去换一个新的字

210
00:10:35,970 --> 00:10:39,220
1000个字淘汰1000次是不是很麻烦

211
00:10:39,220 --> 00:10:41,390
那我们呢，将这个容量啊

212
00:10:41,390 --> 00:10:43,910
稍微呢抽象的更大一些

213
00:10:43,910 --> 00:10:45,610
就形成了液

214
00:10:45,610 --> 00:10:47,970
也就是呢，快这种概念

215
00:10:47,970 --> 00:10:51,130
在移动的过程当中

216
00:10:51,280 --> 00:10:56,640
比如说大家将讲义从家里拿到了公司

217
00:10:56,640 --> 00:10:59,550
那第十页的第十排

218
00:10:59,550 --> 00:11:01,930
第十个字有没有发生变化呀

219
00:11:01,930 --> 00:11:03,400
仍然在那里吧

220
00:11:03,400 --> 00:11:05,060
那这个过程当中

221
00:11:05,060 --> 00:11:08,580
有一个相对的位置是不变的

222
00:11:08,580 --> 00:11:09,660
唉，我们说呢

223
00:11:09,660 --> 00:11:13,640
业内它的位置是相对不会发生变化的

224
00:11:13,640 --> 00:11:18,260
我们呢，主要解决其他部分的对应就可以了

225
00:11:18,260 --> 00:11:21,680
这就是呢，划分液块它的一个功能

226
00:11:21,680 --> 00:11:24,610
我们在讲操作系统的时候

227
00:11:24,610 --> 00:11:28,650
页式存储也有这样的思想在里面

228
00:11:28,650 --> 00:11:32,000
那回到地址映射当中去

229
00:11:32,000 --> 00:11:36,860
储存 KH 划分成相同的页面大小之后

230
00:11:36,860 --> 00:11:39,860
储存有2048个页

231
00:11:39,860 --> 00:11:42,570
catch 呢，有16个页

232
00:11:42,570 --> 00:11:45,740
如何将2048个页

233
00:11:45,740 --> 00:11:48,930
放到16个页的位置上呢

234
00:11:48,930 --> 00:11:54,870
类似于我们有2048个萝卜啊

235
00:11:54,870 --> 00:12:00,040
然后呢，要埋到16个坑当中去

236
00:12:00,040 --> 00:12:02,160
那如何来埋

237
00:12:02,160 --> 00:12:05,470
就是呢，地址映射的过程

238
00:12:05,470 --> 00:12:07,160
第一种方式

239
00:12:07,160 --> 00:12:09,200
直接相连印象

240
00:12:09,200 --> 00:12:15,560
我们将储存划分成与 KH 相同大小的 A 区域

241
00:12:15,560 --> 00:12:21,890
那每一个储存区域当中也有呢，16个页面

242
00:12:21,890 --> 00:12:24,500
一号区也有16个

243
00:12:24,500 --> 00:12:26,320
12

244
00:12:26,320 --> 00:12:28,720
也有呢，16个页面

245
00:12:28,720 --> 00:12:31,680
每一个区域的0号

246
00:12:31,680 --> 00:12:35,480
都与呢， KH 的0号液进行映射

247
00:12:35,480 --> 00:12:40,060
那每一个区域的一号液与 catch 的一号页

248
00:12:40,060 --> 00:12:41,170
进行映射

249
00:12:41,170 --> 00:12:44,810
15号液与15号液进行映射

250
00:12:44,810 --> 00:12:47,530
那在这种情况下

251
00:12:47,530 --> 00:12:51,180
储存它的地址格式

252
00:12:51,180 --> 00:12:53,810
我们呢需要写到，诶

253
00:12:53,810 --> 00:12:56,920
每一个页面内部的页内地址

254
00:12:56,920 --> 00:13:00,320
以及呢，在储存当中

255
00:13:00,320 --> 00:13:02,520
它所属于的区域

256
00:13:02,520 --> 00:13:07,460
在每一个区域当中对应的 catch 的一号位置

257
00:13:07,460 --> 00:13:09,250
这种情况下

258
00:13:09,250 --> 00:13:13,110
固定有128个页面

259
00:13:13,110 --> 00:13:17,170
与相应的一个位置来对应起来

260
00:13:17,170 --> 00:13:20,530
在这种映射过程当中啊

261
00:13:20,530 --> 00:13:24,920
它电路实现呢，是非常简单的

262
00:13:24,920 --> 00:13:28,450
这个过程复杂在哪里呢

263
00:13:28,450 --> 00:13:32,720
主要就体现在关于冲突率上

264
00:13:32,720 --> 00:13:34,780
什么是冲突呢

265
00:13:34,780 --> 00:13:38,170
当我们将储存当中

266
00:13:38,170 --> 00:13:43,630
0号区的0号液放到 KH 0号位置之后

267
00:13:43,630 --> 00:13:49,040
其他区域如果恰好我们要调一号区的一号液

268
00:13:49,040 --> 00:13:50,620
调到 catch 当中

269
00:13:50,620 --> 00:13:53,070
里面已经有内容了

270
00:13:53,070 --> 00:13:55,070
我们就说产生冲突了

271
00:13:55,070 --> 00:13:58,660
那一共有多少个页面冲突呢

272
00:13:58,660 --> 00:14:01,780
128个页面放了一个

273
00:14:01,780 --> 00:14:05,140
其他127都会冲突

274
00:14:05,140 --> 00:14:09,070
另外呢，有一种极端的情况

275
00:14:09,070 --> 00:14:12,270
假设我们将 KH 当中

276
00:14:12,270 --> 00:14:18,140
0号区零到14号液都放到了 KH 当中去

277
00:14:18,140 --> 00:14:21,060
现在 catch 有没有空闲位置啊

278
00:14:21,060 --> 00:14:24,600
只有一个15号液可以放置

279
00:14:24,600 --> 00:14:28,780
我们有多少个页面还没有放进来呢

280
00:14:28,780 --> 00:14:31,620
204

281
00:14:31,910 --> 00:14:35,870
减去已经放置的15个页面

282
00:14:35,870 --> 00:14:38,430
这些页面都没有放吧

283
00:14:38,430 --> 00:14:42,350
那这些页面在调用过程当中

284
00:14:42,350 --> 00:14:47,080
能够成功放到15号位置的有哪些呢

285
00:14:47,080 --> 00:14:50,690
0号区的15号、夜一号区、12

286
00:14:50,690 --> 00:14:52,490
7号区的15号页吧

287
00:14:52,490 --> 00:14:56,710
一共有128是可放的

288
00:14:56,710 --> 00:14:59,080
那剩下的都是呢

289
00:14:59,080 --> 00:14:59,920
不可放

290
00:14:59,920 --> 00:15:01,360
为什么不可放

291
00:15:01,360 --> 00:15:02,900
因为冲突了

292
00:15:02,900 --> 00:15:05,300
在这个过程当中啊

293
00:15:05,300 --> 00:15:11,520
它的冲突率是能够达到90%以上的

294
00:15:11,520 --> 00:15:13,500
不冲突的只有呢

295
00:15:13,500 --> 00:15:16,180
128个页面

296
00:15:16,970 --> 00:15:20,690
所以啊，这种方式电路简单

297
00:15:20,690 --> 00:15:23,530
冲突率是非常高的

298
00:15:36,690 --> 00:15:39,490
关于主存的地质结构

299
00:15:39,490 --> 00:15:41,290
大家呢，听一下就行了

300
00:15:41,290 --> 00:15:45,530
考试当中目前是没有呢，出现过了

301
00:15:45,840 --> 00:15:47,660
第二种方式

302
00:15:47,660 --> 00:15:49,440
全相连印象

303
00:15:49,440 --> 00:15:51,600
我们前面说到啊

304
00:15:51,600 --> 00:15:56,360
如如果目前只有15号页位置可用

305
00:15:56,360 --> 00:15:59,680
而剩下的2048

306
00:15:59,680 --> 00:16:01,760
减15个页面当中啊

307
00:16:01,760 --> 00:16:04,120
只有128可用

308
00:16:04,120 --> 00:16:04,800
为什么

309
00:16:04,800 --> 00:16:08,740
因为其他页面不能往15号位置放啊

310
00:16:08,740 --> 00:16:13,400
那如果我想让其他位置也放进去的话

311
00:16:13,400 --> 00:16:17,520
这样子是不是就不会产生这么高的冲突率了

312
00:16:17,520 --> 00:16:19,650
在这种情况下

313
00:16:19,650 --> 00:16:25,610
让2048个页面和16个 catch 的位置

314
00:16:25,610 --> 00:16:27,620
可以任意对应

315
00:16:27,620 --> 00:16:29,140
在 catch 当中

316
00:16:29,140 --> 00:16:31,600
只要有一个位置空余

317
00:16:31,600 --> 00:16:35,260
我们就能呢往里面接着放数据了

318
00:16:35,260 --> 00:16:38,380
这种冲突率呢，就比较低了

319
00:16:38,380 --> 00:16:40,010
所有的列页面

320
00:16:40,010 --> 00:16:45,130
0号液、一号液、15号液、2047号液

321
00:16:45,130 --> 00:16:48,950
都能够呢放到 KH 的0号液位置

322
00:16:48,950 --> 00:16:52,910
同样储存的0号液可以放到 K

323
00:16:52,910 --> 00:16:56,730
0号液、一号液、15号液的任意位置

324
00:16:56,730 --> 00:16:59,580
一号页可以呢放到任意位

325
00:16:59,580 --> 00:17:03,300
15号页、2004、17号

326
00:17:03,300 --> 00:17:05,290
也是如此

327
00:17:05,290 --> 00:17:07,079
所以这种情况下

328
00:17:07,079 --> 00:17:10,920
它的冲突率啊，很明显的降低了

329
00:17:15,220 --> 00:17:19,500
有没有百分百好的事情呢

330
00:17:19,500 --> 00:17:21,760
基本上没有这么完美

331
00:17:21,760 --> 00:17:23,849
它的冲突率低呀

332
00:17:23,849 --> 00:17:28,730
但是呢，电路复杂度是非常复杂的

333
00:17:32,660 --> 00:17:37,930
我们的储存地址除了业内地址以外

334
00:17:37,930 --> 00:17:42,610
其他的地址全部呢，要做映

335
00:17:42,610 --> 00:17:44,890
才能找到一个位置呢

336
00:17:44,890 --> 00:17:49,160
与之对应电路呢，复杂、冲突率低

337
00:17:49,160 --> 00:17:52,410
是全相连映射的特点

338
00:17:52,410 --> 00:17:55,260
有没有折中方案呢

339
00:17:55,260 --> 00:17:57,400
我们在 it 行业

340
00:17:57,400 --> 00:17:59,420
包括软件设计这一块

341
00:17:59,420 --> 00:18:03,360
都有一个呢，权衡折中的一个思想

342
00:18:03,360 --> 00:18:06,630
在 catch 映射方式当中

343
00:18:06,630 --> 00:18:10,850
也有一种折中叫做呢组相连印象

344
00:18:11,250 --> 00:18:13,130
组相连印象

345
00:18:13,130 --> 00:18:18,460
还是将主存和 KH 划分成相同大小的区域

346
00:18:18,460 --> 00:18:22,670
那同样是128个区域

347
00:18:22,670 --> 00:18:25,650
在这128个区域当中呢

348
00:18:25,650 --> 00:18:27,150
分了组

349
00:18:28,120 --> 00:18:31,680
这里每一组是有两个页面的

350
00:18:31,680 --> 00:18:35,040
那在组相连印象当中啊

351
00:18:35,040 --> 00:18:37,390
主存与 catch 之间

352
00:18:37,390 --> 00:18:40,730
组与组是直接相连的

353
00:18:40,730 --> 00:18:44,660
0号组只能放在0号组位置上

354
00:18:44,660 --> 00:18:47,620
但是0号组内部的页面呢

355
00:18:47,620 --> 00:18:50,040
是可以任意对应的

356
00:18:50,040 --> 00:18:52,720
也就是全相连的思想

357
00:18:52,720 --> 00:18:54,880
这种映射方式啊

358
00:18:54,880 --> 00:18:58,090
它的地址呢，其实会更复杂一些

359
00:18:58,090 --> 00:18:59,570
它有业内地址

360
00:18:59,570 --> 00:19:01,030
还有呢组内页号

361
00:19:01,030 --> 00:19:02,130
还有 CAH 组号

362
00:19:02,130 --> 00:19:04,920
还有呢相应的其他标志

363
00:19:04,920 --> 00:19:07,770
那我们说呢，组相连映象啊

364
00:19:07,770 --> 00:19:10,190
它的映射方式

365
00:19:10,190 --> 00:19:13,610
电路复杂度是二者折中

366
00:19:19,800 --> 00:19:23,200
冲突率也是呢，二者折中

367
00:19:28,460 --> 00:19:31,200
对于这三种映射方式

368
00:19:31,200 --> 00:19:34,660
不要求大家完全理解它的对应

369
00:19:34,660 --> 00:19:36,420
以及呢储存结构

370
00:19:36,420 --> 00:19:37,470
这种划

371
00:19:37,470 --> 00:19:41,700
只要求大家掌握了三种映射方式

372
00:19:41,700 --> 00:19:43,440
它的特点对比

373
00:19:43,440 --> 00:19:48,400
以及呢冲突率和电路复杂度的排序

374
00:19:48,440 --> 00:19:51,090
下面我们汇总一下

375
00:19:51,090 --> 00:19:52,200
看一看呢

376
00:19:52,200 --> 00:19:57,070
对于直接相连印象、全相连印象、组相连印

377
00:19:57,070 --> 00:19:59,580
在冲突率和电路复杂度

378
00:19:59,580 --> 00:20:01,400
它的对比过程

379
00:20:01,400 --> 00:20:04,370
首先直接相连印

380
00:20:04,370 --> 00:20:06,390
零和零直接连

381
00:20:06,390 --> 00:20:10,050
这种方式冲突率是很高的

382
00:20:10,050 --> 00:20:14,990
全相连0号液可以和任意页面进行连接

383
00:20:14,990 --> 00:20:18,770
只要有一个 KH 位置是空闲的

384
00:20:18,770 --> 00:20:22,140
就可以呢往里面去放数据

385
00:20:22,140 --> 00:20:23,600
不需要呢淘汰

386
00:20:23,600 --> 00:20:25,600
冲突率比较低

387
00:20:25,600 --> 00:20:29,300
组相连印象是二者的折中

388
00:20:29,300 --> 00:20:31,470
电路复杂度来看

389
00:20:31,470 --> 00:20:33,510
直接相连印

390
00:20:33,510 --> 00:20:36,330
电路复杂度比较简单

391
00:20:36,330 --> 00:20:39,190
全相连印象呢电路复杂

392
00:20:39,190 --> 00:20:40,790
组相连印

393
00:20:40,790 --> 00:20:43,880
电路复杂度是二者的折中

394
00:20:43,880 --> 00:20:45,660
把这个表格啊

395
00:20:45,660 --> 00:20:48,560
它的排序呢搞清楚

396
00:20:49,650 --> 00:20:51,950
后面我们看一下

397
00:20:51,950 --> 00:20:56,610
对于 catch 在我们软件设计师考试真题当中

398
00:20:56,610 --> 00:20:58,300
它的具体体现

399
00:20:58,300 --> 00:21:00,010
下面这道题

400
00:21:00,010 --> 00:21:04,450
以下关于 catch 高速缓冲寄存器的叙述当中

401
00:21:04,450 --> 00:21:06,290
不正确的是谁

402
00:21:06,290 --> 00:21:08,810
我们在软件设计师考

403
00:21:08,810 --> 00:21:11,290
目前涉及到的缓存

404
00:21:11,290 --> 00:21:15,960
只有储存与 CPU 之间的高速缓存开始

405
00:21:15,960 --> 00:21:17,340
剩下的一级缓存

406
00:21:17,340 --> 00:21:20,680
二级缓存这一类目前没有考察过

407
00:21:20,680 --> 00:21:23,610
那针对这四个选项来看的话

408
00:21:23,610 --> 00:21:28,400
A 选项 catch 的设置扩大了储存的容量

409
00:21:28,400 --> 00:21:32,570
我们在层次化存储体系当中提到 catch 

410
00:21:32,570 --> 00:21:34,410
它属不属于储存呢

411
00:21:34,410 --> 00:21:35,660
并不属于

412
00:21:35,660 --> 00:21:38,170
它是 CPU 与 catch 

413
00:21:38,170 --> 00:21:42,660
catch 是 CPU 与主存之间的一个存储结构

414
00:21:42,660 --> 00:21:46,560
所以没有扩大储存的容量

415
00:21:46,560 --> 00:21:49,450
那这道题要注意

416
00:21:49,450 --> 00:21:52,880
我们选择的是不正确的选项

417
00:21:52,880 --> 00:21:55,660
A 选项就是呢不正确的

418
00:21:55,660 --> 00:21:58,260
所以这道题选择 A 选项

419
00:21:58,260 --> 00:22:01,130
考试的时候一定要看清楚

420
00:22:01,130 --> 00:22:05,010
选择的是正确选项还是呢，错误选项

421
00:22:05,010 --> 00:22:06,920
其他选项当中

422
00:22:06,920 --> 00:22:09,760
B 选项 catch 它的内容啊

423
00:22:09,760 --> 00:22:11,880
是对储存内容的复制

424
00:22:11,880 --> 00:22:15,380
D 选项 catch 呢，位于储存和 CPU 之间

425
00:22:15,380 --> 00:22:17,220
这都是呢， catch 的概念

426
00:22:17,220 --> 00:22:19,080
大家呢，基本上都知道

427
00:22:19,080 --> 00:22:21,280
有些同学存在疑问

428
00:22:21,280 --> 00:22:23,730
就是呢， C 选项 catch 

429
00:22:23,730 --> 00:22:28,650
它的命中率并不会随着容量增大

430
00:22:28,650 --> 00:22:30,470
线性的提高

431
00:22:30,470 --> 00:22:32,320
我们首先知道啊

432
00:22:32,320 --> 00:22:34,020
对于 catch 来说

433
00:22:34,020 --> 00:22:38,920
它的命中率对于容量增大了

434
00:22:38,920 --> 00:22:40,720
唉，容量越来越大

435
00:22:40,720 --> 00:22:43,040
它的命中率一般呢

436
00:22:43,040 --> 00:22:45,540
想象一下应该是有提升的吧

437
00:22:45,540 --> 00:22:51,700
那这种提升从一兆到两兆、到四兆、到八

438
00:22:51,700 --> 00:22:53,250
到16兆

439
00:22:53,250 --> 00:22:57,700
这种提升是不是线性提升啊

440
00:22:57,700 --> 00:22:59,680
不会是线性的

441
00:22:59,680 --> 00:23:04,940
越到后期它的提升会越来越平缓

442
00:23:04,940 --> 00:23:09,320
所以线性提高这种说法呢，是错误的

443
00:23:09,320 --> 00:23:12,170
那没有随着它线性提高

444
00:23:12,170 --> 00:23:14,100
双重否定等于肯定啊

445
00:23:14,100 --> 00:23:16,220
说明这种说法呢，是正确的

446
00:23:16,220 --> 00:23:18,400
没有随着它线性提高

447
00:23:18,400 --> 00:23:21,720
这三个选项的说法是正确的

448
00:23:21,720 --> 00:23:23,400
大家呢，也可以呀

449
00:23:23,400 --> 00:23:25,960
去了解一下这三种说法

450
00:23:25,960 --> 00:23:26,760
防止呢

451
00:23:26,760 --> 00:23:31,400
在以后的考试当中出现在正确选项当中

452
00:23:32,540 --> 00:23:34,240
下面这道题

453
00:23:34,240 --> 00:23:37,260
在程序执行过程当中

454
00:23:37,260 --> 00:23:40,120
高速缓存与 catch 之间

455
00:23:40,120 --> 00:23:44,990
与主存之间的地址映射由谁来完成

456
00:23:44,990 --> 00:23:48,000
这是我们再三强调的一个点

457
00:23:48,000 --> 00:23:50,690
它是由硬件自动完成的

458
00:23:50,690 --> 00:23:52,370
与程序员无关

459
00:23:52,370 --> 00:23:54,030
与操作系统无关

460
00:23:54,030 --> 00:23:58,180
与存储管理软件也是呢没有关系的

461
00:23:58,180 --> 00:24:02,350
考试当中曾经重复考察了三次

462
00:24:02,350 --> 00:24:05,230
所以虽然是一个小的概念点

463
00:24:05,230 --> 00:24:10,150
但是呢，大家一定要记住下面这道题

464
00:24:10,150 --> 00:24:13,790
主存与 catch 地址映射方式当中

465
00:24:13,790 --> 00:24:17,040
以下哪一种方式可以实现

466
00:24:17,040 --> 00:24:19,340
任意一块装入 KH 中

467
00:24:19,340 --> 00:24:20,600
任意位

468
00:24:20,600 --> 00:24:23,140
零和零相对位置

469
00:24:23,140 --> 00:24:26,100
不能任意的是直接映射吧

470
00:24:26,100 --> 00:24:30,990
可以任意对应的是全相连映射方式

471
00:24:30,990 --> 00:24:34,630
那这三种映射方式注意呢

472
00:24:34,630 --> 00:24:39,650
它的冲突率和它的电路复杂度排序

473
00:24:39,650 --> 00:24:43,050
全相连印象冲突率比较低

474
00:24:43,050 --> 00:24:44,670
但是电路复杂

475
00:24:44,670 --> 00:24:47,970
直接相连印象冲突率高

476
00:24:47,970 --> 00:24:50,800
电路简单组相连映像

477
00:24:50,800 --> 00:24:56,220
电路复杂度和冲突率都是二者折中串并联

478
00:24:56,220 --> 00:24:59,360
一般呢出现在物理的电路当中

479
00:24:59,360 --> 00:25:02,290
在我们软件设计师考试当中呢

480
00:25:02,290 --> 00:25:06,210
可靠性计算有串联模型、并联模型

481
00:25:06,210 --> 00:25:08,040
还有呢混联模型

482
00:25:08,040 --> 00:25:12,250
我们在可靠性的知识点当中呢会提到

483
00:25:13,290 --> 00:25:14,390
这些啊

484
00:25:14,390 --> 00:25:18,510
就是要求大家掌握的 catch 相关的知识内容
