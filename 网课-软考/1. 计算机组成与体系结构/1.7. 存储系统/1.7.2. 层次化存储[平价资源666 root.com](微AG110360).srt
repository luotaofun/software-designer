1
00:00:00,000 --> 00:00:04,000
下面展开来看一下存储系统当中

2
00:00:04,000 --> 00:00:06,590
层次化存储的体系结构

3
00:00:06,590 --> 00:00:09,960
什么是层次化存储的体系结构呢

4
00:00:09,960 --> 00:00:11,200
我们想一想

5
00:00:11,200 --> 00:00:14,660
大家在使用计算机或者购买计算机的时候

6
00:00:14,660 --> 00:00:16,820
一般会看哪些参数啊

7
00:00:16,820 --> 00:00:18,600
会涉及到 CPU 

8
00:00:18,600 --> 00:00:21,300
它是啊，酷睿 I 3、 I 5的

9
00:00:21,300 --> 00:00:21,700
唉

10
00:00:21,700 --> 00:00:24,380
然后呢，买计算机的时候

11
00:00:24,380 --> 00:00:27,120
考虑机械硬盘还是固态硬盘

12
00:00:27,120 --> 00:00:29,600
里面是500个 G 还是一个 T 

13
00:00:29,600 --> 00:00:32,119
内存是四个 G 、八个 G 

14
00:00:32,119 --> 00:00:35,200
那这些内容所涉及到的

15
00:00:35,200 --> 00:00:39,440
对于硬盘和我们的内存啊

16
00:00:39,440 --> 00:00:43,420
都是层次化存储结构当中会涉及到的

17
00:00:43,420 --> 00:00:47,120
那我们一般比较大的是硬盘

18
00:00:47,540 --> 00:00:49,360
大家想一想

19
00:00:49,360 --> 00:00:53,760
我们平常要下载一个游戏的时候

20
00:00:53,760 --> 00:00:56,020
诶，这个文件是不是特别大

21
00:00:56,020 --> 00:00:58,120
一般会有几十个 G 吧

22
00:00:58,120 --> 00:01:01,700
那我们显然在买电脑的时候

23
00:01:01,700 --> 00:01:04,300
外存也就是辅助存储器

24
00:01:04,300 --> 00:01:07,080
硬盘呢，可以有500个 G 

25
00:01:07,080 --> 00:01:09,690
而内存一般会在

26
00:01:09,690 --> 00:01:12,720
诶，八个 G 、16个 G 左右吧

27
00:01:12,720 --> 00:01:14,340
那在这个范围内

28
00:01:14,340 --> 00:01:16,640
我们会把文件存在哪里

29
00:01:16,640 --> 00:01:18,700
会不会是内存啊

30
00:01:18,700 --> 00:01:23,140
不可能存不下我们的文件啊

31
00:01:23,140 --> 00:01:27,180
实际上大部分都是存在外存

32
00:01:27,180 --> 00:01:29,520
也就是辅助存储器

33
00:01:29,520 --> 00:01:33,090
简存简称为储存这一部分的

34
00:01:33,090 --> 00:01:37,290
它包含我们提到的，诶，硬盘

35
00:01:37,290 --> 00:01:42,310
然后呢，像光盘、移动硬盘、 U 盘都属于这一类

36
00:01:42,310 --> 00:01:44,160
它的容量啊

37
00:01:44,160 --> 00:01:47,400
基本上可以有一个 T 左右，诶

38
00:01:47,400 --> 00:01:51,450
两三百个 G 、500个 G 都是能正常的

39
00:01:51,450 --> 00:01:57,110
那我们实际运行的过程当中又离不开内存

40
00:01:57,110 --> 00:02:01,410
内存才是主机当中的一个部分

41
00:02:01,410 --> 00:02:04,510
那我们运行的过程当中啊

42
00:02:04,510 --> 00:02:08,590
会把所需要的数据放入内存

43
00:02:08,590 --> 00:02:11,180
再通过 CPU 来调度

44
00:02:11,180 --> 00:02:12,660
我们的 CPU 

45
00:02:12,660 --> 00:02:14,540
在执行过程当中

46
00:02:14,540 --> 00:02:17,740
一般呢，使用的是内存数据

47
00:02:17,740 --> 00:02:19,510
大家可以想一想

48
00:02:19,510 --> 00:02:23,560
我们啊，当内存有限的时候

49
00:02:23,560 --> 00:02:25,690
它在操作的过程当中

50
00:02:25,690 --> 00:02:29,830
很多功能是完成不了的

51
00:02:29,850 --> 00:02:32,450
比如说像早期的，诶

52
00:02:32,450 --> 00:02:34,370
windows 98这一类操作系统

53
00:02:34,370 --> 00:02:37,660
唉，当时在早期的这些机器当中

54
00:02:37,660 --> 00:02:40,080
有一些容量，诶

55
00:02:40,080 --> 00:02:42,890
它内存容量只有几十兆

56
00:02:42,890 --> 00:02:44,740
那这种几十兆

57
00:02:44,740 --> 00:02:49,000
我们在拷贝一些大型的图片的时候

58
00:02:49,000 --> 00:02:51,560
可能呢，都只能单张单张的考

59
00:02:51,560 --> 00:02:52,200
为什么

60
00:02:52,200 --> 00:02:53,760
因为内存太小了

61
00:02:53,760 --> 00:02:55,950
计算机处理不过来

62
00:02:55,950 --> 00:03:00,800
那在这里我们会将外存当中的数据

63
00:03:00,800 --> 00:03:04,530
取一部分放到内存当中

64
00:03:04,530 --> 00:03:06,130
然后呢，唉

65
00:03:06,130 --> 00:03:09,830
内存它在主机当中也叫呢，主存储器

66
00:03:09,830 --> 00:03:11,780
简称为主存

67
00:03:11,780 --> 00:03:17,310
从内存当中再读入到 CPU 来执行

68
00:03:17,310 --> 00:03:19,230
CPU 当中呢

69
00:03:19,230 --> 00:03:21,130
会有一些寄存器

70
00:03:21,130 --> 00:03:23,190
我们之前给大家介绍过一些

71
00:03:23,190 --> 00:03:25,050
寄存器和子部间

72
00:03:25,050 --> 00:03:27,370
在 CPU 当中啊

73
00:03:27,370 --> 00:03:31,120
我们核心处理的单元还是 CPU 

74
00:03:31,120 --> 00:03:32,210
所有数

75
00:03:32,210 --> 00:03:35,970
最终呢，还是会到 CPU 当中去进行执行

76
00:03:35,970 --> 00:03:39,310
那我们在读取的过程当中

77
00:03:39,310 --> 00:03:43,240
如果数据直接放在寄存器当中

78
00:03:43,240 --> 00:03:46,900
它的读取速度一定是最快的

79
00:03:46,900 --> 00:03:53,180
那它的容量一般是以比特位为单位的

80
00:03:53,180 --> 00:03:54,380
比如说，诶

81
00:03:54,380 --> 00:03:56,100
64个比特位

82
00:03:56,100 --> 00:03:57,720
32个比特位

83
00:03:57,720 --> 00:04:01,780
一般呢，跟字长有一定的对应关系

84
00:04:01,780 --> 00:04:03,610
那内存的话

85
00:04:03,610 --> 00:04:06,050
我们前面讲的它一般是

86
00:04:06,050 --> 00:04:08,630
哎，八个 G 左右

87
00:04:08,630 --> 00:04:14,430
这样来看，我们会发现从 CPU 往外的话

88
00:04:14,430 --> 00:04:18,010
它里面所涉及到的存储器

89
00:04:18,010 --> 00:04:20,560
容量会越来越大吧

90
00:04:20,560 --> 00:04:23,320
但是另一方面来讲

91
00:04:23,320 --> 00:04:26,340
CPU 当中寄存器最快

92
00:04:26,340 --> 00:04:28,440
其次呢，就是读内存

93
00:04:28,440 --> 00:04:29,520
读外存

94
00:04:29,520 --> 00:04:32,500
外存的速度是最慢的

95
00:04:32,500 --> 00:04:34,120
所以有很多人啊

96
00:04:34,120 --> 00:04:36,600
在使用计算机的过程当中

97
00:04:36,600 --> 00:04:38,180
会把很多内容呢

98
00:04:38,180 --> 00:04:39,520
放到系统盘当中

99
00:04:39,520 --> 00:04:41,100
希望呢，他读得更快

100
00:04:41,100 --> 00:04:46,810
那这个地方速度会从 CPU 往外越来越慢

101
00:04:46,810 --> 00:04:49,130
还有另外一方面啊

102
00:04:49,130 --> 00:04:52,380
从成本来考虑的话

103
00:04:52,380 --> 00:04:54,620
大家可以想一想

104
00:04:54,620 --> 00:04:59,820
如果让大家200块钱的成本可以扩大

105
00:04:59,820 --> 00:05:01,120
内存多少啊

106
00:05:01,120 --> 00:05:02,760
基本上也就扩大

107
00:05:02,760 --> 00:05:04,080
那么两三个 G 啊

108
00:05:04,080 --> 00:05:05,850
两个 G 、四个 G 的样子

109
00:05:05,850 --> 00:05:07,560
而外存的话

110
00:05:07,560 --> 00:05:10,980
200多块钱可以买个很大容量的

111
00:05:10,980 --> 00:05:11,320
诶

112
00:05:11,320 --> 00:05:13,450
硬盘或者 U 盘的吧

113
00:05:13,450 --> 00:05:15,420
所以越往外

114
00:05:15,420 --> 00:05:19,160
它的成本也会呢，唉，越低

115
00:05:19,160 --> 00:05:21,360
在这个过程当中

116
00:05:21,360 --> 00:05:24,740
目前我们还没有听到说，唉

117
00:05:24,740 --> 00:05:28,000
能够扩展 CPU 里面寄存器的

118
00:05:28,000 --> 00:05:30,970
一般呢，寄存器是出厂就决定的

119
00:05:30,970 --> 00:05:33,480
但是我们可以呢插内存条

120
00:05:33,480 --> 00:05:36,300
可以呢，哎，给他换一下硬盘

121
00:05:36,300 --> 00:05:40,200
或者扩充一下外接硬盘这样的一些呢工作

122
00:05:40,200 --> 00:05:42,760
从而呢，扩大它的容量

123
00:05:43,030 --> 00:05:45,110
那我们发现呢

124
00:05:45,110 --> 00:05:49,410
对于 CPU 和储存之间啊

125
00:05:49,410 --> 00:05:53,950
它们的速度和容量相差非常大

126
00:05:53,950 --> 00:05:55,290
那怎么办呢

127
00:05:55,290 --> 00:05:59,130
我们就在中间新增了一个层次

128
00:05:59,130 --> 00:06:00,410
叫做 KH 

129
00:06:00,410 --> 00:06:03,340
也叫做呢高速缓存

130
00:06:03,340 --> 00:06:05,590
它所出现的目的

131
00:06:05,590 --> 00:06:09,770
就是为了解决 CPU 和主存之间速度

132
00:06:09,770 --> 00:06:11,840
容量不匹配的问题

133
00:06:11,840 --> 00:06:17,450
这里面 catch 的内容都是能从内存复制进去的

134
00:06:17,450 --> 00:06:19,870
那用的过程当中，唉

135
00:06:19,870 --> 00:06:23,590
如果说 CPU 需要的内容刚好在 catch 

136
00:06:23,590 --> 00:06:26,480
它的效率呢，会提高很多

137
00:06:26,480 --> 00:06:28,590
它的量级啊

138
00:06:28,590 --> 00:06:31,930
容量的量级大概呢，在兆左右

139
00:06:31,930 --> 00:06:33,080
那这是呢

140
00:06:33,080 --> 00:06:38,360
各个层次、速度、容量以及成本的对比

141
00:06:38,360 --> 00:06:42,550
那为什么要有这样的层次化存储体系呢

142
00:06:42,550 --> 00:06:45,360
这个系统有什么样的好处呢

143
00:06:45,360 --> 00:06:47,010
我们前面提到啊

144
00:06:47,010 --> 00:06:50,510
如果有一个60 G 的游戏

145
00:06:50,510 --> 00:06:53,010
我们会把这个游戏文件

146
00:06:53,010 --> 00:06:56,640
程序文件下载之后放在硬盘里存储

147
00:06:56,640 --> 00:07:00,360
最终呢，需要 CPU 来调度

148
00:07:00,360 --> 00:07:05,230
很显然， CPU 一次性没有办法调度60个 G 吧

149
00:07:05,230 --> 00:07:06,480
那怎么办

150
00:07:06,480 --> 00:07:12,510
我们会把60个 G 的文件首先切碎

151
00:07:12,750 --> 00:07:16,450
把文件啊切成一块一块的

152
00:07:16,450 --> 00:07:17,490
然后呢

153
00:07:17,490 --> 00:07:23,650
按自己所需要的部分就掉入到内存当中去

154
00:07:23,650 --> 00:07:25,870
那这个调动的过程

155
00:07:25,870 --> 00:07:28,830
我们一般呢，由操作系统来完成

156
00:07:28,830 --> 00:07:32,070
在操作系统存储管理当中呢

157
00:07:32,070 --> 00:07:33,660
会给大家讲到

158
00:07:33,660 --> 00:07:36,220
在这个过程当中的话

159
00:07:36,220 --> 00:07:39,840
诶，内存里面也放了一部分数据吧

160
00:07:39,840 --> 00:07:43,640
但这部分数据是不是可以一次性使用呢

161
00:07:43,640 --> 00:07:44,760
也不行

162
00:07:44,760 --> 00:07:50,600
我们啊，还会通过 catch CPU 来依次调用

163
00:07:50,600 --> 00:07:52,440
那这个过程当中

164
00:07:52,440 --> 00:07:54,760
catch 加内存啊

165
00:07:54,760 --> 00:07:55,900
在这里

166
00:07:55,900 --> 00:08:00,690
这个调度的过程是由硬件来直接完成的

167
00:08:00,690 --> 00:08:06,110
CPU 访问 catch 呢，也是由硬件来完成的

168
00:08:06,110 --> 00:08:08,960
那为什么一小块的数据

169
00:08:08,960 --> 00:08:11,700
就足够我们去用了呢

170
00:08:11,700 --> 00:08:17,310
这个过程啊，其实就涉及到局部性原理

171
00:08:17,310 --> 00:08:18,990
那我们大家呢

172
00:08:18,990 --> 00:08:20,750
唉，知道计算

173
00:08:20,750 --> 00:08:22,990
它主要是处理数据的

174
00:08:22,990 --> 00:08:26,630
那我们比如以生活当中的例子来想一想

175
00:08:26,630 --> 00:08:29,780
如果我们要加工一些东西

176
00:08:29,780 --> 00:08:32,330
比如说加工食材、做饭

177
00:08:32,330 --> 00:08:35,169
那做饭的时候，诶

178
00:08:35,169 --> 00:08:38,789
我们会不会每一次都会呢

179
00:08:38,789 --> 00:08:41,309
去超市买油盐啊

180
00:08:41,309 --> 00:08:42,570
基本上不会吧

181
00:08:42,570 --> 00:08:44,810
我们会提前准备好

182
00:08:44,810 --> 00:08:45,750
为什么呢

183
00:08:45,750 --> 00:08:49,310
因为这一部分东西是常用的

184
00:08:49,310 --> 00:08:54,110
那常用的数据放在 CPU 比较近的地方

185
00:08:54,110 --> 00:08:55,150
在这里呢

186
00:08:55,150 --> 00:08:59,390
因为很可能下一步接着就要去用

187
00:08:59,390 --> 00:09:01,910
所以呢，可以提高效率

188
00:09:01,910 --> 00:09:05,090
同时在处理数据的时候

189
00:09:05,090 --> 00:09:07,150
它还有一个特点

190
00:09:07,150 --> 00:09:08,880
我们的数据啊

191
00:09:08,880 --> 00:09:11,140
有一定关联性的数据呢

192
00:09:11,140 --> 00:09:13,060
经常放在一块儿

193
00:09:13,060 --> 00:09:14,710
包括程序啊

194
00:09:14,710 --> 00:09:16,950
也是呢，关联性的程

195
00:09:16,950 --> 00:09:21,010
基本上呢，会存在一个呢，相近的区域里

196
00:09:21,010 --> 00:09:23,920
那我们在读取的时候访问

197
00:09:23,920 --> 00:09:26,080
诶，某一个数据空间

198
00:09:26,080 --> 00:09:31,740
那接下来很可能就要访问它相邻的空间

199
00:09:31,740 --> 00:09:34,750
这个呢，也能够提高它的效率

200
00:09:34,750 --> 00:09:38,760
因为我们一次性把相邻数据都调入进去了

201
00:09:38,760 --> 00:09:42,620
那这里指的其实就是局部性原理

202
00:09:42,620 --> 00:09:46,100
局部性原理是整个层次化

203
00:09:46,100 --> 00:09:48,560
存储结构的理论支撑

204
00:09:48,560 --> 00:09:51,380
理论基础理论基础

205
00:09:51,380 --> 00:09:53,770
在这当中可以分为

206
00:09:53,770 --> 00:09:57,150
时间局部性和空间局部性

207
00:09:57,150 --> 00:10:01,480
时间局部性能就是我们刚刚所说的重复使用

208
00:10:01,480 --> 00:10:03,740
刚被访问的内

209
00:10:03,740 --> 00:10:05,780
立即又被访问

210
00:10:05,780 --> 00:10:08,340
体现在程序当中啊

211
00:10:08,340 --> 00:10:11,740
典型的就是循环体

212
00:10:13,040 --> 00:10:17,100
我们在程序设计过程当中会发现

213
00:10:17,100 --> 00:10:21,440
程序的结构里面会包含大量的循环

214
00:10:21,440 --> 00:10:24,940
那如果说是1000次循环

215
00:10:24,940 --> 00:10:30,720
如果我们将循环体已经掉入所需的部分呢

216
00:10:30,720 --> 00:10:34,740
哎，我们这1000次只需要调一次就够用了吧

217
00:10:34,740 --> 00:10:36,060
那这就是呢

218
00:10:36,060 --> 00:10:37,900
时间局部性

219
00:10:37,900 --> 00:10:41,090
空间局部性指的是呢

220
00:10:41,090 --> 00:10:42,950
刚被访问的内容

221
00:10:42,950 --> 00:10:44,370
临近的空间

222
00:10:44,370 --> 00:10:47,190
很快呢，又要被访问

223
00:10:47,190 --> 00:10:49,600
那这里体现的就是呢

224
00:10:49,600 --> 00:10:52,820
程序当中它的顺序结构

225
00:10:52,820 --> 00:10:59,250
嘟嘟可计算机与人脑的机区别在于

226
00:10:59,250 --> 00:11:02,500
它会按部就班地去执行程序

227
00:11:02,500 --> 00:11:07,710
那这些程序有很多的内容都是顺序执行

228
00:11:07,710 --> 00:11:11,110
包括我们在用到数据的时候

229
00:11:11,110 --> 00:11:12,930
也会经常用到呢

230
00:11:12,930 --> 00:11:14,620
线性结构的数据

231
00:11:14,620 --> 00:11:17,880
比如说呢，我们最简单的数据结

232
00:11:17,880 --> 00:11:21,340
数组 A 0到 A 100

233
00:11:21,670 --> 00:11:23,930
那我们啊

234
00:11:23,930 --> 00:11:28,670
在局部性原理调用一定页面大小的时候呢

235
00:11:28,670 --> 00:11:31,180
一般不会只掉一个数据

236
00:11:31,180 --> 00:11:35,430
比如说假设我们一次性掉了100个数据

237
00:11:35,430 --> 00:11:37,630
从外存调到内存

238
00:11:37,630 --> 00:11:41,970
再将其中的一部分调到呢 KH 调到 CPU 

239
00:11:41,970 --> 00:11:43,620
那在这个过程当中

240
00:11:43,620 --> 00:11:47,460
我们会发现访问这种线性结构啊

241
00:11:47,460 --> 00:11:49,160
一般用完 A 0

242
00:11:49,160 --> 00:11:50,240
我们会用什么

243
00:11:50,240 --> 00:11:53,000
就会用到相邻的 A 1

244
00:11:53,000 --> 00:11:56,730
接下来 A 2直到 A 100

245
00:11:56,730 --> 00:12:01,430
也就是说访问某一个存储空间之后

246
00:12:01,430 --> 00:12:05,910
接下来很可能会访问它相邻的区域

247
00:12:05,910 --> 00:12:08,880
这就是呢，空间局部性

248
00:12:08,880 --> 00:12:11,520
这两个组合起来呢

249
00:12:11,520 --> 00:12:14,740
就是最终的局部性原理

250
00:12:14,740 --> 00:12:19,530
那在我们的软件设计师考试当中啊

251
00:12:19,530 --> 00:12:23,260
我们需要了解层次化存储当

252
00:12:23,260 --> 00:12:26,280
它的速度、容量、成本的对比

253
00:12:26,280 --> 00:12:29,890
以及呢，局部性原理的概念

254
00:12:29,890 --> 00:12:32,250
在这当中还有一些呢

255
00:12:32,250 --> 00:12:34,630
特殊的存储器的描述

256
00:12:34,630 --> 00:12:37,570
我们在后面呢，再展开来讲

257
00:12:37,570 --> 00:12:39,410
我们再给大家呢

258
00:12:39,410 --> 00:12:42,030
提两个扩展的概念

259
00:12:42,030 --> 00:12:48,580
首先，我们对储存和外存组合起来

260
00:12:48,580 --> 00:12:55,370
一般呢，虚拟存储器是指的这两个部分的组合

261
00:12:55,370 --> 00:12:57,520
那虚拟存储器呢

262
00:12:57,520 --> 00:13:00,380
会让内存和外存啊

263
00:13:00,380 --> 00:13:04,210
按照一定的 A 标准来进行编制

264
00:13:04,210 --> 00:13:06,870
那访问内存不够的时候呢

265
00:13:06,870 --> 00:13:09,650
会找外存这个过程啊

266
00:13:09,650 --> 00:13:13,160
让内存看起来好像包含了

267
00:13:13,160 --> 00:13:14,680
外存作为一个整体

268
00:13:14,680 --> 00:13:15,960
所以叫做呢

269
00:13:15,960 --> 00:13:18,000
虚拟存储体系

270
00:13:18,000 --> 00:13:20,090
其次，外存

271
00:13:20,090 --> 00:13:24,390
内存和 KH 3个部分组合起来呢

272
00:13:24,390 --> 00:13:28,400
我们又称之为三级存储体系

273
00:13:28,400 --> 00:13:29,880
这两个概念啊

274
00:13:29,880 --> 00:13:32,340
简单的知道一下就行了

275
00:13:32,340 --> 00:13:35,550
在考试当中呢，曾经出现过

276
00:13:35,550 --> 00:13:40,640
下面呢，我们看一下存储器它的分类

277
00:13:40,640 --> 00:13:42,460
存储器分类

278
00:13:42,460 --> 00:13:47,370
首先呢，可以按位置存这个存储器的位置啊

279
00:13:47,370 --> 00:13:50,110
我们在计算机结构的时候介绍过

280
00:13:50,110 --> 00:13:53,820
在主机内部的叫内存，也叫主存

281
00:13:53,820 --> 00:13:56,670
主机外部的叫外存，哎

282
00:13:56,670 --> 00:13:58,250
也就是属于外设的

283
00:13:58,250 --> 00:14:00,490
也叫做脑辅存

284
00:14:00,540 --> 00:14:05,900
如果按照存取方式来进行区分的话

285
00:14:05,900 --> 00:14:07,980
这里比较特殊啦

286
00:14:07,980 --> 00:14:12,340
唉，第一个比较特殊的是按内容存取

287
00:14:12,340 --> 00:14:14,100
这种存储器呢

288
00:14:14,100 --> 00:14:16,530
我们叫做相连存储器

289
00:14:16,530 --> 00:14:18,660
典型的就是 catch 

290
00:14:18,660 --> 00:14:21,780
以及呢，我们涉及到的一些页表啊

291
00:14:21,780 --> 00:14:25,260
都会呢，涉及到相联存储器

292
00:14:25,440 --> 00:14:28,820
那什么是按内容存取呢

293
00:14:28,820 --> 00:14:30,820
比如说大家现在啊

294
00:14:30,820 --> 00:14:33,500
要来长沙搞个见面会

295
00:14:33,500 --> 00:14:37,400
那老师需要呢，给大家来安排一下住宿

296
00:14:37,400 --> 00:14:39,130
安排住宿的时候

297
00:14:39,130 --> 00:14:41,530
正常来讲，大家来一个

298
00:14:41,530 --> 00:14:43,170
我们记录一个吧

299
00:14:43,170 --> 00:14:45,590
哎，张三在101

300
00:14:45,590 --> 00:14:47,570
李四在102

301
00:14:47,570 --> 00:14:49,210
依次往下记录

302
00:14:49,210 --> 00:14:50,740
这是顺序结构

303
00:14:50,740 --> 00:14:52,630
如果1000个人

304
00:14:52,630 --> 00:14:54,850
我们呢要找其中一个

305
00:14:54,850 --> 00:14:58,860
是从1000条记录里面去对比查找吧

306
00:14:58,860 --> 00:15:01,910
那所谓的按内容存取呢

307
00:15:01,910 --> 00:15:05,930
诶，就是根据大家的名字

308
00:15:06,340 --> 00:15:09,940
比如说，哎，大家来了一个张三

309
00:15:09,940 --> 00:15:13,480
我们数一数张有多少笔画呢

310
00:15:13,480 --> 00:15:16,830
唉，12345678

311
00:15:16,830 --> 00:15:18,510
哎，803

312
00:15:18,510 --> 00:15:21,590
我们把它呢放到80

313
00:15:21,590 --> 00:15:23,100
这个呢，房间

314
00:15:23,100 --> 00:15:24,790
李四再数一数

315
00:15:24,790 --> 00:15:26,740
给他呢，安排一个房间

316
00:15:26,740 --> 00:15:28,150
这个时候啊

317
00:15:28,150 --> 00:15:32,750
如果让大家找其中某一个人的，诶

318
00:15:32,750 --> 00:15:34,160
房间号怎么找

319
00:15:34,160 --> 00:15:37,290
直接根据名称就能找到吧

320
00:15:37,290 --> 00:15:41,610
按我们分配的这个内容本身

321
00:15:41,610 --> 00:15:43,890
来放置它的对应位置

322
00:15:43,890 --> 00:15:46,150
找到对应位置就叫做呢

323
00:15:46,150 --> 00:15:47,890
按内容存取

324
00:15:47,890 --> 00:15:51,010
也就是相联存储器

325
00:15:51,390 --> 00:15:52,770
第二类呢

326
00:15:52,770 --> 00:15:55,240
就是按地址存取

327
00:15:55,240 --> 00:15:58,810
那按地址存取这种顺序的方式呢

328
00:15:58,810 --> 00:16:01,720
也是属于按地址存取的

329
00:16:01,720 --> 00:16:03,960
它的存取过程啊

330
00:16:03,960 --> 00:16:06,370
可以呢，随机放置

331
00:16:06,370 --> 00:16:08,870
那这个随机存取存

332
00:16:08,870 --> 00:16:11,130
存取存储器指的是啊

333
00:16:11,130 --> 00:16:15,610
每一个房间安排人员的概率是一样的

334
00:16:15,610 --> 00:16:19,150
那这种呢，典型的就是内存

335
00:16:19,150 --> 00:16:24,030
第二种叫做顺序存取存储器

336
00:16:24,030 --> 00:16:26,050
所谓的顺序啊

337
00:16:26,050 --> 00:16:27,050
它就是呢

338
00:16:27,050 --> 00:16:32,310
必须按101、102、103依次往下推

339
00:16:32,310 --> 00:16:33,180
不能跳

340
00:16:33,180 --> 00:16:36,730
那这个过程呢，就叫做顺序存取

341
00:16:36,730 --> 00:16:38,510
不能跳，不能倒

342
00:16:38,510 --> 00:16:43,550
那这个过程比较典型的是我们早期的像磁带

343
00:16:43,550 --> 00:16:46,350
大家在10年以前的话

344
00:16:46,350 --> 00:16:48,610
可能用过复读机这一类

345
00:16:48,610 --> 00:16:50,710
那对于这种磁带的话

346
00:16:50,710 --> 00:16:52,450
只能单向转动吧

347
00:16:52,450 --> 00:16:56,030
如果你要唉做一些调整的话

348
00:16:56,030 --> 00:16:59,970
我们会把磁带的内容手动的去倒转

349
00:16:59,970 --> 00:17:01,800
然后再顺序读吧

350
00:17:01,800 --> 00:17:04,910
这个过程呢，就是顺序存取

351
00:17:04,910 --> 00:17:07,589
叫做呢，顺序存储器

352
00:17:07,589 --> 00:17:09,700
结合二者的

353
00:17:09,700 --> 00:17:10,900
还有一个呢

354
00:17:10,900 --> 00:17:13,420
直接存取存储器

355
00:17:13,420 --> 00:17:16,010
它的存取方式啊

356
00:17:16,010 --> 00:17:18,900
比如典型的磁盘

357
00:17:19,270 --> 00:17:23,869
磁盘的存取过程涉及到两个维度

358
00:17:23,869 --> 00:17:25,700
首先会有呢

359
00:17:25,700 --> 00:17:28,260
唉，移臂调度的过程

360
00:17:28,260 --> 00:17:35,200
那移臂调度这个过程它是典型的随机存取

361
00:17:35,200 --> 00:17:39,870
其次呢，还有一个旋转延迟的过程

362
00:17:39,870 --> 00:17:42,560
旋转延迟它就是呢

363
00:17:42,560 --> 00:17:45,790
典型的顺序存取的过程

364
00:17:45,790 --> 00:17:48,390
所以它结合了两种类型

365
00:17:48,390 --> 00:17:51,110
叫做呢，直接存取存储器

366
00:17:51,110 --> 00:17:55,430
知道呢，磁盘是它的典型体现就可以了

367
00:17:55,430 --> 00:18:00,090
第三种方式呢，是按工作方式来分的

368
00:18:00,090 --> 00:18:01,950
他的工作方式啊

369
00:18:01,950 --> 00:18:05,150
分为只读以及呢可读写

370
00:18:05,270 --> 00:18:08,460
对于可读写的这种呢

371
00:18:08,460 --> 00:18:11,180
就是随机存取存储器

372
00:18:11,180 --> 00:18:13,560
哎，我们叫做 ram r a m 

373
00:18:13,560 --> 00:18:15,620
唉，典型的内存

374
00:18:15,620 --> 00:18:19,740
它是用了动态 ram 来进行存取的

375
00:18:19,740 --> 00:18:21,390
d r a m 

376
00:18:21,390 --> 00:18:23,440
所谓的内存啊

377
00:18:23,440 --> 00:18:24,660
大家想一想

378
00:18:24,660 --> 00:18:28,460
有时候比如说手机或者电脑啊

379
00:18:28,460 --> 00:18:29,680
比较老旧了

380
00:18:29,680 --> 00:18:31,380
性能不好，我们会怎么办

381
00:18:31,380 --> 00:18:32,220
重启

382
00:18:32,220 --> 00:18:34,240
重启可以解决大部分问题

383
00:18:34,240 --> 00:18:34,900
是不是啊

384
00:18:34,900 --> 00:18:37,810
那为什么重启可以达到这种作用呢

385
00:18:37,810 --> 00:18:39,430
因为重启之后

386
00:18:39,430 --> 00:18:43,880
内存当中的内容会全部被清除掉

387
00:18:43,880 --> 00:18:47,910
这种随机存取存储器 ram 

388
00:18:47,910 --> 00:18:51,810
它的内容掉电会丢失

389
00:18:55,440 --> 00:18:59,320
包括现在有一种非常啊

390
00:18:59,320 --> 00:19:00,940
先进一些的数据库

391
00:19:00,940 --> 00:19:02,270
内存数据库

392
00:19:02,270 --> 00:19:03,630
这种数据库的话

393
00:19:03,630 --> 00:19:05,670
有一些掉电也会丢失啊

394
00:19:05,670 --> 00:19:08,920
所以呢，要做好一些备份一致性的工作

395
00:19:08,920 --> 00:19:11,510
那对于这种 ram 的话

396
00:19:11,510 --> 00:19:17,170
它还分 DM 动态的和 SIIM 静态的

397
00:19:17,170 --> 00:19:18,590
所谓动态的

398
00:19:18,590 --> 00:19:20,710
它成本呢会低一些

399
00:19:20,710 --> 00:19:25,070
它呀需要呢定时去做一些刷新的工作

400
00:19:25,070 --> 00:19:28,720
静态 IM 呢，是不需要做定时刷新的

401
00:19:28,720 --> 00:19:30,760
成本呢会高一些

402
00:19:30,760 --> 00:19:32,640
这是呢 RAM 

403
00:19:32,640 --> 00:19:35,060
第二类是只读的

404
00:19:35,060 --> 00:19:37,340
叫做呢只读存储器

405
00:19:37,340 --> 00:19:39,480
这类存储器的话

406
00:19:39,480 --> 00:19:44,260
它的内容掉电保留不会丢失

407
00:19:46,780 --> 00:19:48,970
那大家想到什么

408
00:19:48,970 --> 00:19:51,290
同样我们的计算机，诶

409
00:19:51,290 --> 00:19:52,450
大家如果重启

410
00:19:52,450 --> 00:19:55,150
有没有听说重启操作系统不见呢

411
00:19:55,150 --> 00:19:56,060
没有吧

412
00:19:56,060 --> 00:19:57,700
那这个过程当中

413
00:19:57,700 --> 00:20:00,300
其实像我们的操作系统啊

414
00:20:00,300 --> 00:20:03,820
还有像出厂就写的这种呢

415
00:20:03,820 --> 00:20:06,940
boss 、 DOS 这样的一些底层的系统

416
00:20:06,940 --> 00:20:11,850
都是呢，用 ROM ， ROM 呢来进行存储的

417
00:20:11,850 --> 00:20:14,140
那这里对于 ROM 

418
00:20:14,140 --> 00:20:19,490
还有一些呢，可以用特殊的技术来进行擦写

419
00:20:19,490 --> 00:20:22,990
我们常见的 dim 就是呢

420
00:20:22,990 --> 00:20:25,200
唉，储存的应用

421
00:20:25,200 --> 00:20:28,340
SIIM ，它呢，是静态的

422
00:20:28,340 --> 00:20:30,100
不需要定时刷新

423
00:20:30,100 --> 00:20:32,060
呃，其实它的成本啊

424
00:20:32,060 --> 00:20:34,160
相对来说会高一些

425
00:20:34,160 --> 00:20:36,960
也有呢，把它用在 catch 当中

426
00:20:36,960 --> 00:20:39,640
catch 呢，指的是高速缓存

427
00:20:39,640 --> 00:20:42,300
它是呢，相联存储器

428
00:20:42,300 --> 00:20:44,250
一个呢，典型应用

429
00:20:44,250 --> 00:20:47,660
这里还提到了 EEPROM 

430
00:20:47,660 --> 00:20:52,280
它表示的是可以用电可擦电编程，诶

431
00:20:52,280 --> 00:20:55,230
用电来擦除相应的内容

432
00:20:55,230 --> 00:20:56,340
再通过呢

433
00:20:56,340 --> 00:20:59,620
电来进行编程的只读存储器

434
00:20:59,620 --> 00:21:00,510
一般来讲

435
00:21:00,510 --> 00:21:02,190
这里啊会用到一些呢

436
00:21:02,190 --> 00:21:06,030
特殊的技术来进行擦除和写入

437
00:21:06,030 --> 00:21:08,760
当然这种擦除和写入的话

438
00:21:08,760 --> 00:21:11,980
其实都会呢有一定的寿命限制

439
00:21:11,980 --> 00:21:15,830
那这一些呢是典型的一些存储器

440
00:21:15,830 --> 00:21:18,320
举例在我们考试当中

441
00:21:18,320 --> 00:21:22,180
一般考得比较多的就是呢相联存储器

442
00:21:22,180 --> 00:21:26,990
以及呢储存和 ROM 这些内容

443
00:21:28,520 --> 00:21:31,480
接下来我们来看一下

444
00:21:31,480 --> 00:21:34,950
关于与层次化存储当中啊

445
00:21:34,950 --> 00:21:38,350
这些理论在我们软件设计师

446
00:21:38,350 --> 00:21:40,240
真题当中的体现

447
00:21:40,240 --> 00:21:41,820
下面这道题

448
00:21:41,820 --> 00:21:44,890
CPU 访问存储器的时候被访

449
00:21:44,890 --> 00:21:45,550
数据啊

450
00:21:45,550 --> 00:21:47,070
一般会聚集在一个

451
00:21:47,070 --> 00:21:50,150
较小的连续存储区域当中

452
00:21:50,150 --> 00:21:53,200
若一个存储单元已被访问

453
00:21:53,200 --> 00:21:58,110
那么相邻的存储单元很有可能被访问

454
00:21:58,110 --> 00:22:00,780
这个特性指的是什么呢

455
00:22:00,780 --> 00:22:05,120
这道题考察的就是局部性原理的内容

456
00:22:05,120 --> 00:22:06,400
局部性原

457
00:22:06,400 --> 00:22:08,460
它的概念主要呢

458
00:22:08,460 --> 00:22:11,880
是空间局部性和时间局部性

459
00:22:11,880 --> 00:22:16,850
没有指令局部性和数据指局部性的说法

460
00:22:16,850 --> 00:22:19,690
空间局部性指的就是呢

461
00:22:19,690 --> 00:22:22,370
诶，一个空间被访问了

462
00:22:22,370 --> 00:22:25,500
相邻空间很有可能被访问

463
00:22:25,500 --> 00:22:29,730
时间局部性指的是一个空间被访问了

464
00:22:29,730 --> 00:22:33,220
接下来很有可能再次访问

465
00:22:33,220 --> 00:22:36,750
那这两种说法呢，注意区分一下

466
00:22:36,750 --> 00:22:40,070
一个是循环的体现

467
00:22:40,760 --> 00:22:43,920
一个呢，是顺序的体现

468
00:22:45,420 --> 00:22:49,660
这是关于局部性原理的考察

469
00:22:50,300 --> 00:22:52,120
下面这道题

470
00:22:52,120 --> 00:22:57,750
虚拟存储体系由哪两级存储结构来组成

471
00:22:57,750 --> 00:22:59,700
虚拟存储体系啊

472
00:22:59,700 --> 00:23:01,560
它的虚拟指的是呢

473
00:23:01,560 --> 00:23:03,880
当内存不够的时候

474
00:23:03,880 --> 00:23:06,410
储存不够的时候

475
00:23:06,410 --> 00:23:10,020
外存可以呢，作为一个，诶

476
00:23:10,020 --> 00:23:11,960
相邻的一个部分啊

477
00:23:11,960 --> 00:23:13,720
把它囊括进去

478
00:23:13,720 --> 00:23:18,820
看起来就好像储存的容量变得特别大了

479
00:23:18,820 --> 00:23:20,480
那这个过程呢

480
00:23:20,480 --> 00:23:23,680
形成的就叫呢，虚拟传输体系

481
00:23:23,680 --> 00:23:29,420
所以它指的是储存以及储存这个结构

482
00:23:29,420 --> 00:23:31,720
对于寄存器而言

483
00:23:31,720 --> 00:23:33,030
我们一般啊

484
00:23:33,030 --> 00:23:36,600
很少把它归到真正的存储结构当中去

485
00:23:36,600 --> 00:23:39,450
它的划分一般在 CPU 当中

486
00:23:39,450 --> 00:23:41,210
我们还给大家呢

487
00:23:41,210 --> 00:23:44,010
提到了一个三级存储体系

488
00:23:44,010 --> 00:23:47,950
catch 、储存以及呢，外存

489
00:23:48,000 --> 00:23:50,000
这三个部分呢

490
00:23:50,000 --> 00:23:53,680
也可以称之为三级存储结构

491
00:23:57,340 --> 00:24:01,400
目前在我们的软件设计师考试当中

492
00:24:01,400 --> 00:24:03,780
考察大家 catch 的时候

493
00:24:03,780 --> 00:24:07,760
只提到了 CPU 与主存之间的 catc

494
00:24:07,760 --> 00:24:09,720
储存和外存

495
00:24:09,720 --> 00:24:12,650
还有呢磁盘之间也有一些呢

496
00:24:12,650 --> 00:24:14,530
一级缓存、二级缓存

497
00:24:14,530 --> 00:24:17,380
目前在软件设计师考试当中

498
00:24:17,380 --> 00:24:21,570
并没有涉及到下面这道题

499
00:24:21,570 --> 00:24:24,530
在微机系统当中呢

500
00:24:24,530 --> 00:24:29,630
唉， BIOS 基本输入输出系统

501
00:24:29,630 --> 00:24:33,160
保存在哪一个存储器当中

502
00:24:33,160 --> 00:24:35,370
那我们对于这一类啊

503
00:24:35,370 --> 00:24:39,010
首先考虑一下掉电会不会丢数据

504
00:24:39,010 --> 00:24:41,020
那掉电会不会说

505
00:24:41,020 --> 00:24:43,940
我们的基本的这种 boss 系统不见了

506
00:24:43,940 --> 00:24:44,500
不会

507
00:24:44,500 --> 00:24:49,060
所以它一定是只读的 ROM 寄存器

508
00:24:49,060 --> 00:24:51,960
跟这一类都是没有关系的

509
00:24:51,960 --> 00:24:54,760
它考察的是存储器

510
00:24:54,760 --> 00:24:56,850
主板上的 ram 呢

511
00:24:56,850 --> 00:24:58,870
唉，掉电内容会丢失

512
00:24:58,870 --> 00:25:00,920
一般用在储存

513
00:25:00,920 --> 00:25:02,750
虚拟存储器

514
00:25:02,750 --> 00:25:04,390
我们之前提到呢

515
00:25:04,390 --> 00:25:07,330
它指的是内存以及呢外存

516
00:25:07,330 --> 00:25:10,050
两个级别的存储结构

517
00:25:10,050 --> 00:25:12,680
还有呢，三级存储结构

518
00:25:12,680 --> 00:25:17,560
指的是 catch 储存以及呢外存三个存储结构

519
00:25:17,560 --> 00:25:18,900
那这些呢

520
00:25:18,900 --> 00:25:23,220
就是关于层次化存储的一些理论概念
