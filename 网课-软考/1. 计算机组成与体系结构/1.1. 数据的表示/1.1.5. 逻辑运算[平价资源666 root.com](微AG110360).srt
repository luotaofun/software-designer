1
00:00:00,000 --> 00:00:04,740
接下来看到数据表示逻辑运算的部分

2
00:00:04,740 --> 00:00:08,590
逻辑运算在我们软件设计师教程当中

3
00:00:08,590 --> 00:00:10,850
并没有明确的给大家介绍到

4
00:00:10,850 --> 00:00:13,320
但是呢，在考试当中啊

5
00:00:13,320 --> 00:00:14,770
上五题有出现

6
00:00:14,770 --> 00:00:18,610
并且在写一些条件判断语句的时候

7
00:00:18,610 --> 00:00:20,670
其实大家也会用到

8
00:00:20,670 --> 00:00:22,590
只是呢，没有留意到

9
00:00:22,590 --> 00:00:25,620
说到运算，大家能想到什么

10
00:00:25,620 --> 00:00:29,470
我们常见的运算是加减乘除吧

11
00:00:29,470 --> 00:00:32,439
这一类呢，叫做算术运算

12
00:00:32,439 --> 00:00:33,710
还有一类呢

13
00:00:33,710 --> 00:00:35,880
诶，比较大小

14
00:00:35,880 --> 00:00:39,160
这个过程呢，叫做关系运算

15
00:00:39,160 --> 00:00:42,640
最后呢，在我们的程序设计过程当中

16
00:00:42,640 --> 00:00:45,600
涉及到条件真假值的判断

17
00:00:45,600 --> 00:00:46,720
这一类呢

18
00:00:46,720 --> 00:00:50,520
真假值运算就叫做呢逻辑运算

19
00:00:50,520 --> 00:00:52,550
我们的算术运算呢

20
00:00:52,550 --> 00:00:53,450
加减乘

21
00:00:53,450 --> 00:00:55,570
就没有必要给大家介绍了啊

22
00:00:55,570 --> 00:00:58,580
我们首先看到关系运算

23
00:00:58,580 --> 00:01:00,980
看一看关系运算

24
00:01:00,980 --> 00:01:03,700
以及呢，它们的运算顺序

25
00:01:03,700 --> 00:01:09,650
常见的关系运算符大小比较包括小于、大于

26
00:01:09,650 --> 00:01:13,680
还有小于等于、大于等于

27
00:01:13,680 --> 00:01:17,470
注意这个符号是分开来写的

28
00:01:17,470 --> 00:01:20,070
我们一般在数学当中去写

29
00:01:20,070 --> 00:01:22,580
小于等于是连起来写的吧

30
00:01:22,580 --> 00:01:26,300
但是在写关系表达式的时候

31
00:01:26,300 --> 00:01:27,400
我们一般呢

32
00:01:27,400 --> 00:01:29,240
是分开来写

33
00:01:29,240 --> 00:01:32,320
小于等于和大于等于的符号呢

34
00:01:32,320 --> 00:01:33,530
注意一下

35
00:01:33,530 --> 00:01:36,650
那既然有大小就有相等

36
00:01:36,650 --> 00:01:39,350
第二类呢，叫做等于

37
00:01:39,350 --> 00:01:41,270
以及呢，不等于

38
00:01:41,270 --> 00:01:44,220
我们在日常生活当中看到

39
00:01:44,220 --> 00:01:46,790
等于呢，是单个等号

40
00:01:46,790 --> 00:01:49,940
注意，在关系表达式当中

41
00:01:49,940 --> 00:01:53,240
相等是用双等号来表示的

42
00:01:53,240 --> 00:01:56,810
单等号是用来做赋值的

43
00:01:56,810 --> 00:01:58,080
赋值符号呢

44
00:01:58,080 --> 00:02:00,170
也是一类过程

45
00:02:00,170 --> 00:02:02,260
不等于等号

46
00:02:02,260 --> 00:02:06,980
前面加了一个不感叹号来表示感叹号

47
00:02:06,980 --> 00:02:08,699
在逻辑运算当中啊

48
00:02:08,699 --> 00:02:11,720
是非也就是呢，不的意思

49
00:02:12,030 --> 00:02:15,150
在关系运算符当中

50
00:02:15,150 --> 00:02:19,150
大于和小于这一部分优先级相同

51
00:02:19,150 --> 00:02:20,700
并且较高

52
00:02:20,700 --> 00:02:26,600
而对于等于不等于这一部分的优先级也是相同

53
00:02:26,600 --> 00:02:29,280
但是呢，它的优先级较低

54
00:02:29,280 --> 00:02:32,110
所谓的优先级就是呢

55
00:02:32,110 --> 00:02:34,050
唉，类似于加减乘除

56
00:02:34,050 --> 00:02:37,000
我们先做乘除再做加减

57
00:02:37,000 --> 00:02:40,660
唉，我们说乘除的优先级高于加减

58
00:02:40,660 --> 00:02:41,970
在这里的话

59
00:02:41,970 --> 00:02:44,410
我们先做大小比较

60
00:02:44,410 --> 00:02:46,740
再做呢等于的比较

61
00:02:46,740 --> 00:02:49,550
这就是关系运算符

62
00:02:49,550 --> 00:02:52,010
对于这类运算符啊

63
00:02:52,010 --> 00:02:56,590
它的优先级是低于算术运算符的

64
00:02:56,590 --> 00:03:00,050
也就是说我们先做加减乘除

65
00:03:00,050 --> 00:03:02,610
再做呢大小比较

66
00:03:02,610 --> 00:03:07,880
其次，关系运算符优先级会高于赋值符号

67
00:03:07,880 --> 00:03:10,900
我们会先做相应的比较

68
00:03:10,900 --> 00:03:13,470
再来进行最后的赋值

69
00:03:13,470 --> 00:03:15,130
这个赋值符号啊

70
00:03:15,130 --> 00:03:17,150
优先级是最低的

71
00:03:17,150 --> 00:03:18,330
我们一般呢

72
00:03:18,330 --> 00:03:22,540
如果说 A 等于各种后面的描述

73
00:03:22,540 --> 00:03:26,440
都是将所有的过程计算完成

74
00:03:26,440 --> 00:03:28,190
才会进行赋值

75
00:03:28,190 --> 00:03:29,570
所以我们说呢

76
00:03:29,570 --> 00:03:31,970
负值是最后才去做的

77
00:03:31,970 --> 00:03:35,310
优先级也是呢最低的

78
00:03:36,110 --> 00:03:38,790
再来看逻辑运算

79
00:03:38,800 --> 00:03:43,140
逻辑运算的话就是我们所说的真假值

80
00:03:43,140 --> 00:03:46,910
那真假值其实都是呢，逻辑变量

81
00:03:46,910 --> 00:03:49,590
对于逻辑变量之间的运算

82
00:03:49,590 --> 00:03:51,780
我们称之为逻辑运算

83
00:03:51,780 --> 00:03:55,480
那二进制当中我们说呢，只有零和一

84
00:03:55,480 --> 00:03:56,630
在这里啊

85
00:03:56,630 --> 00:03:57,550
零是假

86
00:03:57,550 --> 00:03:58,470
一是真

87
00:03:58,470 --> 00:04:01,030
它也可以呢，代表真假值

88
00:04:01,030 --> 00:04:01,950
也就是呢

89
00:04:01,950 --> 00:04:03,040
逻辑变量

90
00:04:03,040 --> 00:04:06,430
并且我们的二进制实质是什么

91
00:04:06,430 --> 00:04:07,530
大家还记得吗

92
00:04:07,530 --> 00:04:10,910
二进制的实质是电气信号

93
00:04:10,910 --> 00:04:12,390
在这里的话

94
00:04:12,390 --> 00:04:14,990
我们的逻辑表达式

95
00:04:14,990 --> 00:04:17,640
其实也可以转换成逻辑电路

96
00:04:17,640 --> 00:04:18,750
这一部分的话

97
00:04:18,750 --> 00:04:22,120
在软件设计师考试当中并没有涉及

98
00:04:22,120 --> 00:04:26,010
大家呢，了解有这么回事儿就可以了

99
00:04:26,010 --> 00:04:29,750
下面我们来看一下逻辑运算有哪些呢

100
00:04:29,750 --> 00:04:31,910
主要就是与或非

101
00:04:31,910 --> 00:04:35,420
以及呢，亦或所谓的逻辑

102
00:04:35,420 --> 00:04:37,760
或有这样的一些写法

103
00:04:37,760 --> 00:04:39,800
它是呢， or 的意思

104
00:04:39,800 --> 00:04:42,200
诶，真或者呢，假

105
00:04:42,200 --> 00:04:44,510
在这个过程当中啊

106
00:04:44,510 --> 00:04:48,900
对于两个逻辑值用或连接的时候

107
00:04:48,900 --> 00:04:51,400
只有两者同时为假

108
00:04:51,400 --> 00:04:53,200
它才是为假的

109
00:04:53,200 --> 00:04:55,710
只要有一个过程为真

110
00:04:55,710 --> 00:04:58,280
它就是呢结果为真的

111
00:04:58,280 --> 00:05:03,000
类似于我们物理电路上有两条线路

112
00:05:03,000 --> 00:05:06,110
只要有一条线路是通路

113
00:05:06,110 --> 00:05:09,450
那整个系统呢，都是通路

114
00:05:10,540 --> 00:05:12,780
第二个，逻辑语

115
00:05:12,780 --> 00:05:14,440
它的符号写法

116
00:05:14,440 --> 00:05:15,660
大家可以看到

117
00:05:15,660 --> 00:05:16,840
它表示

118
00:05:16,840 --> 00:05:18,580
and 这样的意思

119
00:05:18,580 --> 00:05:22,040
连接的两端同时为一

120
00:05:22,040 --> 00:05:25,350
采取一同时为假

121
00:05:25,350 --> 00:05:27,250
哎，它就是呢甲

122
00:05:27,250 --> 00:05:29,290
只要有一个是甲

123
00:05:29,290 --> 00:05:31,400
其实它就是为假了

124
00:05:31,400 --> 00:05:34,870
类似于物理电路上串联的电路

125
00:05:34,870 --> 00:05:37,850
只要其中有一部分断了

126
00:05:37,850 --> 00:05:40,670
整个电路呢都是不通的

127
00:05:40,670 --> 00:05:43,010
这就是呢逻辑语

128
00:05:43,060 --> 00:05:46,450
第三个，先来看逻辑非

129
00:05:46,450 --> 00:05:47,860
我们前面说了

130
00:05:47,860 --> 00:05:49,780
非呢是不的意思

131
00:05:49,780 --> 00:05:52,000
用感叹号可以表示

132
00:05:52,000 --> 00:05:53,400
它表示呢， not 

133
00:05:53,400 --> 00:05:56,560
那真它的反面是什么

134
00:05:56,560 --> 00:05:57,790
那就是假

135
00:05:57,790 --> 00:05:59,370
假的反面是什么呢

136
00:05:59,370 --> 00:06:01,890
就是真，非真即假

137
00:06:01,890 --> 00:06:04,570
这就是呢非的含义

138
00:06:04,570 --> 00:06:05,670
取反

139
00:06:05,750 --> 00:06:09,070
第四个，逻辑异或

140
00:06:10,380 --> 00:06:13,600
抑或的操作比较特殊

141
00:06:13,600 --> 00:06:15,700
它在判断的时候

142
00:06:15,700 --> 00:06:19,910
是查看两个逻辑值是否相同

143
00:06:19,910 --> 00:06:22,880
不同情况下结果为一

144
00:06:22,880 --> 00:06:25,940
相同情况下结果为零

145
00:06:25,940 --> 00:06:30,080
异或运算判断的是诶，不同才为一啊

146
00:06:30,080 --> 00:06:33,590
相同的话结果是等于零的

147
00:06:33,590 --> 00:06:34,760
那这样来看

148
00:06:34,760 --> 00:06:38,920
大家可能不了解他最终的这个判断依据

149
00:06:38,920 --> 00:06:42,270
我们给大家呢列了一个真值表

150
00:06:42,270 --> 00:06:45,310
表示呢两端的过程

151
00:06:45,310 --> 00:06:49,910
首先 A 和 B 是两个逻辑变量

152
00:06:49,910 --> 00:06:53,250
它们的取值可以都为真

153
00:06:53,250 --> 00:06:54,230
都为假

154
00:06:54,230 --> 00:06:56,100
亦真亦假

155
00:06:56,100 --> 00:06:58,150
在这个过程当中

156
00:06:58,150 --> 00:07:01,830
如果对 A 进行逻辑非运算

157
00:07:01,830 --> 00:07:04,500
那所有的零会变成一

158
00:07:04,500 --> 00:07:06,560
一会变成零

159
00:07:06,560 --> 00:07:08,120
这就是呢取反

160
00:07:08,120 --> 00:07:10,380
也就是呢非的一

161
00:07:10,380 --> 00:07:14,770
那对 A 和 B 用加号来表示的话

162
00:07:14,770 --> 00:07:17,430
其实它就是逻辑或

163
00:07:20,500 --> 00:07:23,760
A 或 B 表示的什么含义呢

164
00:07:23,760 --> 00:07:26,060
只要有一个为真

165
00:07:26,060 --> 00:07:28,740
出现了真才为真吧

166
00:07:28,740 --> 00:07:31,720
什么样的情况下为假呢

167
00:07:31,720 --> 00:07:34,660
二者同时为假才为假

168
00:07:34,660 --> 00:07:35,860
那这事呢

169
00:07:35,860 --> 00:07:38,180
A 或 B 它的运算

170
00:07:38,180 --> 00:07:43,920
A 乘 B 表示的是 A 和 B 的与运算逻辑

171
00:07:43,920 --> 00:07:49,890
与在与运算的过程当中同时为真才为真吧

172
00:07:49,890 --> 00:07:53,800
所以只有 ab 取值同时为一的时候

173
00:07:53,800 --> 00:07:54,850
它才为一

174
00:07:54,850 --> 00:07:58,590
其他情况取值全部为假

175
00:07:58,590 --> 00:07:59,810
那这是呢

176
00:07:59,810 --> 00:08:01,570
唉， A 与 B 

177
00:08:01,570 --> 00:08:05,000
A 和 B 的异或怎么来看呢

178
00:08:05,000 --> 00:08:06,620
二者相同

179
00:08:06,620 --> 00:08:08,360
同时取零

180
00:08:08,360 --> 00:08:09,560
结果为假

181
00:08:09,560 --> 00:08:12,990
同时取一，结果为假

182
00:08:12,990 --> 00:08:15,450
二者一正一负的时候

183
00:08:15,450 --> 00:08:16,790
一真一假的时候

184
00:08:16,790 --> 00:08:17,690
二者不同

185
00:08:17,690 --> 00:08:19,570
结果呢才为一

186
00:08:19,570 --> 00:08:22,660
这就是呢逻辑运算

187
00:08:23,010 --> 00:08:27,230
我们在做逻辑运算的结果判断的时候啊

188
00:08:27,230 --> 00:08:30,770
可以呢，把真假值列出来再判断

189
00:08:30,770 --> 00:08:35,039
这种考察在2009年之后啊

190
00:08:35,039 --> 00:08:38,039
我们的软色基本上是看不到了

191
00:08:38,039 --> 00:08:40,809
但是呢，这几种运算方

192
00:08:40,809 --> 00:08:43,470
还是需要大家能了解到

193
00:08:44,340 --> 00:08:46,240
逻辑运算符

194
00:08:46,240 --> 00:08:48,870
大家呢，再梳理一下

195
00:08:48,870 --> 00:08:52,160
逻辑与同时为真才为真

196
00:08:52,160 --> 00:08:53,820
只要有一个为假

197
00:08:53,820 --> 00:08:55,200
结果就为假

198
00:08:55,200 --> 00:08:58,640
相当于 and 逻辑或

199
00:08:58,640 --> 00:09:02,110
它是呢，二者同时为假才为假

200
00:09:02,110 --> 00:09:04,310
只要有一个为真

201
00:09:04,310 --> 00:09:05,830
结果呢就为真

202
00:09:05,830 --> 00:09:07,430
相当于 all 

203
00:09:07,430 --> 00:09:10,580
逻辑非一的飞是零

204
00:09:10,580 --> 00:09:12,200
零的飞是一

205
00:09:12,200 --> 00:09:14,340
它是一个取反的操作

206
00:09:14,340 --> 00:09:15,820
相当于 not 

207
00:09:15,820 --> 00:09:17,150
那假设的话

208
00:09:17,150 --> 00:09:20,390
我们对 A 和 B 做与运算

209
00:09:20,390 --> 00:09:22,030
只要呢同时为真

210
00:09:22,030 --> 00:09:23,090
它就为真

211
00:09:23,090 --> 00:09:25,350
A 和 B 做或运算

212
00:09:25,350 --> 00:09:26,790
只要有一个为真

213
00:09:26,790 --> 00:09:28,070
它就是为真的

214
00:09:28,070 --> 00:09:30,760
那对 A 做非运算

215
00:09:30,760 --> 00:09:32,400
它为真的情况下

216
00:09:32,400 --> 00:09:34,340
结果就是假的

217
00:09:34,340 --> 00:09:37,080
这就是呢逻辑运算符

218
00:09:37,080 --> 00:09:41,700
那逻辑运算符有没有先后区别呢

219
00:09:41,700 --> 00:09:46,290
有，它们同样有优先级的排序

220
00:09:46,290 --> 00:09:48,740
对于逻辑运算符

221
00:09:48,740 --> 00:09:50,560
它的优先次序呢

222
00:09:50,560 --> 00:09:53,730
是先做非，再做与

223
00:09:53,730 --> 00:09:56,460
最后才做呢或运算

224
00:09:56,460 --> 00:09:58,300
那我们在这里的话

225
00:09:58,300 --> 00:10:00,200
运算符当中

226
00:10:00,200 --> 00:10:04,300
这里的与和或它们的运算关系呢

227
00:10:04,300 --> 00:10:07,060
是低于关系运算符的

228
00:10:07,060 --> 00:10:07,970
也就是说

229
00:10:07,970 --> 00:10:13,310
我们先做关系运算大小和等于的判定

230
00:10:13,310 --> 00:10:16,210
再来做呢逻辑运算

231
00:10:16,210 --> 00:10:18,660
而对于非来说呢

232
00:10:18,660 --> 00:10:21,640
它是高于算术运算符的

233
00:10:21,640 --> 00:10:25,780
也就是说在所有的运算过程当中

234
00:10:25,780 --> 00:10:28,760
一定是先做非

235
00:10:31,400 --> 00:10:35,400
然后呢，做算数运算

236
00:10:38,600 --> 00:10:42,980
算数运算呢，我们一般先做乘除波

237
00:10:42,980 --> 00:10:45,010
再做加减

238
00:10:45,010 --> 00:10:49,190
算数运算之后呢，是关系运算

239
00:10:51,900 --> 00:10:55,120
关系运算先做大小

240
00:10:55,120 --> 00:10:58,710
大于大于等于小于小于等于

241
00:10:58,710 --> 00:11:01,340
再做呢，唉等于判断

242
00:11:01,340 --> 00:11:03,240
注意是双等号

243
00:11:03,240 --> 00:11:05,730
再做呢不等号的判断

244
00:11:05,730 --> 00:11:08,010
那就是呢，关系运算

245
00:11:08,010 --> 00:11:11,310
最后呢，才做逻辑运算

246
00:11:15,480 --> 00:11:18,280
逻辑运算应该呢

247
00:11:18,280 --> 00:11:21,440
先做与再做或

248
00:11:24,720 --> 00:11:32,050
那这是呢，我们运算符的整个 A 优先级的排序

249
00:11:32,050 --> 00:11:35,480
注意，如果出现括号的话

250
00:11:35,480 --> 00:11:40,110
我们一般呢，要先看括号内部的内容

251
00:11:40,110 --> 00:11:42,700
这是关于优先级的

252
00:11:42,700 --> 00:11:44,280
呃，一个呢，总结

253
00:11:44,280 --> 00:11:46,220
大家呢，可以看到这里啊

254
00:11:46,220 --> 00:11:49,810
也给大家呢，列举了一个啊，排序

255
00:11:49,810 --> 00:11:51,550
我们前面呢，没有提到的

256
00:11:51,550 --> 00:11:53,800
还有一个赋值运算符

257
00:11:53,800 --> 00:11:56,760
比逻辑运算符优先级还要低

258
00:11:56,760 --> 00:11:58,900
它是放在最后才做的

259
00:11:58,900 --> 00:12:00,710
这些啊，就是关于呢

260
00:12:00,710 --> 00:12:03,270
运算符的一些介绍

261
00:12:03,270 --> 00:12:06,580
逻辑运算呢，我们主要用鱼呀

262
00:12:06,580 --> 00:12:07,980
一个呢是计算

263
00:12:07,980 --> 00:12:11,520
还有一个呢，是用在程序设计语言当

264
00:12:11,520 --> 00:12:13,940
做条件判断的

265
00:12:13,940 --> 00:12:17,190
那在运算的过程当中

266
00:12:17,190 --> 00:12:19,090
有一个特殊的原则

267
00:12:19,090 --> 00:12:21,460
叫做呢，短路原则

268
00:12:21,460 --> 00:12:23,470
什么是短路呢

269
00:12:23,470 --> 00:12:24,550
大家想一想

270
00:12:24,550 --> 00:12:26,170
在电路当中啊

271
00:12:26,170 --> 00:12:29,960
如果在电线当中突然截了，诶

272
00:12:29,960 --> 00:12:31,700
把两个点连接起来

273
00:12:31,700 --> 00:12:33,740
用电线直接连接它

274
00:12:33,740 --> 00:12:35,090
是不是就短路了

275
00:12:35,090 --> 00:12:37,100
短路的过程当中

276
00:12:37,100 --> 00:12:41,980
里面的一部分电路是不会流通的

277
00:12:41,980 --> 00:12:45,690
同样，在逻辑运算的过程当中

278
00:12:45,690 --> 00:12:48,290
如果出现短路的话

279
00:12:48,290 --> 00:12:53,190
有一部分运算过程是不会呢流通的

280
00:12:53,190 --> 00:12:54,880
那我们来看一下

281
00:12:54,880 --> 00:12:59,220
在逻辑表达式的求解过程当中啊

282
00:12:59,220 --> 00:13:02,700
并不是所有的运算都要被执行

283
00:13:02,700 --> 00:13:04,210
为什么呢

284
00:13:04,210 --> 00:13:09,280
我们在做一系列与运算的情况下

285
00:13:09,280 --> 00:13:11,680
会发现什么样的情况下

286
00:13:11,680 --> 00:13:13,980
雨的结果才是真啊

287
00:13:13,980 --> 00:13:15,790
所有的结果

288
00:13:15,790 --> 00:13:18,510
所有的变量都是真的情况下

289
00:13:18,510 --> 00:13:19,630
它才为真吧

290
00:13:19,630 --> 00:13:22,760
那如果第一个变量就是假呢

291
00:13:22,760 --> 00:13:24,660
这种情况下

292
00:13:24,660 --> 00:13:26,780
诶，只要有一个为假

293
00:13:26,780 --> 00:13:28,760
后面都为假了吧

294
00:13:28,760 --> 00:13:33,730
所以当 A 的判断是一个价值的话

295
00:13:33,730 --> 00:13:38,350
后面的 BC 表达式不需要去判断了

296
00:13:38,350 --> 00:13:40,800
这就是呢短路

297
00:13:40,800 --> 00:13:44,880
同样，在逻辑或运算当中

298
00:13:44,880 --> 00:13:49,400
如果有三个表达式来求连续的或运算

299
00:13:49,400 --> 00:13:53,560
我们会发现什么样的情况下，诶

300
00:13:53,560 --> 00:13:55,320
我们不需要计算呢

301
00:13:55,320 --> 00:13:59,040
如果说在或运算当中

302
00:13:59,040 --> 00:14:00,660
三个表达式

303
00:14:00,660 --> 00:14:04,130
三个逻辑变量只要有一个为真

304
00:14:04,130 --> 00:14:07,570
那后面整个表达式就为真了吧

305
00:14:07,570 --> 00:14:11,600
所以当 A 为真值的时候

306
00:14:11,600 --> 00:14:14,000
B 和 C 有没有必要判断

307
00:14:14,000 --> 00:14:17,040
哪没有必要去看真假了

308
00:14:17,040 --> 00:14:18,850
那这里呢，就

309
00:14:18,850 --> 00:14:24,010
就是我们提到的短路原则与运算

310
00:14:24,010 --> 00:14:26,590
第一个表达式为假

311
00:14:26,590 --> 00:14:28,730
那整个表达式为假

312
00:14:28,730 --> 00:14:32,120
后面的表达式就可以忽略不算呢

313
00:14:32,120 --> 00:14:33,840
或运算当中呢

314
00:14:33,840 --> 00:14:36,060
第一个表达式，诶

315
00:14:36,060 --> 00:14:37,590
它是呢为真的

316
00:14:37,590 --> 00:14:39,980
那整个结果一定为真

317
00:14:39,980 --> 00:14:43,600
后面的表达式也不需要去计算呢

318
00:14:43,600 --> 00:14:46,080
那我们下面来看一个例子

319
00:14:46,080 --> 00:14:47,540
短路原则

320
00:14:47,540 --> 00:14:51,310
对我们的逻辑运算有什么样的影响呢

321
00:14:51,310 --> 00:14:53,480
下面给了一个表达式

322
00:14:53,480 --> 00:14:56,550
对于这些表达式没有出现非啊

323
00:14:56,550 --> 00:14:59,920
所以我们先做的是大小的比较

324
00:14:59,920 --> 00:15:02,440
唉，但是我们发现有括号吧

325
00:15:02,440 --> 00:15:04,830
所以我们先看括号就可以了

326
00:15:04,830 --> 00:15:11,260
在括号当中先看 A 大于 B 这一部分关系运算

327
00:15:11,260 --> 00:15:13,930
下面给了我们一些参数

328
00:15:13,930 --> 00:15:15,760
A 等于一

329
00:15:15,760 --> 00:15:18,070
B 等于二

330
00:15:19,600 --> 00:15:23,880
M 和 N 的值都是等于一的

331
00:15:23,880 --> 00:15:25,230
一大于二

332
00:15:25,230 --> 00:15:26,470
是否满足呢

333
00:15:26,470 --> 00:15:27,410
不满足吧

334
00:15:27,410 --> 00:15:28,930
它一定是假的

335
00:15:28,930 --> 00:15:30,130
它不是一个真的啊

336
00:15:30,130 --> 00:15:31,340
它是假的

337
00:15:31,340 --> 00:15:35,390
那甲的话，它所对应的值就是呢零

338
00:15:35,390 --> 00:15:38,470
所以我们在这里做了负值

339
00:15:38,470 --> 00:15:40,670
M 等于零

340
00:15:40,800 --> 00:15:42,740
M 等于零的话

341
00:15:42,740 --> 00:15:46,470
我们发现呢，这里是一个与运算吧

342
00:15:46,470 --> 00:15:49,140
在与运算过程当中

343
00:15:49,140 --> 00:15:52,480
如果确定前面为零呢

344
00:15:52,480 --> 00:15:56,160
后面是不需要我们去判断的

345
00:15:56,160 --> 00:16:00,850
所以最终 N 的取值还是等于一

346
00:16:00,850 --> 00:16:02,890
没有发生变化的

347
00:16:02,890 --> 00:16:06,090
这是呢短路原则的结果

348
00:16:06,090 --> 00:16:08,120
如果不考虑短路啊

349
00:16:08,120 --> 00:16:11,200
我们做到最后会发生什么样的情况呢

350
00:16:11,200 --> 00:16:13,010
C 等于三

351
00:16:13,010 --> 00:16:14,400
D 1等于四

352
00:16:14,400 --> 00:16:16,700
A 又是一个价值吧

353
00:16:16,700 --> 00:16:18,440
这种情况下

354
00:16:18,440 --> 00:16:21,130
N 也是等于零的

355
00:16:21,130 --> 00:16:25,680
有没有短路会影响最终的结果

356
00:16:25,680 --> 00:16:28,210
而我们在做逻辑运算的时候

357
00:16:28,210 --> 00:16:31,130
一般呢是考虑短路原则的

358
00:16:31,130 --> 00:16:34,630
那这就是呢短路它的意义

359
00:16:37,380 --> 00:16:40,640
接下来呢，我们看一下逻辑运算

360
00:16:40,640 --> 00:16:43,160
在软件设计师考试当

361
00:16:43,160 --> 00:16:44,920
真题的体现

362
00:16:44,920 --> 00:16:51,910
下面这道题要判断字长为16位的整数 A 

363
00:16:51,910 --> 00:16:55,560
第四位是否全为零

364
00:16:55,560 --> 00:17:01,460
A 选项将 A 与000 F 来进行比较

365
00:17:01,460 --> 00:17:03,220
看到 F 大家想到什么

366
00:17:03,220 --> 00:17:05,780
这是一个16进制数啊

367
00:17:05,780 --> 00:17:09,280
F 的16进制转换成二进

368
00:17:09,280 --> 00:17:11,430
就是1111

369
00:17:11,430 --> 00:17:14,800
那我们考虑的就是第四位吧

370
00:17:14,800 --> 00:17:20,040
假设 A 的取值是否全为零

371
00:17:20,040 --> 00:17:22,220
假设全为零

372
00:17:23,520 --> 00:17:29,680
A 选项对它们进行逻辑与运算吧

373
00:17:29,830 --> 00:17:31,790
结果是多少呢

374
00:17:31,790 --> 00:17:34,370
与运算只要有一个为假

375
00:17:34,370 --> 00:17:35,800
它就为假啊

376
00:17:35,800 --> 00:17:39,460
那如果 A 的值不再全为零呢

377
00:17:39,460 --> 00:17:42,220
0010与1111

378
00:17:42,220 --> 00:17:45,810
做逻辑与它的结果就会变成一吧

379
00:17:45,810 --> 00:17:47,710
哎，大家都为一

380
00:17:47,710 --> 00:17:51,250
那这个结果变成了应该是

381
00:17:53,120 --> 00:17:57,200
它的结果啊，应该是0010

382
00:17:57,250 --> 00:17:59,090
是不是等于零啊

383
00:17:59,090 --> 00:18:00,750
不等于零吧

384
00:18:00,750 --> 00:18:02,610
这种情况

385
00:18:02,610 --> 00:18:06,560
判断运算结果是否等于零

386
00:18:06,560 --> 00:18:08,980
等于零说明什么啊

387
00:18:08,980 --> 00:18:10,700
A 就等于零

388
00:18:10,700 --> 00:18:13,370
这是我们判断的过程

389
00:18:13,370 --> 00:18:17,800
所以 A 选项它就是正确的选项

390
00:18:17,800 --> 00:18:21,740
我们再来看 BCD 的运算过程

391
00:18:21,740 --> 00:18:27,400
如果让 A 和 F 做逻辑或运算

392
00:18:27,400 --> 00:18:31,620
同样假设0000和1111

393
00:18:31,620 --> 00:18:34,260
做逻辑或结果是多少

394
00:18:34,260 --> 00:18:35,980
1111

395
00:18:36,240 --> 00:18:40,860
那0010和1111做逻辑货呢

396
00:18:40,860 --> 00:18:43,290
结果还是1111

397
00:18:43,290 --> 00:18:47,460
那当前判断结果等于 F 吗

398
00:18:47,460 --> 00:18:48,860
唉，等于

399
00:18:48,860 --> 00:18:51,990
那这种情况等于 F 的时候

400
00:18:51,990 --> 00:18:56,470
是否能够确认 A 的取值是全零啊

401
00:18:56,470 --> 00:18:57,450
不能

402
00:18:57,450 --> 00:18:59,020
所以这个情况下

403
00:18:59,020 --> 00:19:02,420
我们是区分不了这两个变量的

404
00:19:02,420 --> 00:19:03,140
它是呢

405
00:19:03,140 --> 00:19:04,420
错误的

406
00:19:06,680 --> 00:19:11,440
同样 D 选项它也是进行逻辑与运算吧

407
00:19:11,440 --> 00:19:15,480
但它判断结果是否等于 F 

408
00:19:15,480 --> 00:19:18,200
那我们判断的是是否等于零

409
00:19:18,200 --> 00:19:20,080
与 F 有没有关系

410
00:19:20,080 --> 00:19:21,340
没有关系

411
00:19:21,340 --> 00:19:23,960
两种情况都不等于 F 

412
00:19:23,960 --> 00:19:26,780
所以同样是判断不了的

413
00:19:26,780 --> 00:19:31,280
比较特殊的是 C 选项 E 或运算

414
00:19:31,280 --> 00:19:32,770
我们来看一下

415
00:19:32,770 --> 00:19:35,790
如果是异或运算的时候

416
00:19:35,790 --> 00:19:38,240
会发生什么样的情况呢

417
00:19:38,240 --> 00:19:44,900
同样是0000与1111做异或

418
00:19:47,240 --> 00:19:49,900
二者不同则为幺吧

419
00:19:49,900 --> 00:19:52,640
所以它的结果是1111

420
00:19:52,640 --> 00:19:56,270
而如果有一个不同的0010

421
00:19:56,270 --> 00:19:58,350
与1111做异或的话

422
00:19:58,350 --> 00:20:01,390
结果变成了1101

423
00:20:01,390 --> 00:20:03,370
唉，二者不同呀

424
00:20:03,370 --> 00:20:04,970
能够区分开

425
00:20:04,970 --> 00:20:10,170
但注意我们在这里区分的是是否等于零

426
00:20:10,170 --> 00:20:13,770
还是是否等于一呀

427
00:20:14,400 --> 00:20:17,980
应该是是否等于全1 F 吧

428
00:20:17,980 --> 00:20:21,700
所以 C 选项它是错误的

429
00:20:21,700 --> 00:20:23,520
那这个地方的话

430
00:20:23,520 --> 00:20:26,120
我们容易出现误解

431
00:20:26,120 --> 00:20:28,050
其实就是 C 选项

432
00:20:28,050 --> 00:20:30,550
我们 C 选项当中等于零的话

433
00:20:30,550 --> 00:20:32,840
跟本题是无关的

434
00:20:32,840 --> 00:20:33,800
然后呢

435
00:20:33,800 --> 00:20:36,100
哎， D 选项等于 F 的话

436
00:20:36,100 --> 00:20:37,860
也跟呢，本题无关

437
00:20:37,860 --> 00:20:41,740
只有 A 选项呢，才是正确的答案

438
00:20:42,520 --> 00:20:47,660
下面这道题对布尔表达式进行短路求值

439
00:20:47,660 --> 00:20:49,100
注意短路啊

440
00:20:49,100 --> 00:20:52,960
无需对表达式当中所有的操作数进行

441
00:20:52,960 --> 00:20:54,590
唉，最终的运算吧

442
00:20:54,590 --> 00:20:58,650
我们在这里看到 or 它是一个什么样的运算

443
00:20:58,650 --> 00:21:00,800
是一个或运算

444
00:21:00,800 --> 00:21:02,800
那对货运算而言

445
00:21:02,800 --> 00:21:06,810
什么样的情况下可以确定它的取值

446
00:21:06,810 --> 00:21:10,220
如果 A 等于零的话

447
00:21:10,220 --> 00:21:13,270
后面这一部分等于零

448
00:21:13,270 --> 00:21:14,190
结果为零

449
00:21:14,190 --> 00:21:15,930
等于一结果为一

450
00:21:15,930 --> 00:21:18,110
有两个线路吧

451
00:21:18,110 --> 00:21:20,450
A 等于一的话

452
00:21:20,450 --> 00:21:23,050
那我们在这里就会发现，哎

453
00:21:23,050 --> 00:21:28,000
无论后面是等于零还是呢等于一

454
00:21:28,000 --> 00:21:30,880
最终的结果都是等于一的

455
00:21:30,880 --> 00:21:32,880
这就是短路原则

456
00:21:32,880 --> 00:21:34,990
在或表达式当中

457
00:21:34,990 --> 00:21:38,650
短路原则它的第一个表达式为真

458
00:21:38,650 --> 00:21:40,780
后面整体都为真

459
00:21:40,780 --> 00:21:43,710
不需要进行后面的运算呢

460
00:21:43,710 --> 00:21:46,410
这就是呢短路的意思

461
00:21:46,410 --> 00:21:47,920
以上内容啊

462
00:21:47,920 --> 00:21:51,670
就是给大家介绍到的逻辑运算相关的部分

463
00:21:51,670 --> 00:21:54,170
大家回去之后呢，消化一下

464
00:21:54,170 --> 00:21:56,010
在程序设计的时候

465
00:21:56,010 --> 00:21:57,150
条件语句啊

466
00:21:57,150 --> 00:22:00,290
有时候呢，也会用到这一部分知识
