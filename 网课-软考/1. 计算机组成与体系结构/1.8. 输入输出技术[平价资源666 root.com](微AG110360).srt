1
00:00:00,000 --> 00:00:01,720
输入输出技术

2
00:00:01,720 --> 00:00:03,600
对于输入输出技术

3
00:00:03,600 --> 00:00:06,520
它呢，输入输出就是简称

4
00:00:06,520 --> 00:00:09,320
我们比较熟悉的 IO 

5
00:00:09,320 --> 00:00:10,890
输入输出技术

6
00:00:10,890 --> 00:00:14,390
它讲的是呢， CPU 控制

7
00:00:14,390 --> 00:00:17,970
我们的储存与外设之间

8
00:00:17,970 --> 00:00:20,950
进行数据交互的过程

9
00:00:20,950 --> 00:00:23,620
那这个过程当中呢

10
00:00:23,620 --> 00:00:26,150
外设它的速度比较慢

11
00:00:26,150 --> 00:00:29,150
储存的存取速度相对较快

12
00:00:29,150 --> 00:00:32,450
所以呢，需要有一定的一定的平衡

13
00:00:32,450 --> 00:00:35,200
在软件设计师考试当中呢

14
00:00:35,200 --> 00:00:38,000
主要提到几种呢，控制方式

15
00:00:38,000 --> 00:00:39,540
需要大家掌握

16
00:00:39,540 --> 00:00:42,980
这几种靠控制方式的特点对比

17
00:00:42,980 --> 00:00:45,500
以及呢，中断 DMA 

18
00:00:45,500 --> 00:00:46,860
在考试当中啊

19
00:00:46,860 --> 00:00:48,620
出现的比较频繁

20
00:00:48,620 --> 00:00:49,790
大家需要呢

21
00:00:49,790 --> 00:00:52,590
更加详细的去掌握一些

22
00:00:52,590 --> 00:00:55,680
我们看到呢，对于数据传输

23
00:00:55,680 --> 00:00:58,620
它的控制方式由谁来控制啊

24
00:00:58,620 --> 00:01:01,530
应该是 CPU 负责控制吧

25
00:01:01,530 --> 00:01:03,960
那它传输的过程当中

26
00:01:03,960 --> 00:01:08,470
是内存与外设之间进行交互

27
00:01:08,470 --> 00:01:09,860
内存较快

28
00:01:09,860 --> 00:01:11,370
外设较慢

29
00:01:11,370 --> 00:01:12,700
在这之中啊

30
00:01:12,700 --> 00:01:14,460
它的传输方式呢

31
00:01:14,460 --> 00:01:15,660
大致看一下

32
00:01:15,660 --> 00:01:18,650
第一类叫做程序查询方式

33
00:01:18,650 --> 00:01:21,010
程序控制查询可以有呢

34
00:01:21,010 --> 00:01:23,500
无条件以及呢，程序查询

35
00:01:23,500 --> 00:01:25,840
对于无条件传送

36
00:01:25,840 --> 00:01:29,600
是系统默认所有的 IO 都是呢准备好的

37
00:01:29,600 --> 00:01:31,680
直接呢开始操作就可以了

38
00:01:31,680 --> 00:01:33,550
没有呢，很大的意义了

39
00:01:33,550 --> 00:01:35,780
程序查询方式呢

40
00:01:35,780 --> 00:01:37,660
是我们的 CPU 

41
00:01:37,660 --> 00:01:40,610
每一次呢，都去问一下各个 IO 设备

42
00:01:40,610 --> 00:01:41,800
唉，你做完了吗

43
00:01:41,800 --> 00:01:44,400
做完了我就开始下一步了

44
00:01:44,400 --> 00:01:48,590
那很显然 CPU 会持续的去进行查询

45
00:01:48,590 --> 00:01:51,990
严重影响 CPU 它的利用率

46
00:01:51,990 --> 00:01:57,040
那这个过程啊，可以类比于我们学习的课堂

47
00:01:57,500 --> 00:02:01,020
学习课堂由谁来进行控制啊

48
00:02:01,020 --> 00:02:04,090
它的核心应该是老师吧

49
00:02:04,090 --> 00:02:08,000
老师控制整个课堂的内容

50
00:02:08,000 --> 00:02:14,080
将自己所学、所掌握的这些知识体系传输给大家

51
00:02:14,080 --> 00:02:17,250
那老师的思路会比较快

52
00:02:17,250 --> 00:02:20,480
而大家的思路会比较慢

53
00:02:20,480 --> 00:02:23,970
这个过程当中内存可以理解为诶

54
00:02:23,970 --> 00:02:26,090
老师的知识储备

55
00:02:27,520 --> 00:02:30,960
而外设呢，是学生哎

56
00:02:30,960 --> 00:02:32,060
他的一个呢

57
00:02:32,060 --> 00:02:33,200
知识

58
00:02:35,780 --> 00:02:39,460
到底这个知识有没有传输完成

59
00:02:39,460 --> 00:02:42,290
由老师来负责控制

60
00:02:42,290 --> 00:02:44,720
那我们在这里的话，诶

61
00:02:44,720 --> 00:02:47,160
比如说程序查询方式的话

62
00:02:47,160 --> 00:02:49,180
对于这种查询方式

63
00:02:49,180 --> 00:02:53,570
就是呢，老师在课堂上不停地走动

64
00:02:53,570 --> 00:02:56,090
然后呢，问各个学员

65
00:02:56,090 --> 00:02:57,470
大家学完了吗

66
00:02:57,470 --> 00:02:59,310
唉，大家学懂了吗

67
00:02:59,310 --> 00:03:00,540
大家听懂了

68
00:03:00,540 --> 00:03:04,080
我们就开始下一段知识的传输了

69
00:03:04,080 --> 00:03:08,380
这种方式呢，就叫做程序查询方式

70
00:03:08,380 --> 00:03:10,670
那如果班上有很多人

71
00:03:10,670 --> 00:03:12,890
只要呢，有人没有听懂的话

72
00:03:12,890 --> 00:03:15,110
老师呢，都必须停下

73
00:03:15,110 --> 00:03:16,660
等大家，唉

74
00:03:16,660 --> 00:03:18,220
然后再次询问

75
00:03:18,220 --> 00:03:20,040
直到大家都完成

76
00:03:20,040 --> 00:03:23,340
才开始下一个知识的传输

77
00:03:23,340 --> 00:03:26,000
这就是程序查询

78
00:03:26,000 --> 00:03:30,190
第二种方式呢，叫做程序中断方式

79
00:03:30,190 --> 00:03:31,590
刚刚的查询

80
00:03:31,590 --> 00:03:34,850
很显然我们的老师太浪费了吧

81
00:03:34,850 --> 00:03:37,570
很多学员呢，大部分都学会了呀

82
00:03:37,570 --> 00:03:41,720
那这个时候其实还有一种方法比较好

83
00:03:41,720 --> 00:03:43,650
我们呢，可以啊

84
00:03:43,650 --> 00:03:46,850
老师持续地做自己的事情

85
00:03:46,850 --> 00:03:49,700
给大家讲解各个知识内容

86
00:03:49,700 --> 00:03:54,480
然后呢，如果有学员没有听懂的话

87
00:03:54,480 --> 00:03:57,760
可以呢，举手打断一下老师

88
00:03:57,760 --> 00:04:00,980
那包括，诶，老师写了一些内容

89
00:04:00,980 --> 00:04:02,330
让大家记笔记

90
00:04:02,330 --> 00:04:03,980
那大家写完了之后

91
00:04:03,980 --> 00:04:05,080
记完笔记之后

92
00:04:05,080 --> 00:04:06,660
诶，举手告诉老师

93
00:04:06,660 --> 00:04:08,300
老师我写完了

94
00:04:08,300 --> 00:04:10,160
那这个过程的话

95
00:04:10,160 --> 00:04:13,230
我们呢，可以理解为中

96
00:04:13,230 --> 00:04:14,640
它的过程啊

97
00:04:14,640 --> 00:04:18,339
是程序在执行过程当中

98
00:04:18,339 --> 00:04:20,959
如果完成了 IO 

99
00:04:20,959 --> 00:04:23,060
会向我们的 CPU 

100
00:04:23,060 --> 00:04:24,280
也就是老师呢

101
00:04:24,280 --> 00:04:26,860
提交一个中断请求

102
00:04:26,860 --> 00:04:29,370
那提交中断请求之后呢

103
00:04:29,370 --> 00:04:31,190
告诉老师，诶，完成了

104
00:04:31,190 --> 00:04:33,170
中间大家抄写的过程

105
00:04:33,170 --> 00:04:35,970
是不影响老师的课程进度的

106
00:04:35,970 --> 00:04:37,030
也就是说

107
00:04:37,030 --> 00:04:44,080
数据的传输与 CPU 之间是一个并行的过程

108
00:04:51,500 --> 00:04:54,800
所以我们 CPU 的效率啊

109
00:04:54,800 --> 00:04:56,770
就有了很大的提高

110
00:04:56,770 --> 00:05:00,240
那当我们数据传输完成之后呢

111
00:05:00,240 --> 00:05:04,280
CPU 会响应终端关于中段的内容

112
00:05:04,280 --> 00:05:07,780
我们稍后呢，再展开来进行介绍

113
00:05:07,780 --> 00:05:10,290
这种方式相对来说

114
00:05:10,290 --> 00:05:12,700
CPU 的效率提升了一部分

115
00:05:12,700 --> 00:05:14,830
是不是最好的方案呢

116
00:05:14,830 --> 00:05:16,810
还有其他的解决方案

117
00:05:16,810 --> 00:05:21,440
可以看到第三种解决方案呢，是 DMA 的方式

118
00:05:21,440 --> 00:05:26,160
DMA 叫做呢，直接内存存取

119
00:05:26,160 --> 00:05:30,850
它是让 IO 和储存直接进行交互

120
00:05:30,850 --> 00:05:37,010
中间的所有工作都交给 DMA 自带的控制器

121
00:05:37,010 --> 00:05:39,170
DMC 来进行

122
00:05:39,170 --> 00:05:42,570
那整个 CPU 除了做一个初始化

123
00:05:42,570 --> 00:05:45,190
就不再参与它的执行了

124
00:05:45,190 --> 00:05:47,850
所以 CPU 该干嘛干嘛

125
00:05:47,850 --> 00:05:50,260
数据传输比较慢的话

126
00:05:50,260 --> 00:05:52,580
可以呢，交给助教去做

127
00:05:52,580 --> 00:05:55,970
这个助教呢，就可以理解为 DMC 

128
00:05:55,970 --> 00:05:57,650
DMA 的方式呢

129
00:05:57,650 --> 00:06:02,360
主要就是为了实现高速批量的数据交换

130
00:06:02,360 --> 00:06:06,560
它的效率啊，比前面两种方式都要高

131
00:06:06,560 --> 00:06:11,970
DMA 方式呢，是不需要 CPU 参与数据传输过程的

132
00:06:11,970 --> 00:06:14,400
那这里啊，我们呢

133
00:06:14,400 --> 00:06:16,240
诶，可以简单看一下

134
00:06:16,240 --> 00:06:17,450
DMAC 呢

135
00:06:17,450 --> 00:06:20,170
它会向总线裁决逻辑

136
00:06:20,170 --> 00:06:22,750
然后呢，提出总线的请求

137
00:06:22,750 --> 00:06:26,060
当 CPU 执行完手上的事情之后

138
00:06:26,060 --> 00:06:29,340
就释放了这个总线的控制权

139
00:06:29,340 --> 00:06:30,970
交给呢 DMAC 

140
00:06:30,970 --> 00:06:33,460
由 DMAC 呢，控制，诶

141
00:06:33,460 --> 00:06:35,380
相应的 IO 过程

142
00:06:35,380 --> 00:06:40,190
那这就是呢， DMAC 它的一个执行过程

143
00:06:40,190 --> 00:06:43,030
简单的了解一下就可以了

144
00:06:43,390 --> 00:06:46,600
最后，通道和 IO 处理机

145
00:06:46,600 --> 00:06:48,680
这是典型的硬件

146
00:06:48,680 --> 00:06:51,740
在我们的软件设计师考试当中呢

147
00:06:51,740 --> 00:06:55,080
并没有涉及到专用硬件部分

148
00:06:55,080 --> 00:06:58,700
那我们在平常使用电脑的时候啊

149
00:06:58,700 --> 00:07:02,840
鼠标键盘是用了中断的方式来响应的

150
00:07:02,840 --> 00:07:06,060
而像我们的移动硬盘这种呢

151
00:07:06,060 --> 00:07:08,020
快速的数据传输啊

152
00:07:08,020 --> 00:07:10,930
就是呢， DMA 方式来传输的

153
00:07:10,930 --> 00:07:12,390
从上往下

154
00:07:12,390 --> 00:07:16,120
整个呢，处理的效率会越来越高

155
00:07:16,120 --> 00:07:17,500
我们再来呢

156
00:07:17,500 --> 00:07:20,510
详细看一下中断它的处理过程

157
00:07:20,510 --> 00:07:22,290
中断处理过程呢

158
00:07:22,290 --> 00:07:26,620
我们整个 CPU 不必呢去查询 IO 状态

159
00:07:26,620 --> 00:07:28,670
只有呢， IO 完成之后

160
00:07:28,670 --> 00:07:30,470
他给我们呢举个手

161
00:07:30,470 --> 00:07:31,750
我们呢才去看

162
00:07:31,750 --> 00:07:34,910
那这个发出中断请求信号

163
00:07:34,910 --> 00:07:39,260
就类似于上课举手打断通知 CPU 

164
00:07:39,260 --> 00:07:41,790
那 CPU 看到有人，哎

165
00:07:41,790 --> 00:07:43,110
老师看到有人举手了

166
00:07:43,110 --> 00:07:44,560
就要去响应一下吧

167
00:07:44,560 --> 00:07:46,370
那响应的过程当中

168
00:07:46,370 --> 00:07:48,490
如果老师原本正在上课

169
00:07:48,490 --> 00:07:49,960
有人打断了

170
00:07:49,960 --> 00:07:51,020
那我们呢

171
00:07:51,020 --> 00:07:55,140
唉，对于计算机来说会停下来

172
00:07:55,140 --> 00:07:58,610
停下来的时候会把当前啊

173
00:07:58,610 --> 00:08:00,010
课程内容

174
00:08:00,010 --> 00:08:02,790
比如说呢，这个执行的现场

175
00:08:02,790 --> 00:08:05,950
唉，比如说大家在讲义上所做的这些呢

176
00:08:05,950 --> 00:08:08,270
板书会保留下来

177
00:08:08,270 --> 00:08:10,070
保留下来叫做呢

178
00:08:10,070 --> 00:08:13,590
保存现场相应的一些呢

179
00:08:13,590 --> 00:08:14,890
状态信息

180
00:08:14,890 --> 00:08:18,110
会存在一个站当中

181
00:08:18,550 --> 00:08:24,180
由站诶，最后呢，再弹出相应的数据进行还原

182
00:08:24,180 --> 00:08:26,490
那这个打断的地方呢

183
00:08:26,490 --> 00:08:28,610
我们叫做断点

184
00:08:28,610 --> 00:08:31,400
当断点诶，打断之后

185
00:08:31,400 --> 00:08:33,400
老师呢，会响应大家吧

186
00:08:33,400 --> 00:08:38,240
那响应的这些问题会记录在一个表格当中

187
00:08:38,240 --> 00:08:39,240
有一个呢

188
00:08:39,240 --> 00:08:40,630
中断向量表

189
00:08:40,630 --> 00:08:42,400
它有多种方式啊

190
00:08:42,400 --> 00:08:44,020
我们在考试当中呢

191
00:08:44,020 --> 00:08:46,990
目前只考察到了中断向量表

192
00:08:46,990 --> 00:08:52,080
中断向量表是可以记录我们需要响应的，诶

193
00:08:52,080 --> 00:08:53,780
相应的服务程序的

194
00:08:53,780 --> 00:08:55,330
中断服务程序

195
00:08:55,330 --> 00:08:57,740
我们根据这个向量表啊

196
00:08:57,740 --> 00:09:00,260
来记录服务程序的入口

197
00:09:00,260 --> 00:09:05,080
根据呢，入口转入相应的程序去执行

198
00:09:05,080 --> 00:09:07,580
执行完成之后呢

199
00:09:07,580 --> 00:09:10,160
再返回我们的断点

200
00:09:10,160 --> 00:09:13,830
接着呢，之前的课程内容往下继续

201
00:09:13,830 --> 00:09:15,560
这就是呢，中断

202
00:09:15,560 --> 00:09:18,760
那我们呢，有一个执行程

203
00:09:18,760 --> 00:09:21,440
打断的地方呢，叫做断点

204
00:09:21,440 --> 00:09:23,610
那我们有中断的话

205
00:09:23,610 --> 00:09:25,230
会响应中断

206
00:09:25,230 --> 00:09:27,850
查询中断向量表

207
00:09:27,850 --> 00:09:33,090
它会记录我们中断服务程序的入口地址

208
00:09:33,090 --> 00:09:35,230
通过入口，诶

209
00:09:35,230 --> 00:09:38,230
找到相应的中断服务程序

210
00:09:38,230 --> 00:09:39,290
响应完了

211
00:09:39,290 --> 00:09:41,730
那我们在这里是 IO 的终端

212
00:09:41,730 --> 00:09:44,060
所以是 IO 服务程序

213
00:09:44,060 --> 00:09:45,440
那执行完呢

214
00:09:45,440 --> 00:09:47,500
诶，回答完了大家的问题

215
00:09:47,500 --> 00:09:49,860
我们要返回站点

216
00:09:49,900 --> 00:09:51,890
返回断点

217
00:09:51,890 --> 00:09:53,410
通过断点呢

218
00:09:53,410 --> 00:09:56,610
接着往下完成前面的程序

219
00:09:56,610 --> 00:09:59,880
那这就是呢整个中段的内容

220
00:09:59,880 --> 00:10:03,080
它会涉及到占这种数据结构

221
00:10:03,080 --> 00:10:04,600
去存储一些内容

222
00:10:04,600 --> 00:10:06,750
从而呢进行回复

223
00:10:06,750 --> 00:10:09,980
里面呢会有保存现场的过程

224
00:10:09,980 --> 00:10:13,290
那大家呢，了解到中断需要呢

225
00:10:13,290 --> 00:10:14,470
大家掌握诶

226
00:10:14,470 --> 00:10:18,330
DMA 它呢，是不参与数据执行过程

227
00:10:18,330 --> 00:10:20,270
程序查询方式

228
00:10:20,270 --> 00:10:23,170
它对 CPU 利用率是最低的

229
00:10:23,170 --> 00:10:24,840
那我们在考试当中呢

230
00:10:24,840 --> 00:10:28,560
主要就是涉及到这些概念部分的考察

231
00:10:29,100 --> 00:10:31,760
下面来看一下这些内容啊

232
00:10:31,760 --> 00:10:34,160
在我们软件设计师真题当中

233
00:10:34,160 --> 00:10:36,920
它的考察方考察的内容

234
00:10:36,920 --> 00:10:38,650
首先第一道题

235
00:10:38,650 --> 00:10:40,390
计算机系统当中啊

236
00:10:40,390 --> 00:10:43,180
常用输入输出控制方式有呢

237
00:10:43,180 --> 00:10:44,580
唉，无条件传送

238
00:10:44,580 --> 00:10:47,410
还有呢中断程序查询和 DMA 

239
00:10:47,410 --> 00:10:52,000
那哪一种方式不需要 CPU 执行指令

240
00:10:52,000 --> 00:10:53,360
我们在这里

241
00:10:53,360 --> 00:10:54,960
首先可以排除的

242
00:10:54,960 --> 00:10:57,460
程序查询和无条件传送

243
00:10:57,460 --> 00:10:59,130
而中断的话

244
00:10:59,130 --> 00:11:01,810
它是需要执行中断指令的

245
00:11:01,810 --> 00:11:04,910
我们在这里 DMA 是不是不需要呢

246
00:11:04,910 --> 00:11:07,080
CPU 参与中间的过程

247
00:11:07,080 --> 00:11:09,940
所以这里选择的是 DMA 

248
00:11:09,940 --> 00:11:13,320
注意呢，熟悉 DMA 的特点

249
00:11:13,930 --> 00:11:15,590
下面这道题

250
00:11:15,590 --> 00:11:19,480
计算机运行过程当中遇到突发事件

251
00:11:19,480 --> 00:11:25,520
要求 CPU 暂时停止正在运行的这个，诶，程序

252
00:11:25,520 --> 00:11:30,880
然后呢，转去为突发事件服务

253
00:11:30,880 --> 00:11:32,590
服务完毕之后，诶

254
00:11:32,590 --> 00:11:35,090
再自动返回原程序

255
00:11:35,090 --> 00:11:36,310
继续执行

256
00:11:36,310 --> 00:11:37,930
这个过程是什么

257
00:11:37,930 --> 00:11:40,320
典型的一个中断过程吧

258
00:11:40,320 --> 00:11:43,600
它的处理过程保存现场是为了什么呢

259
00:11:43,600 --> 00:11:47,080
保存现场是为了我们可以还原之后

260
00:11:47,080 --> 00:11:49,220
接着去进行执行吧

261
00:11:49,220 --> 00:11:50,780
我们的现场啊

262
00:11:50,780 --> 00:11:52,680
它所保存的一般呢

263
00:11:52,680 --> 00:11:56,000
是我们原程序的一些状态

264
00:11:56,000 --> 00:11:58,370
那它跟中断程序呢

265
00:11:58,370 --> 00:12:00,770
并没有完整的关系

266
00:12:00,770 --> 00:12:03,740
并且呢，它在执行的过程当中

267
00:12:03,740 --> 00:12:05,230
它保存的内容啊

268
00:12:05,230 --> 00:12:07,720
一般呢，与防止丢失数据啊

269
00:12:07,720 --> 00:12:11,260
还有对其他部件造成影响都没有关系啊

270
00:12:11,260 --> 00:12:13,780
他只是把状态保留下来

271
00:12:13,780 --> 00:12:17,220
然后呢，返回的时候可以呢，还原

272
00:12:17,220 --> 00:12:19,510
继续执行原程序

273
00:12:19,510 --> 00:12:20,950
那在这个过程当中

274
00:12:20,950 --> 00:12:23,860
数据仍然有可能是丢失

275
00:12:23,860 --> 00:12:27,400
那我们呢，是通过还原的是现场

276
00:12:27,400 --> 00:12:28,960
并不是呢数据

277
00:12:28,960 --> 00:12:30,420
还有呢，其他部件

278
00:12:30,420 --> 00:12:34,520
这道题考察的是中段的一些特点

279
00:12:35,340 --> 00:12:40,610
下面这道题 CPU 是在什么过程当中结束

280
00:12:40,610 --> 00:12:42,370
响应 DMA 请求的

281
00:12:42,370 --> 00:12:45,350
这道题考察的是 DMA 的特点

282
00:12:45,350 --> 00:12:48,010
对于 DMA 直接内存存取

283
00:12:48,010 --> 00:12:53,660
它在 CPU 过程当中会由 CPU 裁决

284
00:12:53,660 --> 00:12:58,080
然后呢当 CPU 自己的总线周期完成之后

285
00:12:58,080 --> 00:13:02,140
才会呢将总线交给我们的 DMC 

286
00:13:02,140 --> 00:13:04,820
所以有一个总线周期

287
00:13:04,820 --> 00:13:07,100
了解一下 DMA 的特点

288
00:13:07,100 --> 00:13:09,720
这些呢就是需要大家掌握的

289
00:13:09,720 --> 00:13:13,440
关于数据传输控制方式的内容

290
00:13:13,440 --> 00:13:17,030
大家需要掌握这几种方式的特点对比

291
00:13:17,030 --> 00:13:20,010
以及呢中断和 DMA 的方式
